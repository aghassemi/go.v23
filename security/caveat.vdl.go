// This file was auto-generated by the veyron vdl tool.
// Source: caveat.vdl

package security

import (
	// VDL system imports
	"v.io/core/veyron2/context"
	"v.io/core/veyron2/i18n"
	"v.io/core/veyron2/vdl"
	"v.io/core/veyron2/verror"

	// VDL user imports
	"v.io/core/veyron2/uniqueid"
)

type nonce [16]byte

func (nonce) __VDLReflect(struct {
	Name string "v.io/core/veyron2/security.nonce"
}) {
}

// publicKeyThirdPartyCaveat represents a third-party caveat that requires
// discharges to be issued by a principal identified by a public key.
//
// The ID of the caveat is base64-encoded:
// hash(hash(Nonce), hash(DischargerKey), hash(Caveats[0]), hash(Caveats[1]), ...)
// where hash is a cryptographic hash function with a security strength
// equivalent to that of the DischargerKey. For example, if DischargerKey
// represents an ECDSA public key with the P384 curve, then hash should be
// SHA384.
type publicKeyThirdPartyCaveat struct {
	// Nonce specifies a cryptographically random nonce associated with an
	// instance of the caveat. This prevents discharge replays, where
	// discharges for ThirdPartyCaveats embedded in the certificates for
	// one blessing can be used for another blessing.
	//
	// Whether discharge re-use is a desired or un-desired property is
	// still under debate. Till the debate is settled, we err on the side
	// of discouraging re-use.
	Nonce nonce
	// Caveats specifies the caveats that have to be validated
	// before minting a discharge for a publicKeyCaveat.
	Caveats []Caveat
	// DER-encoded PKIX public key of the principal that can issue discharges.
	DischargerKey []byte
	// Object name where the third-party that can issue discharges can be found.
	DischargerLocation string
	// Information required by the third-party in order to issue a discharge.
	DischargerRequirements ThirdPartyRequirements
}

func (publicKeyThirdPartyCaveat) __VDLReflect(struct {
	Name string "v.io/core/veyron2/security.publicKeyThirdPartyCaveat"
}) {
}

// publicKeyDischarge represents the discharge issued for publicKeyThirdPartyCaveats.
//
// The message digest of this structure is computed as follows:
// hash(hash(ThirdPartyCaveatID), hash(Caveats[0]), hash(Caveats[1]), ...),
// where hash is a cryptographic hash function with a security strength equivalent to the
// strength of the public key of the principal issuing the discharge.
type publicKeyDischarge struct {
	ThirdPartyCaveatID string    // ID of the third party caveat for which this discharge was issued.
	Caveats            []Caveat  // Caveats on the use of this discharge.
	Signature          Signature // Signature of the content hash of this discharge by the discharger.
}

func (publicKeyDischarge) __VDLReflect(struct {
	Name string "v.io/core/veyron2/security.publicKeyDischarge"
}) {
}

func init() {
	vdl.Register((*nonce)(nil))
	vdl.Register((*publicKeyThirdPartyCaveat)(nil))
	vdl.Register((*publicKeyDischarge)(nil))
}

// ConstCaveat represents a caveat that either always validates or never validates.
var ConstCaveat = CaveatDescriptor{
	ParamType: vdl.TypeOf(false),
}

// UnixTimeExpiryCaveat represents a caveat that validates iff the current
// time is before the time specified in seconds since January 1, 1970 UTC.
//
// TODO(toddw,ashankar): Once VDL support for time.Time is in, create a ExpiryCaveat
// and use that (and drop UnixTimeExpiryCaveatX).
var UnixTimeExpiryCaveatX = CaveatDescriptor{
	Id: uniqueid.Id{
		84,
		166,
		118,
		57,
		129,
		55,
		24,
		126,
		205,
		178,
		109,
		45,
		105,
		186,
		0,
		4,
	},
	ParamType: vdl.TypeOf(int64(0)),
}

// MethodCaveat represents a caveat that validates iff the method being
// invoked is included in this list. An empty list implies that no method can
// be invoked (i.e., the holder of a blessing with this caveat could be a
// server but cannot act as a client).
//
// TODO(ashankar): Rename to MethodCaveat and drop the MethodCaveat helper function?
var MethodCaveatX = CaveatDescriptor{
	Id: uniqueid.Id{
		84,
		166,
		118,
		57,
		129,
		55,
		24,
		126,
		205,
		178,
		109,
		45,
		105,
		186,
		0,
		3,
	},
	ParamType: vdl.TypeOf([]string(nil)),
}

// TODO(ashankar): Rename to PublicKeyThirdPartyCaveat (and
// publicKeyThirdPartyCaveat becomes publicKeyThirdPartyCaveatParam or
// something?).
var PublicKeyThirdPartyCaveatX = CaveatDescriptor{
	Id: uniqueid.Id{
		121,
		114,
		206,
		23,
		74,
		123,
		169,
		63,
		121,
		84,
		125,
		118,
		156,
		145,
		128,
		0,
	},
	ParamType: vdl.TypeOf(publicKeyThirdPartyCaveat{}),
}

var (
	ErrCaveatNotRegistered     = verror.Register("v.io/core/veyron2/security.CaveatNotRegistered", verror.NoRetry, "{1:}{2:} no validation function registered for caveat id {3}")
	ErrCaveatParamAny          = verror.Register("v.io/core/veyron2/security.CaveatParamAny", verror.NoRetry, "{1:}{2:} caveat {3} uses illegal param type any")
	ErrCaveatParamTypeMismatch = verror.Register("v.io/core/veyron2/security.CaveatParamTypeMismatch", verror.NoRetry, "{1:}{2:} bad param type: caveat {3} got {4}, want {5}")
	// TODO(ashankar,toddw,bjornick): The type of "err" here and below
	// should be error once https://github.com/veyron/release-issues/issues/922
	// is resolved.
	ErrCaveatParamCoding = verror.Register("v.io/core/veyron2/security.CaveatParamCoding", verror.NoRetry, "{1:}{2:} unable to encode/decode caveat param(type={4}) for caveat {3}: {5}")
	ErrCaveatValidation  = verror.Register("v.io/core/veyron2/security.CaveatValidation", verror.NoRetry, "{1:}{2:} caveat validation failed: {3}")
)

func init() {
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatNotRegistered.ID), "{1:}{2:} no validation function registered for caveat id {3}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatParamAny.ID), "{1:}{2:} caveat {3} uses illegal param type any")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatParamTypeMismatch.ID), "{1:}{2:} bad param type: caveat {3} got {4}, want {5}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatParamCoding.ID), "{1:}{2:} unable to encode/decode caveat param(type={4}) for caveat {3}: {5}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatValidation.ID), "{1:}{2:} caveat validation failed: {3}")
}

// NewErrCaveatNotRegistered returns an error with the ErrCaveatNotRegistered ID.
func NewErrCaveatNotRegistered(ctx *context.T, id uniqueid.Id) error {
	return verror.New(ErrCaveatNotRegistered, ctx, id)
}

// NewErrCaveatParamAny returns an error with the ErrCaveatParamAny ID.
func NewErrCaveatParamAny(ctx *context.T, id uniqueid.Id) error {
	return verror.New(ErrCaveatParamAny, ctx, id)
}

// NewErrCaveatParamTypeMismatch returns an error with the ErrCaveatParamTypeMismatch ID.
func NewErrCaveatParamTypeMismatch(ctx *context.T, id uniqueid.Id, got *vdl.Type, want *vdl.Type) error {
	return verror.New(ErrCaveatParamTypeMismatch, ctx, id, got, want)
}

// NewErrCaveatParamCoding returns an error with the ErrCaveatParamCoding ID.
func NewErrCaveatParamCoding(ctx *context.T, id uniqueid.Id, typ *vdl.Type, err vdl.AnyRep) error {
	return verror.New(ErrCaveatParamCoding, ctx, id, typ, err)
}

// NewErrCaveatValidation returns an error with the ErrCaveatValidation ID.
func NewErrCaveatValidation(ctx *context.T, err vdl.AnyRep) error {
	return verror.New(ErrCaveatValidation, ctx, err)
}
