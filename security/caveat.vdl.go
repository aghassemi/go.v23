// This file was auto-generated by the veyron vdl tool.
// Source: caveat.vdl

package security

import (
	// VDL system imports
	"v.io/core/veyron2/context"
	"v.io/core/veyron2/i18n"
	"v.io/core/veyron2/vdl"
	"v.io/core/veyron2/verror2"

	// VDL user imports
	"v.io/core/veyron2/uniqueid"
)

// TODO(ashankar): Remove once ValidatorVOM goes away.
type unixTimeExpiryCaveat int64

func (unixTimeExpiryCaveat) __VDLReflect(struct {
	Name string "v.io/core/veyron2/security.unixTimeExpiryCaveat"
}) {
}

type methodCaveat []string

func (methodCaveat) __VDLReflect(struct {
	Name string "v.io/core/veyron2/security.methodCaveat"
}) {
}

type nonce [16]byte

func (nonce) __VDLReflect(struct {
	Name string "v.io/core/veyron2/security.nonce"
}) {
}

// publicKeyThirdPartyCaveat represents a third-party caveat that requires
// discharges to be issued by a principal identified by a public key.
//
// The ID of the caveat is base64-encoded:
// hash(hash(Nonce), hash(DischargerKey), hash(Caveats[0]), hash(Caveats[1]), ...)
// where hash is a cryptographic hash function with a security strength
// equivalent to that of the DischargerKey. For example, if DischargerKey
// represents an ECDSA public key with the P384 curve, then hash should be
// SHA384.
type publicKeyThirdPartyCaveat struct {
	// Nonce specifies a cryptographically random nonce associated with an
	// instance of the caveat. This prevents discharge replays, where
	// discharges for ThirdPartyCaveats embedded in the certificates for
	// one blessing can be used for another blessing.
	//
	// Whether discharge re-use is a desired or un-desired property is
	// still under debate. Till the debate is settled, we err on the side
	// of discouraging re-use.
	Nonce nonce
	// Caveats specifies the caveats that have to be validated
	// before minting a discharge for a publicKeyCaveat.
	Caveats []Caveat
	// DER-encoded PKIX public key of the principal that can issue discharges.
	DischargerKey []byte
	// Object name where the third-party that can issue discharges can be found.
	DischargerLocation string
	// Information required by the third-party in order to issue a discharge.
	DischargerRequirements ThirdPartyRequirements
}

func (publicKeyThirdPartyCaveat) __VDLReflect(struct {
	Name string "v.io/core/veyron2/security.publicKeyThirdPartyCaveat"
}) {
}

// publicKeyDischarge represents the discharge issued for publicKeyThirdPartyCaveats.
//
// The message digest of this structure is computed as follows:
// hash(hash(ThirdPartyCaveatID), hash(Caveats[0]), hash(Caveats[1]), ...),
// where hash is a cryptographic hash function with a security strength equivalent to the
// strength of the public key of the principal issuing the discharge.
type publicKeyDischarge struct {
	ThirdPartyCaveatID string    // ID of the third party caveat for which this discharge was issued.
	Caveats            []Caveat  // Caveats on the use of this discharge.
	Signature          Signature // Signature of the content hash of this discharge by the discharger.
}

func (publicKeyDischarge) __VDLReflect(struct {
	Name string "v.io/core/veyron2/security.publicKeyDischarge"
}) {
}

func init() {
	vdl.Register((*unixTimeExpiryCaveat)(nil))
	vdl.Register((*methodCaveat)(nil))
	vdl.Register((*nonce)(nil))
	vdl.Register((*publicKeyThirdPartyCaveat)(nil))
	vdl.Register((*publicKeyDischarge)(nil))
}

// UnixTimeExpiryCaveat represents a caveat that validates iff the current
// time is before the time specified in seconds since January 1, 1970 UTC.
//
// TODO(toddw,ashankar): Once VDL support for time.Time is in, create a ExpiryCaveat
// and use that (and drop UnixTimeExpiryCaveatX).
var UnixTimeExpiryCaveatX = CaveatDescriptor{
	Id: uniqueid.Id{
		84,
		166,
		118,
		57,
		129,
		55,
		24,
		126,
		205,
		178,
		109,
		45,
		105,
		186,
		0,
		4,
	},
	ParamType: vdl.TypeOf(int64(0)),
}

// MethodCaveat represents a caveat that validates iff the method being
// invoked is included in this list. An empty list implies that no method can
// be invoked (i.e., the holder of a blessing with this caveat could be a
// server but cannot act as a client).
//
// TODO(ashankar): Rename to MethodCaveat and drop methodCaveat before release.
var MethodCaveatX = CaveatDescriptor{
	Id: uniqueid.Id{
		84,
		166,
		118,
		57,
		129,
		55,
		24,
		126,
		205,
		178,
		109,
		45,
		105,
		186,
		0,
		3,
	},
	ParamType: vdl.TypeOf([]string(nil)),
}

// TODO(ashankar): Rename to PublicKeyThirdPartyCaveat (and
// publicKeyThirdPartyCaveat becomes publicKeyThirdPartyCaveatParam or
// something?).
var PublicKeyThirdPartyCaveatX = CaveatDescriptor{
	Id: uniqueid.Id{
		121,
		114,
		206,
		23,
		74,
		123,
		169,
		63,
		121,
		84,
		125,
		118,
		156,
		145,
		128,
		0,
	},
	ParamType: vdl.TypeOf(publicKeyThirdPartyCaveat{}),
}

var (
	ErrCaveatNotRegistered     = verror2.Register("v.io/core/veyron2/security.ErrCaveatNotRegistered", verror2.NoRetry, "{1:}{2:} no validation function registered for caveat id {3}")
	ErrCaveatParamTypeMismatch = verror2.Register("v.io/core/veyron2/security.ErrCaveatParamTypeMismatch", verror2.NoRetry, "{1:}{2:} bad param type: caveat {3} got {4}, want {5}")
	// TODO(ashankar,toddw,bjornick): The type of "err" here and below
	// should be error once https://github.com/veyron/release-issues/issues/922
	// is resolved.
	ErrCaveatParamCoding = verror2.Register("v.io/core/veyron2/security.ErrCaveatParamCoding", verror2.NoRetry, "{1:}{2:} unable to encode/decode caveat param(type={4}) for caveat {3}: {5}")
	ErrCaveatValidation  = verror2.Register("v.io/core/veyron2/security.ErrCaveatValidation", verror2.NoRetry, "{1:}{2:} caveat validation failed: {3}")
)

func init() {
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatNotRegistered.ID), "{1:}{2:} no validation function registered for caveat id {3}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatParamTypeMismatch.ID), "{1:}{2:} bad param type: caveat {3} got {4}, want {5}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatParamCoding.ID), "{1:}{2:} unable to encode/decode caveat param(type={4}) for caveat {3}: {5}")
	i18n.Cat().SetWithBase(i18n.LangID("en"), i18n.MsgID(ErrCaveatValidation.ID), "{1:}{2:} caveat validation failed: {3}")
}

// MakeErrCaveatNotRegistered returns an error with the ErrCaveatNotRegistered ID.
func MakeErrCaveatNotRegistered(ctx *context.T, id uniqueid.Id) error {
	return verror2.Make(ErrCaveatNotRegistered, ctx, id)
}

// MakeErrCaveatParamTypeMismatch returns an error with the ErrCaveatParamTypeMismatch ID.
func MakeErrCaveatParamTypeMismatch(ctx *context.T, id uniqueid.Id, got *vdl.Type, want string) error {
	return verror2.Make(ErrCaveatParamTypeMismatch, ctx, id, got, want)
}

// MakeErrCaveatParamCoding returns an error with the ErrCaveatParamCoding ID.
func MakeErrCaveatParamCoding(ctx *context.T, id uniqueid.Id, typ *vdl.Type, err vdl.AnyRep) error {
	return verror2.Make(ErrCaveatParamCoding, ctx, id, typ, err)
}

// MakeErrCaveatValidation returns an error with the ErrCaveatValidation ID.
func MakeErrCaveatValidation(ctx *context.T, err vdl.AnyRep) error {
	return verror2.Make(ErrCaveatValidation, ctx, err)
}
