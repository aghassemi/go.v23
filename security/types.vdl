package security

// BlessingPattern is a pattern that is matched by specific blessings.
//
// A pattern can be either a blessing (slash-separated human-readable string)
// or a blessing ending in a glob ("/..."). A blessing matches a pattern if it
// can be extended to produce the same string as the pattern.  For example, the
// pattern "a/b/c" is matched by the blessings "a", "a/b" and "a/b/c" but not
// "x", not "a/x", not "a/b/x" and not "a/b/c/x".
//
// Additionally, when the pattern ends with a glob ("/..."), it is matched by
// all blessings that represent delegates of the pattern string excluding the
// glob. For example, the pattern "a/b/c/..." is matched by all the patterns
// that match "a/b/c" ("a", "a/b", "a/b/c") and all delegates of "a/b/c" (like
// "a/b/c/d", "a/b/c/d/e" etc.).
//
// A pattern string not having one of the above described structures is considered
// invalid.
type BlessingPattern string

// Label is an access control right, like Read, Write, Admin, etc.
type Label uint32

// LabelSet is a set of access control labels, represented as a bitmask.
type LabelSet Label

// ACL (Access Control List) tracks the set of blessings that grant
// access to an object and the type of access the blessing grants.
//
// When a principal presents multiple blessings, it should be authorized
// if any one of those blessings matches the ACL. Since the principal
// chooses the subset of its blessings to share (and can thus withold
// any particular one), requiring all presented blessings to match the
// ACL does not provide any security benefits.
type ACL struct {
  // In denotes the set of blessings (represented as BlessingPatterns)
  // that grant access to an object, unless blacklisted by an entry in
  // NotIn.
  //
  // For example:
  //
  //  In: {"foo/bar": "R"}
  //
  // grants "Read" access to a principal that holds the blessing "foo/bar"
  // or a delegator of "foo/bar" ("foo"), but
  // not delegates of "foo/bar" (like "foo/bar/a" or "foo/bar/b").
  //
  // While:
  //
  //  In: {"foo/bar/...": "R"}
  //
  // grants "Read" access to "foo/bar", all its delegates (like "foo/bar/baz")
  // and its delegators ("foo").
  In map[BlessingPattern]LabelSet

  // NotIn denotes the set of blessings (and their delegates) that
  // are explicitly blacklisted from specific kinds of access.
  //
  // The NotIn list is meant to be used as an override. For example:
  //
  //  In: {"foo/...": "RW"}, NotIn: {"foo/bar": "W"}
  //
  // will grant "Read" and "Write" access to "foo" and all its delegates
  // ("foo/friend", "foo/family" etc.) EXCEPT to "foo/bar" and its
  // delegates (e.g. "foo/bar/baz"), who only get "Read" access since
  // "Write" access has been explicitly blacklisted for them.
  NotIn map[string]LabelSet

  // TODO(ataly,ashankar): Add group membership clauses to
  // this structure once the group API is more concrete.
}

// Hash identifies a cryptographic hash function approved for use in signature algorithms.
type Hash string

const (
  AllPrincipals = BlessingPattern("...") // Glob pattern that matches all blessings.

  ChainSeparator = "/" // ChainSeparator joins blessing names to form a blessing chain name.

  ResolveLabel = Label(1 << 0)     // ResolveLabel applies to operations involving navigating the namespace.
  ReadLabel    = Label(1 << 1)     // ReadLabel applies to operations where state of the object is not changed.
  WriteLabel   = Label(1 << 2)     // WriteLabel applies to operations where the contents of an object are changed.
  AdminLabel   = Label(1 << 3)     // AdminLabel applies to operations where metadata about the object (such as access control) is changed.
  DebugLabel   = Label(1 << 4)     // DebugLabel applies to operations that returns metadata about the object.
  MonitoringLabel = Label(1 << 5)  // MonitoringLabel is like DebugLabel.

  SHA1Hash = Hash("SHA1")     // SHA1 cryptographic hash function defined in RFC3174.
  SHA256Hash = Hash("SHA256") // SHA256 cryptographic hash function defined  in FIPS 180-4.
  SHA384Hash = Hash("SHA384") // SHA384 cryptographic hash function defined in FIPS 180-2.
  SHA512Hash = Hash("SHA512") // SHA512 cryptographic hash function defined in FIPS 180-2.

  SignatureForMessageSigning = "S"       // Signature.Purpose used by a Principal to sign arbitrary messages.
  SignatureForBlessingCertificates = "B" // Signature.Purpose used by a Principal when signing Certificates for creating blessings.
  SignatureForDischarge = "D"            // Signature.Purpose used by a Principal when signing discharges for public-key based third-party caveats.
)

// Signature represents a digital signature.
type Signature struct {
  // Purpose of the signature. Can be used to prevent type attacks.
  // (See Section 4.2 of http://www-users.cs.york.ac.uk/~jac/PublishedPapers/reviewV1_1997.pdf for example).
  // The actual signature (R, S values for ECDSA keys) is produced by signing: Hash(Hash(message), Hash(Purpose)).
  Purpose []byte
  // Cryptographic hash function applied to the message before computing the signature.
  Hash Hash
  // Pair of integers that make up an ECDSA signature.
  R, S []byte
}

// ThirdPartyRequirements specifies the information required by the third-party
// that will issue discharges for third-party caveats.
//
// These requirements are typically used to construct a DischargeImpetus, which
// will be sent to the third-party.
type ThirdPartyRequirements struct {
  ReportServer bool     // The blessings presented by the server of an IPC call.
  ReportMethod bool     // The name of the method being invoked.
  ReportArguments bool  // Arguments to the method being invoked.
}

// DischargeImpetus encapsulates the motivation for a discharge being sought.
//
// These values are reported by a principal that is requesting a Discharge for
// a third-party caveat on one of its blessings. The third-party issues
// discharges cannot safely assume that all these values are provided, or that
// they are provided honestly.
//
// Implementations of services that issue discharges are encouraged to add
// caveats to the discharge that bind the discharge to the impetus, thereby
// rendering the discharge unsuable for any other purpose.
type DischargeImpetus struct {
  Server []BlessingPattern  // The client intends to use the discharge to communicate with a server that has a blessing matching one of the patterns in this set.
  Method string             // Name of the method being invoked by the client.
  Arguments []any           // Arguments to the method invocation.
}

// Certificate represents the cryptographic proof of the binding of
// extensions of a blessing held by one principal to another (represented by
// a public key) under specific caveats.
//
// For example, if a principal P1 has a blessing "alice", then it can
// extend it with a Certificate to generate the blessing "alice/friend" for
// another principal P2.
type Certificate struct {
  Extension string     // Human-readable string extension bound to PublicKey.
  PublicKey []byte     // DER-encoded PKIX public key.
  Caveats   []Caveat   // Caveats on the binding of Name to PublicKey.
  Signature Signature  // Signature by the blessing principal that binds the extension to the public key.
}

// Caveat is a condition on the validity of a blessing/discharge.
//
// These conditions are provided when asking a principal to create
// a blessing/discharge and are verified when extracting blessings
// (Blessings.ForName in the Go API).
//
// Given a Hash, the message digest of a caveat is:
// Hash(ValidatorVOM).
type Caveat struct {
  // ValidatorVOM holds the VOM-encoded bytes of the CaveatValidator
  // that validates this caveat.
  ValidatorVOM []byte
}

// WireBlessings encapsulates wire format of a set of blessings and the
// corresponding cryptographic proof that binds them to a principal
// (identified by a public key).
//
// This structure is the "wire" format for sending an receiving blessings
// in RPCs or marshaling to persistent storage. Typically, languages will
// provide a factory function that converts this wire representation to
// a more usable object to inspect and manipulate these blessings. For
// example, the NewBlessings factory function in Go.
// TODO(toddw,ashankar): When vom2 and config file support for VDL is
// in place, then in the config file for types.vdl specify a factory function
// that will convert between the "wire" type and the "in-memory"
// type (Blessings=blessingsImpl) via factory functions that will do the
// integrity checks.
type WireBlessings struct {
  // CertificateChains is an array of chains of certificates that bind
  // a blessing to the public key in the last certificate of the chain.
  CertificateChains [][]Certificate
}
