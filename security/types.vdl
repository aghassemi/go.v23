package security

// Caveat is a condition on the applicability of a blessing (or
// a Discharge).
//
// These conditions are provided to PrivateID.Bless and are verified
// in PublicID.Authorize.
type Caveat struct {
  // ValidatorVOM holds the VOM-encoded bytes of the CaveatValidator
  // that validates this caveat.
  ValidatorVOM []byte
}

// BlessingPattern is a pattern that is matched by specific blessings.
//
// A pattern can be either a blessing (slash-separated human-readable string)
// or a blessing ending in a glob ("/..."). A blessing matches a pattern if it
// can be extended to produce the same string as the pattern.  For example, the
// pattern "a/b/c" is matched by the blessings "a", "a/b" and "a/b/c" but not
// "x", not "a/x", not "a/b/x" and not "a/b/c/x".
//
// Additionally, when the pattern ends with a glob ("/..."), it is matched by
// all blessings that represent delegates of the pattern string excluding the
// glob. For example, the pattern "a/b/c/..." is matched by all the patterns
// that match "a/b/c" ("a", "a/b", "a/b/c") and all delegates of "a/b/c" (like
// "a/b/c/d", "a/b/c/d/e" etc.).
type BlessingPattern string

// Label is an access control right, like Read, Write, Admin, etc.
type Label uint32

// LabelSet is a set of access control labels, represented as a bitmask.
type LabelSet Label

// ACL (Access Control List) tracks the set of blessings that grant
// access to an object and the type of access the blessing grants.
//
// When a principal presents multiple blessings, it should be authorized
// if any one of those blessings matches the ACL. Since the principal
// chooses the subset of its blessings to share (and can thus withold
// any particular one), requiring all presented blessings to match the
// ACL does not provide any security benefits.
type ACL struct {
  // In denotes the set of blessings (represented as BlessingPatterns)
  // that grant access to an object, unless blacklisted by an entry in
  // NotIn.
  //
  // For example:
  //
  //  In: {"foo/bar": "R"}
  //
  // grants "Read" access to a principal that holds the blessing "foo/bar"
  // or a delegator of "foo/bar" ("foo"), but
  // not delegates of "foo/bar" (like "foo/bar/a" or "foo/bar/b").
  //
  // While:
  //
  //  In: {"foo/bar/...": "R"}
  //
  // grants "Read" access to "foo/bar", all its delegates (like "foo/bar/baz")
  // and its delegators ("foo").
  In map[BlessingPattern]LabelSet

  // NotIn denotes the set of blessings (and their delegates) that
  // are explicitly blacklisted from specific kinds of access.
  //
  // The NotIn list is meant to be used as an override. For example:
  //
  //  In: {"foo/...": "RW"}, NotIn: {"foo/bar": "W"}
  //
  // will grant "Read" and "Write" access to "foo" and all its delegates
  // ("foo/friend", "foo/family" etc.) EXCEPT to "foo/bar" and its
  // delegates (e.g. "foo/bar/baz"), who only get "Read" access since
  // "Write" access has been explicitly blacklisted for them.
  NotIn map[string]LabelSet

  // TODO(ataly,ashankar): Add group membership clauses to
  // this structure once the group API is more concrete.
}

// Hash identifies a cryptographic hash function.
type Hash string

const (
  AllPrincipals = BlessingPattern("...") // Glob pattern that matches all blessings.

  ChainSeparator = "/" // ChainSeparator joins blessing names to form a blessing chain name.

  ResolveLabel = Label(1 << 0)     // ResolveLabel applies to operations involving navigating the namespace.
  ReadLabel    = Label(1 << 1)     // ReadLabel applies to operations where state of the object is not changed.
  WriteLabel   = Label(1 << 2)     // WriteLabel applies to operations where the contents of an object are changed.
  AdminLabel   = Label(1 << 3)     // AdminLabel applies to operations where metadata about the object (such as access control) is changed.
  DebugLabel   = Label(1 << 4)     // DebugLabel applies to operations that returns metadata about the object.
  MonitoringLabel = Label(1 << 5)  // MonitoringLabel is like DebugLabel.

  SHA1Hash = Hash("SHA1")     // SHA1 cryptographic hash function defined in RFC3174.
  SHA256Hash = Hash("SHA256") // SHA256 cryptographic hash function defined  in FIPS 180-4.
  SHA384Hash = Hash("SHA384") // SHA384 cryptographic hash function defined in FIPS 180-2.
  SHA512Hash = Hash("SHA512") // SHA512 cryptographic hash function defined in FIPS 180-2.
  NoHash = Hash("")           // Identity hash function.
)

// Signature represents a digital signature.
type Signature struct {
	Hash Hash    // Cryptographic hash function applied to the message before computing the signature.
	R, S []byte  // Pair of integers that make up an ECDSA signature.
}

// DischargeImpetus encapsulates the motivation for a discharge being sought.
//
// These values are reported by the holder of a PublicID with ThirdPartyCaveats when
// requesting a Discharge. The third-party issuing discharges thus cannot safely
// assume that all values are provided, or that they are provided honestly.
//
// Implementations of services that issue discharges are encouraged to add caveats to the
// discharge that bind the discharge to the impetus, thereby rendering the discharge unsuable
// for any other purpose.
type DischargeImpetus struct {
  // Identity (security.PublicID) of the server on which the method is to be invoked.
  // TODO(ashankar): Replace vdlutil.Any here with the appropriate VDL representation of identities.
  Server any
  // Name of the method being invoked which led to the request for a discharge.
  Method string
  // Arguments to the method invocation which led to the request for a discharge.
  Arguments []any
}
