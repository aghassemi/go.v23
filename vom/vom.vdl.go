// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: vom

package vom

import (
	"fmt"
	"v.io/v23/vdl"
	"v.io/v23/vdl/vdlconv"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// ControlKind enumerates the different kinds of control bytes.
type ControlKind int

const (
	ControlKindNil ControlKind = iota
	ControlKindEnd
	ControlKindIncompleteType
)

// ControlKindAll holds all labels for ControlKind.
var ControlKindAll = [...]ControlKind{ControlKindNil, ControlKindEnd, ControlKindIncompleteType}

// ControlKindFromString creates a ControlKind from a string label.
func ControlKindFromString(label string) (x ControlKind, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ControlKind) Set(label string) error {
	switch label {
	case "Nil", "nil":
		*x = ControlKindNil
		return nil
	case "End", "end":
		*x = ControlKindEnd
		return nil
	case "IncompleteType", "incompletetype":
		*x = ControlKindIncompleteType
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in vom.ControlKind", label)
}

// String returns the string label of x.
func (x ControlKind) String() string {
	switch x {
	case ControlKindNil:
		return "Nil"
	case ControlKindEnd:
		return "End"
	case ControlKindIncompleteType:
		return "IncompleteType"
	}
	return ""
}

func (ControlKind) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.ControlKind"`
	Enum struct{ Nil, End, IncompleteType string }
}) {
}

func (m *ControlKind) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *ControlKind) MakeVDLTarget() vdl.Target {
	return &ControlKindTarget{Value: m}
}

type ControlKindTarget struct {
	Value *ControlKind
	vdl.TargetBase
}

func (t *ControlKindTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*ControlKind)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Nil":
		*t.Value = 0
	case "End":
		*t.Value = 1
	case "IncompleteType":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum v.io/v23/vom.ControlKind", src)
	}

	return nil
}

type (
	// Primitive represents any single field of the Primitive union type.
	//
	// Primitive represents one of the primitive vom values.  All vom values are
	// composed of combinations of these primitives.
	Primitive interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the Primitive union type.
		__VDLReflect(__PrimitiveReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// PrimitivePBool represents field PBool of the Primitive union type.
	PrimitivePBool struct{ Value bool }
	// PrimitivePByte represents field PByte of the Primitive union type.
	PrimitivePByte struct{ Value byte }
	// PrimitivePUint represents field PUint of the Primitive union type.
	PrimitivePUint struct{ Value uint64 }
	// PrimitivePInt represents field PInt of the Primitive union type.
	PrimitivePInt struct{ Value int64 }
	// PrimitivePFloat represents field PFloat of the Primitive union type.
	PrimitivePFloat struct{ Value float64 }
	// PrimitivePString represents field PString of the Primitive union type.
	PrimitivePString struct{ Value string }
	// PrimitivePControl represents field PControl of the Primitive union type.
	PrimitivePControl struct{ Value ControlKind }
	// __PrimitiveReflect describes the Primitive union type.
	__PrimitiveReflect struct {
		Name               string `vdl:"v.io/v23/vom.Primitive"`
		Type               Primitive
		UnionTargetFactory primitiveTargetFactory
		Union              struct {
			PBool    PrimitivePBool
			PByte    PrimitivePByte
			PUint    PrimitivePUint
			PInt     PrimitivePInt
			PFloat   PrimitivePFloat
			PString  PrimitivePString
			PControl PrimitivePControl
		}
	}
)

func (x PrimitivePBool) Index() int                      { return 0 }
func (x PrimitivePBool) Interface() interface{}          { return x.Value }
func (x PrimitivePBool) Name() string                    { return "PBool" }
func (x PrimitivePBool) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePBool) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PBool")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromBool(bool(m.Value), tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePBool) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePByte) Index() int                      { return 1 }
func (x PrimitivePByte) Interface() interface{}          { return x.Value }
func (x PrimitivePByte) Name() string                    { return "PByte" }
func (x PrimitivePByte) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePByte) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PByte")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromUint(uint64(m.Value), tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePByte) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePUint) Index() int                      { return 2 }
func (x PrimitivePUint) Interface() interface{}          { return x.Value }
func (x PrimitivePUint) Name() string                    { return "PUint" }
func (x PrimitivePUint) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePUint) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PUint")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromUint(uint64(m.Value), tt.NonOptional().Field(2).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePUint) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePInt) Index() int                      { return 3 }
func (x PrimitivePInt) Interface() interface{}          { return x.Value }
func (x PrimitivePInt) Name() string                    { return "PInt" }
func (x PrimitivePInt) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePInt) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PInt")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromInt(int64(m.Value), tt.NonOptional().Field(3).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePInt) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePFloat) Index() int                      { return 4 }
func (x PrimitivePFloat) Interface() interface{}          { return x.Value }
func (x PrimitivePFloat) Name() string                    { return "PFloat" }
func (x PrimitivePFloat) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePFloat) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PFloat")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromFloat(float64(m.Value), tt.NonOptional().Field(4).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePFloat) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePString) Index() int                      { return 5 }
func (x PrimitivePString) Interface() interface{}          { return x.Value }
func (x PrimitivePString) Name() string                    { return "PString" }
func (x PrimitivePString) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePString) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PString")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), tt.NonOptional().Field(5).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePString) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePControl) Index() int                      { return 6 }
func (x PrimitivePControl) Interface() interface{}          { return x.Value }
func (x PrimitivePControl) Name() string                    { return "PControl" }
func (x PrimitivePControl) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePControl) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PControl")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(6).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePControl) MakeVDLTarget() vdl.Target {
	return nil
}

type PrimitiveTarget struct {
	Value     *Primitive
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *PrimitiveTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*Primitive)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *PrimitiveTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "PBool":
		val := false
		return nil, &vdl.BoolTarget{Value: &val}, nil
	case "PByte":
		val := byte(0)
		return nil, &vdl.ByteTarget{Value: &val}, nil
	case "PUint":
		val := uint64(0)
		return nil, &vdl.Uint64Target{Value: &val}, nil
	case "PInt":
		val := int64(0)
		return nil, &vdl.Int64Target{Value: &val}, nil
	case "PFloat":
		val := float64(0)
		return nil, &vdl.Float64Target{Value: &val}, nil
	case "PString":
		val := ""
		return nil, &vdl.StringTarget{Value: &val}, nil
	case "PControl":
		val := ControlKindNil
		return nil, &ControlKindTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/vom.Primitive", name)
	}
}
func (t *PrimitiveTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "PBool":
		*t.Value = PrimitivePBool{*(fieldTarget.(*vdl.BoolTarget)).Value}
	case "PByte":
		*t.Value = PrimitivePByte{*(fieldTarget.(*vdl.ByteTarget)).Value}
	case "PUint":
		*t.Value = PrimitivePUint{*(fieldTarget.(*vdl.Uint64Target)).Value}
	case "PInt":
		*t.Value = PrimitivePInt{*(fieldTarget.(*vdl.Int64Target)).Value}
	case "PFloat":
		*t.Value = PrimitivePFloat{*(fieldTarget.(*vdl.Float64Target)).Value}
	case "PString":
		*t.Value = PrimitivePString{*(fieldTarget.(*vdl.StringTarget)).Value}
	case "PControl":
		*t.Value = PrimitivePControl{*(fieldTarget.(*ControlKindTarget)).Value}
	}
	return nil
}
func (t *PrimitiveTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type primitiveTargetFactory struct{}

func (t primitiveTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*Primitive); ok {
		return &PrimitiveTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *Primitive", union)
}

// DumpKind enumerates the different kinds of dump atoms.
type DumpKind int

const (
	DumpKindVersion DumpKind = iota
	DumpKindControl
	DumpKindMsgId
	DumpKindTypeMsg
	DumpKindValueMsg
	DumpKindMsgLen
	DumpKindAnyMsgLen
	DumpKindAnyLensLen
	DumpKindTypeIdsLen
	DumpKindTypeId
	DumpKindPrimValue
	DumpKindByteLen
	DumpKindValueLen
	DumpKindIndex
	DumpKindWireTypeIndex
)

// DumpKindAll holds all labels for DumpKind.
var DumpKindAll = [...]DumpKind{DumpKindVersion, DumpKindControl, DumpKindMsgId, DumpKindTypeMsg, DumpKindValueMsg, DumpKindMsgLen, DumpKindAnyMsgLen, DumpKindAnyLensLen, DumpKindTypeIdsLen, DumpKindTypeId, DumpKindPrimValue, DumpKindByteLen, DumpKindValueLen, DumpKindIndex, DumpKindWireTypeIndex}

// DumpKindFromString creates a DumpKind from a string label.
func DumpKindFromString(label string) (x DumpKind, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *DumpKind) Set(label string) error {
	switch label {
	case "Version", "version":
		*x = DumpKindVersion
		return nil
	case "Control", "control":
		*x = DumpKindControl
		return nil
	case "MsgId", "msgid":
		*x = DumpKindMsgId
		return nil
	case "TypeMsg", "typemsg":
		*x = DumpKindTypeMsg
		return nil
	case "ValueMsg", "valuemsg":
		*x = DumpKindValueMsg
		return nil
	case "MsgLen", "msglen":
		*x = DumpKindMsgLen
		return nil
	case "AnyMsgLen", "anymsglen":
		*x = DumpKindAnyMsgLen
		return nil
	case "AnyLensLen", "anylenslen":
		*x = DumpKindAnyLensLen
		return nil
	case "TypeIdsLen", "typeidslen":
		*x = DumpKindTypeIdsLen
		return nil
	case "TypeId", "typeid":
		*x = DumpKindTypeId
		return nil
	case "PrimValue", "primvalue":
		*x = DumpKindPrimValue
		return nil
	case "ByteLen", "bytelen":
		*x = DumpKindByteLen
		return nil
	case "ValueLen", "valuelen":
		*x = DumpKindValueLen
		return nil
	case "Index", "index":
		*x = DumpKindIndex
		return nil
	case "WireTypeIndex", "wiretypeindex":
		*x = DumpKindWireTypeIndex
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in vom.DumpKind", label)
}

// String returns the string label of x.
func (x DumpKind) String() string {
	switch x {
	case DumpKindVersion:
		return "Version"
	case DumpKindControl:
		return "Control"
	case DumpKindMsgId:
		return "MsgId"
	case DumpKindTypeMsg:
		return "TypeMsg"
	case DumpKindValueMsg:
		return "ValueMsg"
	case DumpKindMsgLen:
		return "MsgLen"
	case DumpKindAnyMsgLen:
		return "AnyMsgLen"
	case DumpKindAnyLensLen:
		return "AnyLensLen"
	case DumpKindTypeIdsLen:
		return "TypeIdsLen"
	case DumpKindTypeId:
		return "TypeId"
	case DumpKindPrimValue:
		return "PrimValue"
	case DumpKindByteLen:
		return "ByteLen"
	case DumpKindValueLen:
		return "ValueLen"
	case DumpKindIndex:
		return "Index"
	case DumpKindWireTypeIndex:
		return "WireTypeIndex"
	}
	return ""
}

func (DumpKind) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.DumpKind"`
	Enum struct{ Version, Control, MsgId, TypeMsg, ValueMsg, MsgLen, AnyMsgLen, AnyLensLen, TypeIdsLen, TypeId, PrimValue, ByteLen, ValueLen, Index, WireTypeIndex string }
}) {
}

func (m *DumpKind) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *DumpKind) MakeVDLTarget() vdl.Target {
	return &DumpKindTarget{Value: m}
}

type DumpKindTarget struct {
	Value *DumpKind
	vdl.TargetBase
}

func (t *DumpKindTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*DumpKind)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Version":
		*t.Value = 0
	case "Control":
		*t.Value = 1
	case "MsgId":
		*t.Value = 2
	case "TypeMsg":
		*t.Value = 3
	case "ValueMsg":
		*t.Value = 4
	case "MsgLen":
		*t.Value = 5
	case "AnyMsgLen":
		*t.Value = 6
	case "AnyLensLen":
		*t.Value = 7
	case "TypeIdsLen":
		*t.Value = 8
	case "TypeId":
		*t.Value = 9
	case "PrimValue":
		*t.Value = 10
	case "ByteLen":
		*t.Value = 11
	case "ValueLen":
		*t.Value = 12
	case "Index":
		*t.Value = 13
	case "WireTypeIndex":
		*t.Value = 14
	default:
		return fmt.Errorf("label %s not in enum v.io/v23/vom.DumpKind", src)
	}

	return nil
}

// DumpAtom describes a single indivisible piece of the vom encoding.  The vom
// encoding is composed of a stream of these atoms.
type DumpAtom struct {
	Kind  DumpKind  // The kind of this atom.
	Bytes []byte    // Raw bytes in the vom encoding representing this atom.
	Data  Primitive // Primitive data corresponding to the raw bytes.
	Debug string    // Free-form debug string with more information.
}

func (DumpAtom) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.DumpAtom"`
}) {
}

func (m *DumpAtom) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Kind")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Kind.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Bytes")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := fieldTarget5.FromBytes([]byte(m.Bytes), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Data")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		unionValue8 := m.Data
		if unionValue8 == nil {
			unionValue8 = PrimitivePBool{}
		}
		if err := unionValue8.FillVDLTarget(fieldTarget7, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("Debug")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget10.FromString(string(m.Debug), tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *DumpAtom) MakeVDLTarget() vdl.Target {
	return &DumpAtomTarget{Value: m}
}

type DumpAtomTarget struct {
	Value       *DumpAtom
	kindTarget  DumpKindTarget
	bytesTarget vdl.BytesTarget
	dataTarget  PrimitiveTarget
	debugTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DumpAtomTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*DumpAtom)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *DumpAtomTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Kind":
		t.kindTarget.Value = &t.Value.Kind
		target, err := &t.kindTarget, error(nil)
		return nil, target, err
	case "Bytes":
		t.bytesTarget.Value = &t.Value.Bytes
		target, err := &t.bytesTarget, error(nil)
		return nil, target, err
	case "Data":
		t.dataTarget.Value = &t.Value.Data
		target, err := &t.dataTarget, error(nil)
		return nil, target, err
	case "Debug":
		t.debugTarget.Value = &t.Value.Debug
		target, err := &t.debugTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.DumpAtom", name)
	}
}
func (t *DumpAtomTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *DumpAtomTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// typeId uniquely identifies a type definition within a vom stream.
type typeId uint64

func (typeId) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.typeId"`
}) {
}

func (m *typeId) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *typeId) MakeVDLTarget() vdl.Target {
	return &typeIdTarget{Value: m}
}

type typeIdTarget struct {
	Value *typeId
	vdl.TargetBase
}

func (t *typeIdTarget) FromUint(src uint64, tt *vdl.Type) error {

	*t.Value = typeId(src)

	return nil
}
func (t *typeIdTarget) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = typeId(val)

	return nil
}
func (t *typeIdTarget) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = typeId(val)

	return nil
}
func (t *typeIdTarget) FromComplex(src complex128, tt *vdl.Type) error {

	val, err := vdlconv.Complex128ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = typeId(val)

	return nil
}

// wireNamed represents a type definition for named primitives.
type wireNamed struct {
	Name string
	Base typeId
}

func (wireNamed) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireNamed"`
}) {
}

func (m *wireNamed) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Base")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Base.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireNamed) MakeVDLTarget() vdl.Target {
	return &wireNamedTarget{Value: m}
}

type wireNamedTarget struct {
	Value      *wireNamed
	nameTarget vdl.StringTarget
	baseTarget typeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireNamedTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireNamed)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireNamedTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Base":
		t.baseTarget.Value = &t.Value.Base
		target, err := &t.baseTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.wireNamed", name)
	}
}
func (t *wireNamedTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireNamedTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// wireEnum represents an type definition for enum types.
type wireEnum struct {
	Name   string
	Labels []string
}

func (wireEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireEnum"`
}) {
}

func (m *wireEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Labels")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget6, err := fieldTarget5.StartList(tt.NonOptional().Field(1).Type, len(m.Labels))
		if err != nil {
			return err
		}
		for i, elem8 := range m.Labels {
			elemTarget7, err := listTarget6.StartElem(i)
			if err != nil {
				return err
			}
			if err := elemTarget7.FromString(string(elem8), tt.NonOptional().Field(1).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget6.FinishElem(elemTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget5.FinishList(listTarget6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireEnum) MakeVDLTarget() vdl.Target {
	return &wireEnumTarget{Value: m}
}

type wireEnumTarget struct {
	Value        *wireEnum
	nameTarget   vdl.StringTarget
	labelsTarget vdl.StringSliceTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireEnumTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireEnum)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireEnumTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Labels":
		t.labelsTarget.Value = &t.Value.Labels
		target, err := &t.labelsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.wireEnum", name)
	}
}
func (t *wireEnumTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireEnumTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// wireArray represents an type definition for array types.
type wireArray struct {
	Name string
	Elem typeId
	Len  uint64
}

func (wireArray) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireArray"`
}) {
}

func (m *wireArray) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Elem")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Elem.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Len")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromUint(uint64(m.Len), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireArray) MakeVDLTarget() vdl.Target {
	return &wireArrayTarget{Value: m}
}

type wireArrayTarget struct {
	Value      *wireArray
	nameTarget vdl.StringTarget
	elemTarget typeIdTarget
	lenTarget  vdl.Uint64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireArrayTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireArray)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireArrayTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Elem":
		t.elemTarget.Value = &t.Value.Elem
		target, err := &t.elemTarget, error(nil)
		return nil, target, err
	case "Len":
		t.lenTarget.Value = &t.Value.Len
		target, err := &t.lenTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.wireArray", name)
	}
}
func (t *wireArrayTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireArrayTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// wireList represents a type definition for list types.
type wireList struct {
	Name string
	Elem typeId
}

func (wireList) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireList"`
}) {
}

func (m *wireList) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Elem")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Elem.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireList) MakeVDLTarget() vdl.Target {
	return &wireListTarget{Value: m}
}

type wireListTarget struct {
	Value      *wireList
	nameTarget vdl.StringTarget
	elemTarget typeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireListTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireList)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireListTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Elem":
		t.elemTarget.Value = &t.Value.Elem
		target, err := &t.elemTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.wireList", name)
	}
}
func (t *wireListTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireListTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// wireSet represents a type definition for set types.
type wireSet struct {
	Name string
	Key  typeId
}

func (wireSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireSet"`
}) {
}

func (m *wireSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Key")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Key.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireSet) MakeVDLTarget() vdl.Target {
	return &wireSetTarget{Value: m}
}

type wireSetTarget struct {
	Value      *wireSet
	nameTarget vdl.StringTarget
	keyTarget  typeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireSetTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireSet)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireSetTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.wireSet", name)
	}
}
func (t *wireSetTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireSetTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// wireMap represents a type definition for map types.
type wireMap struct {
	Name string
	Key  typeId
	Elem typeId
}

func (wireMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireMap"`
}) {
}

func (m *wireMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Key")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Key.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Elem")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Elem.FillVDLTarget(fieldTarget7, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireMap) MakeVDLTarget() vdl.Target {
	return &wireMapTarget{Value: m}
}

type wireMapTarget struct {
	Value      *wireMap
	nameTarget vdl.StringTarget
	keyTarget  typeIdTarget
	elemTarget typeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireMapTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireMap)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireMapTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	case "Elem":
		t.elemTarget.Value = &t.Value.Elem
		target, err := &t.elemTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.wireMap", name)
	}
}
func (t *wireMapTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireMapTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// wireField represents a field in a struct or union type.
type wireField struct {
	Name string
	Type typeId
}

func (wireField) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireField"`
}) {
}

func (m *wireField) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Type")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Type.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireField) MakeVDLTarget() vdl.Target {
	return &wireFieldTarget{Value: m}
}

type wireFieldTarget struct {
	Value      *wireField
	nameTarget vdl.StringTarget
	typeTarget typeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireFieldTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireField)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireFieldTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Type":
		t.typeTarget.Value = &t.Value.Type
		target, err := &t.typeTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.wireField", name)
	}
}
func (t *wireFieldTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireFieldTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// wireStruct represents a type definition for struct types.
type wireStruct struct {
	Name   string
	Fields []wireField
}

func (wireStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireStruct"`
}) {
}

func (m *wireStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Fields")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget6, err := fieldTarget5.StartList(tt.NonOptional().Field(1).Type, len(m.Fields))
		if err != nil {
			return err
		}
		for i, elem8 := range m.Fields {
			elemTarget7, err := listTarget6.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem8.FillVDLTarget(elemTarget7, tt.NonOptional().Field(1).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget6.FinishElem(elemTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget5.FinishList(listTarget6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireStruct) MakeVDLTarget() vdl.Target {
	return &wireStructTarget{Value: m}
}

type wireStructTarget struct {
	Value        *wireStruct
	nameTarget   vdl.StringTarget
	fieldsTarget __VDLTarget1_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Fields":
		t.fieldsTarget.Value = &t.Value.Fields
		target, err := &t.fieldsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.wireStruct", name)
	}
}
func (t *wireStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []wireField
type __VDLTarget1_list struct {
	Value      *[]wireField
	elemTarget wireFieldTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]wireField)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]wireField, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// wireUnion represents a type definition for union types.
type wireUnion struct {
	Name   string
	Fields []wireField
}

func (wireUnion) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireUnion"`
}) {
}

func (m *wireUnion) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Fields")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget6, err := fieldTarget5.StartList(tt.NonOptional().Field(1).Type, len(m.Fields))
		if err != nil {
			return err
		}
		for i, elem8 := range m.Fields {
			elemTarget7, err := listTarget6.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem8.FillVDLTarget(elemTarget7, tt.NonOptional().Field(1).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget6.FinishElem(elemTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget5.FinishList(listTarget6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireUnion) MakeVDLTarget() vdl.Target {
	return &wireUnionTarget{Value: m}
}

type wireUnionTarget struct {
	Value        *wireUnion
	nameTarget   vdl.StringTarget
	fieldsTarget __VDLTarget1_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireUnionTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireUnion)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireUnionTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Fields":
		t.fieldsTarget.Value = &t.Value.Fields
		target, err := &t.fieldsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.wireUnion", name)
	}
}
func (t *wireUnionTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireUnionTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// wireOptional represents an type definition for optional types.
type wireOptional struct {
	Name string
	Elem typeId
}

func (wireOptional) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireOptional"`
}) {
}

func (m *wireOptional) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Elem")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Elem.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireOptional) MakeVDLTarget() vdl.Target {
	return &wireOptionalTarget{Value: m}
}

type wireOptionalTarget struct {
	Value      *wireOptional
	nameTarget vdl.StringTarget
	elemTarget typeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireOptionalTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireOptional)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireOptionalTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Elem":
		t.elemTarget.Value = &t.Value.Elem
		target, err := &t.elemTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom.wireOptional", name)
	}
}
func (t *wireOptionalTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireOptionalTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type (
	// wireType represents any single field of the wireType union type.
	//
	// The wireType union is used to encode the payload part of each type message,
	// using the regular rules for encoding union values.  But unlike our regular
	// encoding, the type message for wireType itself (and its fields) are never
	// encoded; we need to bootstrap the system.  Thus unlike regular values, the
	// ordering of fields within the wire* types cannot be changed.
	wireType interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the wireType union type.
		__VDLReflect(__wireTypeReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// wireTypeNamedT represents field NamedT of the wireType union type.
	//
	// FIELD INDICES MUST NOT BE CHANGED.
	wireTypeNamedT struct{ Value wireNamed } // INDEX = 0
	// wireTypeEnumT represents field EnumT of the wireType union type.
	wireTypeEnumT struct{ Value wireEnum } // INDEX = 1
	// wireTypeArrayT represents field ArrayT of the wireType union type.
	wireTypeArrayT struct{ Value wireArray } // INDEX = 2
	// wireTypeListT represents field ListT of the wireType union type.
	wireTypeListT struct{ Value wireList } // INDEX = 3
	// wireTypeSetT represents field SetT of the wireType union type.
	wireTypeSetT struct{ Value wireSet } // INDEX = 4
	// wireTypeMapT represents field MapT of the wireType union type.
	wireTypeMapT struct{ Value wireMap } // INDEX = 5
	// wireTypeStructT represents field StructT of the wireType union type.
	wireTypeStructT struct{ Value wireStruct } // INDEX = 6
	// wireTypeUnionT represents field UnionT of the wireType union type.
	wireTypeUnionT struct{ Value wireUnion } // INDEX = 7
	// wireTypeOptionalT represents field OptionalT of the wireType union type.
	wireTypeOptionalT struct{ Value wireOptional } // INDEX = 8
	// __wireTypeReflect describes the wireType union type.
	__wireTypeReflect struct {
		Name               string `vdl:"v.io/v23/vom.wireType"`
		Type               wireType
		UnionTargetFactory wireTypeTargetFactory
		Union              struct {
			NamedT    wireTypeNamedT
			EnumT     wireTypeEnumT
			ArrayT    wireTypeArrayT
			ListT     wireTypeListT
			SetT      wireTypeSetT
			MapT      wireTypeMapT
			StructT   wireTypeStructT
			UnionT    wireTypeUnionT
			OptionalT wireTypeOptionalT
		}
	}
)

func (x wireTypeNamedT) Index() int                     { return 0 }
func (x wireTypeNamedT) Interface() interface{}         { return x.Value }
func (x wireTypeNamedT) Name() string                   { return "NamedT" }
func (x wireTypeNamedT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeNamedT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("NamedT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeNamedT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeEnumT) Index() int                     { return 1 }
func (x wireTypeEnumT) Interface() interface{}         { return x.Value }
func (x wireTypeEnumT) Name() string                   { return "EnumT" }
func (x wireTypeEnumT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeEnumT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("EnumT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeEnumT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeArrayT) Index() int                     { return 2 }
func (x wireTypeArrayT) Interface() interface{}         { return x.Value }
func (x wireTypeArrayT) Name() string                   { return "ArrayT" }
func (x wireTypeArrayT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeArrayT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ArrayT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(2).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeArrayT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeListT) Index() int                     { return 3 }
func (x wireTypeListT) Interface() interface{}         { return x.Value }
func (x wireTypeListT) Name() string                   { return "ListT" }
func (x wireTypeListT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeListT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ListT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(3).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeListT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeSetT) Index() int                     { return 4 }
func (x wireTypeSetT) Interface() interface{}         { return x.Value }
func (x wireTypeSetT) Name() string                   { return "SetT" }
func (x wireTypeSetT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeSetT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("SetT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(4).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeSetT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeMapT) Index() int                     { return 5 }
func (x wireTypeMapT) Interface() interface{}         { return x.Value }
func (x wireTypeMapT) Name() string                   { return "MapT" }
func (x wireTypeMapT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeMapT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("MapT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(5).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeMapT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeStructT) Index() int                     { return 6 }
func (x wireTypeStructT) Interface() interface{}         { return x.Value }
func (x wireTypeStructT) Name() string                   { return "StructT" }
func (x wireTypeStructT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeStructT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("StructT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(6).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeStructT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeUnionT) Index() int                     { return 7 }
func (x wireTypeUnionT) Interface() interface{}         { return x.Value }
func (x wireTypeUnionT) Name() string                   { return "UnionT" }
func (x wireTypeUnionT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeUnionT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("UnionT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(7).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeUnionT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeOptionalT) Index() int                     { return 8 }
func (x wireTypeOptionalT) Interface() interface{}         { return x.Value }
func (x wireTypeOptionalT) Name() string                   { return "OptionalT" }
func (x wireTypeOptionalT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeOptionalT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("OptionalT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(8).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeOptionalT) MakeVDLTarget() vdl.Target {
	return nil
}

type wireTypeTarget struct {
	Value     *wireType
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*wireType)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *wireTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "NamedT":
		val := wireNamed{}
		return nil, &wireNamedTarget{Value: &val}, nil
	case "EnumT":
		val := wireEnum{}
		return nil, &wireEnumTarget{Value: &val}, nil
	case "ArrayT":
		val := wireArray{}
		return nil, &wireArrayTarget{Value: &val}, nil
	case "ListT":
		val := wireList{}
		return nil, &wireListTarget{Value: &val}, nil
	case "SetT":
		val := wireSet{}
		return nil, &wireSetTarget{Value: &val}, nil
	case "MapT":
		val := wireMap{}
		return nil, &wireMapTarget{Value: &val}, nil
	case "StructT":
		val := wireStruct{}
		return nil, &wireStructTarget{Value: &val}, nil
	case "UnionT":
		val := wireUnion{}
		return nil, &wireUnionTarget{Value: &val}, nil
	case "OptionalT":
		val := wireOptional{}
		return nil, &wireOptionalTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/vom.wireType", name)
	}
}
func (t *wireTypeTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "NamedT":
		*t.Value = wireTypeNamedT{*(fieldTarget.(*wireNamedTarget)).Value}
	case "EnumT":
		*t.Value = wireTypeEnumT{*(fieldTarget.(*wireEnumTarget)).Value}
	case "ArrayT":
		*t.Value = wireTypeArrayT{*(fieldTarget.(*wireArrayTarget)).Value}
	case "ListT":
		*t.Value = wireTypeListT{*(fieldTarget.(*wireListTarget)).Value}
	case "SetT":
		*t.Value = wireTypeSetT{*(fieldTarget.(*wireSetTarget)).Value}
	case "MapT":
		*t.Value = wireTypeMapT{*(fieldTarget.(*wireMapTarget)).Value}
	case "StructT":
		*t.Value = wireTypeStructT{*(fieldTarget.(*wireStructTarget)).Value}
	case "UnionT":
		*t.Value = wireTypeUnionT{*(fieldTarget.(*wireUnionTarget)).Value}
	case "OptionalT":
		*t.Value = wireTypeOptionalT{*(fieldTarget.(*wireOptionalTarget)).Value}
	}
	return nil
}
func (t *wireTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type wireTypeTargetFactory struct{}

func (t wireTypeTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*wireType); ok {
		return &wireTypeTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *wireType", union)
}

// Create zero values for each type.
var (
	__VDLZeroControlKind = ControlKindNil
	__VDLZeroPrimitive   = Primitive(PrimitivePBool{})
	__VDLZeroDumpKind    = DumpKindVersion
	__VDLZeroDumpAtom    = DumpAtom{
		Data: PrimitivePBool{},
	}
	__VDLZerotypeId       = typeId(0)
	__VDLZerowireNamed    = wireNamed{}
	__VDLZerowireEnum     = wireEnum{}
	__VDLZerowireArray    = wireArray{}
	__VDLZerowireList     = wireList{}
	__VDLZerowireSet      = wireSet{}
	__VDLZerowireMap      = wireMap{}
	__VDLZerowireField    = wireField{}
	__VDLZerowireStruct   = wireStruct{}
	__VDLZerowireUnion    = wireUnion{}
	__VDLZerowireOptional = wireOptional{}
	__VDLZerowireType     = wireType(wireTypeNamedT{})
)

//////////////////////////////////////////////////
// Const definitions

// Primitive types.
const WireIdBool = typeId(1)
const WireIdByte = typeId(2)
const WireIdString = typeId(3)
const WireIdUint16 = typeId(4)
const WireIdUint32 = typeId(5)
const WireIdUint64 = typeId(6)
const WireIdInt16 = typeId(7)
const WireIdInt32 = typeId(8)
const WireIdInt64 = typeId(9)
const WireIdFloat32 = typeId(10)
const WireIdFloat64 = typeId(11)
const WireIdComplex64 = typeId(12)
const WireIdComplex128 = typeId(13)
const WireIdTypeObject = typeId(14)
const WireIdAny = typeId(15)
const WireIdInt8 = typeId(16)

// Other commonly used composites.
const WireIdByteList = typeId(39)
const WireIdStringList = typeId(40)

// The first user-defined typeId is 41.
const WireIdFirstUserType = typeId(41)
const WireCtrlNil = byte(224)            // Nil in optional or any
const WireCtrlEnd = byte(225)            // End of struct or union
const WireCtrlTypeIncomplete = byte(226) // Marks that the type message is incomplete until future messages are received

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}

	// Register types.
	vdl.Register((*ControlKind)(nil))
	vdl.Register((*Primitive)(nil))
	vdl.Register((*DumpKind)(nil))
	vdl.Register((*DumpAtom)(nil))
	vdl.Register((*typeId)(nil))
	vdl.Register((*wireNamed)(nil))
	vdl.Register((*wireEnum)(nil))
	vdl.Register((*wireArray)(nil))
	vdl.Register((*wireList)(nil))
	vdl.Register((*wireSet)(nil))
	vdl.Register((*wireMap)(nil))
	vdl.Register((*wireField)(nil))
	vdl.Register((*wireStruct)(nil))
	vdl.Register((*wireUnion)(nil))
	vdl.Register((*wireOptional)(nil))
	vdl.Register((*wireType)(nil))

	return struct{}{}
}
