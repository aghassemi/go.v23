// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: vom

package vom

import (
	"fmt"
	"v.io/v23/vdl"
	"v.io/v23/vdl/vdlconv"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// ControlKind enumerates the different kinds of control bytes.
type ControlKind int

const (
	ControlKindNil ControlKind = iota
	ControlKindEnd
	ControlKindIncompleteType
)

// ControlKindAll holds all labels for ControlKind.
var ControlKindAll = [...]ControlKind{ControlKindNil, ControlKindEnd, ControlKindIncompleteType}

// ControlKindFromString creates a ControlKind from a string label.
func ControlKindFromString(label string) (x ControlKind, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ControlKind) Set(label string) error {
	switch label {
	case "Nil", "nil":
		*x = ControlKindNil
		return nil
	case "End", "end":
		*x = ControlKindEnd
		return nil
	case "IncompleteType", "incompletetype":
		*x = ControlKindIncompleteType
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in vom.ControlKind", label)
}

// String returns the string label of x.
func (x ControlKind) String() string {
	switch x {
	case ControlKindNil:
		return "Nil"
	case ControlKindEnd:
		return "End"
	case ControlKindIncompleteType:
		return "IncompleteType"
	}
	return ""
}

func (ControlKind) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.ControlKind"`
	Enum struct{ Nil, End, IncompleteType string }
}) {
}

func (m *ControlKind) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *ControlKind) MakeVDLTarget() vdl.Target {
	return &ControlKindTarget{Value: m}
}

type ControlKindTarget struct {
	Value *ControlKind
	vdl.TargetBase
}

func (t *ControlKindTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*ControlKind)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Nil":
		*t.Value = 0
	case "End":
		*t.Value = 1
	case "IncompleteType":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum ControlKind", src)
	}

	return nil
}

func (x ControlKind) VDLIsZero() bool {
	return x == ControlKindNil
}

func (x ControlKind) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ControlKind)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ControlKind) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type (
	// Primitive represents any single field of the Primitive union type.
	//
	// Primitive represents one of the primitive vom values.  All vom values are
	// composed of combinations of these primitives.
	Primitive interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the Primitive union type.
		__VDLReflect(__PrimitiveReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// PrimitivePBool represents field PBool of the Primitive union type.
	PrimitivePBool struct{ Value bool }
	// PrimitivePByte represents field PByte of the Primitive union type.
	PrimitivePByte struct{ Value byte }
	// PrimitivePUint represents field PUint of the Primitive union type.
	PrimitivePUint struct{ Value uint64 }
	// PrimitivePInt represents field PInt of the Primitive union type.
	PrimitivePInt struct{ Value int64 }
	// PrimitivePFloat represents field PFloat of the Primitive union type.
	PrimitivePFloat struct{ Value float64 }
	// PrimitivePString represents field PString of the Primitive union type.
	PrimitivePString struct{ Value string }
	// PrimitivePControl represents field PControl of the Primitive union type.
	PrimitivePControl struct{ Value ControlKind }
	// __PrimitiveReflect describes the Primitive union type.
	__PrimitiveReflect struct {
		Name               string `vdl:"v.io/v23/vom.Primitive"`
		Type               Primitive
		UnionTargetFactory primitiveTargetFactory
		Union              struct {
			PBool    PrimitivePBool
			PByte    PrimitivePByte
			PUint    PrimitivePUint
			PInt     PrimitivePInt
			PFloat   PrimitivePFloat
			PString  PrimitivePString
			PControl PrimitivePControl
		}
	}
)

func (x PrimitivePBool) Index() int                      { return 0 }
func (x PrimitivePBool) Interface() interface{}          { return x.Value }
func (x PrimitivePBool) Name() string                    { return "PBool" }
func (x PrimitivePBool) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePBool) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PBool")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromBool(bool(m.Value), tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePBool) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePByte) Index() int                      { return 1 }
func (x PrimitivePByte) Interface() interface{}          { return x.Value }
func (x PrimitivePByte) Name() string                    { return "PByte" }
func (x PrimitivePByte) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePByte) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PByte")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromUint(uint64(m.Value), tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePByte) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePUint) Index() int                      { return 2 }
func (x PrimitivePUint) Interface() interface{}          { return x.Value }
func (x PrimitivePUint) Name() string                    { return "PUint" }
func (x PrimitivePUint) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePUint) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PUint")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromUint(uint64(m.Value), tt.NonOptional().Field(2).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePUint) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePInt) Index() int                      { return 3 }
func (x PrimitivePInt) Interface() interface{}          { return x.Value }
func (x PrimitivePInt) Name() string                    { return "PInt" }
func (x PrimitivePInt) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePInt) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PInt")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromInt(int64(m.Value), tt.NonOptional().Field(3).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePInt) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePFloat) Index() int                      { return 4 }
func (x PrimitivePFloat) Interface() interface{}          { return x.Value }
func (x PrimitivePFloat) Name() string                    { return "PFloat" }
func (x PrimitivePFloat) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePFloat) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PFloat")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromFloat(float64(m.Value), tt.NonOptional().Field(4).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePFloat) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePString) Index() int                      { return 5 }
func (x PrimitivePString) Interface() interface{}          { return x.Value }
func (x PrimitivePString) Name() string                    { return "PString" }
func (x PrimitivePString) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePString) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PString")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), tt.NonOptional().Field(5).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePString) MakeVDLTarget() vdl.Target {
	return nil
}

func (x PrimitivePControl) Index() int                      { return 6 }
func (x PrimitivePControl) Interface() interface{}          { return x.Value }
func (x PrimitivePControl) Name() string                    { return "PControl" }
func (x PrimitivePControl) __VDLReflect(__PrimitiveReflect) {}

func (m PrimitivePControl) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("PControl")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(6).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m PrimitivePControl) MakeVDLTarget() vdl.Target {
	return nil
}

type PrimitiveTarget struct {
	Value     *Primitive
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *PrimitiveTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*Primitive)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *PrimitiveTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "PBool":
		val := false
		return nil, &vdl.BoolTarget{Value: &val}, nil
	case "PByte":
		val := byte(0)
		return nil, &vdl.ByteTarget{Value: &val}, nil
	case "PUint":
		val := uint64(0)
		return nil, &vdl.Uint64Target{Value: &val}, nil
	case "PInt":
		val := int64(0)
		return nil, &vdl.Int64Target{Value: &val}, nil
	case "PFloat":
		val := float64(0)
		return nil, &vdl.Float64Target{Value: &val}, nil
	case "PString":
		val := ""
		return nil, &vdl.StringTarget{Value: &val}, nil
	case "PControl":
		val := ControlKindNil
		return nil, &ControlKindTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/vom.Primitive", name)
	}
}
func (t *PrimitiveTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "PBool":
		*t.Value = PrimitivePBool{*(fieldTarget.(*vdl.BoolTarget)).Value}
	case "PByte":
		*t.Value = PrimitivePByte{*(fieldTarget.(*vdl.ByteTarget)).Value}
	case "PUint":
		*t.Value = PrimitivePUint{*(fieldTarget.(*vdl.Uint64Target)).Value}
	case "PInt":
		*t.Value = PrimitivePInt{*(fieldTarget.(*vdl.Int64Target)).Value}
	case "PFloat":
		*t.Value = PrimitivePFloat{*(fieldTarget.(*vdl.Float64Target)).Value}
	case "PString":
		*t.Value = PrimitivePString{*(fieldTarget.(*vdl.StringTarget)).Value}
	case "PControl":
		*t.Value = PrimitivePControl{*(fieldTarget.(*ControlKindTarget)).Value}
	}
	return nil
}
func (t *PrimitiveTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type primitiveTargetFactory struct{}

func (t primitiveTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*Primitive); ok {
		return &PrimitiveTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *Primitive", union)
}

func (x PrimitivePBool) VDLIsZero() bool {
	return !x.Value
}

func (x PrimitivePByte) VDLIsZero() bool {
	return false
}

func (x PrimitivePUint) VDLIsZero() bool {
	return false
}

func (x PrimitivePInt) VDLIsZero() bool {
	return false
}

func (x PrimitivePFloat) VDLIsZero() bool {
	return false
}

func (x PrimitivePString) VDLIsZero() bool {
	return false
}

func (x PrimitivePControl) VDLIsZero() bool {
	return false
}

func (x PrimitivePBool) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Primitive)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("PBool"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.BoolType); err != nil {
		return err
	}
	if err := enc.EncodeBool(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePByte) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Primitive)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("PByte"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.ByteType); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x.Value)); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePUint) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Primitive)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("PUint"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.Uint64Type); err != nil {
		return err
	}
	if err := enc.EncodeUint(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePInt) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Primitive)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("PInt"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.Int64Type); err != nil {
		return err
	}
	if err := enc.EncodeInt(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePFloat) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Primitive)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("PFloat"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.Float64Type); err != nil {
		return err
	}
	if err := enc.EncodeFloat(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePString) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Primitive)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("PString"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.StringType); err != nil {
		return err
	}
	if err := enc.EncodeString(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x PrimitivePControl) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Primitive)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("PControl"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadPrimitive(dec vdl.Decoder, x *Primitive) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "PBool":
		var field PrimitivePBool
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeBool(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "PByte":
		var field PrimitivePByte
		if err := dec.StartValue(); err != nil {
			return err
		}
		tmp, err := dec.DecodeUint(8)
		if err != nil {
			return err
		}
		field.Value = byte(tmp)
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "PUint":
		var field PrimitivePUint
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeUint(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "PInt":
		var field PrimitivePInt
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeInt(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "PFloat":
		var field PrimitivePFloat
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeFloat(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "PString":
		var field PrimitivePString
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "PControl":
		var field PrimitivePControl
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

// DumpKind enumerates the different kinds of dump atoms.
type DumpKind int

const (
	DumpKindVersion DumpKind = iota
	DumpKindControl
	DumpKindMsgId
	DumpKindTypeMsg
	DumpKindValueMsg
	DumpKindMsgLen
	DumpKindAnyMsgLen
	DumpKindAnyLensLen
	DumpKindTypeIdsLen
	DumpKindTypeId
	DumpKindPrimValue
	DumpKindByteLen
	DumpKindValueLen
	DumpKindIndex
	DumpKindWireTypeIndex
)

// DumpKindAll holds all labels for DumpKind.
var DumpKindAll = [...]DumpKind{DumpKindVersion, DumpKindControl, DumpKindMsgId, DumpKindTypeMsg, DumpKindValueMsg, DumpKindMsgLen, DumpKindAnyMsgLen, DumpKindAnyLensLen, DumpKindTypeIdsLen, DumpKindTypeId, DumpKindPrimValue, DumpKindByteLen, DumpKindValueLen, DumpKindIndex, DumpKindWireTypeIndex}

// DumpKindFromString creates a DumpKind from a string label.
func DumpKindFromString(label string) (x DumpKind, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *DumpKind) Set(label string) error {
	switch label {
	case "Version", "version":
		*x = DumpKindVersion
		return nil
	case "Control", "control":
		*x = DumpKindControl
		return nil
	case "MsgId", "msgid":
		*x = DumpKindMsgId
		return nil
	case "TypeMsg", "typemsg":
		*x = DumpKindTypeMsg
		return nil
	case "ValueMsg", "valuemsg":
		*x = DumpKindValueMsg
		return nil
	case "MsgLen", "msglen":
		*x = DumpKindMsgLen
		return nil
	case "AnyMsgLen", "anymsglen":
		*x = DumpKindAnyMsgLen
		return nil
	case "AnyLensLen", "anylenslen":
		*x = DumpKindAnyLensLen
		return nil
	case "TypeIdsLen", "typeidslen":
		*x = DumpKindTypeIdsLen
		return nil
	case "TypeId", "typeid":
		*x = DumpKindTypeId
		return nil
	case "PrimValue", "primvalue":
		*x = DumpKindPrimValue
		return nil
	case "ByteLen", "bytelen":
		*x = DumpKindByteLen
		return nil
	case "ValueLen", "valuelen":
		*x = DumpKindValueLen
		return nil
	case "Index", "index":
		*x = DumpKindIndex
		return nil
	case "WireTypeIndex", "wiretypeindex":
		*x = DumpKindWireTypeIndex
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in vom.DumpKind", label)
}

// String returns the string label of x.
func (x DumpKind) String() string {
	switch x {
	case DumpKindVersion:
		return "Version"
	case DumpKindControl:
		return "Control"
	case DumpKindMsgId:
		return "MsgId"
	case DumpKindTypeMsg:
		return "TypeMsg"
	case DumpKindValueMsg:
		return "ValueMsg"
	case DumpKindMsgLen:
		return "MsgLen"
	case DumpKindAnyMsgLen:
		return "AnyMsgLen"
	case DumpKindAnyLensLen:
		return "AnyLensLen"
	case DumpKindTypeIdsLen:
		return "TypeIdsLen"
	case DumpKindTypeId:
		return "TypeId"
	case DumpKindPrimValue:
		return "PrimValue"
	case DumpKindByteLen:
		return "ByteLen"
	case DumpKindValueLen:
		return "ValueLen"
	case DumpKindIndex:
		return "Index"
	case DumpKindWireTypeIndex:
		return "WireTypeIndex"
	}
	return ""
}

func (DumpKind) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.DumpKind"`
	Enum struct{ Version, Control, MsgId, TypeMsg, ValueMsg, MsgLen, AnyMsgLen, AnyLensLen, TypeIdsLen, TypeId, PrimValue, ByteLen, ValueLen, Index, WireTypeIndex string }
}) {
}

func (m *DumpKind) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *DumpKind) MakeVDLTarget() vdl.Target {
	return &DumpKindTarget{Value: m}
}

type DumpKindTarget struct {
	Value *DumpKind
	vdl.TargetBase
}

func (t *DumpKindTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*DumpKind)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Version":
		*t.Value = 0
	case "Control":
		*t.Value = 1
	case "MsgId":
		*t.Value = 2
	case "TypeMsg":
		*t.Value = 3
	case "ValueMsg":
		*t.Value = 4
	case "MsgLen":
		*t.Value = 5
	case "AnyMsgLen":
		*t.Value = 6
	case "AnyLensLen":
		*t.Value = 7
	case "TypeIdsLen":
		*t.Value = 8
	case "TypeId":
		*t.Value = 9
	case "PrimValue":
		*t.Value = 10
	case "ByteLen":
		*t.Value = 11
	case "ValueLen":
		*t.Value = 12
	case "Index":
		*t.Value = 13
	case "WireTypeIndex":
		*t.Value = 14
	default:
		return fmt.Errorf("label %s not in enum DumpKind", src)
	}

	return nil
}

func (x DumpKind) VDLIsZero() bool {
	return x == DumpKindVersion
}

func (x DumpKind) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*DumpKind)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *DumpKind) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

// DumpAtom describes a single indivisible piece of the vom encoding.  The vom
// encoding is composed of a stream of these atoms.
type DumpAtom struct {
	Kind  DumpKind  // The kind of this atom.
	Bytes []byte    // Raw bytes in the vom encoding representing this atom.
	Data  Primitive // Primitive data corresponding to the raw bytes.
	Debug string    // Free-form debug string with more information.
}

func (DumpAtom) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.DumpAtom"`
}) {
}

func (m *DumpAtom) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Kind == DumpKindVersion)
	if var4 {
		if err := fieldsTarget1.ZeroField("Kind"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Kind")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Kind.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.Bytes) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("Bytes"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Bytes")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := fieldTarget6.FromBytes([]byte(m.Bytes), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var var10 bool
	if field, ok := m.Data.(PrimitivePBool); ok {

		var11 := (field.Value == false)
		var10 = var11
	}
	if var10 {
		if err := fieldsTarget1.ZeroField("Data"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Data")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			unionValue12 := m.Data
			if unionValue12 == nil {
				unionValue12 = PrimitivePBool{}
			}
			if err := unionValue12.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var15 := (m.Debug == "")
	if var15 {
		if err := fieldsTarget1.ZeroField("Debug"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("Debug")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget14.FromString(string(m.Debug), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *DumpAtom) MakeVDLTarget() vdl.Target {
	return &DumpAtomTarget{Value: m}
}

type DumpAtomTarget struct {
	Value       *DumpAtom
	kindTarget  DumpKindTarget
	bytesTarget vdl.BytesTarget
	dataTarget  PrimitiveTarget
	debugTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *DumpAtomTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*DumpAtom)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *DumpAtomTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Kind":
		t.kindTarget.Value = &t.Value.Kind
		target, err := &t.kindTarget, error(nil)
		return nil, target, err
	case "Bytes":
		t.bytesTarget.Value = &t.Value.Bytes
		target, err := &t.bytesTarget, error(nil)
		return nil, target, err
	case "Data":
		t.dataTarget.Value = &t.Value.Data
		target, err := &t.dataTarget, error(nil)
		return nil, target, err
	case "Debug":
		t.debugTarget.Value = &t.Value.Debug
		target, err := &t.debugTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *DumpAtomTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *DumpAtomTarget) ZeroField(name string) error {
	switch name {
	case "Kind":
		t.Value.Kind = DumpKindVersion
		return nil
	case "Bytes":
		t.Value.Bytes = []byte(nil)
		return nil
	case "Data":
		t.Value.Data = Primitive(PrimitivePBool{})
		return nil
	case "Debug":
		t.Value.Debug = ""
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *DumpAtomTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x DumpAtom) VDLIsZero() bool {
	if x.Kind != DumpKindVersion {
		return false
	}
	if len(x.Bytes) != 0 {
		return false
	}
	if x.Data != nil && !x.Data.VDLIsZero() {
		return false
	}
	if x.Debug != "" {
		return false
	}
	return true
}

func (x DumpAtom) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*DumpAtom)(nil)).Elem()); err != nil {
		return err
	}
	if x.Kind != DumpKindVersion {
		if err := enc.NextField("Kind"); err != nil {
			return err
		}
		if err := x.Kind.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.Bytes) != 0 {
		if err := enc.NextField("Bytes"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*[]byte)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeBytes(x.Bytes); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Data != nil && !x.Data.VDLIsZero() {
		if err := enc.NextField("Data"); err != nil {
			return err
		}
		if err := x.Data.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Debug != "" {
		if err := enc.NextField("Debug"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Debug); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *DumpAtom) VDLRead(dec vdl.Decoder) error {
	*x = DumpAtom{
		Data: PrimitivePBool{},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Kind":
			if err := x.Kind.VDLRead(dec); err != nil {
				return err
			}
		case "Bytes":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if err := dec.DecodeBytes(-1, &x.Bytes); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Data":
			if err := VDLReadPrimitive(dec, &x.Data); err != nil {
				return err
			}
		case "Debug":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Debug, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// TypeId uniquely identifies a type definition within a vom stream.
type TypeId uint64

func (TypeId) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.TypeId"`
}) {
}

func (m *TypeId) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *TypeId) MakeVDLTarget() vdl.Target {
	return &TypeIdTarget{Value: m}
}

type TypeIdTarget struct {
	Value *TypeId
	vdl.TargetBase
}

func (t *TypeIdTarget) FromUint(src uint64, tt *vdl.Type) error {

	*t.Value = TypeId(src)

	return nil
}
func (t *TypeIdTarget) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = TypeId(val)

	return nil
}
func (t *TypeIdTarget) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = TypeId(val)

	return nil
}

func (x TypeId) VDLIsZero() bool {
	return x == 0
}

func (x TypeId) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*TypeId)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *TypeId) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(64)
	if err != nil {
		return err
	}
	*x = TypeId(tmp)
	return dec.FinishValue()
}

// wireNamed represents a type definition for named primitives.
type wireNamed struct {
	Name string
	Base TypeId
}

func (wireNamed) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireNamed"`
}) {
}

func (m *wireNamed) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Base == TypeId(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Base"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Base")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Base.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireNamed) MakeVDLTarget() vdl.Target {
	return &wireNamedTarget{Value: m}
}

type wireNamedTarget struct {
	Value      *wireNamed
	nameTarget vdl.StringTarget
	baseTarget TypeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireNamedTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireNamed)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireNamedTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Base":
		t.baseTarget.Value = &t.Value.Base
		target, err := &t.baseTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *wireNamedTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireNamedTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Base":
		t.Value.Base = TypeId(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *wireNamedTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x wireNamed) VDLIsZero() bool {
	return x == wireNamed{}
}

func (x wireNamed) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireNamed)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Base != 0 {
		if err := enc.NextField("Base"); err != nil {
			return err
		}
		if err := x.Base.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireNamed) VDLRead(dec vdl.Decoder) error {
	*x = wireNamed{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Base":
			if err := x.Base.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// wireEnum represents an type definition for enum types.
type wireEnum struct {
	Name   string
	Labels []string
}

func (wireEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireEnum"`
}) {
}

func (m *wireEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.Labels) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("Labels"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Labels")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget8, err := fieldTarget6.StartList(tt.NonOptional().Field(1).Type, len(m.Labels))
			if err != nil {
				return err
			}
			for i, elem10 := range m.Labels {
				elemTarget9, err := listTarget8.StartElem(i)
				if err != nil {
					return err
				}
				if err := elemTarget9.FromString(string(elem10), tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget8.FinishElem(elemTarget9); err != nil {
					return err
				}
			}
			if err := fieldTarget6.FinishList(listTarget8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireEnum) MakeVDLTarget() vdl.Target {
	return &wireEnumTarget{Value: m}
}

type wireEnumTarget struct {
	Value        *wireEnum
	nameTarget   vdl.StringTarget
	labelsTarget vdl.StringSliceTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireEnumTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireEnum)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireEnumTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Labels":
		t.labelsTarget.Value = &t.Value.Labels
		target, err := &t.labelsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *wireEnumTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireEnumTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Labels":
		t.Value.Labels = []string(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *wireEnumTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x wireEnum) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if len(x.Labels) != 0 {
		return false
	}
	return true
}

func (x wireEnum) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireEnum)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if len(x.Labels) != 0 {
		if err := enc.NextField("Labels"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_1(enc, x.Labels); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_1(enc vdl.Encoder, x []string) error {
	if err := enc.StartValue(vdl.TypeOf((*[]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireEnum) VDLRead(dec vdl.Decoder) error {
	*x = wireEnum{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Labels":
			if err := __VDLReadAnon_list_1(dec, &x.Labels); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_1(dec vdl.Decoder, x *[]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]string, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem string
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if elem, err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// wireArray represents an type definition for array types.
type wireArray struct {
	Name string
	Elem TypeId
	Len  uint64
}

func (wireArray) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireArray"`
}) {
}

func (m *wireArray) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Elem == TypeId(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Elem"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Elem")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Elem.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Len == uint64(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("Len"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Len")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromUint(uint64(m.Len), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireArray) MakeVDLTarget() vdl.Target {
	return &wireArrayTarget{Value: m}
}

type wireArrayTarget struct {
	Value      *wireArray
	nameTarget vdl.StringTarget
	elemTarget TypeIdTarget
	lenTarget  vdl.Uint64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireArrayTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireArray)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireArrayTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Elem":
		t.elemTarget.Value = &t.Value.Elem
		target, err := &t.elemTarget, error(nil)
		return nil, target, err
	case "Len":
		t.lenTarget.Value = &t.Value.Len
		target, err := &t.lenTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *wireArrayTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireArrayTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Elem":
		t.Value.Elem = TypeId(0)
		return nil
	case "Len":
		t.Value.Len = uint64(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *wireArrayTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x wireArray) VDLIsZero() bool {
	return x == wireArray{}
}

func (x wireArray) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireArray)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Elem != 0 {
		if err := enc.NextField("Elem"); err != nil {
			return err
		}
		if err := x.Elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Len != 0 {
		if err := enc.NextField("Len"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(x.Len); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireArray) VDLRead(dec vdl.Decoder) error {
	*x = wireArray{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Elem":
			if err := x.Elem.VDLRead(dec); err != nil {
				return err
			}
		case "Len":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Len, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// wireList represents a type definition for list types.
type wireList struct {
	Name string
	Elem TypeId
}

func (wireList) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireList"`
}) {
}

func (m *wireList) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Elem == TypeId(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Elem"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Elem")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Elem.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireList) MakeVDLTarget() vdl.Target {
	return &wireListTarget{Value: m}
}

type wireListTarget struct {
	Value      *wireList
	nameTarget vdl.StringTarget
	elemTarget TypeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireListTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireList)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireListTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Elem":
		t.elemTarget.Value = &t.Value.Elem
		target, err := &t.elemTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *wireListTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireListTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Elem":
		t.Value.Elem = TypeId(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *wireListTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x wireList) VDLIsZero() bool {
	return x == wireList{}
}

func (x wireList) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireList)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Elem != 0 {
		if err := enc.NextField("Elem"); err != nil {
			return err
		}
		if err := x.Elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireList) VDLRead(dec vdl.Decoder) error {
	*x = wireList{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Elem":
			if err := x.Elem.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// wireSet represents a type definition for set types.
type wireSet struct {
	Name string
	Key  TypeId
}

func (wireSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireSet"`
}) {
}

func (m *wireSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Key == TypeId(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Key"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Key")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Key.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireSet) MakeVDLTarget() vdl.Target {
	return &wireSetTarget{Value: m}
}

type wireSetTarget struct {
	Value      *wireSet
	nameTarget vdl.StringTarget
	keyTarget  TypeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireSetTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireSet)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireSetTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *wireSetTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireSetTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Key":
		t.Value.Key = TypeId(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *wireSetTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x wireSet) VDLIsZero() bool {
	return x == wireSet{}
}

func (x wireSet) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireSet)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Key != 0 {
		if err := enc.NextField("Key"); err != nil {
			return err
		}
		if err := x.Key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireSet) VDLRead(dec vdl.Decoder) error {
	*x = wireSet{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Key":
			if err := x.Key.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// wireMap represents a type definition for map types.
type wireMap struct {
	Name string
	Key  TypeId
	Elem TypeId
}

func (wireMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireMap"`
}) {
}

func (m *wireMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Key == TypeId(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Key"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Key")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Key.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Elem == TypeId(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("Elem"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Elem")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Elem.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireMap) MakeVDLTarget() vdl.Target {
	return &wireMapTarget{Value: m}
}

type wireMapTarget struct {
	Value      *wireMap
	nameTarget vdl.StringTarget
	keyTarget  TypeIdTarget
	elemTarget TypeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireMapTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireMap)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireMapTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	case "Elem":
		t.elemTarget.Value = &t.Value.Elem
		target, err := &t.elemTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *wireMapTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireMapTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Key":
		t.Value.Key = TypeId(0)
		return nil
	case "Elem":
		t.Value.Elem = TypeId(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *wireMapTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x wireMap) VDLIsZero() bool {
	return x == wireMap{}
}

func (x wireMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireMap)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Key != 0 {
		if err := enc.NextField("Key"); err != nil {
			return err
		}
		if err := x.Key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Elem != 0 {
		if err := enc.NextField("Elem"); err != nil {
			return err
		}
		if err := x.Elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireMap) VDLRead(dec vdl.Decoder) error {
	*x = wireMap{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Key":
			if err := x.Key.VDLRead(dec); err != nil {
				return err
			}
		case "Elem":
			if err := x.Elem.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// wireField represents a field in a struct or union type.
type wireField struct {
	Name string
	Type TypeId
}

func (wireField) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireField"`
}) {
}

func (m *wireField) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Type == TypeId(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Type"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Type")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Type.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireField) MakeVDLTarget() vdl.Target {
	return &wireFieldTarget{Value: m}
}

type wireFieldTarget struct {
	Value      *wireField
	nameTarget vdl.StringTarget
	typeTarget TypeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireFieldTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireField)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireFieldTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Type":
		t.typeTarget.Value = &t.Value.Type
		target, err := &t.typeTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *wireFieldTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireFieldTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Type":
		t.Value.Type = TypeId(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *wireFieldTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x wireField) VDLIsZero() bool {
	return x == wireField{}
}

func (x wireField) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireField)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Type != 0 {
		if err := enc.NextField("Type"); err != nil {
			return err
		}
		if err := x.Type.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireField) VDLRead(dec vdl.Decoder) error {
	*x = wireField{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Type":
			if err := x.Type.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// wireStruct represents a type definition for struct types.
type wireStruct struct {
	Name   string
	Fields []wireField
}

func (wireStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireStruct"`
}) {
}

func (m *wireStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.Fields) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("Fields"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Fields")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget8, err := fieldTarget6.StartList(tt.NonOptional().Field(1).Type, len(m.Fields))
			if err != nil {
				return err
			}
			for i, elem10 := range m.Fields {
				elemTarget9, err := listTarget8.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem10.FillVDLTarget(elemTarget9, tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget8.FinishElem(elemTarget9); err != nil {
					return err
				}
			}
			if err := fieldTarget6.FinishList(listTarget8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireStruct) MakeVDLTarget() vdl.Target {
	return &wireStructTarget{Value: m}
}

type wireStructTarget struct {
	Value        *wireStruct
	nameTarget   vdl.StringTarget
	fieldsTarget __VDLTarget1_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Fields":
		t.fieldsTarget.Value = &t.Value.Fields
		target, err := &t.fieldsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *wireStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireStructTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Fields":
		t.Value.Fields = []wireField(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *wireStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []wireField
type __VDLTarget1_list struct {
	Value      *[]wireField
	elemTarget wireFieldTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]wireField)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]wireField, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x wireStruct) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if len(x.Fields) != 0 {
		return false
	}
	return true
}

func (x wireStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if len(x.Fields) != 0 {
		if err := enc.NextField("Fields"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_2(enc, x.Fields); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_2(enc vdl.Encoder, x []wireField) error {
	if err := enc.StartValue(vdl.TypeOf((*[]wireField)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireStruct) VDLRead(dec vdl.Decoder) error {
	*x = wireStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Fields":
			if err := __VDLReadAnon_list_2(dec, &x.Fields); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_2(dec vdl.Decoder, x *[]wireField) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]wireField, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem wireField
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// wireUnion represents a type definition for union types.
type wireUnion struct {
	Name   string
	Fields []wireField
}

func (wireUnion) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireUnion"`
}) {
}

func (m *wireUnion) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.Fields) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("Fields"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Fields")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget8, err := fieldTarget6.StartList(tt.NonOptional().Field(1).Type, len(m.Fields))
			if err != nil {
				return err
			}
			for i, elem10 := range m.Fields {
				elemTarget9, err := listTarget8.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem10.FillVDLTarget(elemTarget9, tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget8.FinishElem(elemTarget9); err != nil {
					return err
				}
			}
			if err := fieldTarget6.FinishList(listTarget8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireUnion) MakeVDLTarget() vdl.Target {
	return &wireUnionTarget{Value: m}
}

type wireUnionTarget struct {
	Value        *wireUnion
	nameTarget   vdl.StringTarget
	fieldsTarget __VDLTarget1_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireUnionTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireUnion)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireUnionTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Fields":
		t.fieldsTarget.Value = &t.Value.Fields
		target, err := &t.fieldsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *wireUnionTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireUnionTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Fields":
		t.Value.Fields = []wireField(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *wireUnionTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x wireUnion) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if len(x.Fields) != 0 {
		return false
	}
	return true
}

func (x wireUnion) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireUnion)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if len(x.Fields) != 0 {
		if err := enc.NextField("Fields"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_2(enc, x.Fields); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireUnion) VDLRead(dec vdl.Decoder) error {
	*x = wireUnion{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Fields":
			if err := __VDLReadAnon_list_2(dec, &x.Fields); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// wireOptional represents an type definition for optional types.
type wireOptional struct {
	Name string
	Elem TypeId
}

func (wireOptional) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom.wireOptional"`
}) {
}

func (m *wireOptional) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Elem == TypeId(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Elem"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Elem")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Elem.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *wireOptional) MakeVDLTarget() vdl.Target {
	return &wireOptionalTarget{Value: m}
}

type wireOptionalTarget struct {
	Value      *wireOptional
	nameTarget vdl.StringTarget
	elemTarget TypeIdTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireOptionalTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*wireOptional)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *wireOptionalTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Elem":
		t.elemTarget.Value = &t.Value.Elem
		target, err := &t.elemTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *wireOptionalTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *wireOptionalTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Elem":
		t.Value.Elem = TypeId(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *wireOptionalTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x wireOptional) VDLIsZero() bool {
	return x == wireOptional{}
}

func (x wireOptional) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireOptional)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Elem != 0 {
		if err := enc.NextField("Elem"); err != nil {
			return err
		}
		if err := x.Elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *wireOptional) VDLRead(dec vdl.Decoder) error {
	*x = wireOptional{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Elem":
			if err := x.Elem.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type (
	// wireType represents any single field of the wireType union type.
	//
	// The wireType union is used to encode the payload part of each type message,
	// using the regular rules for encoding union values.  But unlike our regular
	// encoding, the type message for wireType itself (and its fields) are never
	// encoded; we need to bootstrap the system.  Thus unlike regular values, the
	// ordering of fields within the wire* types cannot be changed.
	wireType interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the wireType union type.
		__VDLReflect(__wireTypeReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// wireTypeNamedT represents field NamedT of the wireType union type.
	//
	// FIELD INDICES MUST NOT BE CHANGED.
	wireTypeNamedT struct{ Value wireNamed } // INDEX = 0
	// wireTypeEnumT represents field EnumT of the wireType union type.
	wireTypeEnumT struct{ Value wireEnum } // INDEX = 1
	// wireTypeArrayT represents field ArrayT of the wireType union type.
	wireTypeArrayT struct{ Value wireArray } // INDEX = 2
	// wireTypeListT represents field ListT of the wireType union type.
	wireTypeListT struct{ Value wireList } // INDEX = 3
	// wireTypeSetT represents field SetT of the wireType union type.
	wireTypeSetT struct{ Value wireSet } // INDEX = 4
	// wireTypeMapT represents field MapT of the wireType union type.
	wireTypeMapT struct{ Value wireMap } // INDEX = 5
	// wireTypeStructT represents field StructT of the wireType union type.
	wireTypeStructT struct{ Value wireStruct } // INDEX = 6
	// wireTypeUnionT represents field UnionT of the wireType union type.
	wireTypeUnionT struct{ Value wireUnion } // INDEX = 7
	// wireTypeOptionalT represents field OptionalT of the wireType union type.
	wireTypeOptionalT struct{ Value wireOptional } // INDEX = 8
	// __wireTypeReflect describes the wireType union type.
	__wireTypeReflect struct {
		Name               string `vdl:"v.io/v23/vom.wireType"`
		Type               wireType
		UnionTargetFactory wireTypeTargetFactory
		Union              struct {
			NamedT    wireTypeNamedT
			EnumT     wireTypeEnumT
			ArrayT    wireTypeArrayT
			ListT     wireTypeListT
			SetT      wireTypeSetT
			MapT      wireTypeMapT
			StructT   wireTypeStructT
			UnionT    wireTypeUnionT
			OptionalT wireTypeOptionalT
		}
	}
)

func (x wireTypeNamedT) Index() int                     { return 0 }
func (x wireTypeNamedT) Interface() interface{}         { return x.Value }
func (x wireTypeNamedT) Name() string                   { return "NamedT" }
func (x wireTypeNamedT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeNamedT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("NamedT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeNamedT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeEnumT) Index() int                     { return 1 }
func (x wireTypeEnumT) Interface() interface{}         { return x.Value }
func (x wireTypeEnumT) Name() string                   { return "EnumT" }
func (x wireTypeEnumT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeEnumT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("EnumT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeEnumT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeArrayT) Index() int                     { return 2 }
func (x wireTypeArrayT) Interface() interface{}         { return x.Value }
func (x wireTypeArrayT) Name() string                   { return "ArrayT" }
func (x wireTypeArrayT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeArrayT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ArrayT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(2).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeArrayT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeListT) Index() int                     { return 3 }
func (x wireTypeListT) Interface() interface{}         { return x.Value }
func (x wireTypeListT) Name() string                   { return "ListT" }
func (x wireTypeListT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeListT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ListT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(3).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeListT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeSetT) Index() int                     { return 4 }
func (x wireTypeSetT) Interface() interface{}         { return x.Value }
func (x wireTypeSetT) Name() string                   { return "SetT" }
func (x wireTypeSetT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeSetT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("SetT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(4).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeSetT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeMapT) Index() int                     { return 5 }
func (x wireTypeMapT) Interface() interface{}         { return x.Value }
func (x wireTypeMapT) Name() string                   { return "MapT" }
func (x wireTypeMapT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeMapT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("MapT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(5).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeMapT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeStructT) Index() int                     { return 6 }
func (x wireTypeStructT) Interface() interface{}         { return x.Value }
func (x wireTypeStructT) Name() string                   { return "StructT" }
func (x wireTypeStructT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeStructT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("StructT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(6).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeStructT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeUnionT) Index() int                     { return 7 }
func (x wireTypeUnionT) Interface() interface{}         { return x.Value }
func (x wireTypeUnionT) Name() string                   { return "UnionT" }
func (x wireTypeUnionT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeUnionT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("UnionT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(7).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeUnionT) MakeVDLTarget() vdl.Target {
	return nil
}

func (x wireTypeOptionalT) Index() int                     { return 8 }
func (x wireTypeOptionalT) Interface() interface{}         { return x.Value }
func (x wireTypeOptionalT) Name() string                   { return "OptionalT" }
func (x wireTypeOptionalT) __VDLReflect(__wireTypeReflect) {}

func (m wireTypeOptionalT) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("OptionalT")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(8).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m wireTypeOptionalT) MakeVDLTarget() vdl.Target {
	return nil
}

type wireTypeTarget struct {
	Value     *wireType
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *wireTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*wireType)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *wireTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "NamedT":
		val := wireNamed{}
		return nil, &wireNamedTarget{Value: &val}, nil
	case "EnumT":
		val := wireEnum{}
		return nil, &wireEnumTarget{Value: &val}, nil
	case "ArrayT":
		val := wireArray{}
		return nil, &wireArrayTarget{Value: &val}, nil
	case "ListT":
		val := wireList{}
		return nil, &wireListTarget{Value: &val}, nil
	case "SetT":
		val := wireSet{}
		return nil, &wireSetTarget{Value: &val}, nil
	case "MapT":
		val := wireMap{}
		return nil, &wireMapTarget{Value: &val}, nil
	case "StructT":
		val := wireStruct{}
		return nil, &wireStructTarget{Value: &val}, nil
	case "UnionT":
		val := wireUnion{}
		return nil, &wireUnionTarget{Value: &val}, nil
	case "OptionalT":
		val := wireOptional{}
		return nil, &wireOptionalTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/vom.wireType", name)
	}
}
func (t *wireTypeTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "NamedT":
		*t.Value = wireTypeNamedT{*(fieldTarget.(*wireNamedTarget)).Value}
	case "EnumT":
		*t.Value = wireTypeEnumT{*(fieldTarget.(*wireEnumTarget)).Value}
	case "ArrayT":
		*t.Value = wireTypeArrayT{*(fieldTarget.(*wireArrayTarget)).Value}
	case "ListT":
		*t.Value = wireTypeListT{*(fieldTarget.(*wireListTarget)).Value}
	case "SetT":
		*t.Value = wireTypeSetT{*(fieldTarget.(*wireSetTarget)).Value}
	case "MapT":
		*t.Value = wireTypeMapT{*(fieldTarget.(*wireMapTarget)).Value}
	case "StructT":
		*t.Value = wireTypeStructT{*(fieldTarget.(*wireStructTarget)).Value}
	case "UnionT":
		*t.Value = wireTypeUnionT{*(fieldTarget.(*wireUnionTarget)).Value}
	case "OptionalT":
		*t.Value = wireTypeOptionalT{*(fieldTarget.(*wireOptionalTarget)).Value}
	}
	return nil
}
func (t *wireTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type wireTypeTargetFactory struct{}

func (t wireTypeTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*wireType); ok {
		return &wireTypeTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *wireType", union)
}

func (x wireTypeNamedT) VDLIsZero() bool {
	return x.Value == wireNamed{}
}

func (x wireTypeEnumT) VDLIsZero() bool {
	return false
}

func (x wireTypeArrayT) VDLIsZero() bool {
	return false
}

func (x wireTypeListT) VDLIsZero() bool {
	return false
}

func (x wireTypeSetT) VDLIsZero() bool {
	return false
}

func (x wireTypeMapT) VDLIsZero() bool {
	return false
}

func (x wireTypeStructT) VDLIsZero() bool {
	return false
}

func (x wireTypeUnionT) VDLIsZero() bool {
	return false
}

func (x wireTypeOptionalT) VDLIsZero() bool {
	return false
}

func (x wireTypeNamedT) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("NamedT"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeEnumT) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("EnumT"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeArrayT) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("ArrayT"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeListT) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("ListT"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeSetT) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("SetT"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeMapT) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("MapT"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeStructT) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("StructT"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeUnionT) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("UnionT"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x wireTypeOptionalT) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*wireType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("OptionalT"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLRead_wireType(dec vdl.Decoder, x *wireType) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "NamedT":
		var field wireTypeNamedT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "EnumT":
		var field wireTypeEnumT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "ArrayT":
		var field wireTypeArrayT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "ListT":
		var field wireTypeListT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "SetT":
		var field wireTypeSetT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "MapT":
		var field wireTypeMapT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "StructT":
		var field wireTypeStructT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "UnionT":
		var field wireTypeUnionT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "OptionalT":
		var field wireTypeOptionalT
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

//////////////////////////////////////////////////
// Const definitions

// Primitive types.
const WireIdBool = TypeId(1)
const WireIdByte = TypeId(2)
const WireIdString = TypeId(3)
const WireIdUint16 = TypeId(4)
const WireIdUint32 = TypeId(5)
const WireIdUint64 = TypeId(6)
const WireIdInt16 = TypeId(7)
const WireIdInt32 = TypeId(8)
const WireIdInt64 = TypeId(9)
const WireIdFloat32 = TypeId(10)
const WireIdFloat64 = TypeId(11)

// Wire ids 12 and 13 were previously used for complex64 and complex 128.
const WireIdTypeObject = TypeId(14)
const WireIdAny = TypeId(15)
const WireIdInt8 = TypeId(16)

// Other commonly used composites.
const WireIdByteList = TypeId(39)
const WireIdStringList = TypeId(40)

// The first user-defined TypeId is 41.
const WireIdFirstUserType = TypeId(41)
const WireCtrlNil = byte(224)            // Nil in optional or any
const WireCtrlEnd = byte(225)            // End of struct or union
const WireCtrlTypeIncomplete = byte(226) // Marks that the type message is incomplete until future messages are received

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*ControlKind)(nil))
	vdl.Register((*Primitive)(nil))
	vdl.Register((*DumpKind)(nil))
	vdl.Register((*DumpAtom)(nil))
	vdl.Register((*TypeId)(nil))
	vdl.Register((*wireNamed)(nil))
	vdl.Register((*wireEnum)(nil))
	vdl.Register((*wireArray)(nil))
	vdl.Register((*wireList)(nil))
	vdl.Register((*wireSet)(nil))
	vdl.Register((*wireMap)(nil))
	vdl.Register((*wireField)(nil))
	vdl.Register((*wireStruct)(nil))
	vdl.Register((*wireUnion)(nil))
	vdl.Register((*wireOptional)(nil))
	vdl.Register((*wireType)(nil))

	return struct{}{}
}
