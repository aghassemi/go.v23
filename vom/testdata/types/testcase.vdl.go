// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Source: testcase.vdl

package types

import (
	"fmt"
	"reflect"
	"v.io/v23/vdl"
)

// TestCase represents an individual testcase for vom encoding and decoding.
type TestCase struct {
	Name       string     // Name of the testcase
	Value      *vdl.Value // Value to test
	TypeString string     // The string representation of the Type
	Hex        string     // Hex pattern representing vom encoding
	HexVersion string     // Hex pattern representing vom encoding of Version
	HexType    string     // Hex pattern representing vom encoding of Type
	HexValue   string     // Hex pattern representing vom encoding of Value
}

func (TestCase) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.TestCase"`
}) {
}

func (m *TestCase) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_testcase_v_io_v23_vom_testdata_types_TestCase == nil || __VDLTypetestcase0 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Value")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Value == nil {
			if err := fieldTarget5.FromNil(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget5, m.Value); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("TypeString")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromString(string(m.TypeString), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Hex")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget9.FromString(string(m.Hex), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("HexVersion")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget11.FromString(string(m.HexVersion), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("HexType")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget13.FromString(string(m.HexType), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("HexValue")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget15.FromString(string(m.HexValue), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TestCase) MakeVDLTarget() vdl.Target {
	return &TestCaseTarget{Value: m}
}

type TestCaseTarget struct {
	Value *TestCase
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TestCaseTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_testcase_v_io_v23_vom_testdata_types_TestCase) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_testcase_v_io_v23_vom_testdata_types_TestCase)
	}
	return t, nil
}
func (t *TestCaseTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		val, err := &vdl.StringTarget{Value: &t.Value.Name}, error(nil)
		return nil, val, err
	case "Value":
		val, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Value))
		return nil, val, err
	case "TypeString":
		val, err := &vdl.StringTarget{Value: &t.Value.TypeString}, error(nil)
		return nil, val, err
	case "Hex":
		val, err := &vdl.StringTarget{Value: &t.Value.Hex}, error(nil)
		return nil, val, err
	case "HexVersion":
		val, err := &vdl.StringTarget{Value: &t.Value.HexVersion}, error(nil)
		return nil, val, err
	case "HexType":
		val, err := &vdl.StringTarget{Value: &t.Value.HexType}, error(nil)
		return nil, val, err
	case "HexValue":
		val, err := &vdl.StringTarget{Value: &t.Value.HexValue}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_testcase_v_io_v23_vom_testdata_types_TestCase)
	}
}
func (t *TestCaseTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TestCaseTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func init() {
	vdl.Register((*TestCase)(nil))
}

var __VDLTypetestcase0 *vdl.Type = vdl.TypeOf((*TestCase)(nil))
var __VDLType_testcase_v_io_v23_vom_testdata_types_TestCase *vdl.Type = vdl.TypeOf(TestCase{})

func __VDLEnsureNativeBuilt_testcase() {
}
