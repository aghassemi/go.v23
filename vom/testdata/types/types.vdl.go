// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: types

package types

import (
	"fmt"
	"reflect"
	"v.io/v23/vdl"
	"v.io/v23/vdl/vdlconv"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// TestCase represents an individual testcase for vom encoding and decoding.
type TestCase struct {
	Name       string     // Name of the testcase
	Value      *vdl.Value // Value to test
	TypeString string     // The string representation of the Type
	Hex        string     // Hex pattern representing vom encoding
	HexVersion string     // Hex pattern representing vom encoding of Version
	HexType    string     // Hex pattern representing vom encoding of Type
	HexValue   string     // Hex pattern representing vom encoding of Value
}

func (TestCase) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.TestCase"`
}) {
}

func (m *TestCase) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Value")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Value == nil {
			if err := fieldTarget5.FromNil(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget5, m.Value); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("TypeString")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromString(string(m.TypeString), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Hex")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget9.FromString(string(m.Hex), tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("HexVersion")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget11.FromString(string(m.HexVersion), tt.NonOptional().Field(4).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("HexType")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget13.FromString(string(m.HexType), tt.NonOptional().Field(5).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("HexValue")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget15.FromString(string(m.HexValue), tt.NonOptional().Field(6).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TestCase) MakeVDLTarget() vdl.Target {
	return &TestCaseTarget{Value: m}
}

type TestCaseTarget struct {
	Value      *TestCase
	nameTarget vdl.StringTarget

	typeStringTarget vdl.StringTarget
	hexTarget        vdl.StringTarget
	hexVersionTarget vdl.StringTarget
	hexTypeTarget    vdl.StringTarget
	hexValueTarget   vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TestCaseTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*TestCase)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *TestCaseTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Value":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Value))
		return nil, target, err
	case "TypeString":
		t.typeStringTarget.Value = &t.Value.TypeString
		target, err := &t.typeStringTarget, error(nil)
		return nil, target, err
	case "Hex":
		t.hexTarget.Value = &t.Value.Hex
		target, err := &t.hexTarget, error(nil)
		return nil, target, err
	case "HexVersion":
		t.hexVersionTarget.Value = &t.Value.HexVersion
		target, err := &t.hexVersionTarget, error(nil)
		return nil, target, err
	case "HexType":
		t.hexTypeTarget.Value = &t.Value.HexType
		target, err := &t.hexTypeTarget, error(nil)
		return nil, target, err
	case "HexValue":
		t.hexValueTarget.Value = &t.Value.HexValue
		target, err := &t.hexValueTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.TestCase", name)
	}
}
func (t *TestCaseTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TestCaseTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// vomdata config types
type ConvertGroup struct {
	Name        string
	PrimaryType *vdl.Type
	Values      []*vdl.Value
}

func (ConvertGroup) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ConvertGroup"`
}) {
}

func (m *ConvertGroup) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("PrimaryType")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		typeObjectVal6 := m.PrimaryType
		if typeObjectVal6 == nil {
			typeObjectVal6 = vdl.AnyType
		}
		if err := fieldTarget5.FromTypeObject(typeObjectVal6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("Values")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget9, err := fieldTarget8.StartList(tt.NonOptional().Field(2).Type, len(m.Values))
		if err != nil {
			return err
		}
		for i, elem11 := range m.Values {
			elemTarget10, err := listTarget9.StartElem(i)
			if err != nil {
				return err
			}

			if elem11 == nil {
				if err := elemTarget10.FromNil(tt.NonOptional().Field(2).Type.Elem()); err != nil {
					return err
				}
			} else {
				if err := vdl.FromValue(elemTarget10, elem11); err != nil {
					return err
				}
			}
			if err := listTarget9.FinishElem(elemTarget10); err != nil {
				return err
			}
		}
		if err := fieldTarget8.FinishList(listTarget9); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConvertGroup) MakeVDLTarget() vdl.Target {
	return &ConvertGroupTarget{Value: m}
}

type ConvertGroupTarget struct {
	Value             *ConvertGroup
	nameTarget        vdl.StringTarget
	primaryTypeTarget vdl.TypeObjectTarget
	valuesTarget      __VDLTarget1_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConvertGroupTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConvertGroup)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConvertGroupTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "PrimaryType":
		t.primaryTypeTarget.Value = &t.Value.PrimaryType
		target, err := &t.primaryTypeTarget, error(nil)
		return nil, target, err
	case "Values":
		t.valuesTarget.Value = &t.Value.Values
		target, err := &t.valuesTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.ConvertGroup", name)
	}
}
func (t *ConvertGroupTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConvertGroupTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []*vdl.Value
type __VDLTarget1_list struct {
	Value *[]*vdl.Value

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]*vdl.Value)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vdl.Value, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

type VomdataStruct struct {
	EncodeDecodeData map[byte][]*vdl.Value // map from min required VOM version to test values
	CompatData       map[string][]*vdl.Type
	ConvertData      map[string][]ConvertGroup
}

func (VomdataStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.VomdataStruct"`
}) {
}

func (m *VomdataStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("EncodeDecodeData")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.EncodeDecodeData))
		if err != nil {
			return err
		}
		for key6, value8 := range m.EncodeDecodeData {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromUint(uint64(key6), tt.NonOptional().Field(0).Type.Key()); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}

			listTarget9, err := valueTarget7.StartList(tt.NonOptional().Field(0).Type.Elem(), len(value8))
			if err != nil {
				return err
			}
			for i, elem11 := range value8 {
				elemTarget10, err := listTarget9.StartElem(i)
				if err != nil {
					return err
				}

				if elem11 == nil {
					if err := elemTarget10.FromNil(tt.NonOptional().Field(0).Type.Elem().Elem()); err != nil {
						return err
					}
				} else {
					if err := vdl.FromValue(elemTarget10, elem11); err != nil {
						return err
					}
				}
				if err := listTarget9.FinishElem(elemTarget10); err != nil {
					return err
				}
			}
			if err := valueTarget7.FinishList(listTarget9); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("CompatData")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget14, err := fieldTarget13.StartMap(tt.NonOptional().Field(1).Type, len(m.CompatData))
		if err != nil {
			return err
		}
		for key16, value18 := range m.CompatData {
			keyTarget15, err := mapTarget14.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget15.FromString(string(key16), tt.NonOptional().Field(1).Type.Key()); err != nil {
				return err
			}
			valueTarget17, err := mapTarget14.FinishKeyStartField(keyTarget15)
			if err != nil {
				return err
			}

			listTarget19, err := valueTarget17.StartList(tt.NonOptional().Field(1).Type.Elem(), len(value18))
			if err != nil {
				return err
			}
			for i, elem21 := range value18 {
				elemTarget20, err := listTarget19.StartElem(i)
				if err != nil {
					return err
				}
				typeObjectVal22 := elem21
				if typeObjectVal22 == nil {
					typeObjectVal22 = vdl.AnyType
				}
				if err := elemTarget20.FromTypeObject(typeObjectVal22); err != nil {
					return err
				}
				if err := listTarget19.FinishElem(elemTarget20); err != nil {
					return err
				}
			}
			if err := valueTarget17.FinishList(listTarget19); err != nil {
				return err
			}
			if err := mapTarget14.FinishField(keyTarget15, valueTarget17); err != nil {
				return err
			}
		}
		if err := fieldTarget13.FinishMap(mapTarget14); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("ConvertData")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget25, err := fieldTarget24.StartMap(tt.NonOptional().Field(2).Type, len(m.ConvertData))
		if err != nil {
			return err
		}
		for key27, value29 := range m.ConvertData {
			keyTarget26, err := mapTarget25.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget26.FromString(string(key27), tt.NonOptional().Field(2).Type.Key()); err != nil {
				return err
			}
			valueTarget28, err := mapTarget25.FinishKeyStartField(keyTarget26)
			if err != nil {
				return err
			}

			listTarget30, err := valueTarget28.StartList(tt.NonOptional().Field(2).Type.Elem(), len(value29))
			if err != nil {
				return err
			}
			for i, elem32 := range value29 {
				elemTarget31, err := listTarget30.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem32.FillVDLTarget(elemTarget31, tt.NonOptional().Field(2).Type.Elem().Elem()); err != nil {
					return err
				}
				if err := listTarget30.FinishElem(elemTarget31); err != nil {
					return err
				}
			}
			if err := valueTarget28.FinishList(listTarget30); err != nil {
				return err
			}
			if err := mapTarget25.FinishField(keyTarget26, valueTarget28); err != nil {
				return err
			}
		}
		if err := fieldTarget24.FinishMap(mapTarget25); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *VomdataStruct) MakeVDLTarget() vdl.Target {
	return &VomdataStructTarget{Value: m}
}

type VomdataStructTarget struct {
	Value                  *VomdataStruct
	encodeDecodeDataTarget __VDLTarget2_map
	compatDataTarget       __VDLTarget3_map
	convertDataTarget      __VDLTarget4_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *VomdataStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*VomdataStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *VomdataStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "EncodeDecodeData":
		t.encodeDecodeDataTarget.Value = &t.Value.EncodeDecodeData
		target, err := &t.encodeDecodeDataTarget, error(nil)
		return nil, target, err
	case "CompatData":
		t.compatDataTarget.Value = &t.Value.CompatData
		target, err := &t.compatDataTarget, error(nil)
		return nil, target, err
	case "ConvertData":
		t.convertDataTarget.Value = &t.Value.ConvertData
		target, err := &t.convertDataTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.VomdataStruct", name)
	}
}
func (t *VomdataStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *VomdataStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[byte][]*vdl.Value
type __VDLTarget2_map struct {
	Value      *map[byte][]*vdl.Value
	currKey    byte
	currElem   []*vdl.Value
	keyTarget  vdl.ByteTarget
	elemTarget __VDLTarget1_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget2_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[byte][]*vdl.Value)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[byte][]*vdl.Value)
	return t, nil
}
func (t *__VDLTarget2_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = byte(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []*vdl.Value(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget2_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[string][]*vdl.Type
type __VDLTarget3_map struct {
	Value      *map[string][]*vdl.Type
	currKey    string
	currElem   []*vdl.Type
	keyTarget  vdl.StringTarget
	elemTarget __VDLTarget5_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget3_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string][]*vdl.Type)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string][]*vdl.Type)
	return t, nil
}
func (t *__VDLTarget3_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []*vdl.Type(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget3_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []*vdl.Type
type __VDLTarget5_list struct {
	Value      *[]*vdl.Type
	elemTarget vdl.TypeObjectTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget5_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]*vdl.Type)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vdl.Type, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget5_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget5_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// map[string][]ConvertGroup
type __VDLTarget4_map struct {
	Value      *map[string][]ConvertGroup
	currKey    string
	currElem   []ConvertGroup
	keyTarget  vdl.StringTarget
	elemTarget __VDLTarget6_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget4_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string][]ConvertGroup)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string][]ConvertGroup)
	return t, nil
}
func (t *__VDLTarget4_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []ConvertGroup(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget4_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []ConvertGroup
type __VDLTarget6_list struct {
	Value      *[]ConvertGroup
	elemTarget ConvertGroupTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget6_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]ConvertGroup)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]ConvertGroup, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget6_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget6_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget6_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Named Types
type NBool bool

func (NBool) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NBool"`
}) {
}

func (m *NBool) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBool(bool((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NBool) MakeVDLTarget() vdl.Target {
	return &NBoolTarget{Value: m}
}

type NBoolTarget struct {
	Value *NBool
	vdl.TargetBase
}

func (t *NBoolTarget) FromBool(src bool, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NBool)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = NBool(src)

	return nil
}

type NString string

func (NString) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NString"`
}) {
}

func (m *NString) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromString(string((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NString) MakeVDLTarget() vdl.Target {
	return &NStringTarget{Value: m}
}

type NStringTarget struct {
	Value *NString
	vdl.TargetBase
}

func (t *NStringTarget) FromString(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NString)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = NString(src)

	return nil
}

type NByteSlice []byte

func (NByteSlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByteSlice"`
}) {
}

func (m *NByteSlice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBytes([]byte((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NByteSlice) MakeVDLTarget() vdl.Target {
	return &NByteSliceTarget{Value: m}
}

type NByteSliceTarget struct {
	Value *NByteSlice
	vdl.TargetBase
}

func (t *NByteSliceTarget) FromBytes(src []byte, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NByteSlice)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if len(src) == 0 {
		*t.Value = nil
	} else {
		*t.Value = make([]byte, len(src))
		copy(*t.Value, src)
	}

	return nil
}

type NByteArray [4]byte

func (NByteArray) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByteArray"`
}) {
}

func (m *NByteArray) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBytes([]byte((*m)[:]), tt); err != nil {
		return err
	}
	return nil
}

func (m *NByteArray) MakeVDLTarget() vdl.Target {
	return &NByteArrayTarget{Value: m}
}

type NByteArrayTarget struct {
	Value *NByteArray
	vdl.TargetBase
}

func (t *NByteArrayTarget) FromBytes(src []byte, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NByteArray)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	copy((*t.Value)[:], src)

	return nil
}

type NByte byte

func (NByte) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByte"`
}) {
}

func (m *NByte) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NByte) MakeVDLTarget() vdl.Target {
	return &NByteTarget{Value: m}
}

type NByteTarget struct {
	Value *NByte
	vdl.TargetBase
}

func (t *NByteTarget) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NByte(val)

	return nil
}
func (t *NByteTarget) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NByte(val)

	return nil
}
func (t *NByteTarget) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NByte(val)

	return nil
}

type NUint16 uint16

func (NUint16) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint16"`
}) {
}

func (m *NUint16) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NUint16) MakeVDLTarget() vdl.Target {
	return &NUint16Target{Value: m}
}

type NUint16Target struct {
	Value *NUint16
	vdl.TargetBase
}

func (t *NUint16Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NUint16(val)

	return nil
}
func (t *NUint16Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NUint16(val)

	return nil
}
func (t *NUint16Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NUint16(val)

	return nil
}

type NUint32 uint32

func (NUint32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint32"`
}) {
}

func (m *NUint32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NUint32) MakeVDLTarget() vdl.Target {
	return &NUint32Target{Value: m}
}

type NUint32Target struct {
	Value *NUint32
	vdl.TargetBase
}

func (t *NUint32Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NUint32(val)

	return nil
}
func (t *NUint32Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NUint32(val)

	return nil
}
func (t *NUint32Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NUint32(val)

	return nil
}

type NUint64 uint64

func (NUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint64"`
}) {
}

func (m *NUint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NUint64) MakeVDLTarget() vdl.Target {
	return &NUint64Target{Value: m}
}

type NUint64Target struct {
	Value *NUint64
	vdl.TargetBase
}

func (t *NUint64Target) FromUint(src uint64, tt *vdl.Type) error {

	*t.Value = NUint64(src)

	return nil
}
func (t *NUint64Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = NUint64(val)

	return nil
}
func (t *NUint64Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = NUint64(val)

	return nil
}

type NInt8 int8

func (NInt8) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt8"`
}) {
}

func (m *NInt8) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NInt8) MakeVDLTarget() vdl.Target {
	return &NInt8Target{Value: m}
}

type NInt8Target struct {
	Value *NInt8
	vdl.TargetBase
}

func (t *NInt8Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NInt8(val)

	return nil
}
func (t *NInt8Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NInt8(val)

	return nil
}
func (t *NInt8Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NInt8(val)

	return nil
}

type NInt16 int16

func (NInt16) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt16"`
}) {
}

func (m *NInt16) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NInt16) MakeVDLTarget() vdl.Target {
	return &NInt16Target{Value: m}
}

type NInt16Target struct {
	Value *NInt16
	vdl.TargetBase
}

func (t *NInt16Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NInt16(val)

	return nil
}
func (t *NInt16Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NInt16(val)

	return nil
}
func (t *NInt16Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NInt16(val)

	return nil
}

type NInt32 int32

func (NInt32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt32"`
}) {
}

func (m *NInt32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NInt32) MakeVDLTarget() vdl.Target {
	return &NInt32Target{Value: m}
}

type NInt32Target struct {
	Value *NInt32
	vdl.TargetBase
}

func (t *NInt32Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NInt32(val)

	return nil
}
func (t *NInt32Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NInt32(val)

	return nil
}
func (t *NInt32Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NInt32(val)

	return nil
}

type NInt64 int64

func (NInt64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt64"`
}) {
}

func (m *NInt64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NInt64) MakeVDLTarget() vdl.Target {
	return &NInt64Target{Value: m}
}

type NInt64Target struct {
	Value *NInt64
	vdl.TargetBase
}

func (t *NInt64Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt64(src)
	if err != nil {
		return err
	}
	*t.Value = NInt64(val)

	return nil
}
func (t *NInt64Target) FromInt(src int64, tt *vdl.Type) error {

	*t.Value = NInt64(src)

	return nil
}
func (t *NInt64Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt64(src)
	if err != nil {
		return err
	}
	*t.Value = NInt64(val)

	return nil
}

type NFloat32 float32

func (NFloat32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NFloat32"`
}) {
}

func (m *NFloat32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromFloat(float64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NFloat32) MakeVDLTarget() vdl.Target {
	return &NFloat32Target{Value: m}
}

type NFloat32Target struct {
	Value *NFloat32
	vdl.TargetBase
}

func (t *NFloat32Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat32(val)

	return nil
}
func (t *NFloat32Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat32(val)

	return nil
}
func (t *NFloat32Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat32(val)

	return nil
}

type NFloat64 float64

func (NFloat64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NFloat64"`
}) {
}

func (m *NFloat64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromFloat(float64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NFloat64) MakeVDLTarget() vdl.Target {
	return &NFloat64Target{Value: m}
}

type NFloat64Target struct {
	Value *NFloat64
	vdl.TargetBase
}

func (t *NFloat64Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToFloat64(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat64(val)

	return nil
}
func (t *NFloat64Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToFloat64(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat64(val)

	return nil
}
func (t *NFloat64Target) FromFloat(src float64, tt *vdl.Type) error {

	*t.Value = NFloat64(src)

	return nil
}

type NArray2Uint64 [2]uint64

func (NArray2Uint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NArray2Uint64"`
}) {
}

func (m *NArray2Uint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 2)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromUint(uint64(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NArray2Uint64) MakeVDLTarget() vdl.Target {
	return &NArray2Uint64Target{Value: m}
}

// NArray2Uint64
type NArray2Uint64Target struct {
	Value      *NArray2Uint64
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *NArray2Uint64Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*NArray2Uint64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *NArray2Uint64Target) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *NArray2Uint64Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *NArray2Uint64Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type NListUint64 []uint64

func (NListUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NListUint64"`
}) {
}

func (m *NListUint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromUint(uint64(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NListUint64) MakeVDLTarget() vdl.Target {
	return &NListUint64Target{Value: m}
}

// NListUint64
type NListUint64Target struct {
	Value      *NListUint64
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *NListUint64Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*NListUint64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(NListUint64, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *NListUint64Target) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *NListUint64Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *NListUint64Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type NSetUint64 map[uint64]struct{}

func (NSetUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NSetUint64"`
}) {
}

func (m *NSetUint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NSetUint64) MakeVDLTarget() vdl.Target {
	return &NSetUint64Target{Value: m}
}

type NSetUint64Target struct {
	Value     *NSetUint64
	currKey   uint64
	keyTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *NSetUint64Target) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*NSetUint64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(NSetUint64)
	return t, nil
}
func (t *NSetUint64Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *NSetUint64Target) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *NSetUint64Target) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type NMapUint64String map[uint64]string

func (NMapUint64String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NMapUint64String"`
}) {
}

func (m *NMapUint64String) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromString(string(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NMapUint64String) MakeVDLTarget() vdl.Target {
	return &NMapUint64StringTarget{Value: m}
}

type NMapUint64StringTarget struct {
	Value      *NMapUint64String
	currKey    uint64
	currElem   string
	keyTarget  vdl.Uint64Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *NMapUint64StringTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*NMapUint64String)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(NMapUint64String)
	return t, nil
}
func (t *NMapUint64StringTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *NMapUint64StringTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *NMapUint64StringTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *NMapUint64StringTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type NStruct struct {
	A bool
	B string
	C int64
}

func (NStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NStruct"`
}) {
}

func (m *NStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.A), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.B), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("C")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromInt(int64(m.C), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NStruct) MakeVDLTarget() vdl.Target {
	return &NStructTarget{Value: m}
}

type NStructTarget struct {
	Value   *NStruct
	aTarget vdl.BoolTarget
	bTarget vdl.StringTarget
	cTarget vdl.Int64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*NStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *NStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "C":
		t.cTarget.Value = &t.Value.C
		target, err := &t.cTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.NStruct", name)
	}
}
func (t *NStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *NStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type NEnum int

const (
	NEnumA NEnum = iota
	NEnumB
	NEnumC
)

// NEnumAll holds all labels for NEnum.
var NEnumAll = [...]NEnum{NEnumA, NEnumB, NEnumC}

// NEnumFromString creates a NEnum from a string label.
func NEnumFromString(label string) (x NEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *NEnum) Set(label string) error {
	switch label {
	case "A", "a":
		*x = NEnumA
		return nil
	case "B", "b":
		*x = NEnumB
		return nil
	case "C", "c":
		*x = NEnumC
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.NEnum", label)
}

// String returns the string label of x.
func (x NEnum) String() string {
	switch x {
	case NEnumA:
		return "A"
	case NEnumB:
		return "B"
	case NEnumC:
		return "C"
	}
	return ""
}

func (NEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NEnum"`
	Enum struct{ A, B, C string }
}) {
}

func (m *NEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *NEnum) MakeVDLTarget() vdl.Target {
	return &NEnumTarget{Value: m}
}

type NEnumTarget struct {
	Value *NEnum
	vdl.TargetBase
}

func (t *NEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NEnum)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "A":
		*t.Value = 0
	case "B":
		*t.Value = 1
	case "C":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum v.io/v23/vom/testdata/types.NEnum", src)
	}

	return nil
}

type (
	// NUnion represents any single field of the NUnion union type.
	NUnion interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the NUnion union type.
		__VDLReflect(__NUnionReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// NUnionA represents field A of the NUnion union type.
	NUnionA struct{ Value bool }
	// NUnionB represents field B of the NUnion union type.
	NUnionB struct{ Value string }
	// NUnionC represents field C of the NUnion union type.
	NUnionC struct{ Value int64 }
	// __NUnionReflect describes the NUnion union type.
	__NUnionReflect struct {
		Name               string `vdl:"v.io/v23/vom/testdata/types.NUnion"`
		Type               NUnion
		UnionTargetFactory nUnionTargetFactory
		Union              struct {
			A NUnionA
			B NUnionB
			C NUnionC
		}
	}
)

func (x NUnionA) Index() int                   { return 0 }
func (x NUnionA) Interface() interface{}       { return x.Value }
func (x NUnionA) Name() string                 { return "A" }
func (x NUnionA) __VDLReflect(__NUnionReflect) {}

func (m NUnionA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromBool(bool(m.Value), tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NUnionA) MakeVDLTarget() vdl.Target {
	return nil
}

func (x NUnionB) Index() int                   { return 1 }
func (x NUnionB) Interface() interface{}       { return x.Value }
func (x NUnionB) Name() string                 { return "B" }
func (x NUnionB) __VDLReflect(__NUnionReflect) {}

func (m NUnionB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NUnionB) MakeVDLTarget() vdl.Target {
	return nil
}

func (x NUnionC) Index() int                   { return 2 }
func (x NUnionC) Interface() interface{}       { return x.Value }
func (x NUnionC) Name() string                 { return "C" }
func (x NUnionC) __VDLReflect(__NUnionReflect) {}

func (m NUnionC) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("C")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromInt(int64(m.Value), tt.NonOptional().Field(2).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NUnionC) MakeVDLTarget() vdl.Target {
	return nil
}

type NUnionTarget struct {
	Value     *NUnion
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NUnionTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*NUnion)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *NUnionTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "A":
		val := false
		return nil, &vdl.BoolTarget{Value: &val}, nil
	case "B":
		val := ""
		return nil, &vdl.StringTarget{Value: &val}, nil
	case "C":
		val := int64(0)
		return nil, &vdl.Int64Target{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/vom/testdata/types.NUnion", name)
	}
}
func (t *NUnionTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "A":
		*t.Value = NUnionA{*(fieldTarget.(*vdl.BoolTarget)).Value}
	case "B":
		*t.Value = NUnionB{*(fieldTarget.(*vdl.StringTarget)).Value}
	case "C":
		*t.Value = NUnionC{*(fieldTarget.(*vdl.Int64Target)).Value}
	}
	return nil
}
func (t *NUnionTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type nUnionTargetFactory struct{}

func (t nUnionTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*NUnion); ok {
		return &NUnionTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *NUnion", union)
}

// Nested Custom Types
type MBool NBool

func (MBool) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MBool"`
}) {
}

func (m *MBool) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBool(bool((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *MBool) MakeVDLTarget() vdl.Target {
	return &MBoolTarget{Value: m}
}

type MBoolTarget struct {
	Value *MBool
	vdl.TargetBase
}

func (t *MBoolTarget) FromBool(src bool, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*MBool)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = MBool(src)

	return nil
}

type MStruct struct {
	A bool
	B NBool
	C MBool
	D *NStruct
	E *vdl.Type
	F *vdl.Value
}

func (MStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MStruct"`
}) {
}

func (m *MStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.A), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.B.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("C")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.C.FillVDLTarget(fieldTarget7, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("D")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.D == nil {
			if err := fieldTarget9.FromNil(tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		} else {
			if err := m.D.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("E")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		typeObjectVal12 := m.E
		if typeObjectVal12 == nil {
			typeObjectVal12 = vdl.AnyType
		}
		if err := fieldTarget11.FromTypeObject(typeObjectVal12); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("F")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.F == nil {
			if err := fieldTarget14.FromNil(tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget14, m.F); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MStruct) MakeVDLTarget() vdl.Target {
	return &MStructTarget{Value: m}
}

type MStructTarget struct {
	Value   *MStruct
	aTarget vdl.BoolTarget
	bTarget NBoolTarget
	cTarget MBoolTarget
	dTarget __VDLTarget7_optional
	eTarget vdl.TypeObjectTarget

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *MStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*MStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *MStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "C":
		t.cTarget.Value = &t.Value.C
		target, err := &t.cTarget, error(nil)
		return nil, target, err
	case "D":
		t.dTarget.Value = &t.Value.D
		target, err := &t.dTarget, error(nil)
		return nil, target, err
	case "E":
		t.eTarget.Value = &t.Value.E
		target, err := &t.eTarget, error(nil)
		return nil, target, err
	case "F":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.F))
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.MStruct", name)
	}
}
func (t *MStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *MStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional NStruct
type __VDLTarget7_optional struct {
	Value      **NStruct
	elemTarget NStructTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget7_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &NStruct{}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget7_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget7_optional) FromNil(tt *vdl.Type) error {

	*t.Value = nil

	return nil
}

type MList []NListUint64

func (MList) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MList"`
}) {
}

func (m *MList) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MList) MakeVDLTarget() vdl.Target {
	return &MListTarget{Value: m}
}

// MList
type MListTarget struct {
	Value      *MList
	elemTarget NListUint64Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *MListTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*MList)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(MList, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *MListTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MListTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *MListTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type MMap map[NFloat32]NListUint64

func (MMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MMap"`
}) {
}

func (m *MMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MMap) MakeVDLTarget() vdl.Target {
	return &MMapTarget{Value: m}
}

type MMapTarget struct {
	Value      *MMap
	currKey    NFloat32
	currElem   NListUint64
	keyTarget  NFloat32Target
	elemTarget NListUint64Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*MMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MMap)
	return t, nil
}
func (t *MMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = NFloat32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = NListUint64(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MByteSlice []byte

func (MByteSlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MByteSlice"`
}) {
}

func (m *MByteSlice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBytes([]byte((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *MByteSlice) MakeVDLTarget() vdl.Target {
	return &MByteSliceTarget{Value: m}
}

type MByteSliceTarget struct {
	Value *MByteSlice
	vdl.TargetBase
}

func (t *MByteSliceTarget) FromBytes(src []byte, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*MByteSlice)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if len(src) == 0 {
		*t.Value = nil
	} else {
		*t.Value = make([]byte, len(src))
		copy(*t.Value, src)
	}

	return nil
}

type MInt8Slice []int8

func (MInt8Slice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MInt8Slice"`
}) {
}

func (m *MInt8Slice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromInt(int64(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MInt8Slice) MakeVDLTarget() vdl.Target {
	return &MInt8SliceTarget{Value: m}
}

// MInt8Slice
type MInt8SliceTarget struct {
	Value      *MInt8Slice
	elemTarget vdl.Int8Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *MInt8SliceTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*MInt8Slice)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(MInt8Slice, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *MInt8SliceTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MInt8SliceTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *MInt8SliceTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Recursive Type Definitions
type RecA []RecA

func (RecA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecA"`
}) {
}

func (m *RecA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecA) MakeVDLTarget() vdl.Target {
	return &RecATarget{Value: m}
}

// RecA
type RecATarget struct {
	Value *RecA

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RecATarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*RecA)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(RecA, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *RecATarget) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &RecATarget{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *RecATarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RecATarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type RecY []RecX

func (RecY) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecY"`
}) {
}

func (m *RecY) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecY) MakeVDLTarget() vdl.Target {
	return &RecYTarget{Value: m}
}

// RecY
type RecYTarget struct {
	Value *RecY

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RecYTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*RecY)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(RecY, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *RecYTarget) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &RecXTarget{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *RecYTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RecYTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

// RecX
type RecXTarget struct {
	Value *RecX

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RecXTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*RecX)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(RecX, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *RecXTarget) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &RecYTarget{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *RecXTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RecXTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type RecX []RecY

func (RecX) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecX"`
}) {
}

func (m *RecX) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecX) MakeVDLTarget() vdl.Target {
	return &RecXTarget{Value: m}
}

type Rec4 []Rec1

func (Rec4) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec4"`
}) {
}

func (m *Rec4) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec4) MakeVDLTarget() vdl.Target {
	return &Rec4Target{Value: m}
}

// Rec4
type Rec4Target struct {
	Value *Rec4

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec4Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Rec4)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec4, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec4Target) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec1Target{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *Rec4Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec4Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Rec1
type Rec1Target struct {
	Value *Rec1

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec1Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Rec1)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec1, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec1Target) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec2Target{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *Rec1Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec1Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Rec2
type Rec2Target struct {
	Value *Rec2

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec2Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Rec2)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec2, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec2Target) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec3Target{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *Rec2Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec2Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Rec3
type Rec3Target struct {
	Value *Rec3

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec3Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Rec3)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec3, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec3Target) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec4Target{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *Rec3Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec3Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Rec3 []Rec4

func (Rec3) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec3"`
}) {
}

func (m *Rec3) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec3) MakeVDLTarget() vdl.Target {
	return &Rec3Target{Value: m}
}

type Rec2 []Rec3

func (Rec2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec2"`
}) {
}

func (m *Rec2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec2) MakeVDLTarget() vdl.Target {
	return &Rec2Target{Value: m}
}

type Rec1 []Rec2

func (Rec1) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1"`
}) {
}

func (m *Rec1) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1) MakeVDLTarget() vdl.Target {
	return &Rec1Target{Value: m}
}

type RecStruct struct {
	A *RecStruct
}

func (RecStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecStruct"`
}) {
}

func (m *RecStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.A == nil {
			if err := fieldTarget3.FromNil(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			if err := m.A.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecStruct) MakeVDLTarget() vdl.Target {
	return &RecStructTarget{Value: m}
}

type RecStructTarget struct {
	Value *RecStruct

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *RecStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*RecStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *RecStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		target, err := &__VDLTarget8_optional{Value: &t.Value.A}, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.RecStruct", name)
	}
}
func (t *RecStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *RecStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional RecStruct
type __VDLTarget8_optional struct {
	Value **RecStruct

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget8_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &RecStruct{}
	}
	target, err := &RecStructTarget{Value: *t.Value}, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget8_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget8_optional) FromNil(tt *vdl.Type) error {

	*t.Value = nil

	return nil
}

type Rec1234 struct {
	R1 Rec1
	R2 Rec2
	R3 Rec3
	R4 Rec4
}

func (Rec1234) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234"`
}) {
}

func (m *Rec1234) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("R1")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.R1.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("R2")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.R2.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("R3")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.R3.FillVDLTarget(fieldTarget7, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("R4")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.R4.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234) MakeVDLTarget() vdl.Target {
	return &Rec1234Target{Value: m}
}

type Rec1234Target struct {
	Value    *Rec1234
	r1Target Rec1Target
	r2Target Rec2Target
	r3Target Rec3Target
	r4Target Rec4Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234Target) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Rec1234)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Rec1234Target) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "R1":
		t.r1Target.Value = &t.Value.R1
		target, err := &t.r1Target, error(nil)
		return nil, target, err
	case "R2":
		t.r2Target.Value = &t.Value.R2
		target, err := &t.r2Target, error(nil)
		return nil, target, err
	case "R3":
		t.r3Target.Value = &t.Value.R3
		target, err := &t.r3Target, error(nil)
		return nil, target, err
	case "R4":
		t.r4Target.Value = &t.Value.R4
		target, err := &t.r4Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.Rec1234", name)
	}
}
func (t *Rec1234Target) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234Target) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type Rec1234A struct {
	A       []Rec1234A
	Rec1234 []Rec1234
}

func (Rec1234A) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234A"`
}) {
}

func (m *Rec1234A) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget4, err := fieldTarget3.StartList(tt.NonOptional().Field(0).Type, len(m.A))
		if err != nil {
			return err
		}
		for i, elem6 := range m.A {
			elemTarget5, err := listTarget4.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem6.FillVDLTarget(elemTarget5, tt.NonOptional().Field(0).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget4.FinishElem(elemTarget5); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishList(listTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("Rec1234")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget9, err := fieldTarget8.StartList(tt.NonOptional().Field(1).Type, len(m.Rec1234))
		if err != nil {
			return err
		}
		for i, elem11 := range m.Rec1234 {
			elemTarget10, err := listTarget9.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem11.FillVDLTarget(elemTarget10, tt.NonOptional().Field(1).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget9.FinishElem(elemTarget10); err != nil {
				return err
			}
		}
		if err := fieldTarget8.FinishList(listTarget9); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234A) MakeVDLTarget() vdl.Target {
	return &Rec1234ATarget{Value: m}
}

type Rec1234ATarget struct {
	Value *Rec1234A

	rec1234Target __VDLTarget9_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234ATarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Rec1234A)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Rec1234ATarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		target, err := &__VDLTarget10_list{Value: &t.Value.A}, error(nil)
		return nil, target, err
	case "Rec1234":
		t.rec1234Target.Value = &t.Value.Rec1234
		target, err := &t.rec1234Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.Rec1234A", name)
	}
}
func (t *Rec1234ATarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234ATarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []Rec1234A
type __VDLTarget10_list struct {
	Value *[]Rec1234A

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget10_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Rec1234A)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Rec1234A, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget10_list) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec1234ATarget{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *__VDLTarget10_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget10_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// []Rec1234
type __VDLTarget9_list struct {
	Value      *[]Rec1234
	elemTarget Rec1234Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget9_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Rec1234)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Rec1234, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget9_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget9_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Rec1234B struct {
	B       []Rec1234B
	Rec1234 []Rec1234
}

func (Rec1234B) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234B"`
}) {
}

func (m *Rec1234B) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget4, err := fieldTarget3.StartList(tt.NonOptional().Field(0).Type, len(m.B))
		if err != nil {
			return err
		}
		for i, elem6 := range m.B {
			elemTarget5, err := listTarget4.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem6.FillVDLTarget(elemTarget5, tt.NonOptional().Field(0).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget4.FinishElem(elemTarget5); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishList(listTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("Rec1234")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget9, err := fieldTarget8.StartList(tt.NonOptional().Field(1).Type, len(m.Rec1234))
		if err != nil {
			return err
		}
		for i, elem11 := range m.Rec1234 {
			elemTarget10, err := listTarget9.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem11.FillVDLTarget(elemTarget10, tt.NonOptional().Field(1).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget9.FinishElem(elemTarget10); err != nil {
				return err
			}
		}
		if err := fieldTarget8.FinishList(listTarget9); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234B) MakeVDLTarget() vdl.Target {
	return &Rec1234BTarget{Value: m}
}

type Rec1234BTarget struct {
	Value *Rec1234B

	rec1234Target __VDLTarget9_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234BTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Rec1234B)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Rec1234BTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "B":
		target, err := &__VDLTarget11_list{Value: &t.Value.B}, error(nil)
		return nil, target, err
	case "Rec1234":
		t.rec1234Target.Value = &t.Value.Rec1234
		target, err := &t.rec1234Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.Rec1234B", name)
	}
}
func (t *Rec1234BTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234BTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []Rec1234B
type __VDLTarget11_list struct {
	Value *[]Rec1234B

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget11_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Rec1234B)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Rec1234B, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget11_list) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec1234BTarget{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *__VDLTarget11_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget11_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Rec1234All struct {
	A Rec1234A
	B Rec1234B
}

func (Rec1234All) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234All"`
}) {
}

func (m *Rec1234All) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.A.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.B.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234All) MakeVDLTarget() vdl.Target {
	return &Rec1234AllTarget{Value: m}
}

type Rec1234AllTarget struct {
	Value   *Rec1234All
	aTarget Rec1234ATarget
	bTarget Rec1234BTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234AllTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Rec1234All)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Rec1234AllTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.Rec1234All", name)
	}
}
func (t *Rec1234AllTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234AllTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Additional types for compatibility and conversion checks
type ListString []string

func (ListString) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ListString"`
}) {
}

func (m *ListString) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromString(string(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ListString) MakeVDLTarget() vdl.Target {
	return &ListStringTarget{Value: m}
}

// ListString
type ListStringTarget struct {
	Value      *ListString
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *ListStringTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*ListString)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(ListString, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *ListStringTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *ListStringTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *ListStringTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Array3String [3]string

func (Array3String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Array3String"`
}) {
}

func (m *Array3String) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 3)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromString(string(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Array3String) MakeVDLTarget() vdl.Target {
	return &Array3StringTarget{Value: m}
}

// Array3String
type Array3StringTarget struct {
	Value      *Array3String
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Array3StringTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Array3String)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Array3StringTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *Array3StringTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Array3StringTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Array4String [4]string

func (Array4String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Array4String"`
}) {
}

func (m *Array4String) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 4)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromString(string(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Array4String) MakeVDLTarget() vdl.Target {
	return &Array4StringTarget{Value: m}
}

// Array4String
type Array4StringTarget struct {
	Value      *Array4String
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Array4StringTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Array4String)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Array4StringTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *Array4StringTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Array4StringTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type AbcStruct struct {
	A bool
	B string
	C int64
}

func (AbcStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AbcStruct"`
}) {
}

func (m *AbcStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.A), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.B), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("C")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromInt(int64(m.C), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AbcStruct) MakeVDLTarget() vdl.Target {
	return &AbcStructTarget{Value: m}
}

type AbcStructTarget struct {
	Value   *AbcStruct
	aTarget vdl.BoolTarget
	bTarget vdl.StringTarget
	cTarget vdl.Int64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AbcStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*AbcStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *AbcStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "C":
		t.cTarget.Value = &t.Value.C
		target, err := &t.cTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.AbcStruct", name)
	}
}
func (t *AbcStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AbcStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type AdeStruct struct {
	A bool
	D *vdl.Value
	E *vdl.Type
}

func (AdeStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AdeStruct"`
}) {
}

func (m *AdeStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.A), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("D")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.D == nil {
			if err := fieldTarget5.FromNil(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget5, m.D); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("E")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		typeObjectVal8 := m.E
		if typeObjectVal8 == nil {
			typeObjectVal8 = vdl.AnyType
		}
		if err := fieldTarget7.FromTypeObject(typeObjectVal8); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AdeStruct) MakeVDLTarget() vdl.Target {
	return &AdeStructTarget{Value: m}
}

type AdeStructTarget struct {
	Value   *AdeStruct
	aTarget vdl.BoolTarget

	eTarget vdl.TypeObjectTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AdeStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*AdeStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *AdeStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "D":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.D))
		return nil, target, err
	case "E":
		t.eTarget.Value = &t.Value.E
		target, err := &t.eTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.AdeStruct", name)
	}
}
func (t *AdeStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AdeStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type XyzStruct struct {
	X bool
	Y MBool
	Z string
}

func (XyzStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.XyzStruct"`
}) {
}

func (m *XyzStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("X")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.X), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Y")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Y.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Z")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromString(string(m.Z), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *XyzStruct) MakeVDLTarget() vdl.Target {
	return &XyzStructTarget{Value: m}
}

type XyzStructTarget struct {
	Value   *XyzStruct
	xTarget vdl.BoolTarget
	yTarget MBoolTarget
	zTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *XyzStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*XyzStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *XyzStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "X":
		t.xTarget.Value = &t.Value.X
		target, err := &t.xTarget, error(nil)
		return nil, target, err
	case "Y":
		t.yTarget.Value = &t.Value.Y
		target, err := &t.yTarget, error(nil)
		return nil, target, err
	case "Z":
		t.zTarget.Value = &t.Value.Z
		target, err := &t.zTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.XyzStruct", name)
	}
}
func (t *XyzStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *XyzStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type YzStruct struct {
	Y NBool
	Z NString
}

func (YzStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.YzStruct"`
}) {
}

func (m *YzStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Y")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Y.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Z")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Z.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *YzStruct) MakeVDLTarget() vdl.Target {
	return &YzStructTarget{Value: m}
}

type YzStructTarget struct {
	Value   *YzStruct
	yTarget NBoolTarget
	zTarget NStringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *YzStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*YzStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *YzStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Y":
		t.yTarget.Value = &t.Value.Y
		target, err := &t.yTarget, error(nil)
		return nil, target, err
	case "Z":
		t.zTarget.Value = &t.Value.Z
		target, err := &t.zTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.YzStruct", name)
	}
}
func (t *YzStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *YzStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type ZStruct struct {
	Z string
}

func (ZStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ZStruct"`
}) {
}

func (m *ZStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Z")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Z), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ZStruct) MakeVDLTarget() vdl.Target {
	return &ZStructTarget{Value: m}
}

type ZStructTarget struct {
	Value   *ZStruct
	zTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ZStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ZStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ZStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Z":
		t.zTarget.Value = &t.Value.Z
		target, err := &t.zTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.ZStruct", name)
	}
}
func (t *ZStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ZStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type MapOnlyStruct struct {
	Key1 int64
	Key2 uint32
}

func (MapOnlyStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyStruct"`
}) {
}

func (m *MapOnlyStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key1")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromInt(int64(m.Key1), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Key2")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromUint(uint64(m.Key2), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyStruct) MakeVDLTarget() vdl.Target {
	return &MapOnlyStructTarget{Value: m}
}

type MapOnlyStructTarget struct {
	Value      *MapOnlyStruct
	key1Target vdl.Int64Target
	key2Target vdl.Uint32Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *MapOnlyStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlyStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *MapOnlyStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key1":
		t.key1Target.Value = &t.Value.Key1
		target, err := &t.key1Target, error(nil)
		return nil, target, err
	case "Key2":
		t.key2Target.Value = &t.Value.Key2
		target, err := &t.key2Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.MapOnlyStruct", name)
	}
}
func (t *MapOnlyStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *MapOnlyStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type StructOnlyMap map[string]uint64

func (StructOnlyMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructOnlyMap"`
}) {
}

func (m *StructOnlyMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromUint(uint64(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructOnlyMap) MakeVDLTarget() vdl.Target {
	return &StructOnlyMapTarget{Value: m}
}

type StructOnlyMapTarget struct {
	Value      *StructOnlyMap
	currKey    string
	currElem   uint64
	keyTarget  vdl.StringTarget
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *StructOnlyMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*StructOnlyMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(StructOnlyMap)
	return t, nil
}
func (t *StructOnlyMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *StructOnlyMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = uint64(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *StructOnlyMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *StructOnlyMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapSetStruct struct {
	Feat bool
	Tire bool
	Eel  bool
}

func (MapSetStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapSetStruct"`
}) {
}

func (m *MapSetStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Feat")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.Feat), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Tire")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromBool(bool(m.Tire), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Eel")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromBool(bool(m.Eel), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapSetStruct) MakeVDLTarget() vdl.Target {
	return &MapSetStructTarget{Value: m}
}

type MapSetStructTarget struct {
	Value      *MapSetStruct
	featTarget vdl.BoolTarget
	tireTarget vdl.BoolTarget
	eelTarget  vdl.BoolTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *MapSetStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*MapSetStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *MapSetStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Feat":
		t.featTarget.Value = &t.Value.Feat
		target, err := &t.featTarget, error(nil)
		return nil, target, err
	case "Tire":
		t.tireTarget.Value = &t.Value.Tire
		target, err := &t.tireTarget, error(nil)
		return nil, target, err
	case "Eel":
		t.eelTarget.Value = &t.Value.Eel
		target, err := &t.eelTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.MapSetStruct", name)
	}
}
func (t *MapSetStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *MapSetStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type SetStructMap map[string]bool

func (SetStructMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetStructMap"`
}) {
}

func (m *SetStructMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromBool(bool(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetStructMap) MakeVDLTarget() vdl.Target {
	return &SetStructMapTarget{Value: m}
}

type SetStructMapTarget struct {
	Value      *SetStructMap
	currKey    string
	currElem   bool
	keyTarget  vdl.StringTarget
	elemTarget vdl.BoolTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SetStructMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*SetStructMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetStructMap)
	return t, nil
}
func (t *SetStructMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetStructMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = false
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *SetStructMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SetStructMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapStructSet map[string]struct{}

func (MapStructSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapStructSet"`
}) {
}

func (m *MapStructSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapStructSet) MakeVDLTarget() vdl.Target {
	return &MapStructSetTarget{Value: m}
}

type MapStructSetTarget struct {
	Value     *MapStructSet
	currKey   string
	keyTarget vdl.StringTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *MapStructSetTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*MapStructSet)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapStructSet)
	return t, nil
}
func (t *MapStructSetTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapStructSetTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *MapStructSetTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SetOnlyMap map[float64]bool

func (SetOnlyMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyMap"`
}) {
}

func (m *SetOnlyMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromFloat(float64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromBool(bool(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyMap) MakeVDLTarget() vdl.Target {
	return &SetOnlyMapTarget{Value: m}
}

type SetOnlyMapTarget struct {
	Value      *SetOnlyMap
	currKey    float64
	currElem   bool
	keyTarget  vdl.Float64Target
	elemTarget vdl.BoolTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SetOnlyMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*SetOnlyMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetOnlyMap)
	return t, nil
}
func (t *SetOnlyMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetOnlyMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = false
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *SetOnlyMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SetOnlyMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SometimesSetMap map[float64]*vdl.Value

func (SometimesSetMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SometimesSetMap"`
}) {
}

func (m *SometimesSetMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromFloat(float64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if value5 == nil {
			if err := valueTarget4.FromNil(tt.NonOptional().Elem()); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(valueTarget4, value5); err != nil {
				return err
			}
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SometimesSetMap) MakeVDLTarget() vdl.Target {
	return &SometimesSetMapTarget{Value: m}
}

type SometimesSetMapTarget struct {
	Value     *SometimesSetMap
	currKey   float64
	currElem  *vdl.Value
	keyTarget vdl.Float64Target

	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SometimesSetMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*SometimesSetMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SometimesSetMap)
	return t, nil
}
func (t *SometimesSetMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SometimesSetMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = (*vdl.Value)(nil)
	target, err := vdl.ReflectTarget(reflect.ValueOf(&t.currElem))
	return target, err
}
func (t *SometimesSetMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SometimesSetMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapOnlySet map[float64]struct{}

func (MapOnlySet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlySet"`
}) {
}

func (m *MapOnlySet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromFloat(float64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlySet) MakeVDLTarget() vdl.Target {
	return &MapOnlySetTarget{Value: m}
}

type MapOnlySetTarget struct {
	Value     *MapOnlySet
	currKey   float64
	keyTarget vdl.Float64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *MapOnlySetTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlySet)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapOnlySet)
	return t, nil
}
func (t *MapOnlySetTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapOnlySetTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *MapOnlySetTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SetOnlyA map[bool]struct{}

func (SetOnlyA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyA"`
}) {
}

func (m *SetOnlyA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromBool(bool(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyA) MakeVDLTarget() vdl.Target {
	return &SetOnlyATarget{Value: m}
}

type SetOnlyATarget struct {
	Value     *SetOnlyA
	currKey   bool
	keyTarget vdl.BoolTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyATarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*SetOnlyA)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetOnlyA)
	return t, nil
}
func (t *SetOnlyATarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = false
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetOnlyATarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyATarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SetOnlyA2 map[NBool]struct{}

func (SetOnlyA2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyA2"`
}) {
}

func (m *SetOnlyA2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyA2) MakeVDLTarget() vdl.Target {
	return &SetOnlyA2Target{Value: m}
}

type SetOnlyA2Target struct {
	Value     *SetOnlyA2
	currKey   NBool
	keyTarget NBoolTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyA2Target) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*SetOnlyA2)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetOnlyA2)
	return t, nil
}
func (t *SetOnlyA2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = NBool(false)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetOnlyA2Target) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyA2Target) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SetOnlyB map[int16]struct{}

func (SetOnlyB) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyB"`
}) {
}

func (m *SetOnlyB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromInt(int64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyB) MakeVDLTarget() vdl.Target {
	return &SetOnlyBTarget{Value: m}
}

type SetOnlyBTarget struct {
	Value     *SetOnlyB
	currKey   int16
	keyTarget vdl.Int16Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyBTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*SetOnlyB)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetOnlyB)
	return t, nil
}
func (t *SetOnlyBTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = int16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetOnlyBTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyBTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SetOnlyB2 map[NInt16]struct{}

func (SetOnlyB2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyB2"`
}) {
}

func (m *SetOnlyB2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyB2) MakeVDLTarget() vdl.Target {
	return &SetOnlyB2Target{Value: m}
}

type SetOnlyB2Target struct {
	Value     *SetOnlyB2
	currKey   NInt16
	keyTarget NInt16Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyB2Target) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*SetOnlyB2)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetOnlyB2)
	return t, nil
}
func (t *SetOnlyB2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = NInt16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetOnlyB2Target) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyB2Target) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapOnlyA map[uint32]uint32

func (MapOnlyA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyA"`
}) {
}

func (m *MapOnlyA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromUint(uint64(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyA) MakeVDLTarget() vdl.Target {
	return &MapOnlyATarget{Value: m}
}

type MapOnlyATarget struct {
	Value      *MapOnlyA
	currKey    uint32
	currElem   uint32
	keyTarget  vdl.Uint32Target
	elemTarget vdl.Uint32Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyATarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlyA)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapOnlyA)
	return t, nil
}
func (t *MapOnlyATarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapOnlyATarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = uint32(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MapOnlyATarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyATarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapOnlyA2 map[int64]float64

func (MapOnlyA2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyA2"`
}) {
}

func (m *MapOnlyA2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromInt(int64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromFloat(float64(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyA2) MakeVDLTarget() vdl.Target {
	return &MapOnlyA2Target{Value: m}
}

type MapOnlyA2Target struct {
	Value      *MapOnlyA2
	currKey    int64
	currElem   float64
	keyTarget  vdl.Int64Target
	elemTarget vdl.Float64Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyA2Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlyA2)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapOnlyA2)
	return t, nil
}
func (t *MapOnlyA2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapOnlyA2Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = float64(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MapOnlyA2Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyA2Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapOnlyB map[bool]string

func (MapOnlyB) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyB"`
}) {
}

func (m *MapOnlyB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromBool(bool(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromString(string(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyB) MakeVDLTarget() vdl.Target {
	return &MapOnlyBTarget{Value: m}
}

type MapOnlyBTarget struct {
	Value      *MapOnlyB
	currKey    bool
	currElem   string
	keyTarget  vdl.BoolTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyBTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlyB)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapOnlyB)
	return t, nil
}
func (t *MapOnlyBTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = false
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapOnlyBTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MapOnlyBTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyBTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapOnlyB2 map[NBool]NString

func (MapOnlyB2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyB2"`
}) {
}

func (m *MapOnlyB2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyB2) MakeVDLTarget() vdl.Target {
	return &MapOnlyB2Target{Value: m}
}

type MapOnlyB2Target struct {
	Value      *MapOnlyB2
	currKey    NBool
	currElem   NString
	keyTarget  NBoolTarget
	elemTarget NStringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyB2Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlyB2)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapOnlyB2)
	return t, nil
}
func (t *MapOnlyB2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = NBool(false)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapOnlyB2Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = NString("")
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MapOnlyB2Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyB2Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type (
	// BdeUnion represents any single field of the BdeUnion union type.
	BdeUnion interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the BdeUnion union type.
		__VDLReflect(__BdeUnionReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// BdeUnionB represents field B of the BdeUnion union type.
	BdeUnionB struct{ Value string }
	// BdeUnionD represents field D of the BdeUnion union type.
	BdeUnionD struct{ Value *vdl.Value }
	// BdeUnionE represents field E of the BdeUnion union type.
	BdeUnionE struct{ Value *vdl.Type }
	// __BdeUnionReflect describes the BdeUnion union type.
	__BdeUnionReflect struct {
		Name               string `vdl:"v.io/v23/vom/testdata/types.BdeUnion"`
		Type               BdeUnion
		UnionTargetFactory bdeUnionTargetFactory
		Union              struct {
			B BdeUnionB
			D BdeUnionD
			E BdeUnionE
		}
	}
)

func (x BdeUnionB) Index() int                     { return 0 }
func (x BdeUnionB) Interface() interface{}         { return x.Value }
func (x BdeUnionB) Name() string                   { return "B" }
func (x BdeUnionB) __VDLReflect(__BdeUnionReflect) {}

func (m BdeUnionB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m BdeUnionB) MakeVDLTarget() vdl.Target {
	return nil
}

func (x BdeUnionD) Index() int                     { return 1 }
func (x BdeUnionD) Interface() interface{}         { return x.Value }
func (x BdeUnionD) Name() string                   { return "D" }
func (x BdeUnionD) __VDLReflect(__BdeUnionReflect) {}

func (m BdeUnionD) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("D")
	if err != nil {
		return err
	}

	if m.Value == nil {
		if err := fieldTarget3.FromNil(tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
	} else {
		if err := vdl.FromValue(fieldTarget3, m.Value); err != nil {
			return err
		}
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m BdeUnionD) MakeVDLTarget() vdl.Target {
	return nil
}

func (x BdeUnionE) Index() int                     { return 2 }
func (x BdeUnionE) Interface() interface{}         { return x.Value }
func (x BdeUnionE) Name() string                   { return "E" }
func (x BdeUnionE) __VDLReflect(__BdeUnionReflect) {}

func (m BdeUnionE) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("E")
	if err != nil {
		return err
	}
	typeObjectVal4 := m.Value
	if typeObjectVal4 == nil {
		typeObjectVal4 = vdl.AnyType
	}
	if err := fieldTarget3.FromTypeObject(typeObjectVal4); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m BdeUnionE) MakeVDLTarget() vdl.Target {
	return nil
}

type BdeUnionTarget struct {
	Value     *BdeUnion
	fieldName string
	anyValue  vdl.Value
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BdeUnionTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*BdeUnion)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *BdeUnionTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "B":
		val := ""
		return nil, &vdl.StringTarget{Value: &val}, nil
	case "D":
		t.anyValue = vdl.Value{}
		target, err := vdl.ValueTarget(&t.anyValue)
		return nil, target, err
	case "E":
		val := vdl.AnyType
		return nil, &vdl.TypeObjectTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/vom/testdata/types.BdeUnion", name)
	}
}
func (t *BdeUnionTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "B":
		*t.Value = BdeUnionB{*(fieldTarget.(*vdl.StringTarget)).Value}
	case "D":
		*t.Value = BdeUnionD{&t.anyValue}
	case "E":
		*t.Value = BdeUnionE{*(fieldTarget.(*vdl.TypeObjectTarget)).Value}
	}
	return nil
}
func (t *BdeUnionTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type bdeUnionTargetFactory struct{}

func (t bdeUnionTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*BdeUnion); ok {
		return &BdeUnionTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *BdeUnion", union)
}

type BrieEnum int

const (
	BrieEnumGlee BrieEnum = iota
	BrieEnumBrie
	BrieEnumThree
)

// BrieEnumAll holds all labels for BrieEnum.
var BrieEnumAll = [...]BrieEnum{BrieEnumGlee, BrieEnumBrie, BrieEnumThree}

// BrieEnumFromString creates a BrieEnum from a string label.
func BrieEnumFromString(label string) (x BrieEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *BrieEnum) Set(label string) error {
	switch label {
	case "Glee", "glee":
		*x = BrieEnumGlee
		return nil
	case "Brie", "brie":
		*x = BrieEnumBrie
		return nil
	case "Three", "three":
		*x = BrieEnumThree
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.BrieEnum", label)
}

// String returns the string label of x.
func (x BrieEnum) String() string {
	switch x {
	case BrieEnumGlee:
		return "Glee"
	case BrieEnumBrie:
		return "Brie"
	case BrieEnumThree:
		return "Three"
	}
	return ""
}

func (BrieEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.BrieEnum"`
	Enum struct{ Glee, Brie, Three string }
}) {
}

func (m *BrieEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *BrieEnum) MakeVDLTarget() vdl.Target {
	return &BrieEnumTarget{Value: m}
}

type BrieEnumTarget struct {
	Value *BrieEnum
	vdl.TargetBase
}

func (t *BrieEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*BrieEnum)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Glee":
		*t.Value = 0
	case "Brie":
		*t.Value = 1
	case "Three":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum v.io/v23/vom/testdata/types.BrieEnum", src)
	}

	return nil
}

type BeanEnum int

const (
	BeanEnumBean BeanEnum = iota
)

// BeanEnumAll holds all labels for BeanEnum.
var BeanEnumAll = [...]BeanEnum{BeanEnumBean}

// BeanEnumFromString creates a BeanEnum from a string label.
func BeanEnumFromString(label string) (x BeanEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *BeanEnum) Set(label string) error {
	switch label {
	case "Bean", "bean":
		*x = BeanEnumBean
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.BeanEnum", label)
}

// String returns the string label of x.
func (x BeanEnum) String() string {
	switch x {
	case BeanEnumBean:
		return "Bean"
	}
	return ""
}

func (BeanEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.BeanEnum"`
	Enum struct{ Bean string }
}) {
}

func (m *BeanEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *BeanEnum) MakeVDLTarget() vdl.Target {
	return &BeanEnumTarget{Value: m}
}

type BeanEnumTarget struct {
	Value *BeanEnum
	vdl.TargetBase
}

func (t *BeanEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*BeanEnum)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Bean":
		*t.Value = 0
	default:
		return fmt.Errorf("label %s not in enum v.io/v23/vom/testdata/types.BeanEnum", src)
	}

	return nil
}

type FoodEnum int

const (
	FoodEnumBean FoodEnum = iota
	FoodEnumBrie
	FoodEnumCherry
)

// FoodEnumAll holds all labels for FoodEnum.
var FoodEnumAll = [...]FoodEnum{FoodEnumBean, FoodEnumBrie, FoodEnumCherry}

// FoodEnumFromString creates a FoodEnum from a string label.
func FoodEnumFromString(label string) (x FoodEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *FoodEnum) Set(label string) error {
	switch label {
	case "Bean", "bean":
		*x = FoodEnumBean
		return nil
	case "Brie", "brie":
		*x = FoodEnumBrie
		return nil
	case "Cherry", "cherry":
		*x = FoodEnumCherry
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.FoodEnum", label)
}

// String returns the string label of x.
func (x FoodEnum) String() string {
	switch x {
	case FoodEnumBean:
		return "Bean"
	case FoodEnumBrie:
		return "Brie"
	case FoodEnumCherry:
		return "Cherry"
	}
	return ""
}

func (FoodEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.FoodEnum"`
	Enum struct{ Bean, Brie, Cherry string }
}) {
}

func (m *FoodEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *FoodEnum) MakeVDLTarget() vdl.Target {
	return &FoodEnumTarget{Value: m}
}

type FoodEnumTarget struct {
	Value *FoodEnum
	vdl.TargetBase
}

func (t *FoodEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*FoodEnum)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Bean":
		*t.Value = 0
	case "Brie":
		*t.Value = 1
	case "Cherry":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum v.io/v23/vom/testdata/types.FoodEnum", src)
	}

	return nil
}

type StructAny struct {
	Any *vdl.Value
}

func (StructAny) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructAny"`
}) {
}

func (m *StructAny) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Any")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Any == nil {
			if err := fieldTarget3.FromNil(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget3, m.Any); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructAny) MakeVDLTarget() vdl.Target {
	return &StructAnyTarget{Value: m}
}

type StructAnyTarget struct {
	Value *StructAny

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *StructAnyTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*StructAny)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *StructAnyTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Any":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Any))
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.StructAny", name)
	}
}
func (t *StructAnyTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *StructAnyTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type StructMap struct {
	Map map[int64]int64
}

func (StructMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructMap"`
}) {
}

func (m *StructMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Map")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.Map))
		if err != nil {
			return err
		}
		for key6, value8 := range m.Map {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromInt(int64(key6), tt.NonOptional().Field(0).Type.Key()); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}
			if err := valueTarget7.FromInt(int64(value8), tt.NonOptional().Field(0).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructMap) MakeVDLTarget() vdl.Target {
	return &StructMapTarget{Value: m}
}

type StructMapTarget struct {
	Value     *StructMap
	mapTarget __VDLTarget12_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *StructMapTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*StructMap)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *StructMapTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Map":
		t.mapTarget.Value = &t.Value.Map
		target, err := &t.mapTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.StructMap", name)
	}
}
func (t *StructMapTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *StructMapTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[int64]int64
type __VDLTarget12_map struct {
	Value      *map[int64]int64
	currKey    int64
	currElem   int64
	keyTarget  vdl.Int64Target
	elemTarget vdl.Int64Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget12_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int64]int64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int64]int64)
	return t, nil
}
func (t *__VDLTarget12_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget12_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = int64(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget12_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget12_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// Since the encoding changes if struct fields are zero values,
// test each of the kinds in a struct both as zero and non-zero values.
type StructManyTypes struct {
	Bool             bool
	AByte            byte
	Int16            int16
	Int32            int32
	Int64            int64
	Uint16           uint16
	Uint32           uint32
	Uint64           uint64
	String           string
	Bytes            []byte
	Float32          float32
	Float64          float64
	FoodEnum         FoodEnum
	NEnum            NEnum
	NListUint64      NListUint64
	NByteArray       NByteArray
	NArray2Uint64    NArray2Uint64
	NSetUint64       NSetUint64
	NMapUint64String NMapUint64String
	NStruct          NStruct
	NUnion           NUnion
	TypeObject       *vdl.Type
}

func (StructManyTypes) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructManyTypes"`
}) {
}

func (m *StructManyTypes) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Bool")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.Bool), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("AByte")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromUint(uint64(m.AByte), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Int16")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromInt(int64(m.Int16), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Int32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget9.FromInt(int64(m.Int32), tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("Int64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget11.FromInt(int64(m.Int64), tt.NonOptional().Field(4).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("Uint16")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget13.FromUint(uint64(m.Uint16), tt.NonOptional().Field(5).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("Uint32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget15.FromUint(uint64(m.Uint32), tt.NonOptional().Field(6).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	keyTarget16, fieldTarget17, err := fieldsTarget1.StartField("Uint64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget17.FromUint(uint64(m.Uint64), tt.NonOptional().Field(7).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget16, fieldTarget17); err != nil {
			return err
		}
	}
	keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("String")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget19.FromString(string(m.String), tt.NonOptional().Field(8).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
			return err
		}
	}
	keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("Bytes")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := fieldTarget21.FromBytes([]byte(m.Bytes), tt.NonOptional().Field(9).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
			return err
		}
	}
	keyTarget22, fieldTarget23, err := fieldsTarget1.StartField("Float32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget23.FromFloat(float64(m.Float32), tt.NonOptional().Field(10).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget22, fieldTarget23); err != nil {
			return err
		}
	}
	keyTarget24, fieldTarget25, err := fieldsTarget1.StartField("Float64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget25.FromFloat(float64(m.Float64), tt.NonOptional().Field(11).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget24, fieldTarget25); err != nil {
			return err
		}
	}
	keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("FoodEnum")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.FoodEnum.FillVDLTarget(fieldTarget27, tt.NonOptional().Field(12).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
			return err
		}
	}
	keyTarget28, fieldTarget29, err := fieldsTarget1.StartField("NEnum")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NEnum.FillVDLTarget(fieldTarget29, tt.NonOptional().Field(13).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget28, fieldTarget29); err != nil {
			return err
		}
	}
	keyTarget30, fieldTarget31, err := fieldsTarget1.StartField("NListUint64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NListUint64.FillVDLTarget(fieldTarget31, tt.NonOptional().Field(14).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget30, fieldTarget31); err != nil {
			return err
		}
	}
	keyTarget32, fieldTarget33, err := fieldsTarget1.StartField("NByteArray")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NByteArray.FillVDLTarget(fieldTarget33, tt.NonOptional().Field(15).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget32, fieldTarget33); err != nil {
			return err
		}
	}
	keyTarget34, fieldTarget35, err := fieldsTarget1.StartField("NArray2Uint64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NArray2Uint64.FillVDLTarget(fieldTarget35, tt.NonOptional().Field(16).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget34, fieldTarget35); err != nil {
			return err
		}
	}
	keyTarget36, fieldTarget37, err := fieldsTarget1.StartField("NSetUint64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NSetUint64.FillVDLTarget(fieldTarget37, tt.NonOptional().Field(17).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget36, fieldTarget37); err != nil {
			return err
		}
	}
	keyTarget38, fieldTarget39, err := fieldsTarget1.StartField("NMapUint64String")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NMapUint64String.FillVDLTarget(fieldTarget39, tt.NonOptional().Field(18).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget38, fieldTarget39); err != nil {
			return err
		}
	}
	keyTarget40, fieldTarget41, err := fieldsTarget1.StartField("NStruct")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NStruct.FillVDLTarget(fieldTarget41, tt.NonOptional().Field(19).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget40, fieldTarget41); err != nil {
			return err
		}
	}
	keyTarget42, fieldTarget43, err := fieldsTarget1.StartField("NUnion")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		unionValue44 := m.NUnion
		if unionValue44 == nil {
			unionValue44 = NUnionA{}
		}
		if err := unionValue44.FillVDLTarget(fieldTarget43, tt.NonOptional().Field(20).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget42, fieldTarget43); err != nil {
			return err
		}
	}
	keyTarget45, fieldTarget46, err := fieldsTarget1.StartField("TypeObject")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		typeObjectVal47 := m.TypeObject
		if typeObjectVal47 == nil {
			typeObjectVal47 = vdl.AnyType
		}
		if err := fieldTarget46.FromTypeObject(typeObjectVal47); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget45, fieldTarget46); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructManyTypes) MakeVDLTarget() vdl.Target {
	return &StructManyTypesTarget{Value: m}
}

type StructManyTypesTarget struct {
	Value                  *StructManyTypes
	boolTarget             vdl.BoolTarget
	aByteTarget            vdl.ByteTarget
	int16Target            vdl.Int16Target
	int32Target            vdl.Int32Target
	int64Target            vdl.Int64Target
	uint16Target           vdl.Uint16Target
	uint32Target           vdl.Uint32Target
	uint64Target           vdl.Uint64Target
	stringTarget           vdl.StringTarget
	bytesTarget            vdl.BytesTarget
	float32Target          vdl.Float32Target
	float64Target          vdl.Float64Target
	foodEnumTarget         FoodEnumTarget
	nEnumTarget            NEnumTarget
	nListUint64Target      NListUint64Target
	nByteArrayTarget       NByteArrayTarget
	nArray2Uint64Target    NArray2Uint64Target
	nSetUint64Target       NSetUint64Target
	nMapUint64StringTarget NMapUint64StringTarget
	nStructTarget          NStructTarget
	nUnionTarget           NUnionTarget
	typeObjectTarget       vdl.TypeObjectTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *StructManyTypesTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*StructManyTypes)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *StructManyTypesTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Bool":
		t.boolTarget.Value = &t.Value.Bool
		target, err := &t.boolTarget, error(nil)
		return nil, target, err
	case "AByte":
		t.aByteTarget.Value = &t.Value.AByte
		target, err := &t.aByteTarget, error(nil)
		return nil, target, err
	case "Int16":
		t.int16Target.Value = &t.Value.Int16
		target, err := &t.int16Target, error(nil)
		return nil, target, err
	case "Int32":
		t.int32Target.Value = &t.Value.Int32
		target, err := &t.int32Target, error(nil)
		return nil, target, err
	case "Int64":
		t.int64Target.Value = &t.Value.Int64
		target, err := &t.int64Target, error(nil)
		return nil, target, err
	case "Uint16":
		t.uint16Target.Value = &t.Value.Uint16
		target, err := &t.uint16Target, error(nil)
		return nil, target, err
	case "Uint32":
		t.uint32Target.Value = &t.Value.Uint32
		target, err := &t.uint32Target, error(nil)
		return nil, target, err
	case "Uint64":
		t.uint64Target.Value = &t.Value.Uint64
		target, err := &t.uint64Target, error(nil)
		return nil, target, err
	case "String":
		t.stringTarget.Value = &t.Value.String
		target, err := &t.stringTarget, error(nil)
		return nil, target, err
	case "Bytes":
		t.bytesTarget.Value = &t.Value.Bytes
		target, err := &t.bytesTarget, error(nil)
		return nil, target, err
	case "Float32":
		t.float32Target.Value = &t.Value.Float32
		target, err := &t.float32Target, error(nil)
		return nil, target, err
	case "Float64":
		t.float64Target.Value = &t.Value.Float64
		target, err := &t.float64Target, error(nil)
		return nil, target, err
	case "FoodEnum":
		t.foodEnumTarget.Value = &t.Value.FoodEnum
		target, err := &t.foodEnumTarget, error(nil)
		return nil, target, err
	case "NEnum":
		t.nEnumTarget.Value = &t.Value.NEnum
		target, err := &t.nEnumTarget, error(nil)
		return nil, target, err
	case "NListUint64":
		t.nListUint64Target.Value = &t.Value.NListUint64
		target, err := &t.nListUint64Target, error(nil)
		return nil, target, err
	case "NByteArray":
		t.nByteArrayTarget.Value = &t.Value.NByteArray
		target, err := &t.nByteArrayTarget, error(nil)
		return nil, target, err
	case "NArray2Uint64":
		t.nArray2Uint64Target.Value = &t.Value.NArray2Uint64
		target, err := &t.nArray2Uint64Target, error(nil)
		return nil, target, err
	case "NSetUint64":
		t.nSetUint64Target.Value = &t.Value.NSetUint64
		target, err := &t.nSetUint64Target, error(nil)
		return nil, target, err
	case "NMapUint64String":
		t.nMapUint64StringTarget.Value = &t.Value.NMapUint64String
		target, err := &t.nMapUint64StringTarget, error(nil)
		return nil, target, err
	case "NStruct":
		t.nStructTarget.Value = &t.Value.NStruct
		target, err := &t.nStructTarget, error(nil)
		return nil, target, err
	case "NUnion":
		t.nUnionTarget.Value = &t.Value.NUnion
		target, err := &t.nUnionTarget, error(nil)
		return nil, target, err
	case "TypeObject":
		t.typeObjectTarget.Value = &t.Value.TypeObject
		target, err := &t.typeObjectTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.StructManyTypes", name)
	}
}
func (t *StructManyTypesTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *StructManyTypesTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type AnySlice []*vdl.Value

func (AnySlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AnySlice"`
}) {
}

func (m *AnySlice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if elem3 == nil {
			if err := elemTarget2.FromNil(tt.NonOptional().Elem()); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(elemTarget2, elem3); err != nil {
				return err
			}
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AnySlice) MakeVDLTarget() vdl.Target {
	return &AnySliceTarget{Value: m}
}

// AnySlice
type AnySliceTarget struct {
	Value *AnySlice

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *AnySliceTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*AnySlice)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(AnySlice, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *AnySliceTarget) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
	return target, err
}
func (t *AnySliceTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *AnySliceTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type LargeMessageType struct {
	Payload []byte
	Next    *LargeMessageType
}

func (LargeMessageType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.LargeMessageType"`
}) {
}

func (m *LargeMessageType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Payload")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := fieldTarget3.FromBytes([]byte(m.Payload), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Next")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Next == nil {
			if err := fieldTarget5.FromNil(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {
			if err := m.Next.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LargeMessageType) MakeVDLTarget() vdl.Target {
	return &LargeMessageTypeTarget{Value: m}
}

type LargeMessageTypeTarget struct {
	Value         *LargeMessageType
	payloadTarget vdl.BytesTarget

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LargeMessageTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LargeMessageType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LargeMessageTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Payload":
		t.payloadTarget.Value = &t.Value.Payload
		target, err := &t.payloadTarget, error(nil)
		return nil, target, err
	case "Next":
		target, err := &__VDLTarget13_optional{Value: &t.Value.Next}, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.LargeMessageType", name)
	}
}
func (t *LargeMessageTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LargeMessageTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional LargeMessageType
type __VDLTarget13_optional struct {
	Value **LargeMessageType

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget13_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &LargeMessageType{}
	}
	target, err := &LargeMessageTypeTarget{Value: *t.Value}, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget13_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget13_optional) FromNil(tt *vdl.Type) error {

	*t.Value = nil

	return nil
}

type LargeAnyMessageType struct {
	Payload *vdl.Value
	Next    *LargeAnyMessageType
}

func (LargeAnyMessageType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.LargeAnyMessageType"`
}) {
}

func (m *LargeAnyMessageType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Payload")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Payload == nil {
			if err := fieldTarget3.FromNil(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget3, m.Payload); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Next")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Next == nil {
			if err := fieldTarget5.FromNil(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {
			if err := m.Next.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LargeAnyMessageType) MakeVDLTarget() vdl.Target {
	return &LargeAnyMessageTypeTarget{Value: m}
}

type LargeAnyMessageTypeTarget struct {
	Value *LargeAnyMessageType

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LargeAnyMessageTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LargeAnyMessageType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LargeAnyMessageTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Payload":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Payload))
		return nil, target, err
	case "Next":
		target, err := &__VDLTarget14_optional{Value: &t.Value.Next}, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/vom/testdata/types.LargeAnyMessageType", name)
	}
}
func (t *LargeAnyMessageTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LargeAnyMessageTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional LargeAnyMessageType
type __VDLTarget14_optional struct {
	Value **LargeAnyMessageType

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget14_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &LargeAnyMessageType{}
	}
	target, err := &LargeAnyMessageTypeTarget{Value: *t.Value}, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget14_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget14_optional) FromNil(tt *vdl.Type) error {

	*t.Value = nil

	return nil
}

// Create zero values for each type.
var (
	__VDLZeroTestCase     = TestCase{}
	__VDLZeroConvertGroup = ConvertGroup{
		PrimaryType: vdl.AnyType,
	}
	__VDLZeroVomdataStruct    = VomdataStruct{}
	__VDLZeroNBool            = NBool(false)
	__VDLZeroNString          = NString("")
	__VDLZeroNByteSlice       = NByteSlice(nil)
	__VDLZeroNByteArray       = NByteArray{}
	__VDLZeroNByte            = NByte(0)
	__VDLZeroNUint16          = NUint16(0)
	__VDLZeroNUint32          = NUint32(0)
	__VDLZeroNUint64          = NUint64(0)
	__VDLZeroNInt8            = NInt8(0)
	__VDLZeroNInt16           = NInt16(0)
	__VDLZeroNInt32           = NInt32(0)
	__VDLZeroNInt64           = NInt64(0)
	__VDLZeroNFloat32         = NFloat32(0)
	__VDLZeroNFloat64         = NFloat64(0)
	__VDLZeroNArray2Uint64    = NArray2Uint64{}
	__VDLZeroNListUint64      = NListUint64(nil)
	__VDLZeroNSetUint64       = NSetUint64(nil)
	__VDLZeroNMapUint64String = NMapUint64String(nil)
	__VDLZeroNStruct          = NStruct{}
	__VDLZeroNEnum            = NEnumA
	__VDLZeroNUnion           = NUnion(NUnionA{})
	__VDLZeroMBool            = MBool(false)
	__VDLZeroMStruct          = MStruct{
		E: vdl.AnyType,
	}
	__VDLZeroMList        = MList(nil)
	__VDLZeroMMap         = MMap(nil)
	__VDLZeroMByteSlice   = MByteSlice(nil)
	__VDLZeroMInt8Slice   = MInt8Slice(nil)
	__VDLZeroRecA         = RecA(nil)
	__VDLZeroRecY         = RecY(nil)
	__VDLZeroRecX         = RecX(nil)
	__VDLZeroRec4         = Rec4(nil)
	__VDLZeroRec3         = Rec3(nil)
	__VDLZeroRec2         = Rec2(nil)
	__VDLZeroRec1         = Rec1(nil)
	__VDLZeroRecStruct    = RecStruct{}
	__VDLZeroRec1234      = Rec1234{}
	__VDLZeroRec1234A     = Rec1234A{}
	__VDLZeroRec1234B     = Rec1234B{}
	__VDLZeroRec1234All   = Rec1234All{}
	__VDLZeroListString   = ListString(nil)
	__VDLZeroArray3String = Array3String{}
	__VDLZeroArray4String = Array4String{}
	__VDLZeroAbcStruct    = AbcStruct{}
	__VDLZeroAdeStruct    = AdeStruct{
		E: vdl.AnyType,
	}
	__VDLZeroXyzStruct       = XyzStruct{}
	__VDLZeroYzStruct        = YzStruct{}
	__VDLZeroZStruct         = ZStruct{}
	__VDLZeroMapOnlyStruct   = MapOnlyStruct{}
	__VDLZeroStructOnlyMap   = StructOnlyMap(nil)
	__VDLZeroMapSetStruct    = MapSetStruct{}
	__VDLZeroSetStructMap    = SetStructMap(nil)
	__VDLZeroMapStructSet    = MapStructSet(nil)
	__VDLZeroSetOnlyMap      = SetOnlyMap(nil)
	__VDLZeroSometimesSetMap = SometimesSetMap(nil)
	__VDLZeroMapOnlySet      = MapOnlySet(nil)
	__VDLZeroSetOnlyA        = SetOnlyA(nil)
	__VDLZeroSetOnlyA2       = SetOnlyA2(nil)
	__VDLZeroSetOnlyB        = SetOnlyB(nil)
	__VDLZeroSetOnlyB2       = SetOnlyB2(nil)
	__VDLZeroMapOnlyA        = MapOnlyA(nil)
	__VDLZeroMapOnlyA2       = MapOnlyA2(nil)
	__VDLZeroMapOnlyB        = MapOnlyB(nil)
	__VDLZeroMapOnlyB2       = MapOnlyB2(nil)
	__VDLZeroBdeUnion        = BdeUnion(BdeUnionB{})
	__VDLZeroBrieEnum        = BrieEnumGlee
	__VDLZeroBeanEnum        = BeanEnumBean
	__VDLZeroFoodEnum        = FoodEnumBean
	__VDLZeroStructAny       = StructAny{}
	__VDLZeroStructMap       = StructMap{}
	__VDLZeroStructManyTypes = StructManyTypes{
		NUnion:     NUnionA{},
		TypeObject: vdl.AnyType,
	}
	__VDLZeroAnySlice            = AnySlice(nil)
	__VDLZeroLargeMessageType    = LargeMessageType{}
	__VDLZeroLargeAnyMessageType = LargeAnyMessageType{}
)

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}

	// Register types.
	vdl.Register((*TestCase)(nil))
	vdl.Register((*ConvertGroup)(nil))
	vdl.Register((*VomdataStruct)(nil))
	vdl.Register((*NBool)(nil))
	vdl.Register((*NString)(nil))
	vdl.Register((*NByteSlice)(nil))
	vdl.Register((*NByteArray)(nil))
	vdl.Register((*NByte)(nil))
	vdl.Register((*NUint16)(nil))
	vdl.Register((*NUint32)(nil))
	vdl.Register((*NUint64)(nil))
	vdl.Register((*NInt8)(nil))
	vdl.Register((*NInt16)(nil))
	vdl.Register((*NInt32)(nil))
	vdl.Register((*NInt64)(nil))
	vdl.Register((*NFloat32)(nil))
	vdl.Register((*NFloat64)(nil))
	vdl.Register((*NArray2Uint64)(nil))
	vdl.Register((*NListUint64)(nil))
	vdl.Register((*NSetUint64)(nil))
	vdl.Register((*NMapUint64String)(nil))
	vdl.Register((*NStruct)(nil))
	vdl.Register((*NEnum)(nil))
	vdl.Register((*NUnion)(nil))
	vdl.Register((*MBool)(nil))
	vdl.Register((*MStruct)(nil))
	vdl.Register((*MList)(nil))
	vdl.Register((*MMap)(nil))
	vdl.Register((*MByteSlice)(nil))
	vdl.Register((*MInt8Slice)(nil))
	vdl.Register((*RecA)(nil))
	vdl.Register((*RecY)(nil))
	vdl.Register((*RecX)(nil))
	vdl.Register((*Rec4)(nil))
	vdl.Register((*Rec3)(nil))
	vdl.Register((*Rec2)(nil))
	vdl.Register((*Rec1)(nil))
	vdl.Register((*RecStruct)(nil))
	vdl.Register((*Rec1234)(nil))
	vdl.Register((*Rec1234A)(nil))
	vdl.Register((*Rec1234B)(nil))
	vdl.Register((*Rec1234All)(nil))
	vdl.Register((*ListString)(nil))
	vdl.Register((*Array3String)(nil))
	vdl.Register((*Array4String)(nil))
	vdl.Register((*AbcStruct)(nil))
	vdl.Register((*AdeStruct)(nil))
	vdl.Register((*XyzStruct)(nil))
	vdl.Register((*YzStruct)(nil))
	vdl.Register((*ZStruct)(nil))
	vdl.Register((*MapOnlyStruct)(nil))
	vdl.Register((*StructOnlyMap)(nil))
	vdl.Register((*MapSetStruct)(nil))
	vdl.Register((*SetStructMap)(nil))
	vdl.Register((*MapStructSet)(nil))
	vdl.Register((*SetOnlyMap)(nil))
	vdl.Register((*SometimesSetMap)(nil))
	vdl.Register((*MapOnlySet)(nil))
	vdl.Register((*SetOnlyA)(nil))
	vdl.Register((*SetOnlyA2)(nil))
	vdl.Register((*SetOnlyB)(nil))
	vdl.Register((*SetOnlyB2)(nil))
	vdl.Register((*MapOnlyA)(nil))
	vdl.Register((*MapOnlyA2)(nil))
	vdl.Register((*MapOnlyB)(nil))
	vdl.Register((*MapOnlyB2)(nil))
	vdl.Register((*BdeUnion)(nil))
	vdl.Register((*BrieEnum)(nil))
	vdl.Register((*BeanEnum)(nil))
	vdl.Register((*FoodEnum)(nil))
	vdl.Register((*StructAny)(nil))
	vdl.Register((*StructMap)(nil))
	vdl.Register((*StructManyTypes)(nil))
	vdl.Register((*AnySlice)(nil))
	vdl.Register((*LargeMessageType)(nil))
	vdl.Register((*LargeAnyMessageType)(nil))

	return struct{}{}
}
