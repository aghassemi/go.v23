// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: types

package types

import (
	"fmt"
	"reflect"
	"v.io/v23/vdl"
	"v.io/v23/vdl/vdlconv"
)

// TestCase represents an individual testcase for vom encoding and decoding.
type TestCase struct {
	Name       string     // Name of the testcase
	Value      *vdl.Value // Value to test
	TypeString string     // The string representation of the Type
	Hex        string     // Hex pattern representing vom encoding
	HexVersion string     // Hex pattern representing vom encoding of Version
	HexType    string     // Hex pattern representing vom encoding of Type
	HexValue   string     // Hex pattern representing vom encoding of Value
}

func (TestCase) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.TestCase"`
}) {
}

func (m *TestCase) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_TestCase == nil || __VDLType0 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Value")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Value == nil {
			if err := fieldTarget5.FromNil(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget5, m.Value); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("TypeString")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromString(string(m.TypeString), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Hex")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget9.FromString(string(m.Hex), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("HexVersion")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget11.FromString(string(m.HexVersion), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("HexType")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget13.FromString(string(m.HexType), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("HexValue")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget15.FromString(string(m.HexValue), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TestCase) MakeVDLTarget() vdl.Target {
	return &TestCaseTarget{Value: m}
}

type TestCaseTarget struct {
	Value *TestCase
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TestCaseTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_TestCase) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_TestCase)
	}
	return t, nil
}
func (t *TestCaseTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		val, err := &vdl.StringTarget{Value: &t.Value.Name}, error(nil)
		return nil, val, err
	case "Value":
		val, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Value))
		return nil, val, err
	case "TypeString":
		val, err := &vdl.StringTarget{Value: &t.Value.TypeString}, error(nil)
		return nil, val, err
	case "Hex":
		val, err := &vdl.StringTarget{Value: &t.Value.Hex}, error(nil)
		return nil, val, err
	case "HexVersion":
		val, err := &vdl.StringTarget{Value: &t.Value.HexVersion}, error(nil)
		return nil, val, err
	case "HexType":
		val, err := &vdl.StringTarget{Value: &t.Value.HexType}, error(nil)
		return nil, val, err
	case "HexValue":
		val, err := &vdl.StringTarget{Value: &t.Value.HexValue}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_TestCase)
	}
}
func (t *TestCaseTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TestCaseTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// vomdata config types
type ConvertGroup struct {
	Name        string
	PrimaryType *vdl.Type
	Values      []*vdl.Value
}

func (ConvertGroup) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ConvertGroup"`
}) {
}

func (m *ConvertGroup) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_ConvertGroup == nil || __VDLType1 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("PrimaryType")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		typeObjectVal6 := m.PrimaryType
		if typeObjectVal6 == nil {
			typeObjectVal6 = vdl.AnyType
		}
		if err := fieldTarget5.FromTypeObject(typeObjectVal6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("Values")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget9, err := fieldTarget8.StartList(__VDLType2, len(m.Values))
		if err != nil {
			return err
		}
		for i, elem11 := range m.Values {
			elemTarget10, err := listTarget9.StartElem(i)
			if err != nil {
				return err
			}

			if elem11 == nil {
				if err := elemTarget10.FromNil(vdl.AnyType); err != nil {
					return err
				}
			} else {
				if err := vdl.FromValue(elemTarget10, elem11); err != nil {
					return err
				}
			}
			if err := listTarget9.FinishElem(elemTarget10); err != nil {
				return err
			}
		}
		if err := fieldTarget8.FinishList(listTarget9); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConvertGroup) MakeVDLTarget() vdl.Target {
	return &ConvertGroupTarget{Value: m}
}

type ConvertGroupTarget struct {
	Value *ConvertGroup
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConvertGroupTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_ConvertGroup) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_ConvertGroup)
	}
	return t, nil
}
func (t *ConvertGroupTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		val, err := &vdl.StringTarget{Value: &t.Value.Name}, error(nil)
		return nil, val, err
	case "PrimaryType":
		val, err := &vdl.TypeObjectTarget{Value: &t.Value.PrimaryType}, error(nil)
		return nil, val, err
	case "Values":
		val, err := &unnamed_5b5d616e79_Target{Value: &t.Value.Values}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_ConvertGroup)
	}
}
func (t *ConvertGroupTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConvertGroupTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type unnamed_5b5d616e79_Target struct {
	Value *[]*vdl.Value
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *unnamed_5b5d616e79_Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType2) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType2)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vdl.Value, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *unnamed_5b5d616e79_Target) StartElem(index int) (elem vdl.Target, _ error) {
	return vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
}
func (t *unnamed_5b5d616e79_Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *unnamed_5b5d616e79_Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type VomdataStruct struct {
	EncodeDecodeData map[byte][]*vdl.Value // map from min required VOM version to test values
	CompatData       map[string][]*vdl.Type
	ConvertData      map[string][]ConvertGroup
}

func (VomdataStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.VomdataStruct"`
}) {
}

func (m *VomdataStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_VomdataStruct == nil || __VDLType3 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("EncodeDecodeData")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(__VDLType4, len(m.EncodeDecodeData))
		if err != nil {
			return err
		}
		for key6, value8 := range m.EncodeDecodeData {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromUint(uint64(key6), vdl.ByteType); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}

			listTarget9, err := valueTarget7.StartList(__VDLType2, len(value8))
			if err != nil {
				return err
			}
			for i, elem11 := range value8 {
				elemTarget10, err := listTarget9.StartElem(i)
				if err != nil {
					return err
				}

				if elem11 == nil {
					if err := elemTarget10.FromNil(vdl.AnyType); err != nil {
						return err
					}
				} else {
					if err := vdl.FromValue(elemTarget10, elem11); err != nil {
						return err
					}
				}
				if err := listTarget9.FinishElem(elemTarget10); err != nil {
					return err
				}
			}
			if err := valueTarget7.FinishList(listTarget9); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("CompatData")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget14, err := fieldTarget13.StartMap(__VDLType5, len(m.CompatData))
		if err != nil {
			return err
		}
		for key16, value18 := range m.CompatData {
			keyTarget15, err := mapTarget14.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget15.FromString(string(key16), vdl.StringType); err != nil {
				return err
			}
			valueTarget17, err := mapTarget14.FinishKeyStartField(keyTarget15)
			if err != nil {
				return err
			}

			listTarget19, err := valueTarget17.StartList(__VDLType6, len(value18))
			if err != nil {
				return err
			}
			for i, elem21 := range value18 {
				elemTarget20, err := listTarget19.StartElem(i)
				if err != nil {
					return err
				}
				typeObjectVal22 := elem21
				if typeObjectVal22 == nil {
					typeObjectVal22 = vdl.AnyType
				}
				if err := elemTarget20.FromTypeObject(typeObjectVal22); err != nil {
					return err
				}
				if err := listTarget19.FinishElem(elemTarget20); err != nil {
					return err
				}
			}
			if err := valueTarget17.FinishList(listTarget19); err != nil {
				return err
			}
			if err := mapTarget14.FinishField(keyTarget15, valueTarget17); err != nil {
				return err
			}
		}
		if err := fieldTarget13.FinishMap(mapTarget14); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("ConvertData")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget25, err := fieldTarget24.StartMap(__VDLType7, len(m.ConvertData))
		if err != nil {
			return err
		}
		for key27, value29 := range m.ConvertData {
			keyTarget26, err := mapTarget25.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget26.FromString(string(key27), vdl.StringType); err != nil {
				return err
			}
			valueTarget28, err := mapTarget25.FinishKeyStartField(keyTarget26)
			if err != nil {
				return err
			}

			listTarget30, err := valueTarget28.StartList(__VDLType8, len(value29))
			if err != nil {
				return err
			}
			for i, elem32 := range value29 {
				elemTarget31, err := listTarget30.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem32.FillVDLTarget(elemTarget31, __VDLType_v_io_v23_vom_testdata_types_ConvertGroup); err != nil {
					return err
				}
				if err := listTarget30.FinishElem(elemTarget31); err != nil {
					return err
				}
			}
			if err := valueTarget28.FinishList(listTarget30); err != nil {
				return err
			}
			if err := mapTarget25.FinishField(keyTarget26, valueTarget28); err != nil {
				return err
			}
		}
		if err := fieldTarget24.FinishMap(mapTarget25); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *VomdataStruct) MakeVDLTarget() vdl.Target {
	return &VomdataStructTarget{Value: m}
}

type VomdataStructTarget struct {
	Value *VomdataStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *VomdataStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_VomdataStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_VomdataStruct)
	}
	return t, nil
}
func (t *VomdataStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "EncodeDecodeData":
		val, err := &unnamed_6d61705b627974655d5b5d616e79_Target{Value: &t.Value.EncodeDecodeData}, error(nil)
		return nil, val, err
	case "CompatData":
		val, err := &unnamed_6d61705b737472696e675d5b5d747970656f626a656374_Target{Value: &t.Value.CompatData}, error(nil)
		return nil, val, err
	case "ConvertData":
		val, err := &unnamed_6d61705b737472696e675d5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target{Value: &t.Value.ConvertData}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_VomdataStruct)
	}
}
func (t *VomdataStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *VomdataStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type unnamed_6d61705b627974655d5b5d616e79_Target struct {
	Value    *map[byte][]*vdl.Value
	currKey  byte
	currElem []*vdl.Value
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *unnamed_6d61705b627974655d5b5d616e79_Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType4) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType4)
	}
	*t.Value = make(map[byte][]*vdl.Value)
	return t, nil
}
func (t *unnamed_6d61705b627974655d5b5d616e79_Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = byte(0)
	return &vdl.ByteTarget{Value: &t.currKey}, error(nil)
}
func (t *unnamed_6d61705b627974655d5b5d616e79_Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []*vdl.Value(nil)
	return &unnamed_5b5d616e79_Target{Value: &t.currElem}, error(nil)
}
func (t *unnamed_6d61705b627974655d5b5d616e79_Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *unnamed_6d61705b627974655d5b5d616e79_Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type unnamed_6d61705b737472696e675d5b5d747970656f626a656374_Target struct {
	Value    *map[string][]*vdl.Type
	currKey  string
	currElem []*vdl.Type
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *unnamed_6d61705b737472696e675d5b5d747970656f626a656374_Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType5) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType5)
	}
	*t.Value = make(map[string][]*vdl.Type)
	return t, nil
}
func (t *unnamed_6d61705b737472696e675d5b5d747970656f626a656374_Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	return &vdl.StringTarget{Value: &t.currKey}, error(nil)
}
func (t *unnamed_6d61705b737472696e675d5b5d747970656f626a656374_Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []*vdl.Type(nil)
	return &unnamed_5b5d747970656f626a656374_Target{Value: &t.currElem}, error(nil)
}
func (t *unnamed_6d61705b737472696e675d5b5d747970656f626a656374_Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *unnamed_6d61705b737472696e675d5b5d747970656f626a656374_Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type unnamed_5b5d747970656f626a656374_Target struct {
	Value *[]*vdl.Type
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *unnamed_5b5d747970656f626a656374_Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType6) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType6)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vdl.Type, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *unnamed_5b5d747970656f626a656374_Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &vdl.TypeObjectTarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *unnamed_5b5d747970656f626a656374_Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *unnamed_5b5d747970656f626a656374_Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type unnamed_6d61705b737472696e675d5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target struct {
	Value    *map[string][]ConvertGroup
	currKey  string
	currElem []ConvertGroup
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *unnamed_6d61705b737472696e675d5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType7) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType7)
	}
	*t.Value = make(map[string][]ConvertGroup)
	return t, nil
}
func (t *unnamed_6d61705b737472696e675d5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	return &vdl.StringTarget{Value: &t.currKey}, error(nil)
}
func (t *unnamed_6d61705b737472696e675d5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []ConvertGroup(nil)
	return &unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target{Value: &t.currElem}, error(nil)
}
func (t *unnamed_6d61705b737472696e675d5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *unnamed_6d61705b737472696e675d5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target struct {
	Value *[]ConvertGroup
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType8) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType8)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]ConvertGroup, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &ConvertGroupTarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e436f6e7665727447726f7570207374727563747b4e616d6520737472696e673b5072696d6172795479706520747970656f626a6563743b56616c756573205b5d616e797d_Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Named Types
type NBool bool

func (NBool) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NBool"`
}) {
}

func (m *NBool) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBool(bool((*m)), __VDLType_v_io_v23_vom_testdata_types_NBool); err != nil {
		return err
	}
	return nil
}

func (m *NBool) MakeVDLTarget() vdl.Target {
	return &NBoolTarget{Value: m}
}

type NBoolTarget struct {
	Value *NBool
	vdl.TargetBase
}

func (t *NBoolTarget) FromBool(src bool, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_NBool) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_NBool)
	}
	*t.Value = NBool(src)

	return nil
}

type NString string

func (NString) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NString"`
}) {
}

func (m *NString) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromString(string((*m)), __VDLType_v_io_v23_vom_testdata_types_NString); err != nil {
		return err
	}
	return nil
}

func (m *NString) MakeVDLTarget() vdl.Target {
	return &NStringTarget{Value: m}
}

type NStringTarget struct {
	Value *NString
	vdl.TargetBase
}

func (t *NStringTarget) FromString(src string, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_NString) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_NString)
	}
	*t.Value = NString(src)

	return nil
}

type NByteSlice []byte

func (NByteSlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByteSlice"`
}) {
}

func (m *NByteSlice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBytes([]byte((*m)), __VDLType_v_io_v23_vom_testdata_types_NByteSlice); err != nil {
		return err
	}
	return nil
}

func (m *NByteSlice) MakeVDLTarget() vdl.Target {
	return &NByteSliceTarget{Value: m}
}

type NByteSliceTarget struct {
	Value *NByteSlice
	vdl.TargetBase
}

func (t *NByteSliceTarget) FromBytes(src []byte, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_NByteSlice) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_NByteSlice)
	}
	if len(src) == 0 {
		*t.Value = nil
	} else {
		*t.Value = make([]byte, len(src))
		copy(*t.Value, src)
	}

	return nil
}

type NByteArray [4]byte

func (NByteArray) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByteArray"`
}) {
}

func (m *NByteArray) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBytes([]byte((*m)[:]), __VDLType_v_io_v23_vom_testdata_types_NByteArray); err != nil {
		return err
	}
	return nil
}

func (m *NByteArray) MakeVDLTarget() vdl.Target {
	return &NByteArrayTarget{Value: m}
}

type NByteArrayTarget struct {
	Value *NByteArray
	vdl.TargetBase
}

func (t *NByteArrayTarget) FromBytes(src []byte, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_NByteArray) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_NByteArray)
	}
	copy((*t.Value)[:], src)

	return nil
}

type NByte byte

func (NByte) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByte"`
}) {
}

func (m *NByte) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), __VDLType_v_io_v23_vom_testdata_types_NByte); err != nil {
		return err
	}
	return nil
}

func (m *NByte) MakeVDLTarget() vdl.Target {
	return &NByteTarget{Value: m}
}

type NByteTarget struct {
	Value *NByte
	vdl.TargetBase
}

func (t *NByteTarget) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NByte(val)

	return nil
}
func (t *NByteTarget) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NByte(val)

	return nil
}
func (t *NByteTarget) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NByte(val)

	return nil
}
func (t *NByteTarget) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NByte(val)

	return nil
}

type NUint16 uint16

func (NUint16) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint16"`
}) {
}

func (m *NUint16) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), __VDLType_v_io_v23_vom_testdata_types_NUint16); err != nil {
		return err
	}
	return nil
}

func (m *NUint16) MakeVDLTarget() vdl.Target {
	return &NUint16Target{Value: m}
}

type NUint16Target struct {
	Value *NUint16
	vdl.TargetBase
}

func (t *NUint16Target) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NUint16(val)

	return nil
}
func (t *NUint16Target) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NUint16(val)

	return nil
}
func (t *NUint16Target) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NUint16(val)

	return nil
}
func (t *NUint16Target) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NUint16(val)

	return nil
}

type NUint32 uint32

func (NUint32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint32"`
}) {
}

func (m *NUint32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), __VDLType_v_io_v23_vom_testdata_types_NUint32); err != nil {
		return err
	}
	return nil
}

func (m *NUint32) MakeVDLTarget() vdl.Target {
	return &NUint32Target{Value: m}
}

type NUint32Target struct {
	Value *NUint32
	vdl.TargetBase
}

func (t *NUint32Target) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NUint32(val)

	return nil
}
func (t *NUint32Target) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NUint32(val)

	return nil
}
func (t *NUint32Target) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NUint32(val)

	return nil
}
func (t *NUint32Target) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NUint32(val)

	return nil
}

type NUint64 uint64

func (NUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint64"`
}) {
}

func (m *NUint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), __VDLType_v_io_v23_vom_testdata_types_NUint64); err != nil {
		return err
	}
	return nil
}

func (m *NUint64) MakeVDLTarget() vdl.Target {
	return &NUint64Target{Value: m}
}

type NUint64Target struct {
	Value *NUint64
	vdl.TargetBase
}

func (t *NUint64Target) FromUint(src uint64, tt *vdl.Type) error {
	*t.Value = NUint64(src)

	return nil
}
func (t *NUint64Target) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = NUint64(val)

	return nil
}
func (t *NUint64Target) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = NUint64(val)

	return nil
}
func (t *NUint64Target) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = NUint64(val)

	return nil
}

type NInt8 int8

func (NInt8) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt8"`
}) {
}

func (m *NInt8) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), __VDLType_v_io_v23_vom_testdata_types_NInt8); err != nil {
		return err
	}
	return nil
}

func (m *NInt8) MakeVDLTarget() vdl.Target {
	return &NInt8Target{Value: m}
}

type NInt8Target struct {
	Value *NInt8
	vdl.TargetBase
}

func (t *NInt8Target) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NInt8(val)

	return nil
}
func (t *NInt8Target) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NInt8(val)

	return nil
}
func (t *NInt8Target) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NInt8(val)

	return nil
}
func (t *NInt8Target) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NInt8(val)

	return nil
}

type NInt16 int16

func (NInt16) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt16"`
}) {
}

func (m *NInt16) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), __VDLType_v_io_v23_vom_testdata_types_NInt16); err != nil {
		return err
	}
	return nil
}

func (m *NInt16) MakeVDLTarget() vdl.Target {
	return &NInt16Target{Value: m}
}

type NInt16Target struct {
	Value *NInt16
	vdl.TargetBase
}

func (t *NInt16Target) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NInt16(val)

	return nil
}
func (t *NInt16Target) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NInt16(val)

	return nil
}
func (t *NInt16Target) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NInt16(val)

	return nil
}
func (t *NInt16Target) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NInt16(val)

	return nil
}

type NInt32 int32

func (NInt32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt32"`
}) {
}

func (m *NInt32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), __VDLType_v_io_v23_vom_testdata_types_NInt32); err != nil {
		return err
	}
	return nil
}

func (m *NInt32) MakeVDLTarget() vdl.Target {
	return &NInt32Target{Value: m}
}

type NInt32Target struct {
	Value *NInt32
	vdl.TargetBase
}

func (t *NInt32Target) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NInt32(val)

	return nil
}
func (t *NInt32Target) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NInt32(val)

	return nil
}
func (t *NInt32Target) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NInt32(val)

	return nil
}
func (t *NInt32Target) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NInt32(val)

	return nil
}

type NInt64 int64

func (NInt64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt64"`
}) {
}

func (m *NInt64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), __VDLType_v_io_v23_vom_testdata_types_NInt64); err != nil {
		return err
	}
	return nil
}

func (m *NInt64) MakeVDLTarget() vdl.Target {
	return &NInt64Target{Value: m}
}

type NInt64Target struct {
	Value *NInt64
	vdl.TargetBase
}

func (t *NInt64Target) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToInt64(src)
	if err != nil {
		return err
	}
	*t.Value = NInt64(val)

	return nil
}
func (t *NInt64Target) FromInt(src int64, tt *vdl.Type) error {
	*t.Value = NInt64(src)

	return nil
}
func (t *NInt64Target) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToInt64(src)
	if err != nil {
		return err
	}
	*t.Value = NInt64(val)

	return nil
}
func (t *NInt64Target) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToInt64(src)
	if err != nil {
		return err
	}
	*t.Value = NInt64(val)

	return nil
}

type NFloat32 float32

func (NFloat32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NFloat32"`
}) {
}

func (m *NFloat32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromFloat(float64((*m)), __VDLType_v_io_v23_vom_testdata_types_NFloat32); err != nil {
		return err
	}
	return nil
}

func (m *NFloat32) MakeVDLTarget() vdl.Target {
	return &NFloat32Target{Value: m}
}

type NFloat32Target struct {
	Value *NFloat32
	vdl.TargetBase
}

func (t *NFloat32Target) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat32(val)

	return nil
}
func (t *NFloat32Target) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat32(val)

	return nil
}
func (t *NFloat32Target) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat32(val)

	return nil
}
func (t *NFloat32Target) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat32(val)

	return nil
}

type NFloat64 float64

func (NFloat64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NFloat64"`
}) {
}

func (m *NFloat64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromFloat(float64((*m)), __VDLType_v_io_v23_vom_testdata_types_NFloat64); err != nil {
		return err
	}
	return nil
}

func (m *NFloat64) MakeVDLTarget() vdl.Target {
	return &NFloat64Target{Value: m}
}

type NFloat64Target struct {
	Value *NFloat64
	vdl.TargetBase
}

func (t *NFloat64Target) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToFloat64(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat64(val)

	return nil
}
func (t *NFloat64Target) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToFloat64(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat64(val)

	return nil
}
func (t *NFloat64Target) FromFloat(src float64, tt *vdl.Type) error {
	*t.Value = NFloat64(src)

	return nil
}
func (t *NFloat64Target) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToFloat64(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat64(val)

	return nil
}

type NComplex64 complex64

func (NComplex64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NComplex64"`
}) {
}

func (m *NComplex64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromComplex(complex128((*m)), __VDLType_v_io_v23_vom_testdata_types_NComplex64); err != nil {
		return err
	}
	return nil
}

func (m *NComplex64) MakeVDLTarget() vdl.Target {
	return &NComplex64Target{Value: m}
}

type NComplex64Target struct {
	Value *NComplex64
	vdl.TargetBase
}

func (t *NComplex64Target) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToComplex64(src)
	if err != nil {
		return err
	}
	*t.Value = NComplex64(val)

	return nil
}
func (t *NComplex64Target) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToComplex64(src)
	if err != nil {
		return err
	}
	*t.Value = NComplex64(val)

	return nil
}
func (t *NComplex64Target) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToComplex64(src)
	if err != nil {
		return err
	}
	*t.Value = NComplex64(val)

	return nil
}
func (t *NComplex64Target) FromComplex(src complex128, tt *vdl.Type) error {
	val, err := vdlconv.Complex128ToComplex64(src)
	if err != nil {
		return err
	}
	*t.Value = NComplex64(val)

	return nil
}

type NComplex128 complex128

func (NComplex128) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NComplex128"`
}) {
}

func (m *NComplex128) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromComplex(complex128((*m)), __VDLType_v_io_v23_vom_testdata_types_NComplex128); err != nil {
		return err
	}
	return nil
}

func (m *NComplex128) MakeVDLTarget() vdl.Target {
	return &NComplex128Target{Value: m}
}

type NComplex128Target struct {
	Value *NComplex128
	vdl.TargetBase
}

func (t *NComplex128Target) FromUint(src uint64, tt *vdl.Type) error {
	val, err := vdlconv.Uint64ToComplex128(src)
	if err != nil {
		return err
	}
	*t.Value = NComplex128(val)

	return nil
}
func (t *NComplex128Target) FromInt(src int64, tt *vdl.Type) error {
	val, err := vdlconv.Int64ToComplex128(src)
	if err != nil {
		return err
	}
	*t.Value = NComplex128(val)

	return nil
}
func (t *NComplex128Target) FromFloat(src float64, tt *vdl.Type) error {
	val, err := vdlconv.Float64ToComplex128(src)
	if err != nil {
		return err
	}
	*t.Value = NComplex128(val)

	return nil
}
func (t *NComplex128Target) FromComplex(src complex128, tt *vdl.Type) error {
	*t.Value = NComplex128(src)

	return nil
}

type NArray2Uint64 [2]uint64

func (NArray2Uint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NArray2Uint64"`
}) {
}

func (m *NArray2Uint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_NArray2Uint64, 2)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromUint(uint64(elem3), vdl.Uint64Type); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NArray2Uint64) MakeVDLTarget() vdl.Target {
	return &NArray2Uint64Target{Value: m}
}

type NArray2Uint64Target struct {
	Value *NArray2Uint64
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *NArray2Uint64Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_NArray2Uint64) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_NArray2Uint64)
	}
	return t, nil
}
func (t *NArray2Uint64Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &vdl.Uint64Target{Value: &(*t.Value)[index]}, error(nil)
}
func (t *NArray2Uint64Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *NArray2Uint64Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type NListUint64 []uint64

func (NListUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NListUint64"`
}) {
}

func (m *NListUint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_NListUint64, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromUint(uint64(elem3), vdl.Uint64Type); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NListUint64) MakeVDLTarget() vdl.Target {
	return &NListUint64Target{Value: m}
}

type NListUint64Target struct {
	Value *NListUint64
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *NListUint64Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_NListUint64) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_NListUint64)
	}
	if cap(*t.Value) < len {
		*t.Value = make(NListUint64, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *NListUint64Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &vdl.Uint64Target{Value: &(*t.Value)[index]}, error(nil)
}
func (t *NListUint64Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *NListUint64Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type NSetUint64 map[uint64]struct{}

func (NSetUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NSetUint64"`
}) {
}

func (m *NSetUint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(__VDLType_v_io_v23_vom_testdata_types_NSetUint64, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), vdl.Uint64Type); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NSetUint64) MakeVDLTarget() vdl.Target {
	return &NSetUint64Target{Value: m}
}

type NSetUint64Target struct {
	Value   *NSetUint64
	currKey uint64
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *NSetUint64Target) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_NSetUint64) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_NSetUint64)
	}
	*t.Value = make(NSetUint64)
	return t, nil
}
func (t *NSetUint64Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	return &vdl.Uint64Target{Value: &t.currKey}, error(nil)
}
func (t *NSetUint64Target) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *NSetUint64Target) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type NMapUint64String map[uint64]string

func (NMapUint64String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NMapUint64String"`
}) {
}

func (m *NMapUint64String) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_v23_vom_testdata_types_NMapUint64String, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), vdl.Uint64Type); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromString(string(value5), vdl.StringType); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NMapUint64String) MakeVDLTarget() vdl.Target {
	return &NMapUint64StringTarget{Value: m}
}

type NMapUint64StringTarget struct {
	Value    *NMapUint64String
	currKey  uint64
	currElem string
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *NMapUint64StringTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_NMapUint64String) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_NMapUint64String)
	}
	*t.Value = make(NMapUint64String)
	return t, nil
}
func (t *NMapUint64StringTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	return &vdl.Uint64Target{Value: &t.currKey}, error(nil)
}
func (t *NMapUint64StringTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	return &vdl.StringTarget{Value: &t.currElem}, error(nil)
}
func (t *NMapUint64StringTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *NMapUint64StringTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type NStruct struct {
	A bool
	B string
	C int64
}

func (NStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NStruct"`
}) {
}

func (m *NStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_NStruct == nil || __VDLType9 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.A), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.B), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("C")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromInt(int64(m.C), vdl.Int64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NStruct) MakeVDLTarget() vdl.Target {
	return &NStructTarget{Value: m}
}

type NStructTarget struct {
	Value *NStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_NStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_NStruct)
	}
	return t, nil
}
func (t *NStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		val, err := &vdl.BoolTarget{Value: &t.Value.A}, error(nil)
		return nil, val, err
	case "B":
		val, err := &vdl.StringTarget{Value: &t.Value.B}, error(nil)
		return nil, val, err
	case "C":
		val, err := &vdl.Int64Target{Value: &t.Value.C}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_NStruct)
	}
}
func (t *NStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *NStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type NEnum int

const (
	NEnumA NEnum = iota
	NEnumB
	NEnumC
)

// NEnumAll holds all labels for NEnum.
var NEnumAll = [...]NEnum{NEnumA, NEnumB, NEnumC}

// NEnumFromString creates a NEnum from a string label.
func NEnumFromString(label string) (x NEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *NEnum) Set(label string) error {
	switch label {
	case "A", "a":
		*x = NEnumA
		return nil
	case "B", "b":
		*x = NEnumB
		return nil
	case "C", "c":
		*x = NEnumC
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.NEnum", label)
}

// String returns the string label of x.
func (x NEnum) String() string {
	switch x {
	case NEnumA:
		return "A"
	case NEnumB:
		return "B"
	case NEnumC:
		return "C"
	}
	return ""
}

func (NEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NEnum"`
	Enum struct{ A, B, C string }
}) {
}

func (m *NEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), __VDLType_v_io_v23_vom_testdata_types_NEnum); err != nil {
		return err
	}
	return nil
}

func (m *NEnum) MakeVDLTarget() vdl.Target {
	return &NEnumTarget{Value: m}
}

type NEnumTarget struct {
	Value *NEnum
	vdl.TargetBase
}

func (t *NEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_NEnum) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_NEnum)
	}
	switch src {
	case "A":
		*t.Value = 0
	case "B":
		*t.Value = 1
	case "C":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum %v", src, __VDLType_v_io_v23_vom_testdata_types_NEnum)
	}

	return nil
}

type (
	// NUnion represents any single field of the NUnion union type.
	NUnion interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the NUnion union type.
		__VDLReflect(__NUnionReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// NUnionA represents field A of the NUnion union type.
	NUnionA struct{ Value bool }
	// NUnionB represents field B of the NUnion union type.
	NUnionB struct{ Value string }
	// NUnionC represents field C of the NUnion union type.
	NUnionC struct{ Value int64 }
	// __NUnionReflect describes the NUnion union type.
	__NUnionReflect struct {
		Name  string `vdl:"v.io/v23/vom/testdata/types.NUnion"`
		Type  NUnion
		Union struct {
			A NUnionA
			B NUnionB
			C NUnionC
		}
	}
)

func (x NUnionA) Index() int                   { return 0 }
func (x NUnionA) Interface() interface{}       { return x.Value }
func (x NUnionA) Name() string                 { return "A" }
func (x NUnionA) __VDLReflect(__NUnionReflect) {}

func (m NUnionA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(__VDLType_v_io_v23_vom_testdata_types_NUnion)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromBool(bool(m.Value), vdl.BoolType); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NUnionA) MakeVDLTarget() vdl.Target {
	return nil
}

func (x NUnionB) Index() int                   { return 1 }
func (x NUnionB) Interface() interface{}       { return x.Value }
func (x NUnionB) Name() string                 { return "B" }
func (x NUnionB) __VDLReflect(__NUnionReflect) {}

func (m NUnionB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(__VDLType_v_io_v23_vom_testdata_types_NUnion)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), vdl.StringType); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NUnionB) MakeVDLTarget() vdl.Target {
	return nil
}

func (x NUnionC) Index() int                   { return 2 }
func (x NUnionC) Interface() interface{}       { return x.Value }
func (x NUnionC) Name() string                 { return "C" }
func (x NUnionC) __VDLReflect(__NUnionReflect) {}

func (m NUnionC) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(__VDLType_v_io_v23_vom_testdata_types_NUnion)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("C")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromInt(int64(m.Value), vdl.Int64Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NUnionC) MakeVDLTarget() vdl.Target {
	return nil
}

// Nested Custom Types
type MBool NBool

func (MBool) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MBool"`
}) {
}

func (m *MBool) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBool(bool((*m)), __VDLType_v_io_v23_vom_testdata_types_MBool); err != nil {
		return err
	}
	return nil
}

func (m *MBool) MakeVDLTarget() vdl.Target {
	return &MBoolTarget{Value: m}
}

type MBoolTarget struct {
	Value *MBool
	vdl.TargetBase
}

func (t *MBoolTarget) FromBool(src bool, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MBool) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MBool)
	}
	*t.Value = MBool(src)

	return nil
}

type MStruct struct {
	A bool
	B NBool
	C MBool
	D *NStruct
	E *vdl.Type
	F *vdl.Value
}

func (MStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MStruct"`
}) {
}

func (m *MStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_MStruct == nil || __VDLType10 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.A), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.B.FillVDLTarget(fieldTarget5, __VDLType_v_io_v23_vom_testdata_types_NBool); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("C")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.C.FillVDLTarget(fieldTarget7, __VDLType_v_io_v23_vom_testdata_types_MBool); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("D")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.D == nil {
			if err := fieldTarget9.FromNil(__VDLType9); err != nil {
				return err
			}
		} else {
			if err := m.D.FillVDLTarget(fieldTarget9, __VDLType_v_io_v23_vom_testdata_types_NStruct); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("E")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		typeObjectVal12 := m.E
		if typeObjectVal12 == nil {
			typeObjectVal12 = vdl.AnyType
		}
		if err := fieldTarget11.FromTypeObject(typeObjectVal12); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("F")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.F == nil {
			if err := fieldTarget14.FromNil(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget14, m.F); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MStruct) MakeVDLTarget() vdl.Target {
	return &MStructTarget{Value: m}
}

type MStructTarget struct {
	Value *MStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *MStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MStruct)
	}
	return t, nil
}
func (t *MStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		val, err := &vdl.BoolTarget{Value: &t.Value.A}, error(nil)
		return nil, val, err
	case "B":
		val, err := &NBoolTarget{Value: &t.Value.B}, error(nil)
		return nil, val, err
	case "C":
		val, err := &MBoolTarget{Value: &t.Value.C}, error(nil)
		return nil, val, err
	case "D":
		val, err := &unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4e537472756374207374727563747b4120626f6f6c3b4220737472696e673b4320696e7436347d_Target{Value: &t.Value.D}, error(nil)
		return nil, val, err
	case "E":
		val, err := &vdl.TypeObjectTarget{Value: &t.Value.E}, error(nil)
		return nil, val, err
	case "F":
		val, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.F))
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_MStruct)
	}
}
func (t *MStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *MStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4e537472756374207374727563747b4120626f6f6c3b4220737472696e673b4320696e7436347d_Target struct {
	Value **NStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4e537472756374207374727563747b4120626f6f6c3b4220737472696e673b4320696e7436347d_Target) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if *t.Value == nil {
		*t.Value = &NStruct{}
	}
	target, err := &NStructTarget{Value: *t.Value}, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4e537472756374207374727563747b4120626f6f6c3b4220737472696e673b4320696e7436347d_Target) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4e537472756374207374727563747b4120626f6f6c3b4220737472696e673b4320696e7436347d_Target) FromNil(tt *vdl.Type) error {
	*t.Value = nil

	return nil
}

type MList []NListUint64

func (MList) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MList"`
}) {
}

func (m *MList) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_MList, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, __VDLType_v_io_v23_vom_testdata_types_NListUint64); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MList) MakeVDLTarget() vdl.Target {
	return &MListTarget{Value: m}
}

type MListTarget struct {
	Value *MList
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *MListTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MList) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MList)
	}
	if cap(*t.Value) < len {
		*t.Value = make(MList, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *MListTarget) StartElem(index int) (elem vdl.Target, _ error) {
	return &NListUint64Target{Value: &(*t.Value)[index]}, error(nil)
}
func (t *MListTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *MListTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type MMap map[NFloat32]NListUint64

func (MMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MMap"`
}) {
}

func (m *MMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_v23_vom_testdata_types_MMap, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, __VDLType_v_io_v23_vom_testdata_types_NFloat32); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, __VDLType_v_io_v23_vom_testdata_types_NListUint64); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MMap) MakeVDLTarget() vdl.Target {
	return &MMapTarget{Value: m}
}

type MMapTarget struct {
	Value    *MMap
	currKey  NFloat32
	currElem NListUint64
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MMap) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MMap)
	}
	*t.Value = make(MMap)
	return t, nil
}
func (t *MMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = NFloat32(0)
	return &NFloat32Target{Value: &t.currKey}, error(nil)
}
func (t *MMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = NListUint64(nil)
	return &NListUint64Target{Value: &t.currElem}, error(nil)
}
func (t *MMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MByteSlice []byte

func (MByteSlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MByteSlice"`
}) {
}

func (m *MByteSlice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBytes([]byte((*m)), __VDLType_v_io_v23_vom_testdata_types_MByteSlice); err != nil {
		return err
	}
	return nil
}

func (m *MByteSlice) MakeVDLTarget() vdl.Target {
	return &MByteSliceTarget{Value: m}
}

type MByteSliceTarget struct {
	Value *MByteSlice
	vdl.TargetBase
}

func (t *MByteSliceTarget) FromBytes(src []byte, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MByteSlice) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MByteSlice)
	}
	if len(src) == 0 {
		*t.Value = nil
	} else {
		*t.Value = make([]byte, len(src))
		copy(*t.Value, src)
	}

	return nil
}

type MInt8Slice []int8

func (MInt8Slice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MInt8Slice"`
}) {
}

func (m *MInt8Slice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_MInt8Slice, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromInt(int64(elem3), vdl.Int8Type); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MInt8Slice) MakeVDLTarget() vdl.Target {
	return &MInt8SliceTarget{Value: m}
}

type MInt8SliceTarget struct {
	Value *MInt8Slice
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *MInt8SliceTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MInt8Slice) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MInt8Slice)
	}
	if cap(*t.Value) < len {
		*t.Value = make(MInt8Slice, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *MInt8SliceTarget) StartElem(index int) (elem vdl.Target, _ error) {
	return &vdl.Int8Target{Value: &(*t.Value)[index]}, error(nil)
}
func (t *MInt8SliceTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *MInt8SliceTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Recursive Type Definitions
type RecA []RecA

func (RecA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecA"`
}) {
}

func (m *RecA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_RecA, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, __VDLType_v_io_v23_vom_testdata_types_RecA); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecA) MakeVDLTarget() vdl.Target {
	return &RecATarget{Value: m}
}

type RecATarget struct {
	Value *RecA
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RecATarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_RecA) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_RecA)
	}
	if cap(*t.Value) < len {
		*t.Value = make(RecA, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *RecATarget) StartElem(index int) (elem vdl.Target, _ error) {
	return &RecATarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *RecATarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RecATarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type RecX []RecY

func (RecX) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecX"`
}) {
}

func (m *RecX) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_RecX, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, __VDLType_v_io_v23_vom_testdata_types_RecY); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecX) MakeVDLTarget() vdl.Target {
	return &RecXTarget{Value: m}
}

type RecXTarget struct {
	Value *RecX
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RecXTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_RecX) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_RecX)
	}
	if cap(*t.Value) < len {
		*t.Value = make(RecX, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *RecXTarget) StartElem(index int) (elem vdl.Target, _ error) {
	return &RecYTarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *RecXTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RecXTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type RecYTarget struct {
	Value *RecY
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RecYTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_RecY) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_RecY)
	}
	if cap(*t.Value) < len {
		*t.Value = make(RecY, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *RecYTarget) StartElem(index int) (elem vdl.Target, _ error) {
	return &RecXTarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *RecYTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RecYTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type RecY []RecX

func (RecY) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecY"`
}) {
}

func (m *RecY) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_RecY, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, __VDLType_v_io_v23_vom_testdata_types_RecX); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecY) MakeVDLTarget() vdl.Target {
	return &RecYTarget{Value: m}
}

type Rec1 []Rec2

func (Rec1) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1"`
}) {
}

func (m *Rec1) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_Rec1, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, __VDLType_v_io_v23_vom_testdata_types_Rec2); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1) MakeVDLTarget() vdl.Target {
	return &Rec1Target{Value: m}
}

type Rec1Target struct {
	Value *Rec1
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec1Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_Rec1) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_Rec1)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec1, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec1Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &Rec2Target{Value: &(*t.Value)[index]}, error(nil)
}
func (t *Rec1Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec1Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Rec2Target struct {
	Value *Rec2
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec2Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_Rec2) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_Rec2)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec2, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec2Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &Rec3Target{Value: &(*t.Value)[index]}, error(nil)
}
func (t *Rec2Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec2Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Rec3Target struct {
	Value *Rec3
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec3Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_Rec3) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_Rec3)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec3, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec3Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &Rec4Target{Value: &(*t.Value)[index]}, error(nil)
}
func (t *Rec3Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec3Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Rec4Target struct {
	Value *Rec4
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec4Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_Rec4) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_Rec4)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec4, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec4Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &Rec1Target{Value: &(*t.Value)[index]}, error(nil)
}
func (t *Rec4Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec4Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Rec2 []Rec3

func (Rec2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec2"`
}) {
}

func (m *Rec2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_Rec2, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, __VDLType_v_io_v23_vom_testdata_types_Rec3); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec2) MakeVDLTarget() vdl.Target {
	return &Rec2Target{Value: m}
}

type Rec3 []Rec4

func (Rec3) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec3"`
}) {
}

func (m *Rec3) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_Rec3, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, __VDLType_v_io_v23_vom_testdata_types_Rec4); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec3) MakeVDLTarget() vdl.Target {
	return &Rec3Target{Value: m}
}

type Rec4 []Rec1

func (Rec4) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec4"`
}) {
}

func (m *Rec4) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_Rec4, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, __VDLType_v_io_v23_vom_testdata_types_Rec1); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec4) MakeVDLTarget() vdl.Target {
	return &Rec4Target{Value: m}
}

type RecStruct struct {
	A *RecStruct
}

func (RecStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecStruct"`
}) {
}

func (m *RecStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_RecStruct == nil || __VDLType11 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.A == nil {
			if err := fieldTarget3.FromNil(__VDLType11); err != nil {
				return err
			}
		} else {
			if err := m.A.FillVDLTarget(fieldTarget3, __VDLType_v_io_v23_vom_testdata_types_RecStruct); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecStruct) MakeVDLTarget() vdl.Target {
	return &RecStructTarget{Value: m}
}

type RecStructTarget struct {
	Value *RecStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *RecStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_RecStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_RecStruct)
	}
	return t, nil
}
func (t *RecStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		val, err := &unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563537472756374207374727563747b41203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265635374727563747d_Target{Value: &t.Value.A}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_RecStruct)
	}
}
func (t *RecStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *RecStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563537472756374207374727563747b41203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265635374727563747d_Target struct {
	Value **RecStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563537472756374207374727563747b41203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265635374727563747d_Target) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if *t.Value == nil {
		*t.Value = &RecStruct{}
	}
	target, err := &RecStructTarget{Value: *t.Value}, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563537472756374207374727563747b41203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265635374727563747d_Target) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563537472756374207374727563747b41203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265635374727563747d_Target) FromNil(tt *vdl.Type) error {
	*t.Value = nil

	return nil
}

type Rec1234 struct {
	R1 Rec1
	R2 Rec2
	R3 Rec3
	R4 Rec4
}

func (Rec1234) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234"`
}) {
}

func (m *Rec1234) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_Rec1234 == nil || __VDLType12 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("R1")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.R1.FillVDLTarget(fieldTarget3, __VDLType_v_io_v23_vom_testdata_types_Rec1); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("R2")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.R2.FillVDLTarget(fieldTarget5, __VDLType_v_io_v23_vom_testdata_types_Rec2); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("R3")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.R3.FillVDLTarget(fieldTarget7, __VDLType_v_io_v23_vom_testdata_types_Rec3); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("R4")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.R4.FillVDLTarget(fieldTarget9, __VDLType_v_io_v23_vom_testdata_types_Rec4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234) MakeVDLTarget() vdl.Target {
	return &Rec1234Target{Value: m}
}

type Rec1234Target struct {
	Value *Rec1234
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234Target) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_Rec1234) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_Rec1234)
	}
	return t, nil
}
func (t *Rec1234Target) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "R1":
		val, err := &Rec1Target{Value: &t.Value.R1}, error(nil)
		return nil, val, err
	case "R2":
		val, err := &Rec2Target{Value: &t.Value.R2}, error(nil)
		return nil, val, err
	case "R3":
		val, err := &Rec3Target{Value: &t.Value.R3}, error(nil)
		return nil, val, err
	case "R4":
		val, err := &Rec4Target{Value: &t.Value.R4}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_Rec1234)
	}
}
func (t *Rec1234Target) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234Target) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type Rec1234A struct {
	A       []Rec1234A
	Rec1234 []Rec1234
}

func (Rec1234A) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234A"`
}) {
}

func (m *Rec1234A) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_Rec1234A == nil || __VDLType13 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget4, err := fieldTarget3.StartList(__VDLType14, len(m.A))
		if err != nil {
			return err
		}
		for i, elem6 := range m.A {
			elemTarget5, err := listTarget4.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem6.FillVDLTarget(elemTarget5, __VDLType_v_io_v23_vom_testdata_types_Rec1234A); err != nil {
				return err
			}
			if err := listTarget4.FinishElem(elemTarget5); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishList(listTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("Rec1234")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget9, err := fieldTarget8.StartList(__VDLType15, len(m.Rec1234))
		if err != nil {
			return err
		}
		for i, elem11 := range m.Rec1234 {
			elemTarget10, err := listTarget9.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem11.FillVDLTarget(elemTarget10, __VDLType_v_io_v23_vom_testdata_types_Rec1234); err != nil {
				return err
			}
			if err := listTarget9.FinishElem(elemTarget10); err != nil {
				return err
			}
		}
		if err := fieldTarget8.FinishList(listTarget9); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234A) MakeVDLTarget() vdl.Target {
	return &Rec1234ATarget{Value: m}
}

type Rec1234ATarget struct {
	Value *Rec1234A
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234ATarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_Rec1234A) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_Rec1234A)
	}
	return t, nil
}
func (t *Rec1234ATarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		val, err := &unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333441207374727563747b41205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334413b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target{Value: &t.Value.A}, error(nil)
		return nil, val, err
	case "Rec1234":
		val, err := &unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d_Target{Value: &t.Value.Rec1234}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_Rec1234A)
	}
}
func (t *Rec1234ATarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234ATarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333441207374727563747b41205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334413b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target struct {
	Value *[]Rec1234A
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333441207374727563747b41205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334413b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType14) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType14)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Rec1234A, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333441207374727563747b41205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334413b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &Rec1234ATarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333441207374727563747b41205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334413b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333441207374727563747b41205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334413b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d_Target struct {
	Value *[]Rec1234
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d_Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType15) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType15)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Rec1234, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d_Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &Rec1234Target{Value: &(*t.Value)[index]}, error(nil)
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d_Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d_Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Rec1234B struct {
	B       []Rec1234B
	Rec1234 []Rec1234
}

func (Rec1234B) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234B"`
}) {
}

func (m *Rec1234B) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_Rec1234B == nil || __VDLType16 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget4, err := fieldTarget3.StartList(__VDLType17, len(m.B))
		if err != nil {
			return err
		}
		for i, elem6 := range m.B {
			elemTarget5, err := listTarget4.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem6.FillVDLTarget(elemTarget5, __VDLType_v_io_v23_vom_testdata_types_Rec1234B); err != nil {
				return err
			}
			if err := listTarget4.FinishElem(elemTarget5); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishList(listTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("Rec1234")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget9, err := fieldTarget8.StartList(__VDLType15, len(m.Rec1234))
		if err != nil {
			return err
		}
		for i, elem11 := range m.Rec1234 {
			elemTarget10, err := listTarget9.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem11.FillVDLTarget(elemTarget10, __VDLType_v_io_v23_vom_testdata_types_Rec1234); err != nil {
				return err
			}
			if err := listTarget9.FinishElem(elemTarget10); err != nil {
				return err
			}
		}
		if err := fieldTarget8.FinishList(listTarget9); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234B) MakeVDLTarget() vdl.Target {
	return &Rec1234BTarget{Value: m}
}

type Rec1234BTarget struct {
	Value *Rec1234B
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234BTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_Rec1234B) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_Rec1234B)
	}
	return t, nil
}
func (t *Rec1234BTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "B":
		val, err := &unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333442207374727563747b42205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334423b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target{Value: &t.Value.B}, error(nil)
		return nil, val, err
	case "Rec1234":
		val, err := &unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d_Target{Value: &t.Value.Rec1234}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_Rec1234B)
	}
}
func (t *Rec1234BTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234BTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333442207374727563747b42205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334423b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target struct {
	Value *[]Rec1234B
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333442207374727563747b42205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334423b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType17) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType17)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Rec1234B, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333442207374727563747b42205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334423b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target) StartElem(index int) (elem vdl.Target, _ error) {
	return &Rec1234BTarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333442207374727563747b42205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334423b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *unnamed_5b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e5265633132333442207374727563747b42205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334423b52656331323334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331323334207374727563747b523120762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656331205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656332205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656333205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e52656334205b5d762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563313b523220762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563323b523320762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563333b523420762e696f2f7632332f766f6d2f74657374646174612f74797065732e526563347d7d_Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Rec1234All struct {
	A Rec1234A
	B Rec1234B
}

func (Rec1234All) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234All"`
}) {
}

func (m *Rec1234All) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_Rec1234All == nil || __VDLType18 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.A.FillVDLTarget(fieldTarget3, __VDLType_v_io_v23_vom_testdata_types_Rec1234A); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.B.FillVDLTarget(fieldTarget5, __VDLType_v_io_v23_vom_testdata_types_Rec1234B); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234All) MakeVDLTarget() vdl.Target {
	return &Rec1234AllTarget{Value: m}
}

type Rec1234AllTarget struct {
	Value *Rec1234All
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234AllTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_Rec1234All) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_Rec1234All)
	}
	return t, nil
}
func (t *Rec1234AllTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		val, err := &Rec1234ATarget{Value: &t.Value.A}, error(nil)
		return nil, val, err
	case "B":
		val, err := &Rec1234BTarget{Value: &t.Value.B}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_Rec1234All)
	}
}
func (t *Rec1234AllTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234AllTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Additional types for compatibility and conversion checks
type ListString []string

func (ListString) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ListString"`
}) {
}

func (m *ListString) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_ListString, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromString(string(elem3), vdl.StringType); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ListString) MakeVDLTarget() vdl.Target {
	return &ListStringTarget{Value: m}
}

type ListStringTarget struct {
	Value *ListString
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *ListStringTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_ListString) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_ListString)
	}
	if cap(*t.Value) < len {
		*t.Value = make(ListString, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *ListStringTarget) StartElem(index int) (elem vdl.Target, _ error) {
	return &vdl.StringTarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *ListStringTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *ListStringTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Array3String [3]string

func (Array3String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Array3String"`
}) {
}

func (m *Array3String) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_Array3String, 3)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromString(string(elem3), vdl.StringType); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Array3String) MakeVDLTarget() vdl.Target {
	return &Array3StringTarget{Value: m}
}

type Array3StringTarget struct {
	Value *Array3String
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Array3StringTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_Array3String) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_Array3String)
	}
	return t, nil
}
func (t *Array3StringTarget) StartElem(index int) (elem vdl.Target, _ error) {
	return &vdl.StringTarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *Array3StringTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Array3StringTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Array4String [4]string

func (Array4String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Array4String"`
}) {
}

func (m *Array4String) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_Array4String, 4)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromString(string(elem3), vdl.StringType); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Array4String) MakeVDLTarget() vdl.Target {
	return &Array4StringTarget{Value: m}
}

type Array4StringTarget struct {
	Value *Array4String
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Array4StringTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_Array4String) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_Array4String)
	}
	return t, nil
}
func (t *Array4StringTarget) StartElem(index int) (elem vdl.Target, _ error) {
	return &vdl.StringTarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *Array4StringTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Array4StringTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type AbcStruct struct {
	A bool
	B string
	C int64
}

func (AbcStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AbcStruct"`
}) {
}

func (m *AbcStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_AbcStruct == nil || __VDLType19 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.A), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.B), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("C")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromInt(int64(m.C), vdl.Int64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AbcStruct) MakeVDLTarget() vdl.Target {
	return &AbcStructTarget{Value: m}
}

type AbcStructTarget struct {
	Value *AbcStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AbcStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_AbcStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_AbcStruct)
	}
	return t, nil
}
func (t *AbcStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		val, err := &vdl.BoolTarget{Value: &t.Value.A}, error(nil)
		return nil, val, err
	case "B":
		val, err := &vdl.StringTarget{Value: &t.Value.B}, error(nil)
		return nil, val, err
	case "C":
		val, err := &vdl.Int64Target{Value: &t.Value.C}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_AbcStruct)
	}
}
func (t *AbcStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AbcStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type AdeStruct struct {
	A bool
	D *vdl.Value
	E *vdl.Type
}

func (AdeStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AdeStruct"`
}) {
}

func (m *AdeStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_AdeStruct == nil || __VDLType20 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.A), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("D")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.D == nil {
			if err := fieldTarget5.FromNil(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget5, m.D); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("E")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		typeObjectVal8 := m.E
		if typeObjectVal8 == nil {
			typeObjectVal8 = vdl.AnyType
		}
		if err := fieldTarget7.FromTypeObject(typeObjectVal8); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AdeStruct) MakeVDLTarget() vdl.Target {
	return &AdeStructTarget{Value: m}
}

type AdeStructTarget struct {
	Value *AdeStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AdeStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_AdeStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_AdeStruct)
	}
	return t, nil
}
func (t *AdeStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		val, err := &vdl.BoolTarget{Value: &t.Value.A}, error(nil)
		return nil, val, err
	case "D":
		val, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.D))
		return nil, val, err
	case "E":
		val, err := &vdl.TypeObjectTarget{Value: &t.Value.E}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_AdeStruct)
	}
}
func (t *AdeStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AdeStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type XyzStruct struct {
	X bool
	Y MBool
	Z string
}

func (XyzStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.XyzStruct"`
}) {
}

func (m *XyzStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_XyzStruct == nil || __VDLType21 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("X")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.X), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Y")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Y.FillVDLTarget(fieldTarget5, __VDLType_v_io_v23_vom_testdata_types_MBool); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Z")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromString(string(m.Z), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *XyzStruct) MakeVDLTarget() vdl.Target {
	return &XyzStructTarget{Value: m}
}

type XyzStructTarget struct {
	Value *XyzStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *XyzStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_XyzStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_XyzStruct)
	}
	return t, nil
}
func (t *XyzStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "X":
		val, err := &vdl.BoolTarget{Value: &t.Value.X}, error(nil)
		return nil, val, err
	case "Y":
		val, err := &MBoolTarget{Value: &t.Value.Y}, error(nil)
		return nil, val, err
	case "Z":
		val, err := &vdl.StringTarget{Value: &t.Value.Z}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_XyzStruct)
	}
}
func (t *XyzStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *XyzStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type YzStruct struct {
	Y NBool
	Z NString
}

func (YzStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.YzStruct"`
}) {
}

func (m *YzStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_YzStruct == nil || __VDLType22 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Y")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Y.FillVDLTarget(fieldTarget3, __VDLType_v_io_v23_vom_testdata_types_NBool); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Z")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Z.FillVDLTarget(fieldTarget5, __VDLType_v_io_v23_vom_testdata_types_NString); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *YzStruct) MakeVDLTarget() vdl.Target {
	return &YzStructTarget{Value: m}
}

type YzStructTarget struct {
	Value *YzStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *YzStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_YzStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_YzStruct)
	}
	return t, nil
}
func (t *YzStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Y":
		val, err := &NBoolTarget{Value: &t.Value.Y}, error(nil)
		return nil, val, err
	case "Z":
		val, err := &NStringTarget{Value: &t.Value.Z}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_YzStruct)
	}
}
func (t *YzStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *YzStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type ZStruct struct {
	Z string
}

func (ZStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ZStruct"`
}) {
}

func (m *ZStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_ZStruct == nil || __VDLType23 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Z")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Z), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ZStruct) MakeVDLTarget() vdl.Target {
	return &ZStructTarget{Value: m}
}

type ZStructTarget struct {
	Value *ZStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ZStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_ZStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_ZStruct)
	}
	return t, nil
}
func (t *ZStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Z":
		val, err := &vdl.StringTarget{Value: &t.Value.Z}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_ZStruct)
	}
}
func (t *ZStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ZStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type MapOnlyStruct struct {
	Key1 int64
	Key2 uint32
	Key3 complex128
}

func (MapOnlyStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyStruct"`
}) {
}

func (m *MapOnlyStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_MapOnlyStruct == nil || __VDLType24 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key1")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromInt(int64(m.Key1), vdl.Int64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Key2")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromUint(uint64(m.Key2), vdl.Uint32Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Key3")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromComplex(complex128(m.Key3), vdl.Complex128Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyStruct) MakeVDLTarget() vdl.Target {
	return &MapOnlyStructTarget{Value: m}
}

type MapOnlyStructTarget struct {
	Value *MapOnlyStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *MapOnlyStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlyStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlyStruct)
	}
	return t, nil
}
func (t *MapOnlyStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key1":
		val, err := &vdl.Int64Target{Value: &t.Value.Key1}, error(nil)
		return nil, val, err
	case "Key2":
		val, err := &vdl.Uint32Target{Value: &t.Value.Key2}, error(nil)
		return nil, val, err
	case "Key3":
		val, err := &vdl.Complex128Target{Value: &t.Value.Key3}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_MapOnlyStruct)
	}
}
func (t *MapOnlyStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *MapOnlyStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type StructOnlyMap map[string]uint64

func (StructOnlyMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructOnlyMap"`
}) {
}

func (m *StructOnlyMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_v23_vom_testdata_types_StructOnlyMap, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), vdl.StringType); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromUint(uint64(value5), vdl.Uint64Type); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructOnlyMap) MakeVDLTarget() vdl.Target {
	return &StructOnlyMapTarget{Value: m}
}

type StructOnlyMapTarget struct {
	Value    *StructOnlyMap
	currKey  string
	currElem uint64
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *StructOnlyMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_StructOnlyMap) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_StructOnlyMap)
	}
	*t.Value = make(StructOnlyMap)
	return t, nil
}
func (t *StructOnlyMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	return &vdl.StringTarget{Value: &t.currKey}, error(nil)
}
func (t *StructOnlyMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = uint64(0)
	return &vdl.Uint64Target{Value: &t.currElem}, error(nil)
}
func (t *StructOnlyMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *StructOnlyMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapSetStruct struct {
	Feat bool
	Tire bool
	Eel  bool
}

func (MapSetStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapSetStruct"`
}) {
}

func (m *MapSetStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_MapSetStruct == nil || __VDLType25 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Feat")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.Feat), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Tire")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromBool(bool(m.Tire), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Eel")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromBool(bool(m.Eel), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapSetStruct) MakeVDLTarget() vdl.Target {
	return &MapSetStructTarget{Value: m}
}

type MapSetStructTarget struct {
	Value *MapSetStruct
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *MapSetStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MapSetStruct) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MapSetStruct)
	}
	return t, nil
}
func (t *MapSetStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Feat":
		val, err := &vdl.BoolTarget{Value: &t.Value.Feat}, error(nil)
		return nil, val, err
	case "Tire":
		val, err := &vdl.BoolTarget{Value: &t.Value.Tire}, error(nil)
		return nil, val, err
	case "Eel":
		val, err := &vdl.BoolTarget{Value: &t.Value.Eel}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_MapSetStruct)
	}
}
func (t *MapSetStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *MapSetStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type SetStructMap map[string]bool

func (SetStructMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetStructMap"`
}) {
}

func (m *SetStructMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_v23_vom_testdata_types_SetStructMap, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), vdl.StringType); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromBool(bool(value5), vdl.BoolType); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetStructMap) MakeVDLTarget() vdl.Target {
	return &SetStructMapTarget{Value: m}
}

type SetStructMapTarget struct {
	Value    *SetStructMap
	currKey  string
	currElem bool
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SetStructMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_SetStructMap) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_SetStructMap)
	}
	*t.Value = make(SetStructMap)
	return t, nil
}
func (t *SetStructMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	return &vdl.StringTarget{Value: &t.currKey}, error(nil)
}
func (t *SetStructMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = false
	return &vdl.BoolTarget{Value: &t.currElem}, error(nil)
}
func (t *SetStructMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SetStructMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapStructSet map[string]struct{}

func (MapStructSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapStructSet"`
}) {
}

func (m *MapStructSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(__VDLType_v_io_v23_vom_testdata_types_MapStructSet, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), vdl.StringType); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapStructSet) MakeVDLTarget() vdl.Target {
	return &MapStructSetTarget{Value: m}
}

type MapStructSetTarget struct {
	Value   *MapStructSet
	currKey string
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *MapStructSetTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MapStructSet) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MapStructSet)
	}
	*t.Value = make(MapStructSet)
	return t, nil
}
func (t *MapStructSetTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	return &vdl.StringTarget{Value: &t.currKey}, error(nil)
}
func (t *MapStructSetTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *MapStructSetTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SetOnlyMap map[float64]bool

func (SetOnlyMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyMap"`
}) {
}

func (m *SetOnlyMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_v23_vom_testdata_types_SetOnlyMap, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromFloat(float64(key3), vdl.Float64Type); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromBool(bool(value5), vdl.BoolType); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyMap) MakeVDLTarget() vdl.Target {
	return &SetOnlyMapTarget{Value: m}
}

type SetOnlyMapTarget struct {
	Value    *SetOnlyMap
	currKey  float64
	currElem bool
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SetOnlyMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_SetOnlyMap) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_SetOnlyMap)
	}
	*t.Value = make(SetOnlyMap)
	return t, nil
}
func (t *SetOnlyMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	return &vdl.Float64Target{Value: &t.currKey}, error(nil)
}
func (t *SetOnlyMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = false
	return &vdl.BoolTarget{Value: &t.currElem}, error(nil)
}
func (t *SetOnlyMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SetOnlyMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SometimesSetMap map[float64]*vdl.Value

func (SometimesSetMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SometimesSetMap"`
}) {
}

func (m *SometimesSetMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_v23_vom_testdata_types_SometimesSetMap, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromFloat(float64(key3), vdl.Float64Type); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if value5 == nil {
			if err := valueTarget4.FromNil(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(valueTarget4, value5); err != nil {
				return err
			}
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SometimesSetMap) MakeVDLTarget() vdl.Target {
	return &SometimesSetMapTarget{Value: m}
}

type SometimesSetMapTarget struct {
	Value    *SometimesSetMap
	currKey  float64
	currElem *vdl.Value
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SometimesSetMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_SometimesSetMap) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_SometimesSetMap)
	}
	*t.Value = make(SometimesSetMap)
	return t, nil
}
func (t *SometimesSetMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	return &vdl.Float64Target{Value: &t.currKey}, error(nil)
}
func (t *SometimesSetMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = (*vdl.Value)(nil)
	return vdl.ReflectTarget(reflect.ValueOf(&t.currElem))
}
func (t *SometimesSetMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SometimesSetMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapOnlySet map[float64]struct{}

func (MapOnlySet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlySet"`
}) {
}

func (m *MapOnlySet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(__VDLType_v_io_v23_vom_testdata_types_MapOnlySet, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromFloat(float64(key3), vdl.Float64Type); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlySet) MakeVDLTarget() vdl.Target {
	return &MapOnlySetTarget{Value: m}
}

type MapOnlySetTarget struct {
	Value   *MapOnlySet
	currKey float64
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *MapOnlySetTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlySet) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlySet)
	}
	*t.Value = make(MapOnlySet)
	return t, nil
}
func (t *MapOnlySetTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	return &vdl.Float64Target{Value: &t.currKey}, error(nil)
}
func (t *MapOnlySetTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *MapOnlySetTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SetOnlyA map[bool]struct{}

func (SetOnlyA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyA"`
}) {
}

func (m *SetOnlyA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(__VDLType_v_io_v23_vom_testdata_types_SetOnlyA, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromBool(bool(key3), vdl.BoolType); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyA) MakeVDLTarget() vdl.Target {
	return &SetOnlyATarget{Value: m}
}

type SetOnlyATarget struct {
	Value   *SetOnlyA
	currKey bool
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyATarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_SetOnlyA) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_SetOnlyA)
	}
	*t.Value = make(SetOnlyA)
	return t, nil
}
func (t *SetOnlyATarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = false
	return &vdl.BoolTarget{Value: &t.currKey}, error(nil)
}
func (t *SetOnlyATarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyATarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SetOnlyA2 map[NBool]struct{}

func (SetOnlyA2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyA2"`
}) {
}

func (m *SetOnlyA2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(__VDLType_v_io_v23_vom_testdata_types_SetOnlyA2, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, __VDLType_v_io_v23_vom_testdata_types_NBool); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyA2) MakeVDLTarget() vdl.Target {
	return &SetOnlyA2Target{Value: m}
}

type SetOnlyA2Target struct {
	Value   *SetOnlyA2
	currKey NBool
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyA2Target) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_SetOnlyA2) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_SetOnlyA2)
	}
	*t.Value = make(SetOnlyA2)
	return t, nil
}
func (t *SetOnlyA2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = NBool(false)
	return &NBoolTarget{Value: &t.currKey}, error(nil)
}
func (t *SetOnlyA2Target) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyA2Target) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SetOnlyB map[int16]struct{}

func (SetOnlyB) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyB"`
}) {
}

func (m *SetOnlyB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(__VDLType_v_io_v23_vom_testdata_types_SetOnlyB, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromInt(int64(key3), vdl.Int16Type); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyB) MakeVDLTarget() vdl.Target {
	return &SetOnlyBTarget{Value: m}
}

type SetOnlyBTarget struct {
	Value   *SetOnlyB
	currKey int16
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyBTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_SetOnlyB) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_SetOnlyB)
	}
	*t.Value = make(SetOnlyB)
	return t, nil
}
func (t *SetOnlyBTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = int16(0)
	return &vdl.Int16Target{Value: &t.currKey}, error(nil)
}
func (t *SetOnlyBTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyBTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type SetOnlyB2 map[NInt16]struct{}

func (SetOnlyB2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyB2"`
}) {
}

func (m *SetOnlyB2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(__VDLType_v_io_v23_vom_testdata_types_SetOnlyB2, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, __VDLType_v_io_v23_vom_testdata_types_NInt16); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyB2) MakeVDLTarget() vdl.Target {
	return &SetOnlyB2Target{Value: m}
}

type SetOnlyB2Target struct {
	Value   *SetOnlyB2
	currKey NInt16
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyB2Target) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_SetOnlyB2) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_SetOnlyB2)
	}
	*t.Value = make(SetOnlyB2)
	return t, nil
}
func (t *SetOnlyB2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = NInt16(0)
	return &NInt16Target{Value: &t.currKey}, error(nil)
}
func (t *SetOnlyB2Target) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyB2Target) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapOnlyA map[uint32]uint32

func (MapOnlyA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyA"`
}) {
}

func (m *MapOnlyA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_v23_vom_testdata_types_MapOnlyA, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), vdl.Uint32Type); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromUint(uint64(value5), vdl.Uint32Type); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyA) MakeVDLTarget() vdl.Target {
	return &MapOnlyATarget{Value: m}
}

type MapOnlyATarget struct {
	Value    *MapOnlyA
	currKey  uint32
	currElem uint32
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyATarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlyA) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlyA)
	}
	*t.Value = make(MapOnlyA)
	return t, nil
}
func (t *MapOnlyATarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint32(0)
	return &vdl.Uint32Target{Value: &t.currKey}, error(nil)
}
func (t *MapOnlyATarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = uint32(0)
	return &vdl.Uint32Target{Value: &t.currElem}, error(nil)
}
func (t *MapOnlyATarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyATarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapOnlyA2 map[int64]float64

func (MapOnlyA2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyA2"`
}) {
}

func (m *MapOnlyA2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_v23_vom_testdata_types_MapOnlyA2, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromInt(int64(key3), vdl.Int64Type); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromFloat(float64(value5), vdl.Float64Type); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyA2) MakeVDLTarget() vdl.Target {
	return &MapOnlyA2Target{Value: m}
}

type MapOnlyA2Target struct {
	Value    *MapOnlyA2
	currKey  int64
	currElem float64
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyA2Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlyA2) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlyA2)
	}
	*t.Value = make(MapOnlyA2)
	return t, nil
}
func (t *MapOnlyA2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	return &vdl.Int64Target{Value: &t.currKey}, error(nil)
}
func (t *MapOnlyA2Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = float64(0)
	return &vdl.Float64Target{Value: &t.currElem}, error(nil)
}
func (t *MapOnlyA2Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyA2Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapOnlyB map[bool]string

func (MapOnlyB) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyB"`
}) {
}

func (m *MapOnlyB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_v23_vom_testdata_types_MapOnlyB, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromBool(bool(key3), vdl.BoolType); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromString(string(value5), vdl.StringType); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyB) MakeVDLTarget() vdl.Target {
	return &MapOnlyBTarget{Value: m}
}

type MapOnlyBTarget struct {
	Value    *MapOnlyB
	currKey  bool
	currElem string
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyBTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlyB) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlyB)
	}
	*t.Value = make(MapOnlyB)
	return t, nil
}
func (t *MapOnlyBTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = false
	return &vdl.BoolTarget{Value: &t.currKey}, error(nil)
}
func (t *MapOnlyBTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	return &vdl.StringTarget{Value: &t.currElem}, error(nil)
}
func (t *MapOnlyBTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyBTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type MapOnlyB2 map[NBool]NString

func (MapOnlyB2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyB2"`
}) {
}

func (m *MapOnlyB2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(__VDLType_v_io_v23_vom_testdata_types_MapOnlyB2, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, __VDLType_v_io_v23_vom_testdata_types_NBool); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, __VDLType_v_io_v23_vom_testdata_types_NString); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyB2) MakeVDLTarget() vdl.Target {
	return &MapOnlyB2Target{Value: m}
}

type MapOnlyB2Target struct {
	Value    *MapOnlyB2
	currKey  NBool
	currElem NString
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyB2Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlyB2) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_MapOnlyB2)
	}
	*t.Value = make(MapOnlyB2)
	return t, nil
}
func (t *MapOnlyB2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = NBool(false)
	return &NBoolTarget{Value: &t.currKey}, error(nil)
}
func (t *MapOnlyB2Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = NString("")
	return &NStringTarget{Value: &t.currElem}, error(nil)
}
func (t *MapOnlyB2Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyB2Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type (
	// BdeUnion represents any single field of the BdeUnion union type.
	BdeUnion interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the BdeUnion union type.
		__VDLReflect(__BdeUnionReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// BdeUnionB represents field B of the BdeUnion union type.
	BdeUnionB struct{ Value string }
	// BdeUnionD represents field D of the BdeUnion union type.
	BdeUnionD struct{ Value *vdl.Value }
	// BdeUnionE represents field E of the BdeUnion union type.
	BdeUnionE struct{ Value *vdl.Type }
	// __BdeUnionReflect describes the BdeUnion union type.
	__BdeUnionReflect struct {
		Name  string `vdl:"v.io/v23/vom/testdata/types.BdeUnion"`
		Type  BdeUnion
		Union struct {
			B BdeUnionB
			D BdeUnionD
			E BdeUnionE
		}
	}
)

func (x BdeUnionB) Index() int                     { return 0 }
func (x BdeUnionB) Interface() interface{}         { return x.Value }
func (x BdeUnionB) Name() string                   { return "B" }
func (x BdeUnionB) __VDLReflect(__BdeUnionReflect) {}

func (m BdeUnionB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(__VDLType_v_io_v23_vom_testdata_types_BdeUnion)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), vdl.StringType); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m BdeUnionB) MakeVDLTarget() vdl.Target {
	return nil
}

func (x BdeUnionD) Index() int                     { return 1 }
func (x BdeUnionD) Interface() interface{}         { return x.Value }
func (x BdeUnionD) Name() string                   { return "D" }
func (x BdeUnionD) __VDLReflect(__BdeUnionReflect) {}

func (m BdeUnionD) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(__VDLType_v_io_v23_vom_testdata_types_BdeUnion)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("D")
	if err != nil {
		return err
	}

	if m.Value == nil {
		if err := fieldTarget3.FromNil(vdl.AnyType); err != nil {
			return err
		}
	} else {
		if err := vdl.FromValue(fieldTarget3, m.Value); err != nil {
			return err
		}
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m BdeUnionD) MakeVDLTarget() vdl.Target {
	return nil
}

func (x BdeUnionE) Index() int                     { return 2 }
func (x BdeUnionE) Interface() interface{}         { return x.Value }
func (x BdeUnionE) Name() string                   { return "E" }
func (x BdeUnionE) __VDLReflect(__BdeUnionReflect) {}

func (m BdeUnionE) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(__VDLType_v_io_v23_vom_testdata_types_BdeUnion)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("E")
	if err != nil {
		return err
	}
	typeObjectVal4 := m.Value
	if typeObjectVal4 == nil {
		typeObjectVal4 = vdl.AnyType
	}
	if err := fieldTarget3.FromTypeObject(typeObjectVal4); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m BdeUnionE) MakeVDLTarget() vdl.Target {
	return nil
}

type BrieEnum int

const (
	BrieEnumGlee BrieEnum = iota
	BrieEnumBrie
	BrieEnumThree
)

// BrieEnumAll holds all labels for BrieEnum.
var BrieEnumAll = [...]BrieEnum{BrieEnumGlee, BrieEnumBrie, BrieEnumThree}

// BrieEnumFromString creates a BrieEnum from a string label.
func BrieEnumFromString(label string) (x BrieEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *BrieEnum) Set(label string) error {
	switch label {
	case "Glee", "glee":
		*x = BrieEnumGlee
		return nil
	case "Brie", "brie":
		*x = BrieEnumBrie
		return nil
	case "Three", "three":
		*x = BrieEnumThree
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.BrieEnum", label)
}

// String returns the string label of x.
func (x BrieEnum) String() string {
	switch x {
	case BrieEnumGlee:
		return "Glee"
	case BrieEnumBrie:
		return "Brie"
	case BrieEnumThree:
		return "Three"
	}
	return ""
}

func (BrieEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.BrieEnum"`
	Enum struct{ Glee, Brie, Three string }
}) {
}

func (m *BrieEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), __VDLType_v_io_v23_vom_testdata_types_BrieEnum); err != nil {
		return err
	}
	return nil
}

func (m *BrieEnum) MakeVDLTarget() vdl.Target {
	return &BrieEnumTarget{Value: m}
}

type BrieEnumTarget struct {
	Value *BrieEnum
	vdl.TargetBase
}

func (t *BrieEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_BrieEnum) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_BrieEnum)
	}
	switch src {
	case "Glee":
		*t.Value = 0
	case "Brie":
		*t.Value = 1
	case "Three":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum %v", src, __VDLType_v_io_v23_vom_testdata_types_BrieEnum)
	}

	return nil
}

type BeanEnum int

const (
	BeanEnumBean BeanEnum = iota
)

// BeanEnumAll holds all labels for BeanEnum.
var BeanEnumAll = [...]BeanEnum{BeanEnumBean}

// BeanEnumFromString creates a BeanEnum from a string label.
func BeanEnumFromString(label string) (x BeanEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *BeanEnum) Set(label string) error {
	switch label {
	case "Bean", "bean":
		*x = BeanEnumBean
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.BeanEnum", label)
}

// String returns the string label of x.
func (x BeanEnum) String() string {
	switch x {
	case BeanEnumBean:
		return "Bean"
	}
	return ""
}

func (BeanEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.BeanEnum"`
	Enum struct{ Bean string }
}) {
}

func (m *BeanEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), __VDLType_v_io_v23_vom_testdata_types_BeanEnum); err != nil {
		return err
	}
	return nil
}

func (m *BeanEnum) MakeVDLTarget() vdl.Target {
	return &BeanEnumTarget{Value: m}
}

type BeanEnumTarget struct {
	Value *BeanEnum
	vdl.TargetBase
}

func (t *BeanEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_BeanEnum) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_BeanEnum)
	}
	switch src {
	case "Bean":
		*t.Value = 0
	default:
		return fmt.Errorf("label %s not in enum %v", src, __VDLType_v_io_v23_vom_testdata_types_BeanEnum)
	}

	return nil
}

type FoodEnum int

const (
	FoodEnumBean FoodEnum = iota
	FoodEnumBrie
	FoodEnumCherry
)

// FoodEnumAll holds all labels for FoodEnum.
var FoodEnumAll = [...]FoodEnum{FoodEnumBean, FoodEnumBrie, FoodEnumCherry}

// FoodEnumFromString creates a FoodEnum from a string label.
func FoodEnumFromString(label string) (x FoodEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *FoodEnum) Set(label string) error {
	switch label {
	case "Bean", "bean":
		*x = FoodEnumBean
		return nil
	case "Brie", "brie":
		*x = FoodEnumBrie
		return nil
	case "Cherry", "cherry":
		*x = FoodEnumCherry
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.FoodEnum", label)
}

// String returns the string label of x.
func (x FoodEnum) String() string {
	switch x {
	case FoodEnumBean:
		return "Bean"
	case FoodEnumBrie:
		return "Brie"
	case FoodEnumCherry:
		return "Cherry"
	}
	return ""
}

func (FoodEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.FoodEnum"`
	Enum struct{ Bean, Brie, Cherry string }
}) {
}

func (m *FoodEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), __VDLType_v_io_v23_vom_testdata_types_FoodEnum); err != nil {
		return err
	}
	return nil
}

func (m *FoodEnum) MakeVDLTarget() vdl.Target {
	return &FoodEnumTarget{Value: m}
}

type FoodEnumTarget struct {
	Value *FoodEnum
	vdl.TargetBase
}

func (t *FoodEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_FoodEnum) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_FoodEnum)
	}
	switch src {
	case "Bean":
		*t.Value = 0
	case "Brie":
		*t.Value = 1
	case "Cherry":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum %v", src, __VDLType_v_io_v23_vom_testdata_types_FoodEnum)
	}

	return nil
}

type StructAny struct {
	Any *vdl.Value
}

func (StructAny) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructAny"`
}) {
}

func (m *StructAny) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_StructAny == nil || __VDLType26 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Any")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Any == nil {
			if err := fieldTarget3.FromNil(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget3, m.Any); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructAny) MakeVDLTarget() vdl.Target {
	return &StructAnyTarget{Value: m}
}

type StructAnyTarget struct {
	Value *StructAny
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *StructAnyTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_StructAny) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_StructAny)
	}
	return t, nil
}
func (t *StructAnyTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Any":
		val, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Any))
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_StructAny)
	}
}
func (t *StructAnyTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *StructAnyTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type StructMap struct {
	Map map[int64]int64
}

func (StructMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructMap"`
}) {
}

func (m *StructMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_StructMap == nil || __VDLType27 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Map")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(__VDLType28, len(m.Map))
		if err != nil {
			return err
		}
		for key6, value8 := range m.Map {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromInt(int64(key6), vdl.Int64Type); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}
			if err := valueTarget7.FromInt(int64(value8), vdl.Int64Type); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructMap) MakeVDLTarget() vdl.Target {
	return &StructMapTarget{Value: m}
}

type StructMapTarget struct {
	Value *StructMap
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *StructMapTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_StructMap) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_StructMap)
	}
	return t, nil
}
func (t *StructMapTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Map":
		val, err := &unnamed_6d61705b696e7436345d696e743634_Target{Value: &t.Value.Map}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_StructMap)
	}
}
func (t *StructMapTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *StructMapTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type unnamed_6d61705b696e7436345d696e743634_Target struct {
	Value    *map[int64]int64
	currKey  int64
	currElem int64
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *unnamed_6d61705b696e7436345d696e743634_Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLType28) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType28)
	}
	*t.Value = make(map[int64]int64)
	return t, nil
}
func (t *unnamed_6d61705b696e7436345d696e743634_Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	return &vdl.Int64Target{Value: &t.currKey}, error(nil)
}
func (t *unnamed_6d61705b696e7436345d696e743634_Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = int64(0)
	return &vdl.Int64Target{Value: &t.currElem}, error(nil)
}
func (t *unnamed_6d61705b696e7436345d696e743634_Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *unnamed_6d61705b696e7436345d696e743634_Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// Since the encoding changes if struct fields are zero values,
// test each of the kinds in a struct both as zero and non-zero values.
type StructManyTypes struct {
	Bool             bool
	AByte            byte
	Int16            int16
	Int32            int32
	Int64            int64
	Uint16           uint16
	Uint32           uint32
	Uint64           uint64
	String           string
	Bytes            []byte
	Float32          float32
	Float64          float64
	Complex64        complex64
	Complex128       complex128
	FoodEnum         FoodEnum
	NEnum            NEnum
	NListUint64      NListUint64
	NByteArray       NByteArray
	NArray2Uint64    NArray2Uint64
	NSetUint64       NSetUint64
	NMapUint64String NMapUint64String
	NStruct          NStruct
	NUnion           NUnion
	TypeObject       *vdl.Type
}

func (StructManyTypes) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructManyTypes"`
}) {
}

func (m *StructManyTypes) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_StructManyTypes == nil || __VDLType29 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Bool")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromBool(bool(m.Bool), vdl.BoolType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("AByte")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromUint(uint64(m.AByte), vdl.ByteType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Int16")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromInt(int64(m.Int16), vdl.Int16Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Int32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget9.FromInt(int64(m.Int32), vdl.Int32Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("Int64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget11.FromInt(int64(m.Int64), vdl.Int64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("Uint16")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget13.FromUint(uint64(m.Uint16), vdl.Uint16Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("Uint32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget15.FromUint(uint64(m.Uint32), vdl.Uint32Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	keyTarget16, fieldTarget17, err := fieldsTarget1.StartField("Uint64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget17.FromUint(uint64(m.Uint64), vdl.Uint64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget16, fieldTarget17); err != nil {
			return err
		}
	}
	keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("String")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget19.FromString(string(m.String), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
			return err
		}
	}
	keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("Bytes")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := fieldTarget21.FromBytes([]byte(m.Bytes), __VDLType30); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
			return err
		}
	}
	keyTarget22, fieldTarget23, err := fieldsTarget1.StartField("Float32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget23.FromFloat(float64(m.Float32), vdl.Float32Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget22, fieldTarget23); err != nil {
			return err
		}
	}
	keyTarget24, fieldTarget25, err := fieldsTarget1.StartField("Float64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget25.FromFloat(float64(m.Float64), vdl.Float64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget24, fieldTarget25); err != nil {
			return err
		}
	}
	keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("Complex64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget27.FromComplex(complex128(m.Complex64), vdl.Complex64Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
			return err
		}
	}
	keyTarget28, fieldTarget29, err := fieldsTarget1.StartField("Complex128")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget29.FromComplex(complex128(m.Complex128), vdl.Complex128Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget28, fieldTarget29); err != nil {
			return err
		}
	}
	keyTarget30, fieldTarget31, err := fieldsTarget1.StartField("FoodEnum")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.FoodEnum.FillVDLTarget(fieldTarget31, __VDLType_v_io_v23_vom_testdata_types_FoodEnum); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget30, fieldTarget31); err != nil {
			return err
		}
	}
	keyTarget32, fieldTarget33, err := fieldsTarget1.StartField("NEnum")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NEnum.FillVDLTarget(fieldTarget33, __VDLType_v_io_v23_vom_testdata_types_NEnum); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget32, fieldTarget33); err != nil {
			return err
		}
	}
	keyTarget34, fieldTarget35, err := fieldsTarget1.StartField("NListUint64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NListUint64.FillVDLTarget(fieldTarget35, __VDLType_v_io_v23_vom_testdata_types_NListUint64); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget34, fieldTarget35); err != nil {
			return err
		}
	}
	keyTarget36, fieldTarget37, err := fieldsTarget1.StartField("NByteArray")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NByteArray.FillVDLTarget(fieldTarget37, __VDLType_v_io_v23_vom_testdata_types_NByteArray); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget36, fieldTarget37); err != nil {
			return err
		}
	}
	keyTarget38, fieldTarget39, err := fieldsTarget1.StartField("NArray2Uint64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NArray2Uint64.FillVDLTarget(fieldTarget39, __VDLType_v_io_v23_vom_testdata_types_NArray2Uint64); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget38, fieldTarget39); err != nil {
			return err
		}
	}
	keyTarget40, fieldTarget41, err := fieldsTarget1.StartField("NSetUint64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NSetUint64.FillVDLTarget(fieldTarget41, __VDLType_v_io_v23_vom_testdata_types_NSetUint64); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget40, fieldTarget41); err != nil {
			return err
		}
	}
	keyTarget42, fieldTarget43, err := fieldsTarget1.StartField("NMapUint64String")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NMapUint64String.FillVDLTarget(fieldTarget43, __VDLType_v_io_v23_vom_testdata_types_NMapUint64String); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget42, fieldTarget43); err != nil {
			return err
		}
	}
	keyTarget44, fieldTarget45, err := fieldsTarget1.StartField("NStruct")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.NStruct.FillVDLTarget(fieldTarget45, __VDLType_v_io_v23_vom_testdata_types_NStruct); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget44, fieldTarget45); err != nil {
			return err
		}
	}
	keyTarget46, fieldTarget47, err := fieldsTarget1.StartField("NUnion")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		unionValue48 := m.NUnion
		if unionValue48 == nil {
			unionValue48 = NUnionA{}
		}
		if err := unionValue48.FillVDLTarget(fieldTarget47, __VDLType_v_io_v23_vom_testdata_types_NUnion); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget46, fieldTarget47); err != nil {
			return err
		}
	}
	keyTarget49, fieldTarget50, err := fieldsTarget1.StartField("TypeObject")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		typeObjectVal51 := m.TypeObject
		if typeObjectVal51 == nil {
			typeObjectVal51 = vdl.AnyType
		}
		if err := fieldTarget50.FromTypeObject(typeObjectVal51); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget49, fieldTarget50); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructManyTypes) MakeVDLTarget() vdl.Target {
	return &StructManyTypesTarget{Value: m}
}

type StructManyTypesTarget struct {
	Value *StructManyTypes
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *StructManyTypesTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_StructManyTypes) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_StructManyTypes)
	}
	return t, nil
}
func (t *StructManyTypesTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Bool":
		val, err := &vdl.BoolTarget{Value: &t.Value.Bool}, error(nil)
		return nil, val, err
	case "AByte":
		val, err := &vdl.ByteTarget{Value: &t.Value.AByte}, error(nil)
		return nil, val, err
	case "Int16":
		val, err := &vdl.Int16Target{Value: &t.Value.Int16}, error(nil)
		return nil, val, err
	case "Int32":
		val, err := &vdl.Int32Target{Value: &t.Value.Int32}, error(nil)
		return nil, val, err
	case "Int64":
		val, err := &vdl.Int64Target{Value: &t.Value.Int64}, error(nil)
		return nil, val, err
	case "Uint16":
		val, err := &vdl.Uint16Target{Value: &t.Value.Uint16}, error(nil)
		return nil, val, err
	case "Uint32":
		val, err := &vdl.Uint32Target{Value: &t.Value.Uint32}, error(nil)
		return nil, val, err
	case "Uint64":
		val, err := &vdl.Uint64Target{Value: &t.Value.Uint64}, error(nil)
		return nil, val, err
	case "String":
		val, err := &vdl.StringTarget{Value: &t.Value.String}, error(nil)
		return nil, val, err
	case "Bytes":
		val, err := &vdl.BytesTarget{Value: &t.Value.Bytes}, error(nil)
		return nil, val, err
	case "Float32":
		val, err := &vdl.Float32Target{Value: &t.Value.Float32}, error(nil)
		return nil, val, err
	case "Float64":
		val, err := &vdl.Float64Target{Value: &t.Value.Float64}, error(nil)
		return nil, val, err
	case "Complex64":
		val, err := &vdl.Complex64Target{Value: &t.Value.Complex64}, error(nil)
		return nil, val, err
	case "Complex128":
		val, err := &vdl.Complex128Target{Value: &t.Value.Complex128}, error(nil)
		return nil, val, err
	case "FoodEnum":
		val, err := &FoodEnumTarget{Value: &t.Value.FoodEnum}, error(nil)
		return nil, val, err
	case "NEnum":
		val, err := &NEnumTarget{Value: &t.Value.NEnum}, error(nil)
		return nil, val, err
	case "NListUint64":
		val, err := &NListUint64Target{Value: &t.Value.NListUint64}, error(nil)
		return nil, val, err
	case "NByteArray":
		val, err := &NByteArrayTarget{Value: &t.Value.NByteArray}, error(nil)
		return nil, val, err
	case "NArray2Uint64":
		val, err := &NArray2Uint64Target{Value: &t.Value.NArray2Uint64}, error(nil)
		return nil, val, err
	case "NSetUint64":
		val, err := &NSetUint64Target{Value: &t.Value.NSetUint64}, error(nil)
		return nil, val, err
	case "NMapUint64String":
		val, err := &NMapUint64StringTarget{Value: &t.Value.NMapUint64String}, error(nil)
		return nil, val, err
	case "NStruct":
		val, err := &NStructTarget{Value: &t.Value.NStruct}, error(nil)
		return nil, val, err
	case "NUnion":
		val, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.NUnion))
		return nil, val, err
	case "TypeObject":
		val, err := &vdl.TypeObjectTarget{Value: &t.Value.TypeObject}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_StructManyTypes)
	}
}
func (t *StructManyTypesTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *StructManyTypesTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type AnySlice []*vdl.Value

func (AnySlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AnySlice"`
}) {
}

func (m *AnySlice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(__VDLType_v_io_v23_vom_testdata_types_AnySlice, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if elem3 == nil {
			if err := elemTarget2.FromNil(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(elemTarget2, elem3); err != nil {
				return err
			}
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AnySlice) MakeVDLTarget() vdl.Target {
	return &AnySliceTarget{Value: m}
}

type AnySliceTarget struct {
	Value *AnySlice
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *AnySliceTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_AnySlice) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_AnySlice)
	}
	if cap(*t.Value) < len {
		*t.Value = make(AnySlice, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *AnySliceTarget) StartElem(index int) (elem vdl.Target, _ error) {
	return vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
}
func (t *AnySliceTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *AnySliceTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type LargeMessageType struct {
	Payload []byte
	Next    *LargeMessageType
}

func (LargeMessageType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.LargeMessageType"`
}) {
}

func (m *LargeMessageType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_LargeMessageType == nil || __VDLType31 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Payload")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := fieldTarget3.FromBytes([]byte(m.Payload), __VDLType30); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Next")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Next == nil {
			if err := fieldTarget5.FromNil(__VDLType31); err != nil {
				return err
			}
		} else {
			if err := m.Next.FillVDLTarget(fieldTarget5, __VDLType_v_io_v23_vom_testdata_types_LargeMessageType); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LargeMessageType) MakeVDLTarget() vdl.Target {
	return &LargeMessageTypeTarget{Value: m}
}

type LargeMessageTypeTarget struct {
	Value *LargeMessageType
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LargeMessageTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_LargeMessageType) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_LargeMessageType)
	}
	return t, nil
}
func (t *LargeMessageTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Payload":
		val, err := &vdl.BytesTarget{Value: &t.Value.Payload}, error(nil)
		return nil, val, err
	case "Next":
		val, err := &unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c617267654d65737361676554797065207374727563747b5061796c6f6164205b5d627974653b4e657874203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c617267654d657373616765547970657d_Target{Value: &t.Value.Next}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_LargeMessageType)
	}
}
func (t *LargeMessageTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LargeMessageTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c617267654d65737361676554797065207374727563747b5061796c6f6164205b5d627974653b4e657874203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c617267654d657373616765547970657d_Target struct {
	Value **LargeMessageType
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c617267654d65737361676554797065207374727563747b5061796c6f6164205b5d627974653b4e657874203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c617267654d657373616765547970657d_Target) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if *t.Value == nil {
		*t.Value = &LargeMessageType{}
	}
	target, err := &LargeMessageTypeTarget{Value: *t.Value}, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c617267654d65737361676554797065207374727563747b5061796c6f6164205b5d627974653b4e657874203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c617267654d657373616765547970657d_Target) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c617267654d65737361676554797065207374727563747b5061796c6f6164205b5d627974653b4e657874203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c617267654d657373616765547970657d_Target) FromNil(tt *vdl.Type) error {
	*t.Value = nil

	return nil
}

type LargeAnyMessageType struct {
	Payload *vdl.Value
	Next    *LargeAnyMessageType
}

func (LargeAnyMessageType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.LargeAnyMessageType"`
}) {
}

func (m *LargeAnyMessageType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_v_io_v23_vom_testdata_types_LargeAnyMessageType == nil || __VDLType32 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Payload")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Payload == nil {
			if err := fieldTarget3.FromNil(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := vdl.FromValue(fieldTarget3, m.Payload); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Next")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Next == nil {
			if err := fieldTarget5.FromNil(__VDLType32); err != nil {
				return err
			}
		} else {
			if err := m.Next.FillVDLTarget(fieldTarget5, __VDLType_v_io_v23_vom_testdata_types_LargeAnyMessageType); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LargeAnyMessageType) MakeVDLTarget() vdl.Target {
	return &LargeAnyMessageTypeTarget{Value: m}
}

type LargeAnyMessageTypeTarget struct {
	Value *LargeAnyMessageType
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LargeAnyMessageTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_v_io_v23_vom_testdata_types_LargeAnyMessageType) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_v_io_v23_vom_testdata_types_LargeAnyMessageType)
	}
	return t, nil
}
func (t *LargeAnyMessageTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Payload":
		val, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Payload))
		return nil, val, err
	case "Next":
		val, err := &unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c61726765416e794d65737361676554797065207374727563747b5061796c6f616420616e793b4e657874203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c61726765416e794d657373616765547970657d_Target{Value: &t.Value.Next}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_v_io_v23_vom_testdata_types_LargeAnyMessageType)
	}
}
func (t *LargeAnyMessageTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LargeAnyMessageTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c61726765416e794d65737361676554797065207374727563747b5061796c6f616420616e793b4e657874203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c61726765416e794d657373616765547970657d_Target struct {
	Value **LargeAnyMessageType
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c61726765416e794d65737361676554797065207374727563747b5061796c6f616420616e793b4e657874203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c61726765416e794d657373616765547970657d_Target) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if *t.Value == nil {
		*t.Value = &LargeAnyMessageType{}
	}
	target, err := &LargeAnyMessageTypeTarget{Value: *t.Value}, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c61726765416e794d65737361676554797065207374727563747b5061796c6f616420616e793b4e657874203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c61726765416e794d657373616765547970657d_Target) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *unnamed_3f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c61726765416e794d65737361676554797065207374727563747b5061796c6f616420616e793b4e657874203f762e696f2f7632332f766f6d2f74657374646174612f74797065732e4c61726765416e794d657373616765547970657d_Target) FromNil(tt *vdl.Type) error {
	*t.Value = nil

	return nil
}

func init() {
	vdl.Register((*TestCase)(nil))
	vdl.Register((*ConvertGroup)(nil))
	vdl.Register((*VomdataStruct)(nil))
	vdl.Register((*NBool)(nil))
	vdl.Register((*NString)(nil))
	vdl.Register((*NByteSlice)(nil))
	vdl.Register((*NByteArray)(nil))
	vdl.Register((*NByte)(nil))
	vdl.Register((*NUint16)(nil))
	vdl.Register((*NUint32)(nil))
	vdl.Register((*NUint64)(nil))
	vdl.Register((*NInt8)(nil))
	vdl.Register((*NInt16)(nil))
	vdl.Register((*NInt32)(nil))
	vdl.Register((*NInt64)(nil))
	vdl.Register((*NFloat32)(nil))
	vdl.Register((*NFloat64)(nil))
	vdl.Register((*NComplex64)(nil))
	vdl.Register((*NComplex128)(nil))
	vdl.Register((*NArray2Uint64)(nil))
	vdl.Register((*NListUint64)(nil))
	vdl.Register((*NSetUint64)(nil))
	vdl.Register((*NMapUint64String)(nil))
	vdl.Register((*NStruct)(nil))
	vdl.Register((*NEnum)(nil))
	vdl.Register((*NUnion)(nil))
	vdl.Register((*MBool)(nil))
	vdl.Register((*MStruct)(nil))
	vdl.Register((*MList)(nil))
	vdl.Register((*MMap)(nil))
	vdl.Register((*MByteSlice)(nil))
	vdl.Register((*MInt8Slice)(nil))
	vdl.Register((*RecA)(nil))
	vdl.Register((*RecX)(nil))
	vdl.Register((*RecY)(nil))
	vdl.Register((*Rec1)(nil))
	vdl.Register((*Rec2)(nil))
	vdl.Register((*Rec3)(nil))
	vdl.Register((*Rec4)(nil))
	vdl.Register((*RecStruct)(nil))
	vdl.Register((*Rec1234)(nil))
	vdl.Register((*Rec1234A)(nil))
	vdl.Register((*Rec1234B)(nil))
	vdl.Register((*Rec1234All)(nil))
	vdl.Register((*ListString)(nil))
	vdl.Register((*Array3String)(nil))
	vdl.Register((*Array4String)(nil))
	vdl.Register((*AbcStruct)(nil))
	vdl.Register((*AdeStruct)(nil))
	vdl.Register((*XyzStruct)(nil))
	vdl.Register((*YzStruct)(nil))
	vdl.Register((*ZStruct)(nil))
	vdl.Register((*MapOnlyStruct)(nil))
	vdl.Register((*StructOnlyMap)(nil))
	vdl.Register((*MapSetStruct)(nil))
	vdl.Register((*SetStructMap)(nil))
	vdl.Register((*MapStructSet)(nil))
	vdl.Register((*SetOnlyMap)(nil))
	vdl.Register((*SometimesSetMap)(nil))
	vdl.Register((*MapOnlySet)(nil))
	vdl.Register((*SetOnlyA)(nil))
	vdl.Register((*SetOnlyA2)(nil))
	vdl.Register((*SetOnlyB)(nil))
	vdl.Register((*SetOnlyB2)(nil))
	vdl.Register((*MapOnlyA)(nil))
	vdl.Register((*MapOnlyA2)(nil))
	vdl.Register((*MapOnlyB)(nil))
	vdl.Register((*MapOnlyB2)(nil))
	vdl.Register((*BdeUnion)(nil))
	vdl.Register((*BrieEnum)(nil))
	vdl.Register((*BeanEnum)(nil))
	vdl.Register((*FoodEnum)(nil))
	vdl.Register((*StructAny)(nil))
	vdl.Register((*StructMap)(nil))
	vdl.Register((*StructManyTypes)(nil))
	vdl.Register((*AnySlice)(nil))
	vdl.Register((*LargeMessageType)(nil))
	vdl.Register((*LargeAnyMessageType)(nil))
}

var __VDLType19 *vdl.Type = vdl.TypeOf((*AbcStruct)(nil))
var __VDLType20 *vdl.Type = vdl.TypeOf((*AdeStruct)(nil))
var __VDLType1 *vdl.Type = vdl.TypeOf((*ConvertGroup)(nil))
var __VDLType32 *vdl.Type = vdl.TypeOf((*LargeAnyMessageType)(nil))
var __VDLType31 *vdl.Type = vdl.TypeOf((*LargeMessageType)(nil))
var __VDLType10 *vdl.Type = vdl.TypeOf((*MStruct)(nil))
var __VDLType24 *vdl.Type = vdl.TypeOf((*MapOnlyStruct)(nil))
var __VDLType25 *vdl.Type = vdl.TypeOf((*MapSetStruct)(nil))
var __VDLType9 *vdl.Type = vdl.TypeOf((*NStruct)(nil))
var __VDLType12 *vdl.Type = vdl.TypeOf((*Rec1234)(nil))
var __VDLType13 *vdl.Type = vdl.TypeOf((*Rec1234A)(nil))
var __VDLType18 *vdl.Type = vdl.TypeOf((*Rec1234All)(nil))
var __VDLType16 *vdl.Type = vdl.TypeOf((*Rec1234B)(nil))
var __VDLType11 *vdl.Type = vdl.TypeOf((*RecStruct)(nil))
var __VDLType26 *vdl.Type = vdl.TypeOf((*StructAny)(nil))
var __VDLType29 *vdl.Type = vdl.TypeOf((*StructManyTypes)(nil))
var __VDLType27 *vdl.Type = vdl.TypeOf((*StructMap)(nil))
var __VDLType0 *vdl.Type = vdl.TypeOf((*TestCase)(nil))
var __VDLType3 *vdl.Type = vdl.TypeOf((*VomdataStruct)(nil))
var __VDLType21 *vdl.Type = vdl.TypeOf((*XyzStruct)(nil))
var __VDLType22 *vdl.Type = vdl.TypeOf((*YzStruct)(nil))
var __VDLType23 *vdl.Type = vdl.TypeOf((*ZStruct)(nil))
var __VDLType2 *vdl.Type = vdl.TypeOf([]*vdl.Value(nil))
var __VDLType30 *vdl.Type = vdl.TypeOf([]byte(nil))
var __VDLType6 *vdl.Type = vdl.TypeOf([]*vdl.Type(nil))
var __VDLType8 *vdl.Type = vdl.TypeOf([]ConvertGroup(nil))
var __VDLType15 *vdl.Type = vdl.TypeOf([]Rec1234(nil))
var __VDLType14 *vdl.Type = vdl.TypeOf([]Rec1234A(nil))
var __VDLType17 *vdl.Type = vdl.TypeOf([]Rec1234B(nil))
var __VDLType4 *vdl.Type = vdl.TypeOf(map[byte][]*vdl.Value(nil))
var __VDLType28 *vdl.Type = vdl.TypeOf(map[int64]int64(nil))
var __VDLType5 *vdl.Type = vdl.TypeOf(map[string][]*vdl.Type(nil))
var __VDLType7 *vdl.Type = vdl.TypeOf(map[string][]ConvertGroup(nil))
var __VDLType_v_io_v23_vom_testdata_types_AbcStruct *vdl.Type = vdl.TypeOf(AbcStruct{})
var __VDLType_v_io_v23_vom_testdata_types_AdeStruct *vdl.Type = vdl.TypeOf(AdeStruct{
	E: vdl.AnyType,
})
var __VDLType_v_io_v23_vom_testdata_types_AnySlice *vdl.Type = vdl.TypeOf(AnySlice(nil))
var __VDLType_v_io_v23_vom_testdata_types_Array3String *vdl.Type = vdl.TypeOf(Array3String{})
var __VDLType_v_io_v23_vom_testdata_types_Array4String *vdl.Type = vdl.TypeOf(Array4String{})
var __VDLType_v_io_v23_vom_testdata_types_BdeUnion *vdl.Type = vdl.TypeOf(BdeUnion(BdeUnionB{""}))
var __VDLType_v_io_v23_vom_testdata_types_BeanEnum *vdl.Type = vdl.TypeOf(BeanEnumBean)
var __VDLType_v_io_v23_vom_testdata_types_BrieEnum *vdl.Type = vdl.TypeOf(BrieEnumGlee)
var __VDLType_v_io_v23_vom_testdata_types_ConvertGroup *vdl.Type = vdl.TypeOf(ConvertGroup{
	PrimaryType: vdl.AnyType,
})
var __VDLType_v_io_v23_vom_testdata_types_FoodEnum *vdl.Type = vdl.TypeOf(FoodEnumBean)
var __VDLType_v_io_v23_vom_testdata_types_LargeAnyMessageType *vdl.Type = vdl.TypeOf(LargeAnyMessageType{})
var __VDLType_v_io_v23_vom_testdata_types_LargeMessageType *vdl.Type = vdl.TypeOf(LargeMessageType{})
var __VDLType_v_io_v23_vom_testdata_types_ListString *vdl.Type = vdl.TypeOf(ListString(nil))
var __VDLType_v_io_v23_vom_testdata_types_MBool *vdl.Type = vdl.TypeOf(MBool(false))
var __VDLType_v_io_v23_vom_testdata_types_MByteSlice *vdl.Type = vdl.TypeOf(MByteSlice(nil))
var __VDLType_v_io_v23_vom_testdata_types_MInt8Slice *vdl.Type = vdl.TypeOf(MInt8Slice(nil))
var __VDLType_v_io_v23_vom_testdata_types_MList *vdl.Type = vdl.TypeOf(MList(nil))
var __VDLType_v_io_v23_vom_testdata_types_MMap *vdl.Type = vdl.TypeOf(MMap(nil))
var __VDLType_v_io_v23_vom_testdata_types_MStruct *vdl.Type = vdl.TypeOf(MStruct{
	E: vdl.AnyType,
})
var __VDLType_v_io_v23_vom_testdata_types_MapOnlyA *vdl.Type = vdl.TypeOf(MapOnlyA(nil))
var __VDLType_v_io_v23_vom_testdata_types_MapOnlyA2 *vdl.Type = vdl.TypeOf(MapOnlyA2(nil))
var __VDLType_v_io_v23_vom_testdata_types_MapOnlyB *vdl.Type = vdl.TypeOf(MapOnlyB(nil))
var __VDLType_v_io_v23_vom_testdata_types_MapOnlyB2 *vdl.Type = vdl.TypeOf(MapOnlyB2(nil))
var __VDLType_v_io_v23_vom_testdata_types_MapOnlySet *vdl.Type = vdl.TypeOf(MapOnlySet(nil))
var __VDLType_v_io_v23_vom_testdata_types_MapOnlyStruct *vdl.Type = vdl.TypeOf(MapOnlyStruct{})
var __VDLType_v_io_v23_vom_testdata_types_MapSetStruct *vdl.Type = vdl.TypeOf(MapSetStruct{})
var __VDLType_v_io_v23_vom_testdata_types_MapStructSet *vdl.Type = vdl.TypeOf(MapStructSet(nil))
var __VDLType_v_io_v23_vom_testdata_types_NArray2Uint64 *vdl.Type = vdl.TypeOf(NArray2Uint64{})
var __VDLType_v_io_v23_vom_testdata_types_NBool *vdl.Type = vdl.TypeOf(NBool(false))
var __VDLType_v_io_v23_vom_testdata_types_NByte *vdl.Type = vdl.TypeOf(NByte(0))
var __VDLType_v_io_v23_vom_testdata_types_NByteArray *vdl.Type = vdl.TypeOf(NByteArray{})
var __VDLType_v_io_v23_vom_testdata_types_NByteSlice *vdl.Type = vdl.TypeOf(NByteSlice(nil))
var __VDLType_v_io_v23_vom_testdata_types_NComplex128 *vdl.Type = vdl.TypeOf(NComplex128(0))
var __VDLType_v_io_v23_vom_testdata_types_NComplex64 *vdl.Type = vdl.TypeOf(NComplex64(0))
var __VDLType_v_io_v23_vom_testdata_types_NEnum *vdl.Type = vdl.TypeOf(NEnumA)
var __VDLType_v_io_v23_vom_testdata_types_NFloat32 *vdl.Type = vdl.TypeOf(NFloat32(0))
var __VDLType_v_io_v23_vom_testdata_types_NFloat64 *vdl.Type = vdl.TypeOf(NFloat64(0))
var __VDLType_v_io_v23_vom_testdata_types_NInt16 *vdl.Type = vdl.TypeOf(NInt16(0))
var __VDLType_v_io_v23_vom_testdata_types_NInt32 *vdl.Type = vdl.TypeOf(NInt32(0))
var __VDLType_v_io_v23_vom_testdata_types_NInt64 *vdl.Type = vdl.TypeOf(NInt64(0))
var __VDLType_v_io_v23_vom_testdata_types_NInt8 *vdl.Type = vdl.TypeOf(NInt8(0))
var __VDLType_v_io_v23_vom_testdata_types_NListUint64 *vdl.Type = vdl.TypeOf(NListUint64(nil))
var __VDLType_v_io_v23_vom_testdata_types_NMapUint64String *vdl.Type = vdl.TypeOf(NMapUint64String(nil))
var __VDLType_v_io_v23_vom_testdata_types_NSetUint64 *vdl.Type = vdl.TypeOf(NSetUint64(nil))
var __VDLType_v_io_v23_vom_testdata_types_NString *vdl.Type = vdl.TypeOf(NString(""))
var __VDLType_v_io_v23_vom_testdata_types_NStruct *vdl.Type = vdl.TypeOf(NStruct{})
var __VDLType_v_io_v23_vom_testdata_types_NUint16 *vdl.Type = vdl.TypeOf(NUint16(0))
var __VDLType_v_io_v23_vom_testdata_types_NUint32 *vdl.Type = vdl.TypeOf(NUint32(0))
var __VDLType_v_io_v23_vom_testdata_types_NUint64 *vdl.Type = vdl.TypeOf(NUint64(0))
var __VDLType_v_io_v23_vom_testdata_types_NUnion *vdl.Type = vdl.TypeOf(NUnion(NUnionA{false}))
var __VDLType_v_io_v23_vom_testdata_types_Rec1 *vdl.Type = vdl.TypeOf(Rec1(nil))
var __VDLType_v_io_v23_vom_testdata_types_Rec1234 *vdl.Type = vdl.TypeOf(Rec1234{})
var __VDLType_v_io_v23_vom_testdata_types_Rec1234A *vdl.Type = vdl.TypeOf(Rec1234A{})
var __VDLType_v_io_v23_vom_testdata_types_Rec1234All *vdl.Type = vdl.TypeOf(Rec1234All{})
var __VDLType_v_io_v23_vom_testdata_types_Rec1234B *vdl.Type = vdl.TypeOf(Rec1234B{})
var __VDLType_v_io_v23_vom_testdata_types_Rec2 *vdl.Type = vdl.TypeOf(Rec2(nil))
var __VDLType_v_io_v23_vom_testdata_types_Rec3 *vdl.Type = vdl.TypeOf(Rec3(nil))
var __VDLType_v_io_v23_vom_testdata_types_Rec4 *vdl.Type = vdl.TypeOf(Rec4(nil))
var __VDLType_v_io_v23_vom_testdata_types_RecA *vdl.Type = vdl.TypeOf(RecA(nil))
var __VDLType_v_io_v23_vom_testdata_types_RecStruct *vdl.Type = vdl.TypeOf(RecStruct{})
var __VDLType_v_io_v23_vom_testdata_types_RecX *vdl.Type = vdl.TypeOf(RecX(nil))
var __VDLType_v_io_v23_vom_testdata_types_RecY *vdl.Type = vdl.TypeOf(RecY(nil))
var __VDLType_v_io_v23_vom_testdata_types_SetOnlyA *vdl.Type = vdl.TypeOf(SetOnlyA(nil))
var __VDLType_v_io_v23_vom_testdata_types_SetOnlyA2 *vdl.Type = vdl.TypeOf(SetOnlyA2(nil))
var __VDLType_v_io_v23_vom_testdata_types_SetOnlyB *vdl.Type = vdl.TypeOf(SetOnlyB(nil))
var __VDLType_v_io_v23_vom_testdata_types_SetOnlyB2 *vdl.Type = vdl.TypeOf(SetOnlyB2(nil))
var __VDLType_v_io_v23_vom_testdata_types_SetOnlyMap *vdl.Type = vdl.TypeOf(SetOnlyMap(nil))
var __VDLType_v_io_v23_vom_testdata_types_SetStructMap *vdl.Type = vdl.TypeOf(SetStructMap(nil))
var __VDLType_v_io_v23_vom_testdata_types_SometimesSetMap *vdl.Type = vdl.TypeOf(SometimesSetMap(nil))
var __VDLType_v_io_v23_vom_testdata_types_StructAny *vdl.Type = vdl.TypeOf(StructAny{})
var __VDLType_v_io_v23_vom_testdata_types_StructManyTypes *vdl.Type = vdl.TypeOf(StructManyTypes{
	NUnion:     NUnionA{false},
	TypeObject: vdl.AnyType,
})
var __VDLType_v_io_v23_vom_testdata_types_StructMap *vdl.Type = vdl.TypeOf(StructMap{})
var __VDLType_v_io_v23_vom_testdata_types_StructOnlyMap *vdl.Type = vdl.TypeOf(StructOnlyMap(nil))
var __VDLType_v_io_v23_vom_testdata_types_TestCase *vdl.Type = vdl.TypeOf(TestCase{})
var __VDLType_v_io_v23_vom_testdata_types_VomdataStruct *vdl.Type = vdl.TypeOf(VomdataStruct{})
var __VDLType_v_io_v23_vom_testdata_types_XyzStruct *vdl.Type = vdl.TypeOf(XyzStruct{})
var __VDLType_v_io_v23_vom_testdata_types_YzStruct *vdl.Type = vdl.TypeOf(YzStruct{})
var __VDLType_v_io_v23_vom_testdata_types_ZStruct *vdl.Type = vdl.TypeOf(ZStruct{})

func __VDLEnsureNativeBuilt() {
}
