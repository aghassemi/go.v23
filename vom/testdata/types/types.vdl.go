// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: types

package types

import (
	"fmt"
	"v.io/v23/vdl"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// TestCase represents an individual testcase for vom encoding and decoding.
type TestCase struct {
	Name       string     // Name of the testcase
	Value      *vdl.Value // Value to test
	TypeString string     // The string representation of the Type
	Hex        string     // Hex pattern representing vom encoding
	HexVersion string     // Hex pattern representing vom encoding of Version
	HexType    string     // Hex pattern representing vom encoding of Type
	HexValue   string     // Hex pattern representing vom encoding of Value
}

func (TestCase) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.TestCase"`
}) {
}

func (x TestCase) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if x.Value != nil && !x.Value.VDLIsZero() {
		return false
	}
	if x.TypeString != "" {
		return false
	}
	if x.Hex != "" {
		return false
	}
	if x.HexVersion != "" {
		return false
	}
	if x.HexType != "" {
		return false
	}
	if x.HexValue != "" {
		return false
	}
	return true
}

func (x TestCase) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*TestCase)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Value != nil && !x.Value.VDLIsZero() {
		if err := enc.NextField("Value"); err != nil {
			return err
		}
		if err := x.Value.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.TypeString != "" {
		if err := enc.NextField("TypeString"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.TypeString); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Hex != "" {
		if err := enc.NextField("Hex"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Hex); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.HexVersion != "" {
		if err := enc.NextField("HexVersion"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.HexVersion); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.HexType != "" {
		if err := enc.NextField("HexType"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.HexType); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.HexValue != "" {
		if err := enc.NextField("HexValue"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.HexValue); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *TestCase) VDLRead(dec vdl.Decoder) error {
	*x = TestCase{
		Value: vdl.ZeroValue(vdl.AnyType),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Value":
			x.Value = new(vdl.Value)
			if err := x.Value.VDLRead(dec); err != nil {
				return err
			}
		case "TypeString":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.TypeString, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Hex":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Hex, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "HexVersion":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.HexVersion, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "HexType":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.HexType, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "HexValue":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.HexValue, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// vomdata config types
type ConvertGroup struct {
	Name        string
	PrimaryType *vdl.Type
	Values      []*vdl.Value
}

func (ConvertGroup) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ConvertGroup"`
}) {
}

func (x ConvertGroup) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if x.PrimaryType != nil && x.PrimaryType != vdl.AnyType {
		return false
	}
	if len(x.Values) != 0 {
		return false
	}
	return true
}

func (x ConvertGroup) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ConvertGroup)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.PrimaryType != nil && x.PrimaryType != vdl.AnyType {
		if err := enc.NextField("PrimaryType"); err != nil {
			return err
		}
		if err := x.PrimaryType.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.Values) != 0 {
		if err := enc.NextField("Values"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_1(enc, x.Values); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_1(enc vdl.Encoder, x []*vdl.Value) error {
	if err := enc.StartValue(vdl.TypeOf((*[]*vdl.Value)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if x[i] == nil {
			if err := enc.NilValue(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := x[i].VDLWrite(enc); err != nil {
				return err
			}
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ConvertGroup) VDLRead(dec vdl.Decoder) error {
	*x = ConvertGroup{
		PrimaryType: vdl.AnyType,
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "PrimaryType":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.PrimaryType, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Values":
			if err := __VDLReadAnon_list_1(dec, &x.Values); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_1(dec vdl.Decoder, x *[]*vdl.Value) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]*vdl.Value, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem *vdl.Value
		elem = new(vdl.Value)
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type VomdataStruct struct {
	EncodeDecodeData map[byte][]*vdl.Value // map from min required VOM version to test values
	CompatData       map[string][]*vdl.Type
	ConvertData      map[string][]ConvertGroup
}

func (VomdataStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.VomdataStruct"`
}) {
}

func (x VomdataStruct) VDLIsZero() bool {
	if len(x.EncodeDecodeData) != 0 {
		return false
	}
	if len(x.CompatData) != 0 {
		return false
	}
	if len(x.ConvertData) != 0 {
		return false
	}
	return true
}

func (x VomdataStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*VomdataStruct)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.EncodeDecodeData) != 0 {
		if err := enc.NextField("EncodeDecodeData"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_2(enc, x.EncodeDecodeData); err != nil {
			return err
		}
	}
	if len(x.CompatData) != 0 {
		if err := enc.NextField("CompatData"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_3(enc, x.CompatData); err != nil {
			return err
		}
	}
	if len(x.ConvertData) != 0 {
		if err := enc.NextField("ConvertData"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_4(enc, x.ConvertData); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_2(enc vdl.Encoder, x map[byte][]*vdl.Value) error {
	if err := enc.StartValue(vdl.TypeOf((*map[byte][]*vdl.Value)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_1(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_3(enc vdl.Encoder, x map[string][]*vdl.Type) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string][]*vdl.Type)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_5(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_4(enc vdl.Encoder, x map[string][]ConvertGroup) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string][]ConvertGroup)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_6(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_5(enc vdl.Encoder, x []*vdl.Type) error {
	if err := enc.StartValue(vdl.TypeOf((*[]*vdl.Type)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_6(enc vdl.Encoder, x []ConvertGroup) error {
	if err := enc.StartValue(vdl.TypeOf((*[]ConvertGroup)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *VomdataStruct) VDLRead(dec vdl.Decoder) error {
	*x = VomdataStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "EncodeDecodeData":
			if err := __VDLReadAnon_map_2(dec, &x.EncodeDecodeData); err != nil {
				return err
			}
		case "CompatData":
			if err := __VDLReadAnon_map_3(dec, &x.CompatData); err != nil {
				return err
			}
		case "ConvertData":
			if err := __VDLReadAnon_map_4(dec, &x.ConvertData); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_2(dec vdl.Decoder, x *map[byte][]*vdl.Value) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[byte][]*vdl.Value
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[byte][]*vdl.Value, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key byte
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			key = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem []*vdl.Value
		{
			if err := __VDLReadAnon_list_1(dec, &elem); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[byte][]*vdl.Value)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_3(dec vdl.Decoder, x *map[string][]*vdl.Type) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string][]*vdl.Type
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string][]*vdl.Type, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem []*vdl.Type
		{
			if err := __VDLReadAnon_list_5(dec, &elem); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string][]*vdl.Type)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_4(dec vdl.Decoder, x *map[string][]ConvertGroup) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string][]ConvertGroup
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string][]ConvertGroup, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem []ConvertGroup
		{
			if err := __VDLReadAnon_list_6(dec, &elem); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string][]ConvertGroup)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_list_5(dec vdl.Decoder, x *[]*vdl.Type) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]*vdl.Type, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem *vdl.Type
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if elem, err = dec.DecodeTypeObject(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLReadAnon_list_6(dec vdl.Decoder, x *[]ConvertGroup) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]ConvertGroup, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem ConvertGroup
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// Named Types
type NBool bool

func (NBool) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NBool"`
}) {
}

func (x NBool) VDLIsZero() bool {
	return bool(!x)
}

func (x NBool) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NBool)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeBool(bool(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NBool) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeBool()
	if err != nil {
		return err
	}
	*x = NBool(tmp)
	return dec.FinishValue()
}

type NString string

func (NString) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NString"`
}) {
}

func (x NString) VDLIsZero() bool {
	return x == ""
}

func (x NString) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NString)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(string(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NString) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeString()
	if err != nil {
		return err
	}
	*x = NString(tmp)
	return dec.FinishValue()
}

type NByteSlice []byte

func (NByteSlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByteSlice"`
}) {
}

func (x NByteSlice) VDLIsZero() bool {
	return len(x) == 0
}

func (x NByteSlice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NByteSlice)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeBytes([]byte(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NByteSlice) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	var bytes []byte
	if err := dec.DecodeBytes(-1, &bytes); err != nil {
		return err
	}
	*x = bytes
	return dec.FinishValue()
}

type NByteArray [4]byte

func (NByteArray) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByteArray"`
}) {
}

func (x NByteArray) VDLIsZero() bool {
	return x == NByteArray{}
}

func (x NByteArray) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NByteArray)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeBytes([]byte(x[:])); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NByteArray) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	bytes := x[:]
	if err := dec.DecodeBytes(4, &bytes); err != nil {
		return err
	}
	return dec.FinishValue()
}

type NByte byte

func (NByte) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByte"`
}) {
}

func (x NByte) VDLIsZero() bool {
	return x == 0
}

func (x NByte) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NByte)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NByte) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(8)
	if err != nil {
		return err
	}
	*x = NByte(tmp)
	return dec.FinishValue()
}

type NUint16 uint16

func (NUint16) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint16"`
}) {
}

func (x NUint16) VDLIsZero() bool {
	return x == 0
}

func (x NUint16) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUint16)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NUint16) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(16)
	if err != nil {
		return err
	}
	*x = NUint16(tmp)
	return dec.FinishValue()
}

type NUint32 uint32

func (NUint32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint32"`
}) {
}

func (x NUint32) VDLIsZero() bool {
	return x == 0
}

func (x NUint32) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUint32)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NUint32) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(32)
	if err != nil {
		return err
	}
	*x = NUint32(tmp)
	return dec.FinishValue()
}

type NUint64 uint64

func (NUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint64"`
}) {
}

func (x NUint64) VDLIsZero() bool {
	return x == 0
}

func (x NUint64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUint64)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NUint64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(64)
	if err != nil {
		return err
	}
	*x = NUint64(tmp)
	return dec.FinishValue()
}

type NInt8 int8

func (NInt8) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt8"`
}) {
}

func (x NInt8) VDLIsZero() bool {
	return x == 0
}

func (x NInt8) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NInt8)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeInt(int64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NInt8) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(8)
	if err != nil {
		return err
	}
	*x = NInt8(tmp)
	return dec.FinishValue()
}

type NInt16 int16

func (NInt16) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt16"`
}) {
}

func (x NInt16) VDLIsZero() bool {
	return x == 0
}

func (x NInt16) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NInt16)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeInt(int64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NInt16) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(16)
	if err != nil {
		return err
	}
	*x = NInt16(tmp)
	return dec.FinishValue()
}

type NInt32 int32

func (NInt32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt32"`
}) {
}

func (x NInt32) VDLIsZero() bool {
	return x == 0
}

func (x NInt32) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NInt32)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeInt(int64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NInt32) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(32)
	if err != nil {
		return err
	}
	*x = NInt32(tmp)
	return dec.FinishValue()
}

type NInt64 int64

func (NInt64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt64"`
}) {
}

func (x NInt64) VDLIsZero() bool {
	return x == 0
}

func (x NInt64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NInt64)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeInt(int64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NInt64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(64)
	if err != nil {
		return err
	}
	*x = NInt64(tmp)
	return dec.FinishValue()
}

type NFloat32 float32

func (NFloat32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NFloat32"`
}) {
}

func (x NFloat32) VDLIsZero() bool {
	return x == 0
}

func (x NFloat32) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NFloat32)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeFloat(float64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NFloat32) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeFloat(32)
	if err != nil {
		return err
	}
	*x = NFloat32(tmp)
	return dec.FinishValue()
}

type NFloat64 float64

func (NFloat64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NFloat64"`
}) {
}

func (x NFloat64) VDLIsZero() bool {
	return x == 0
}

func (x NFloat64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NFloat64)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeFloat(float64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NFloat64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeFloat(64)
	if err != nil {
		return err
	}
	*x = NFloat64(tmp)
	return dec.FinishValue()
}

type NArray2Uint64 [2]uint64

func (NArray2Uint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NArray2Uint64"`
}) {
}

func (x NArray2Uint64) VDLIsZero() bool {
	return x == NArray2Uint64{}
}

func (x NArray2Uint64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NArray2Uint64)(nil))); err != nil {
		return err
	}
	for i := 0; i < 2; i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NArray2Uint64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, done:%v index:%d len:%d %T)", done, index, len(*x), *x)
		case done:
			return dec.FinishValue()
		}
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if x[index], err = dec.DecodeUint(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		index++
	}
}

type NListUint64 []uint64

func (NListUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NListUint64"`
}) {
}

func (x NListUint64) VDLIsZero() bool {
	return len(x) == 0
}

func (x NListUint64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NListUint64)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NListUint64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(NListUint64, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem uint64
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if elem, err = dec.DecodeUint(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type NSetUint64 map[uint64]struct{}

func (NSetUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NSetUint64"`
}) {
}

func (x NSetUint64) VDLIsZero() bool {
	return len(x) == 0
}

func (x NSetUint64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NSetUint64)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NSetUint64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap NSetUint64
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(NSetUint64, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(NSetUint64)
		}
		tmpMap[key] = struct{}{}
	}
}

type NMapUint64String map[uint64]string

func (NMapUint64String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NMapUint64String"`
}) {
}

func (x NMapUint64String) VDLIsZero() bool {
	return len(x) == 0
}

func (x NMapUint64String) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NMapUint64String)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NMapUint64String) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap NMapUint64String
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(NMapUint64String, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(NMapUint64String)
		}
		tmpMap[key] = elem
	}
}

type NStruct struct {
	A bool
	B string
	C int64
}

func (NStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NStruct"`
}) {
}

func (x NStruct) VDLIsZero() bool {
	return x == NStruct{}
}

func (x NStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.A {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.A); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.B != "" {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.B); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.C != 0 {
		if err := enc.NextField("C"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.C); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NStruct) VDLRead(dec vdl.Decoder) error {
	*x = NStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.A, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "B":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.B, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "C":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.C, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type NEnum int

const (
	NEnumA NEnum = iota
	NEnumB
	NEnumC
)

// NEnumAll holds all labels for NEnum.
var NEnumAll = [...]NEnum{NEnumA, NEnumB, NEnumC}

// NEnumFromString creates a NEnum from a string label.
func NEnumFromString(label string) (x NEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *NEnum) Set(label string) error {
	switch label {
	case "A", "a":
		*x = NEnumA
		return nil
	case "B", "b":
		*x = NEnumB
		return nil
	case "C", "c":
		*x = NEnumC
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.NEnum", label)
}

// String returns the string label of x.
func (x NEnum) String() string {
	switch x {
	case NEnumA:
		return "A"
	case NEnumB:
		return "B"
	case NEnumC:
		return "C"
	}
	return ""
}

func (NEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NEnum"`
	Enum struct{ A, B, C string }
}) {
}

func (x NEnum) VDLIsZero() bool {
	return x == NEnumA
}

func (x NEnum) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NEnum)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NEnum) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type (
	// NUnion represents any single field of the NUnion union type.
	NUnion interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the NUnion union type.
		__VDLReflect(__NUnionReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// NUnionA represents field A of the NUnion union type.
	NUnionA struct{ Value bool }
	// NUnionB represents field B of the NUnion union type.
	NUnionB struct{ Value string }
	// NUnionC represents field C of the NUnion union type.
	NUnionC struct{ Value int64 }
	// __NUnionReflect describes the NUnion union type.
	__NUnionReflect struct {
		Name  string `vdl:"v.io/v23/vom/testdata/types.NUnion"`
		Type  NUnion
		Union struct {
			A NUnionA
			B NUnionB
			C NUnionC
		}
	}
)

func (x NUnionA) Index() int                   { return 0 }
func (x NUnionA) Interface() interface{}       { return x.Value }
func (x NUnionA) Name() string                 { return "A" }
func (x NUnionA) __VDLReflect(__NUnionReflect) {}

func (x NUnionB) Index() int                   { return 1 }
func (x NUnionB) Interface() interface{}       { return x.Value }
func (x NUnionB) Name() string                 { return "B" }
func (x NUnionB) __VDLReflect(__NUnionReflect) {}

func (x NUnionC) Index() int                   { return 2 }
func (x NUnionC) Interface() interface{}       { return x.Value }
func (x NUnionC) Name() string                 { return "C" }
func (x NUnionC) __VDLReflect(__NUnionReflect) {}

func (x NUnionA) VDLIsZero() bool {
	return !x.Value
}

func (x NUnionB) VDLIsZero() bool {
	return false
}

func (x NUnionC) VDLIsZero() bool {
	return false
}

func (x NUnionA) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("A"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.BoolType); err != nil {
		return err
	}
	if err := enc.EncodeBool(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x NUnionB) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("B"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.StringType); err != nil {
		return err
	}
	if err := enc.EncodeString(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x NUnionC) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("C"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.Int64Type); err != nil {
		return err
	}
	if err := enc.EncodeInt(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadNUnion(dec vdl.Decoder, x *NUnion) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "A":
		var field NUnionA
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeBool(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "B":
		var field NUnionB
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "C":
		var field NUnionC
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeInt(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

// Nested Custom Types
type MBool NBool

func (MBool) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MBool"`
}) {
}

func (x MBool) VDLIsZero() bool {
	return bool(!x)
}

func (x MBool) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MBool)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeBool(bool(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MBool) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeBool()
	if err != nil {
		return err
	}
	*x = MBool(tmp)
	return dec.FinishValue()
}

type MStruct struct {
	A bool
	B NBool
	C MBool
	D *NStruct
	E *vdl.Type
	F *vdl.Value
}

func (MStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MStruct"`
}) {
}

func (x MStruct) VDLIsZero() bool {
	if x.A {
		return false
	}
	if x.B {
		return false
	}
	if x.C {
		return false
	}
	if x.D != nil {
		return false
	}
	if x.E != nil && x.E != vdl.AnyType {
		return false
	}
	if x.F != nil && !x.F.VDLIsZero() {
		return false
	}
	return true
}

func (x MStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.A {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.A); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.B {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := x.B.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.C {
		if err := enc.NextField("C"); err != nil {
			return err
		}
		if err := x.C.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.D != nil {
		if err := enc.NextField("D"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()

		if err := x.D.VDLWrite(enc); err != nil {
			return err
		}

	}
	if x.E != nil && x.E != vdl.AnyType {
		if err := enc.NextField("E"); err != nil {
			return err
		}
		if err := x.E.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.F != nil && !x.F.VDLIsZero() {
		if err := enc.NextField("F"); err != nil {
			return err
		}
		if err := x.F.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MStruct) VDLRead(dec vdl.Decoder) error {
	*x = MStruct{
		E: vdl.AnyType,
		F: vdl.ZeroValue(vdl.AnyType),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.A, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "B":
			if err := x.B.VDLRead(dec); err != nil {
				return err
			}
		case "C":
			if err := x.C.VDLRead(dec); err != nil {
				return err
			}
		case "D":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.D), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.D, dec.Type())
				}
				x.D = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.D = new(NStruct)
				dec.IgnoreNextStartValue()
				if err := x.D.VDLRead(dec); err != nil {
					return err
				}
			}
		case "E":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.E, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "F":
			x.F = new(vdl.Value)
			if err := x.F.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type MList []NListUint64

func (MList) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MList"`
}) {
}

func (x MList) VDLIsZero() bool {
	return len(x) == 0
}

func (x MList) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MList)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MList) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(MList, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem NListUint64
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type MMap map[NFloat32]NListUint64

func (MMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MMap"`
}) {
}

func (x MMap) VDLIsZero() bool {
	return len(x) == 0
}

func (x MMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MMap)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MMap) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap MMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key NFloat32
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		var elem NListUint64
		{
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MMap)
		}
		tmpMap[key] = elem
	}
}

type MByteSlice []byte

func (MByteSlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MByteSlice"`
}) {
}

func (x MByteSlice) VDLIsZero() bool {
	return len(x) == 0
}

func (x MByteSlice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MByteSlice)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeBytes([]byte(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MByteSlice) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	var bytes []byte
	if err := dec.DecodeBytes(-1, &bytes); err != nil {
		return err
	}
	*x = bytes
	return dec.FinishValue()
}

type MInt8Slice []int8

func (MInt8Slice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MInt8Slice"`
}) {
}

func (x MInt8Slice) VDLIsZero() bool {
	return len(x) == 0
}

func (x MInt8Slice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MInt8Slice)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int8Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x[i])); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MInt8Slice) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(MInt8Slice, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem int8
		if err := dec.StartValue(); err != nil {
			return err
		}
		tmp, err := dec.DecodeInt(8)
		if err != nil {
			return err
		}
		elem = int8(tmp)
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// Recursive Type Definitions
type RecA []RecA

func (RecA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecA"`
}) {
}

func (x RecA) VDLIsZero() bool {
	return len(x) == 0
}

func (x RecA) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*RecA)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RecA) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(RecA, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem RecA
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type RecY []RecX

func (RecY) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecY"`
}) {
}

func (x RecY) VDLIsZero() bool {
	return len(x) == 0
}

func (x RecY) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*RecY)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RecY) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(RecY, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem RecX
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type RecX []RecY

func (RecX) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecX"`
}) {
}

func (x RecX) VDLIsZero() bool {
	return len(x) == 0
}

func (x RecX) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*RecX)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RecX) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(RecX, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem RecY
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec4 []Rec1

func (Rec4) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec4"`
}) {
}

func (x Rec4) VDLIsZero() bool {
	return len(x) == 0
}

func (x Rec4) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec4)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec4) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(Rec4, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec1
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec3 []Rec4

func (Rec3) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec3"`
}) {
}

func (x Rec3) VDLIsZero() bool {
	return len(x) == 0
}

func (x Rec3) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec3)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec3) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(Rec3, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec4
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec2 []Rec3

func (Rec2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec2"`
}) {
}

func (x Rec2) VDLIsZero() bool {
	return len(x) == 0
}

func (x Rec2) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec2)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec2) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(Rec2, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec3
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec1 []Rec2

func (Rec1) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1"`
}) {
}

func (x Rec1) VDLIsZero() bool {
	return len(x) == 0
}

func (x Rec1) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec1)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec1) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(Rec1, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec2
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type RecStruct struct {
	A *RecStruct
}

func (RecStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecStruct"`
}) {
}

func (x RecStruct) VDLIsZero() bool {
	return x == RecStruct{}
}

func (x RecStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*RecStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.A != nil {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()

		if err := x.A.VDLWrite(enc); err != nil {
			return err
		}

	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RecStruct) VDLRead(dec vdl.Decoder) error {
	*x = RecStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.A), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.A, dec.Type())
				}
				x.A = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.A = new(RecStruct)
				dec.IgnoreNextStartValue()
				if err := x.A.VDLRead(dec); err != nil {
					return err
				}
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Rec1234 struct {
	R1 Rec1
	R2 Rec2
	R3 Rec3
	R4 Rec4
}

func (Rec1234) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234"`
}) {
}

func (x Rec1234) VDLIsZero() bool {
	if len(x.R1) != 0 {
		return false
	}
	if len(x.R2) != 0 {
		return false
	}
	if len(x.R3) != 0 {
		return false
	}
	if len(x.R4) != 0 {
		return false
	}
	return true
}

func (x Rec1234) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec1234)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.R1) != 0 {
		if err := enc.NextField("R1"); err != nil {
			return err
		}
		if err := x.R1.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.R2) != 0 {
		if err := enc.NextField("R2"); err != nil {
			return err
		}
		if err := x.R2.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.R3) != 0 {
		if err := enc.NextField("R3"); err != nil {
			return err
		}
		if err := x.R3.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.R4) != 0 {
		if err := enc.NextField("R4"); err != nil {
			return err
		}
		if err := x.R4.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec1234) VDLRead(dec vdl.Decoder) error {
	*x = Rec1234{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "R1":
			if err := x.R1.VDLRead(dec); err != nil {
				return err
			}
		case "R2":
			if err := x.R2.VDLRead(dec); err != nil {
				return err
			}
		case "R3":
			if err := x.R3.VDLRead(dec); err != nil {
				return err
			}
		case "R4":
			if err := x.R4.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Rec1234A struct {
	A       []Rec1234A
	Rec1234 []Rec1234
}

func (Rec1234A) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234A"`
}) {
}

func (x Rec1234A) VDLIsZero() bool {
	if len(x.A) != 0 {
		return false
	}
	if len(x.Rec1234) != 0 {
		return false
	}
	return true
}

func (x Rec1234A) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec1234A)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.A) != 0 {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_7(enc, x.A); err != nil {
			return err
		}
	}
	if len(x.Rec1234) != 0 {
		if err := enc.NextField("Rec1234"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_8(enc, x.Rec1234); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_7(enc vdl.Encoder, x []Rec1234A) error {
	if err := enc.StartValue(vdl.TypeOf((*[]Rec1234A)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_8(enc vdl.Encoder, x []Rec1234) error {
	if err := enc.StartValue(vdl.TypeOf((*[]Rec1234)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec1234A) VDLRead(dec vdl.Decoder) error {
	*x = Rec1234A{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := __VDLReadAnon_list_7(dec, &x.A); err != nil {
				return err
			}
		case "Rec1234":
			if err := __VDLReadAnon_list_8(dec, &x.Rec1234); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_7(dec vdl.Decoder, x *[]Rec1234A) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]Rec1234A, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec1234A
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLReadAnon_list_8(dec vdl.Decoder, x *[]Rec1234) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]Rec1234, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec1234
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec1234B struct {
	B       []Rec1234B
	Rec1234 []Rec1234
}

func (Rec1234B) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234B"`
}) {
}

func (x Rec1234B) VDLIsZero() bool {
	if len(x.B) != 0 {
		return false
	}
	if len(x.Rec1234) != 0 {
		return false
	}
	return true
}

func (x Rec1234B) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec1234B)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.B) != 0 {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_9(enc, x.B); err != nil {
			return err
		}
	}
	if len(x.Rec1234) != 0 {
		if err := enc.NextField("Rec1234"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_8(enc, x.Rec1234); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_9(enc vdl.Encoder, x []Rec1234B) error {
	if err := enc.StartValue(vdl.TypeOf((*[]Rec1234B)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec1234B) VDLRead(dec vdl.Decoder) error {
	*x = Rec1234B{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "B":
			if err := __VDLReadAnon_list_9(dec, &x.B); err != nil {
				return err
			}
		case "Rec1234":
			if err := __VDLReadAnon_list_8(dec, &x.Rec1234); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_9(dec vdl.Decoder, x *[]Rec1234B) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]Rec1234B, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec1234B
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec1234All struct {
	A Rec1234A
	B Rec1234B
}

func (Rec1234All) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234All"`
}) {
}

func (x Rec1234All) VDLIsZero() bool {
	if !x.A.VDLIsZero() {
		return false
	}
	if !x.B.VDLIsZero() {
		return false
	}
	return true
}

func (x Rec1234All) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec1234All)(nil)).Elem()); err != nil {
		return err
	}
	if !x.A.VDLIsZero() {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := x.A.VDLWrite(enc); err != nil {
			return err
		}
	}
	if !x.B.VDLIsZero() {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := x.B.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec1234All) VDLRead(dec vdl.Decoder) error {
	*x = Rec1234All{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := x.A.VDLRead(dec); err != nil {
				return err
			}
		case "B":
			if err := x.B.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// Additional types for compatibility and conversion checks
type ListString []string

func (ListString) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ListString"`
}) {
}

func (x ListString) VDLIsZero() bool {
	return len(x) == 0
}

func (x ListString) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ListString)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ListString) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(ListString, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem string
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if elem, err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Array3String [3]string

func (Array3String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Array3String"`
}) {
}

func (x Array3String) VDLIsZero() bool {
	return x == Array3String{}
}

func (x Array3String) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Array3String)(nil))); err != nil {
		return err
	}
	for i := 0; i < 3; i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Array3String) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, done:%v index:%d len:%d %T)", done, index, len(*x), *x)
		case done:
			return dec.FinishValue()
		}
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if x[index], err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		index++
	}
}

type Array4String [4]string

func (Array4String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Array4String"`
}) {
}

func (x Array4String) VDLIsZero() bool {
	return x == Array4String{}
}

func (x Array4String) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Array4String)(nil))); err != nil {
		return err
	}
	for i := 0; i < 4; i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Array4String) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, done:%v index:%d len:%d %T)", done, index, len(*x), *x)
		case done:
			return dec.FinishValue()
		}
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if x[index], err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		index++
	}
}

type AbcStruct struct {
	A bool
	B string
	C int64
}

func (AbcStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AbcStruct"`
}) {
}

func (x AbcStruct) VDLIsZero() bool {
	return x == AbcStruct{}
}

func (x AbcStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AbcStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.A {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.A); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.B != "" {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.B); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.C != 0 {
		if err := enc.NextField("C"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.C); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AbcStruct) VDLRead(dec vdl.Decoder) error {
	*x = AbcStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.A, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "B":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.B, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "C":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.C, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type AdeStruct struct {
	A bool
	D *vdl.Value
	E *vdl.Type
}

func (AdeStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AdeStruct"`
}) {
}

func (x AdeStruct) VDLIsZero() bool {
	if x.A {
		return false
	}
	if x.D != nil && !x.D.VDLIsZero() {
		return false
	}
	if x.E != nil && x.E != vdl.AnyType {
		return false
	}
	return true
}

func (x AdeStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AdeStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.A {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.A); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.D != nil && !x.D.VDLIsZero() {
		if err := enc.NextField("D"); err != nil {
			return err
		}
		if err := x.D.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.E != nil && x.E != vdl.AnyType {
		if err := enc.NextField("E"); err != nil {
			return err
		}
		if err := x.E.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AdeStruct) VDLRead(dec vdl.Decoder) error {
	*x = AdeStruct{
		D: vdl.ZeroValue(vdl.AnyType),
		E: vdl.AnyType,
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.A, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "D":
			x.D = new(vdl.Value)
			if err := x.D.VDLRead(dec); err != nil {
				return err
			}
		case "E":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.E, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type XyzStruct struct {
	X bool
	Y MBool
	Z string
}

func (XyzStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.XyzStruct"`
}) {
}

func (x XyzStruct) VDLIsZero() bool {
	return x == XyzStruct{}
}

func (x XyzStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*XyzStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.X {
		if err := enc.NextField("X"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.X); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Y {
		if err := enc.NextField("Y"); err != nil {
			return err
		}
		if err := x.Y.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Z != "" {
		if err := enc.NextField("Z"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Z); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *XyzStruct) VDLRead(dec vdl.Decoder) error {
	*x = XyzStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "X":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.X, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Y":
			if err := x.Y.VDLRead(dec); err != nil {
				return err
			}
		case "Z":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Z, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type YzStruct struct {
	Y NBool
	Z NString
}

func (YzStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.YzStruct"`
}) {
}

func (x YzStruct) VDLIsZero() bool {
	return x == YzStruct{}
}

func (x YzStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*YzStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.Y {
		if err := enc.NextField("Y"); err != nil {
			return err
		}
		if err := x.Y.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Z != "" {
		if err := enc.NextField("Z"); err != nil {
			return err
		}
		if err := x.Z.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *YzStruct) VDLRead(dec vdl.Decoder) error {
	*x = YzStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Y":
			if err := x.Y.VDLRead(dec); err != nil {
				return err
			}
		case "Z":
			if err := x.Z.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type ZStruct struct {
	Z string
}

func (ZStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ZStruct"`
}) {
}

func (x ZStruct) VDLIsZero() bool {
	return x == ZStruct{}
}

func (x ZStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ZStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.Z != "" {
		if err := enc.NextField("Z"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Z); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ZStruct) VDLRead(dec vdl.Decoder) error {
	*x = ZStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Z":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Z, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type MapOnlyStruct struct {
	Key1 int64
	Key2 uint32
}

func (MapOnlyStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyStruct"`
}) {
}

func (x MapOnlyStruct) VDLIsZero() bool {
	return x == MapOnlyStruct{}
}

func (x MapOnlyStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlyStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.Key1 != 0 {
		if err := enc.NextField("Key1"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.Key1); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Key2 != 0 {
		if err := enc.NextField("Key2"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Key2)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlyStruct) VDLRead(dec vdl.Decoder) error {
	*x = MapOnlyStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Key1":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Key1, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Key2":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			x.Key2 = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type StructOnlyMap map[string]uint64

func (StructOnlyMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructOnlyMap"`
}) {
}

func (x StructOnlyMap) VDLIsZero() bool {
	return len(x) == 0
}

func (x StructOnlyMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*StructOnlyMap)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *StructOnlyMap) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap StructOnlyMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(StructOnlyMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(StructOnlyMap)
		}
		tmpMap[key] = elem
	}
}

type MapSetStruct struct {
	Feat bool
	Tire bool
	Eel  bool
}

func (MapSetStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapSetStruct"`
}) {
}

func (x MapSetStruct) VDLIsZero() bool {
	return x == MapSetStruct{}
}

func (x MapSetStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapSetStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.Feat {
		if err := enc.NextField("Feat"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Feat); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Tire {
		if err := enc.NextField("Tire"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Tire); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Eel {
		if err := enc.NextField("Eel"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Eel); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapSetStruct) VDLRead(dec vdl.Decoder) error {
	*x = MapSetStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Feat":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Feat, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Tire":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Tire, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Eel":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Eel, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type SetStructMap map[string]bool

func (SetStructMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetStructMap"`
}) {
}

func (x SetStructMap) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetStructMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetStructMap)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetStructMap) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap SetStructMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetStructMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem bool
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetStructMap)
		}
		tmpMap[key] = elem
	}
}

type MapStructSet map[string]struct{}

func (MapStructSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapStructSet"`
}) {
}

func (x MapStructSet) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapStructSet) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapStructSet)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapStructSet) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap MapStructSet
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapStructSet, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapStructSet)
		}
		tmpMap[key] = struct{}{}
	}
}

type SetOnlyMap map[float64]bool

func (SetOnlyMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyMap"`
}) {
}

func (x SetOnlyMap) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetOnlyMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetOnlyMap)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetOnlyMap) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap SetOnlyMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetOnlyMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key float64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem bool
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetOnlyMap)
		}
		tmpMap[key] = elem
	}
}

type SometimesSetMap map[float64]*vdl.Value

func (SometimesSetMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SometimesSetMap"`
}) {
}

func (x SometimesSetMap) VDLIsZero() bool {
	return len(x) == 0
}

func (x SometimesSetMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SometimesSetMap)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if elem == nil {
			if err := enc.NilValue(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := elem.VDLWrite(enc); err != nil {
				return err
			}
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SometimesSetMap) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap SometimesSetMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SometimesSetMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key float64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem *vdl.Value
		{
			elem = new(vdl.Value)
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SometimesSetMap)
		}
		tmpMap[key] = elem
	}
}

type MapOnlySet map[float64]struct{}

func (MapOnlySet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlySet"`
}) {
}

func (x MapOnlySet) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapOnlySet) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlySet)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlySet) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap MapOnlySet
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapOnlySet, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key float64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapOnlySet)
		}
		tmpMap[key] = struct{}{}
	}
}

type SetOnlyA map[bool]struct{}

func (SetOnlyA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyA"`
}) {
}

func (x SetOnlyA) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetOnlyA) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetOnlyA)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetOnlyA) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap SetOnlyA
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetOnlyA, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key bool
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetOnlyA)
		}
		tmpMap[key] = struct{}{}
	}
}

type SetOnlyA2 map[NBool]struct{}

func (SetOnlyA2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyA2"`
}) {
}

func (x SetOnlyA2) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetOnlyA2) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetOnlyA2)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetOnlyA2) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap SetOnlyA2
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetOnlyA2, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key NBool
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetOnlyA2)
		}
		tmpMap[key] = struct{}{}
	}
}

type SetOnlyB map[int16]struct{}

func (SetOnlyB) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyB"`
}) {
}

func (x SetOnlyB) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetOnlyB) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetOnlyB)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetOnlyB) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap SetOnlyB
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetOnlyB, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int16
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			key = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetOnlyB)
		}
		tmpMap[key] = struct{}{}
	}
}

type SetOnlyB2 map[NInt16]struct{}

func (SetOnlyB2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyB2"`
}) {
}

func (x SetOnlyB2) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetOnlyB2) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetOnlyB2)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetOnlyB2) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap SetOnlyB2
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetOnlyB2, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key NInt16
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetOnlyB2)
		}
		tmpMap[key] = struct{}{}
	}
}

type MapOnlyA map[uint32]uint32

func (MapOnlyA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyA"`
}) {
}

func (x MapOnlyA) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapOnlyA) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlyA)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(elem)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlyA) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap MapOnlyA
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapOnlyA, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			key = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem uint32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			elem = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapOnlyA)
		}
		tmpMap[key] = elem
	}
}

type MapOnlyA2 map[int64]float64

func (MapOnlyA2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyA2"`
}) {
}

func (x MapOnlyA2) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapOnlyA2) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlyA2)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlyA2) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap MapOnlyA2
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapOnlyA2, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem float64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapOnlyA2)
		}
		tmpMap[key] = elem
	}
}

type MapOnlyB map[bool]string

func (MapOnlyB) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyB"`
}) {
}

func (x MapOnlyB) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapOnlyB) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlyB)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlyB) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap MapOnlyB
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapOnlyB, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key bool
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapOnlyB)
		}
		tmpMap[key] = elem
	}
}

type MapOnlyB2 map[NBool]NString

func (MapOnlyB2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyB2"`
}) {
}

func (x MapOnlyB2) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapOnlyB2) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlyB2)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlyB2) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap MapOnlyB2
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapOnlyB2, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key NBool
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		var elem NString
		{
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapOnlyB2)
		}
		tmpMap[key] = elem
	}
}

type (
	// BdeUnion represents any single field of the BdeUnion union type.
	BdeUnion interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the BdeUnion union type.
		__VDLReflect(__BdeUnionReflect)
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// BdeUnionB represents field B of the BdeUnion union type.
	BdeUnionB struct{ Value string }
	// BdeUnionD represents field D of the BdeUnion union type.
	BdeUnionD struct{ Value *vdl.Value }
	// BdeUnionE represents field E of the BdeUnion union type.
	BdeUnionE struct{ Value *vdl.Type }
	// __BdeUnionReflect describes the BdeUnion union type.
	__BdeUnionReflect struct {
		Name  string `vdl:"v.io/v23/vom/testdata/types.BdeUnion"`
		Type  BdeUnion
		Union struct {
			B BdeUnionB
			D BdeUnionD
			E BdeUnionE
		}
	}
)

func (x BdeUnionB) Index() int                     { return 0 }
func (x BdeUnionB) Interface() interface{}         { return x.Value }
func (x BdeUnionB) Name() string                   { return "B" }
func (x BdeUnionB) __VDLReflect(__BdeUnionReflect) {}

func (x BdeUnionD) Index() int                     { return 1 }
func (x BdeUnionD) Interface() interface{}         { return x.Value }
func (x BdeUnionD) Name() string                   { return "D" }
func (x BdeUnionD) __VDLReflect(__BdeUnionReflect) {}

func (x BdeUnionE) Index() int                     { return 2 }
func (x BdeUnionE) Interface() interface{}         { return x.Value }
func (x BdeUnionE) Name() string                   { return "E" }
func (x BdeUnionE) __VDLReflect(__BdeUnionReflect) {}

func (x BdeUnionB) VDLIsZero() bool {
	return x.Value == ""
}

func (x BdeUnionD) VDLIsZero() bool {
	return false
}

func (x BdeUnionE) VDLIsZero() bool {
	return false
}

func (x BdeUnionB) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BdeUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("B"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.StringType); err != nil {
		return err
	}
	if err := enc.EncodeString(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x BdeUnionD) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BdeUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("D"); err != nil {
		return err
	}
	if x.Value == nil {
		if err := enc.NilValue(vdl.AnyType); err != nil {
			return err
		}
	} else {
		if err := x.Value.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x BdeUnionE) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BdeUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("E"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadBdeUnion(dec vdl.Decoder, x *BdeUnion) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "B":
		var field BdeUnionB
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "D":
		var field BdeUnionD
		field.Value = new(vdl.Value)
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "E":
		var field BdeUnionE
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeTypeObject(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type BrieEnum int

const (
	BrieEnumGlee BrieEnum = iota
	BrieEnumBrie
	BrieEnumThree
)

// BrieEnumAll holds all labels for BrieEnum.
var BrieEnumAll = [...]BrieEnum{BrieEnumGlee, BrieEnumBrie, BrieEnumThree}

// BrieEnumFromString creates a BrieEnum from a string label.
func BrieEnumFromString(label string) (x BrieEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *BrieEnum) Set(label string) error {
	switch label {
	case "Glee", "glee":
		*x = BrieEnumGlee
		return nil
	case "Brie", "brie":
		*x = BrieEnumBrie
		return nil
	case "Three", "three":
		*x = BrieEnumThree
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.BrieEnum", label)
}

// String returns the string label of x.
func (x BrieEnum) String() string {
	switch x {
	case BrieEnumGlee:
		return "Glee"
	case BrieEnumBrie:
		return "Brie"
	case BrieEnumThree:
		return "Three"
	}
	return ""
}

func (BrieEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.BrieEnum"`
	Enum struct{ Glee, Brie, Three string }
}) {
}

func (x BrieEnum) VDLIsZero() bool {
	return x == BrieEnumGlee
}

func (x BrieEnum) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BrieEnum)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BrieEnum) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type BeanEnum int

const (
	BeanEnumBean BeanEnum = iota
)

// BeanEnumAll holds all labels for BeanEnum.
var BeanEnumAll = [...]BeanEnum{BeanEnumBean}

// BeanEnumFromString creates a BeanEnum from a string label.
func BeanEnumFromString(label string) (x BeanEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *BeanEnum) Set(label string) error {
	switch label {
	case "Bean", "bean":
		*x = BeanEnumBean
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.BeanEnum", label)
}

// String returns the string label of x.
func (x BeanEnum) String() string {
	switch x {
	case BeanEnumBean:
		return "Bean"
	}
	return ""
}

func (BeanEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.BeanEnum"`
	Enum struct{ Bean string }
}) {
}

func (x BeanEnum) VDLIsZero() bool {
	return x == BeanEnumBean
}

func (x BeanEnum) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BeanEnum)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BeanEnum) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type FoodEnum int

const (
	FoodEnumBean FoodEnum = iota
	FoodEnumBrie
	FoodEnumCherry
)

// FoodEnumAll holds all labels for FoodEnum.
var FoodEnumAll = [...]FoodEnum{FoodEnumBean, FoodEnumBrie, FoodEnumCherry}

// FoodEnumFromString creates a FoodEnum from a string label.
func FoodEnumFromString(label string) (x FoodEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *FoodEnum) Set(label string) error {
	switch label {
	case "Bean", "bean":
		*x = FoodEnumBean
		return nil
	case "Brie", "brie":
		*x = FoodEnumBrie
		return nil
	case "Cherry", "cherry":
		*x = FoodEnumCherry
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.FoodEnum", label)
}

// String returns the string label of x.
func (x FoodEnum) String() string {
	switch x {
	case FoodEnumBean:
		return "Bean"
	case FoodEnumBrie:
		return "Brie"
	case FoodEnumCherry:
		return "Cherry"
	}
	return ""
}

func (FoodEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.FoodEnum"`
	Enum struct{ Bean, Brie, Cherry string }
}) {
}

func (x FoodEnum) VDLIsZero() bool {
	return x == FoodEnumBean
}

func (x FoodEnum) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*FoodEnum)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FoodEnum) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type StructAny struct {
	Any *vdl.Value
}

func (StructAny) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructAny"`
}) {
}

func (x StructAny) VDLIsZero() bool {
	if x.Any != nil && !x.Any.VDLIsZero() {
		return false
	}
	return true
}

func (x StructAny) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*StructAny)(nil)).Elem()); err != nil {
		return err
	}
	if x.Any != nil && !x.Any.VDLIsZero() {
		if err := enc.NextField("Any"); err != nil {
			return err
		}
		if err := x.Any.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *StructAny) VDLRead(dec vdl.Decoder) error {
	*x = StructAny{
		Any: vdl.ZeroValue(vdl.AnyType),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Any":
			x.Any = new(vdl.Value)
			if err := x.Any.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type StructMap struct {
	Map map[int64]int64
}

func (StructMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructMap"`
}) {
}

func (x StructMap) VDLIsZero() bool {
	if len(x.Map) != 0 {
		return false
	}
	return true
}

func (x StructMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*StructMap)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.Map) != 0 {
		if err := enc.NextField("Map"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_10(enc, x.Map); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_10(enc vdl.Encoder, x map[int64]int64) error {
	if err := enc.StartValue(vdl.TypeOf((*map[int64]int64)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *StructMap) VDLRead(dec vdl.Decoder) error {
	*x = StructMap{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Map":
			if err := __VDLReadAnon_map_10(dec, &x.Map); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_10(dec vdl.Decoder, x *map[int64]int64) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[int64]int64
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int64]int64, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem int64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[int64]int64)
		}
		tmpMap[key] = elem
	}
}

// Since the encoding changes if struct fields are zero values,
// test each of the kinds in a struct both as zero and non-zero values.
type StructManyTypes struct {
	Bool             bool
	AByte            byte
	Int16            int16
	Int32            int32
	Int64            int64
	Uint16           uint16
	Uint32           uint32
	Uint64           uint64
	String           string
	Bytes            []byte
	Float32          float32
	Float64          float64
	FoodEnum         FoodEnum
	NEnum            NEnum
	NListUint64      NListUint64
	NByteArray       NByteArray
	NArray2Uint64    NArray2Uint64
	NSetUint64       NSetUint64
	NMapUint64String NMapUint64String
	NStruct          NStruct
	NUnion           NUnion
	TypeObject       *vdl.Type
}

func (StructManyTypes) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructManyTypes"`
}) {
}

func (x StructManyTypes) VDLIsZero() bool {
	if x.Bool {
		return false
	}
	if x.AByte != 0 {
		return false
	}
	if x.Int16 != 0 {
		return false
	}
	if x.Int32 != 0 {
		return false
	}
	if x.Int64 != 0 {
		return false
	}
	if x.Uint16 != 0 {
		return false
	}
	if x.Uint32 != 0 {
		return false
	}
	if x.Uint64 != 0 {
		return false
	}
	if x.String != "" {
		return false
	}
	if len(x.Bytes) != 0 {
		return false
	}
	if x.Float32 != 0 {
		return false
	}
	if x.Float64 != 0 {
		return false
	}
	if x.FoodEnum != FoodEnumBean {
		return false
	}
	if x.NEnum != NEnumA {
		return false
	}
	if len(x.NListUint64) != 0 {
		return false
	}
	if x.NByteArray != (NByteArray{}) {
		return false
	}
	if x.NArray2Uint64 != (NArray2Uint64{}) {
		return false
	}
	if len(x.NSetUint64) != 0 {
		return false
	}
	if len(x.NMapUint64String) != 0 {
		return false
	}
	if x.NStruct != (NStruct{}) {
		return false
	}
	if x.NUnion != nil && !x.NUnion.VDLIsZero() {
		return false
	}
	if x.TypeObject != nil && x.TypeObject != vdl.AnyType {
		return false
	}
	return true
}

func (x StructManyTypes) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*StructManyTypes)(nil)).Elem()); err != nil {
		return err
	}
	if x.Bool {
		if err := enc.NextField("Bool"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Bool); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.AByte != 0 {
		if err := enc.NextField("AByte"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.AByte)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Int16 != 0 {
		if err := enc.NextField("Int16"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x.Int16)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Int32 != 0 {
		if err := enc.NextField("Int32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int32Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x.Int32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Int64 != 0 {
		if err := enc.NextField("Int64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.Int64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Uint16 != 0 {
		if err := enc.NextField("Uint16"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint16Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Uint16)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Uint32 != 0 {
		if err := enc.NextField("Uint32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Uint32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Uint64 != 0 {
		if err := enc.NextField("Uint64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(x.Uint64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.String != "" {
		if err := enc.NextField("String"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.String); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if len(x.Bytes) != 0 {
		if err := enc.NextField("Bytes"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*[]byte)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeBytes(x.Bytes); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Float32 != 0 {
		if err := enc.NextField("Float32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float32Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(float64(x.Float32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Float64 != 0 {
		if err := enc.NextField("Float64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(x.Float64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.FoodEnum != FoodEnumBean {
		if err := enc.NextField("FoodEnum"); err != nil {
			return err
		}
		if err := x.FoodEnum.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.NEnum != NEnumA {
		if err := enc.NextField("NEnum"); err != nil {
			return err
		}
		if err := x.NEnum.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.NListUint64) != 0 {
		if err := enc.NextField("NListUint64"); err != nil {
			return err
		}
		if err := x.NListUint64.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.NByteArray != (NByteArray{}) {
		if err := enc.NextField("NByteArray"); err != nil {
			return err
		}
		if err := x.NByteArray.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.NArray2Uint64 != (NArray2Uint64{}) {
		if err := enc.NextField("NArray2Uint64"); err != nil {
			return err
		}
		if err := x.NArray2Uint64.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.NSetUint64) != 0 {
		if err := enc.NextField("NSetUint64"); err != nil {
			return err
		}
		if err := x.NSetUint64.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.NMapUint64String) != 0 {
		if err := enc.NextField("NMapUint64String"); err != nil {
			return err
		}
		if err := x.NMapUint64String.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.NStruct != (NStruct{}) {
		if err := enc.NextField("NStruct"); err != nil {
			return err
		}
		if err := x.NStruct.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.NUnion != nil && !x.NUnion.VDLIsZero() {
		if err := enc.NextField("NUnion"); err != nil {
			return err
		}
		if err := x.NUnion.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.TypeObject != nil && x.TypeObject != vdl.AnyType {
		if err := enc.NextField("TypeObject"); err != nil {
			return err
		}
		if err := x.TypeObject.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *StructManyTypes) VDLRead(dec vdl.Decoder) error {
	*x = StructManyTypes{
		NUnion:     NUnionA{},
		TypeObject: vdl.AnyType,
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Bool":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Bool, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "AByte":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.AByte = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Int16":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			x.Int16 = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Int32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.Int32 = int32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Int64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Int64, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Uint16":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			x.Uint16 = uint16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Uint32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			x.Uint32 = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Uint64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Uint64, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "String":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.String, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Bytes":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if err := dec.DecodeBytes(-1, &x.Bytes); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Float32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			x.Float32 = float32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Float64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Float64, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "FoodEnum":
			if err := x.FoodEnum.VDLRead(dec); err != nil {
				return err
			}
		case "NEnum":
			if err := x.NEnum.VDLRead(dec); err != nil {
				return err
			}
		case "NListUint64":
			if err := x.NListUint64.VDLRead(dec); err != nil {
				return err
			}
		case "NByteArray":
			if err := x.NByteArray.VDLRead(dec); err != nil {
				return err
			}
		case "NArray2Uint64":
			if err := x.NArray2Uint64.VDLRead(dec); err != nil {
				return err
			}
		case "NSetUint64":
			if err := x.NSetUint64.VDLRead(dec); err != nil {
				return err
			}
		case "NMapUint64String":
			if err := x.NMapUint64String.VDLRead(dec); err != nil {
				return err
			}
		case "NStruct":
			if err := x.NStruct.VDLRead(dec); err != nil {
				return err
			}
		case "NUnion":
			if err := VDLReadNUnion(dec, &x.NUnion); err != nil {
				return err
			}
		case "TypeObject":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.TypeObject, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type AnySlice []*vdl.Value

func (AnySlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AnySlice"`
}) {
}

func (x AnySlice) VDLIsZero() bool {
	return len(x) == 0
}

func (x AnySlice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AnySlice)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if x[i] == nil {
			if err := enc.NilValue(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := x[i].VDLWrite(enc); err != nil {
				return err
			}
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AnySlice) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(AnySlice, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem *vdl.Value
		elem = new(vdl.Value)
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type LargeMessageType struct {
	Payload []byte
	Next    *LargeMessageType
}

func (LargeMessageType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.LargeMessageType"`
}) {
}

func (x LargeMessageType) VDLIsZero() bool {
	if len(x.Payload) != 0 {
		return false
	}
	if x.Next != nil {
		return false
	}
	return true
}

func (x LargeMessageType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*LargeMessageType)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.Payload) != 0 {
		if err := enc.NextField("Payload"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*[]byte)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeBytes(x.Payload); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Next != nil {
		if err := enc.NextField("Next"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()

		if err := x.Next.VDLWrite(enc); err != nil {
			return err
		}

	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *LargeMessageType) VDLRead(dec vdl.Decoder) error {
	*x = LargeMessageType{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Payload":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if err := dec.DecodeBytes(-1, &x.Payload); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Next":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.Next), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.Next, dec.Type())
				}
				x.Next = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.Next = new(LargeMessageType)
				dec.IgnoreNextStartValue()
				if err := x.Next.VDLRead(dec); err != nil {
					return err
				}
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type LargeAnyMessageType struct {
	Payload *vdl.Value
	Next    *LargeAnyMessageType
}

func (LargeAnyMessageType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.LargeAnyMessageType"`
}) {
}

func (x LargeAnyMessageType) VDLIsZero() bool {
	if x.Payload != nil && !x.Payload.VDLIsZero() {
		return false
	}
	if x.Next != nil {
		return false
	}
	return true
}

func (x LargeAnyMessageType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*LargeAnyMessageType)(nil)).Elem()); err != nil {
		return err
	}
	if x.Payload != nil && !x.Payload.VDLIsZero() {
		if err := enc.NextField("Payload"); err != nil {
			return err
		}
		if err := x.Payload.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Next != nil {
		if err := enc.NextField("Next"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()

		if err := x.Next.VDLWrite(enc); err != nil {
			return err
		}

	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *LargeAnyMessageType) VDLRead(dec vdl.Decoder) error {
	*x = LargeAnyMessageType{
		Payload: vdl.ZeroValue(vdl.AnyType),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Payload":
			x.Payload = new(vdl.Value)
			if err := x.Payload.VDLRead(dec); err != nil {
				return err
			}
		case "Next":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.Next), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.Next, dec.Type())
				}
				x.Next = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.Next = new(LargeAnyMessageType)
				dec.IgnoreNextStartValue()
				if err := x.Next.VDLRead(dec); err != nil {
					return err
				}
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*TestCase)(nil))
	vdl.Register((*ConvertGroup)(nil))
	vdl.Register((*VomdataStruct)(nil))
	vdl.Register((*NBool)(nil))
	vdl.Register((*NString)(nil))
	vdl.Register((*NByteSlice)(nil))
	vdl.Register((*NByteArray)(nil))
	vdl.Register((*NByte)(nil))
	vdl.Register((*NUint16)(nil))
	vdl.Register((*NUint32)(nil))
	vdl.Register((*NUint64)(nil))
	vdl.Register((*NInt8)(nil))
	vdl.Register((*NInt16)(nil))
	vdl.Register((*NInt32)(nil))
	vdl.Register((*NInt64)(nil))
	vdl.Register((*NFloat32)(nil))
	vdl.Register((*NFloat64)(nil))
	vdl.Register((*NArray2Uint64)(nil))
	vdl.Register((*NListUint64)(nil))
	vdl.Register((*NSetUint64)(nil))
	vdl.Register((*NMapUint64String)(nil))
	vdl.Register((*NStruct)(nil))
	vdl.Register((*NEnum)(nil))
	vdl.Register((*NUnion)(nil))
	vdl.Register((*MBool)(nil))
	vdl.Register((*MStruct)(nil))
	vdl.Register((*MList)(nil))
	vdl.Register((*MMap)(nil))
	vdl.Register((*MByteSlice)(nil))
	vdl.Register((*MInt8Slice)(nil))
	vdl.Register((*RecA)(nil))
	vdl.Register((*RecY)(nil))
	vdl.Register((*RecX)(nil))
	vdl.Register((*Rec4)(nil))
	vdl.Register((*Rec3)(nil))
	vdl.Register((*Rec2)(nil))
	vdl.Register((*Rec1)(nil))
	vdl.Register((*RecStruct)(nil))
	vdl.Register((*Rec1234)(nil))
	vdl.Register((*Rec1234A)(nil))
	vdl.Register((*Rec1234B)(nil))
	vdl.Register((*Rec1234All)(nil))
	vdl.Register((*ListString)(nil))
	vdl.Register((*Array3String)(nil))
	vdl.Register((*Array4String)(nil))
	vdl.Register((*AbcStruct)(nil))
	vdl.Register((*AdeStruct)(nil))
	vdl.Register((*XyzStruct)(nil))
	vdl.Register((*YzStruct)(nil))
	vdl.Register((*ZStruct)(nil))
	vdl.Register((*MapOnlyStruct)(nil))
	vdl.Register((*StructOnlyMap)(nil))
	vdl.Register((*MapSetStruct)(nil))
	vdl.Register((*SetStructMap)(nil))
	vdl.Register((*MapStructSet)(nil))
	vdl.Register((*SetOnlyMap)(nil))
	vdl.Register((*SometimesSetMap)(nil))
	vdl.Register((*MapOnlySet)(nil))
	vdl.Register((*SetOnlyA)(nil))
	vdl.Register((*SetOnlyA2)(nil))
	vdl.Register((*SetOnlyB)(nil))
	vdl.Register((*SetOnlyB2)(nil))
	vdl.Register((*MapOnlyA)(nil))
	vdl.Register((*MapOnlyA2)(nil))
	vdl.Register((*MapOnlyB)(nil))
	vdl.Register((*MapOnlyB2)(nil))
	vdl.Register((*BdeUnion)(nil))
	vdl.Register((*BrieEnum)(nil))
	vdl.Register((*BeanEnum)(nil))
	vdl.Register((*FoodEnum)(nil))
	vdl.Register((*StructAny)(nil))
	vdl.Register((*StructMap)(nil))
	vdl.Register((*StructManyTypes)(nil))
	vdl.Register((*AnySlice)(nil))
	vdl.Register((*LargeMessageType)(nil))
	vdl.Register((*LargeAnyMessageType)(nil))

	return struct{}{}
}
