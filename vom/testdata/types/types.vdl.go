// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: types

package types

import (
	"fmt"
	"reflect"
	"v.io/v23/vdl"
	"v.io/v23/vdl/vdlconv"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// TestCase represents an individual testcase for vom encoding and decoding.
type TestCase struct {
	Name       string     // Name of the testcase
	Value      *vdl.Value // Value to test
	TypeString string     // The string representation of the Type
	Hex        string     // Hex pattern representing vom encoding
	HexVersion string     // Hex pattern representing vom encoding of Version
	HexType    string     // Hex pattern representing vom encoding of Type
	HexValue   string     // Hex pattern representing vom encoding of Value
}

func (TestCase) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.TestCase"`
}) {
}

func (m *TestCase) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := m.Value == nil || (m.Value.Kind() == vdl.Any && m.Value.IsZero())
	if var7 {
		if err := fieldsTarget1.ZeroField("Value"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Value")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := vdl.FromValue(fieldTarget6, m.Value); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.TypeString == "")
	if var10 {
		if err := fieldsTarget1.ZeroField("TypeString"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("TypeString")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromString(string(m.TypeString), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.Hex == "")
	if var13 {
		if err := fieldsTarget1.ZeroField("Hex"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Hex")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromString(string(m.Hex), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var16 := (m.HexVersion == "")
	if var16 {
		if err := fieldsTarget1.ZeroField("HexVersion"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("HexVersion")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget15.FromString(string(m.HexVersion), tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var19 := (m.HexType == "")
	if var19 {
		if err := fieldsTarget1.ZeroField("HexType"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("HexType")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget18.FromString(string(m.HexType), tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
				return err
			}
		}
	}
	var22 := (m.HexValue == "")
	if var22 {
		if err := fieldsTarget1.ZeroField("HexValue"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("HexValue")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget21.FromString(string(m.HexValue), tt.NonOptional().Field(6).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TestCase) MakeVDLTarget() vdl.Target {
	return &TestCaseTarget{Value: m}
}

type TestCaseTarget struct {
	Value      *TestCase
	nameTarget vdl.StringTarget

	typeStringTarget vdl.StringTarget
	hexTarget        vdl.StringTarget
	hexVersionTarget vdl.StringTarget
	hexTypeTarget    vdl.StringTarget
	hexValueTarget   vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TestCaseTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*TestCase)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *TestCaseTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Value":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Value))
		return nil, target, err
	case "TypeString":
		t.typeStringTarget.Value = &t.Value.TypeString
		target, err := &t.typeStringTarget, error(nil)
		return nil, target, err
	case "Hex":
		t.hexTarget.Value = &t.Value.Hex
		target, err := &t.hexTarget, error(nil)
		return nil, target, err
	case "HexVersion":
		t.hexVersionTarget.Value = &t.Value.HexVersion
		target, err := &t.hexVersionTarget, error(nil)
		return nil, target, err
	case "HexType":
		t.hexTypeTarget.Value = &t.Value.HexType
		target, err := &t.hexTypeTarget, error(nil)
		return nil, target, err
	case "HexValue":
		t.hexValueTarget.Value = &t.Value.HexValue
		target, err := &t.hexValueTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *TestCaseTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TestCaseTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Value":
		t.Value.Value = vdl.ZeroValue(vdl.AnyType)
		return nil
	case "TypeString":
		t.Value.TypeString = ""
		return nil
	case "Hex":
		t.Value.Hex = ""
		return nil
	case "HexVersion":
		t.Value.HexVersion = ""
		return nil
	case "HexType":
		t.Value.HexType = ""
		return nil
	case "HexValue":
		t.Value.HexValue = ""
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *TestCaseTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x TestCase) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if x.Value != nil && !x.Value.VDLIsZero() {
		return false
	}
	if x.TypeString != "" {
		return false
	}
	if x.Hex != "" {
		return false
	}
	if x.HexVersion != "" {
		return false
	}
	if x.HexType != "" {
		return false
	}
	if x.HexValue != "" {
		return false
	}
	return true
}

func (x TestCase) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*TestCase)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Value != nil && !x.Value.VDLIsZero() {
		if err := enc.NextField("Value"); err != nil {
			return err
		}
		if err := x.Value.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.TypeString != "" {
		if err := enc.NextField("TypeString"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.TypeString); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Hex != "" {
		if err := enc.NextField("Hex"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Hex); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.HexVersion != "" {
		if err := enc.NextField("HexVersion"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.HexVersion); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.HexType != "" {
		if err := enc.NextField("HexType"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.HexType); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.HexValue != "" {
		if err := enc.NextField("HexValue"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.HexValue); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *TestCase) VDLRead(dec vdl.Decoder) error {
	*x = TestCase{
		Value: vdl.ZeroValue(vdl.AnyType),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Value":
			x.Value = new(vdl.Value)
			if err := x.Value.VDLRead(dec); err != nil {
				return err
			}
		case "TypeString":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.TypeString, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Hex":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Hex, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "HexVersion":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.HexVersion, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "HexType":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.HexType, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "HexValue":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.HexValue, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// vomdata config types
type ConvertGroup struct {
	Name        string
	PrimaryType *vdl.Type
	Values      []*vdl.Value
}

func (ConvertGroup) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ConvertGroup"`
}) {
}

func (m *ConvertGroup) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.PrimaryType == nil || m.PrimaryType == vdl.AnyType)
	if var7 {
		if err := fieldsTarget1.ZeroField("PrimaryType"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("PrimaryType")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			typeObjectVal8 := m.PrimaryType
			if typeObjectVal8 == nil {
				typeObjectVal8 = vdl.AnyType
			}
			if err := fieldTarget6.FromTypeObject(typeObjectVal8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var var11 bool
	if len(m.Values) == 0 {
		var11 = true
	}
	if var11 {
		if err := fieldsTarget1.ZeroField("Values"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("Values")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget12, err := fieldTarget10.StartList(tt.NonOptional().Field(2).Type, len(m.Values))
			if err != nil {
				return err
			}
			for i, elem14 := range m.Values {
				elemTarget13, err := listTarget12.StartElem(i)
				if err != nil {
					return err
				}

				if err := vdl.FromValue(elemTarget13, elem14); err != nil {
					return err
				}
				if err := listTarget12.FinishElem(elemTarget13); err != nil {
					return err
				}
			}
			if err := fieldTarget10.FinishList(listTarget12); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConvertGroup) MakeVDLTarget() vdl.Target {
	return &ConvertGroupTarget{Value: m}
}

type ConvertGroupTarget struct {
	Value             *ConvertGroup
	nameTarget        vdl.StringTarget
	primaryTypeTarget vdl.TypeObjectTarget
	valuesTarget      __VDLTarget1_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConvertGroupTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConvertGroup)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConvertGroupTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "PrimaryType":
		t.primaryTypeTarget.Value = &t.Value.PrimaryType
		target, err := &t.primaryTypeTarget, error(nil)
		return nil, target, err
	case "Values":
		t.valuesTarget.Value = &t.Value.Values
		target, err := &t.valuesTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ConvertGroupTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConvertGroupTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "PrimaryType":
		t.Value.PrimaryType = vdl.AnyType
		return nil
	case "Values":
		t.Value.Values = []*vdl.Value(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ConvertGroupTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []*vdl.Value
type __VDLTarget1_list struct {
	Value *[]*vdl.Value

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]*vdl.Value)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vdl.Value, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x ConvertGroup) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if x.PrimaryType != nil && x.PrimaryType != vdl.AnyType {
		return false
	}
	if len(x.Values) != 0 {
		return false
	}
	return true
}

func (x ConvertGroup) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ConvertGroup)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.PrimaryType != nil && x.PrimaryType != vdl.AnyType {
		if err := enc.NextField("PrimaryType"); err != nil {
			return err
		}
		if err := x.PrimaryType.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.Values) != 0 {
		if err := enc.NextField("Values"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_1(enc, x.Values); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_1(enc vdl.Encoder, x []*vdl.Value) error {
	if err := enc.StartValue(vdl.TypeOf((*[]*vdl.Value)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if x[i] == nil {
			if err := enc.NilValue(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := x[i].VDLWrite(enc); err != nil {
				return err
			}
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ConvertGroup) VDLRead(dec vdl.Decoder) error {
	*x = ConvertGroup{
		PrimaryType: vdl.AnyType,
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "PrimaryType":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.PrimaryType, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Values":
			if err := __VDLReadAnon_list_1(dec, &x.Values); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_1(dec vdl.Decoder, x *[]*vdl.Value) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]*vdl.Value, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem *vdl.Value
		elem = new(vdl.Value)
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type VomdataStruct struct {
	EncodeDecodeData map[byte][]*vdl.Value // map from min required VOM version to test values
	CompatData       map[string][]*vdl.Type
	ConvertData      map[string][]ConvertGroup
}

func (VomdataStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.VomdataStruct"`
}) {
}

func (m *VomdataStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.EncodeDecodeData) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("EncodeDecodeData"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("EncodeDecodeData")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget5, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.EncodeDecodeData))
			if err != nil {
				return err
			}
			for key7, value9 := range m.EncodeDecodeData {
				keyTarget6, err := mapTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromUint(uint64(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				valueTarget8, err := mapTarget5.FinishKeyStartField(keyTarget6)
				if err != nil {
					return err
				}

				listTarget10, err := valueTarget8.StartList(tt.NonOptional().Field(0).Type.Elem(), len(value9))
				if err != nil {
					return err
				}
				for i, elem12 := range value9 {
					elemTarget11, err := listTarget10.StartElem(i)
					if err != nil {
						return err
					}

					if err := vdl.FromValue(elemTarget11, elem12); err != nil {
						return err
					}
					if err := listTarget10.FinishElem(elemTarget11); err != nil {
						return err
					}
				}
				if err := valueTarget8.FinishList(listTarget10); err != nil {
					return err
				}
				if err := mapTarget5.FinishField(keyTarget6, valueTarget8); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishMap(mapTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var15 bool
	if len(m.CompatData) == 0 {
		var15 = true
	}
	if var15 {
		if err := fieldsTarget1.ZeroField("CompatData"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("CompatData")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget16, err := fieldTarget14.StartMap(tt.NonOptional().Field(1).Type, len(m.CompatData))
			if err != nil {
				return err
			}
			for key18, value20 := range m.CompatData {
				keyTarget17, err := mapTarget16.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget17.FromString(string(key18), tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				valueTarget19, err := mapTarget16.FinishKeyStartField(keyTarget17)
				if err != nil {
					return err
				}

				listTarget21, err := valueTarget19.StartList(tt.NonOptional().Field(1).Type.Elem(), len(value20))
				if err != nil {
					return err
				}
				for i, elem23 := range value20 {
					elemTarget22, err := listTarget21.StartElem(i)
					if err != nil {
						return err
					}
					typeObjectVal24 := elem23
					if typeObjectVal24 == nil {
						typeObjectVal24 = vdl.AnyType
					}
					if err := elemTarget22.FromTypeObject(typeObjectVal24); err != nil {
						return err
					}
					if err := listTarget21.FinishElem(elemTarget22); err != nil {
						return err
					}
				}
				if err := valueTarget19.FinishList(listTarget21); err != nil {
					return err
				}
				if err := mapTarget16.FinishField(keyTarget17, valueTarget19); err != nil {
					return err
				}
			}
			if err := fieldTarget14.FinishMap(mapTarget16); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
				return err
			}
		}
	}
	var var27 bool
	if len(m.ConvertData) == 0 {
		var27 = true
	}
	if var27 {
		if err := fieldsTarget1.ZeroField("ConvertData"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget25, fieldTarget26, err := fieldsTarget1.StartField("ConvertData")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget28, err := fieldTarget26.StartMap(tt.NonOptional().Field(2).Type, len(m.ConvertData))
			if err != nil {
				return err
			}
			for key30, value32 := range m.ConvertData {
				keyTarget29, err := mapTarget28.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget29.FromString(string(key30), tt.NonOptional().Field(2).Type.Key()); err != nil {
					return err
				}
				valueTarget31, err := mapTarget28.FinishKeyStartField(keyTarget29)
				if err != nil {
					return err
				}

				listTarget33, err := valueTarget31.StartList(tt.NonOptional().Field(2).Type.Elem(), len(value32))
				if err != nil {
					return err
				}
				for i, elem35 := range value32 {
					elemTarget34, err := listTarget33.StartElem(i)
					if err != nil {
						return err
					}

					if err := elem35.FillVDLTarget(elemTarget34, tt.NonOptional().Field(2).Type.Elem().Elem()); err != nil {
						return err
					}
					if err := listTarget33.FinishElem(elemTarget34); err != nil {
						return err
					}
				}
				if err := valueTarget31.FinishList(listTarget33); err != nil {
					return err
				}
				if err := mapTarget28.FinishField(keyTarget29, valueTarget31); err != nil {
					return err
				}
			}
			if err := fieldTarget26.FinishMap(mapTarget28); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget25, fieldTarget26); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *VomdataStruct) MakeVDLTarget() vdl.Target {
	return &VomdataStructTarget{Value: m}
}

type VomdataStructTarget struct {
	Value                  *VomdataStruct
	encodeDecodeDataTarget __VDLTarget2_map
	compatDataTarget       __VDLTarget3_map
	convertDataTarget      __VDLTarget4_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *VomdataStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*VomdataStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *VomdataStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "EncodeDecodeData":
		t.encodeDecodeDataTarget.Value = &t.Value.EncodeDecodeData
		target, err := &t.encodeDecodeDataTarget, error(nil)
		return nil, target, err
	case "CompatData":
		t.compatDataTarget.Value = &t.Value.CompatData
		target, err := &t.compatDataTarget, error(nil)
		return nil, target, err
	case "ConvertData":
		t.convertDataTarget.Value = &t.Value.ConvertData
		target, err := &t.convertDataTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *VomdataStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *VomdataStructTarget) ZeroField(name string) error {
	switch name {
	case "EncodeDecodeData":
		t.Value.EncodeDecodeData = map[byte][]*vdl.Value(nil)
		return nil
	case "CompatData":
		t.Value.CompatData = map[string][]*vdl.Type(nil)
		return nil
	case "ConvertData":
		t.Value.ConvertData = map[string][]ConvertGroup(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *VomdataStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[byte][]*vdl.Value
type __VDLTarget2_map struct {
	Value      *map[byte][]*vdl.Value
	currKey    byte
	currElem   []*vdl.Value
	keyTarget  vdl.ByteTarget
	elemTarget __VDLTarget1_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget2_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[byte][]*vdl.Value)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[byte][]*vdl.Value)
	return t, nil
}
func (t *__VDLTarget2_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = byte(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []*vdl.Value(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget2_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[string][]*vdl.Type
type __VDLTarget3_map struct {
	Value      *map[string][]*vdl.Type
	currKey    string
	currElem   []*vdl.Type
	keyTarget  vdl.StringTarget
	elemTarget __VDLTarget5_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget3_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string][]*vdl.Type)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string][]*vdl.Type)
	return t, nil
}
func (t *__VDLTarget3_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []*vdl.Type(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget3_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []*vdl.Type
type __VDLTarget5_list struct {
	Value      *[]*vdl.Type
	elemTarget vdl.TypeObjectTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget5_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]*vdl.Type)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vdl.Type, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget5_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget5_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// map[string][]ConvertGroup
type __VDLTarget4_map struct {
	Value      *map[string][]ConvertGroup
	currKey    string
	currElem   []ConvertGroup
	keyTarget  vdl.StringTarget
	elemTarget __VDLTarget6_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget4_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string][]ConvertGroup)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string][]ConvertGroup)
	return t, nil
}
func (t *__VDLTarget4_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []ConvertGroup(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget4_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []ConvertGroup
type __VDLTarget6_list struct {
	Value      *[]ConvertGroup
	elemTarget ConvertGroupTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget6_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]ConvertGroup)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]ConvertGroup, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget6_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget6_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget6_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x VomdataStruct) VDLIsZero() bool {
	if len(x.EncodeDecodeData) != 0 {
		return false
	}
	if len(x.CompatData) != 0 {
		return false
	}
	if len(x.ConvertData) != 0 {
		return false
	}
	return true
}

func (x VomdataStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*VomdataStruct)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.EncodeDecodeData) != 0 {
		if err := enc.NextField("EncodeDecodeData"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_2(enc, x.EncodeDecodeData); err != nil {
			return err
		}
	}
	if len(x.CompatData) != 0 {
		if err := enc.NextField("CompatData"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_3(enc, x.CompatData); err != nil {
			return err
		}
	}
	if len(x.ConvertData) != 0 {
		if err := enc.NextField("ConvertData"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_4(enc, x.ConvertData); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_2(enc vdl.Encoder, x map[byte][]*vdl.Value) error {
	if err := enc.StartValue(vdl.TypeOf((*map[byte][]*vdl.Value)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_1(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_3(enc vdl.Encoder, x map[string][]*vdl.Type) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string][]*vdl.Type)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_5(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_4(enc vdl.Encoder, x map[string][]ConvertGroup) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string][]ConvertGroup)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_6(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_5(enc vdl.Encoder, x []*vdl.Type) error {
	if err := enc.StartValue(vdl.TypeOf((*[]*vdl.Type)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_6(enc vdl.Encoder, x []ConvertGroup) error {
	if err := enc.StartValue(vdl.TypeOf((*[]ConvertGroup)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *VomdataStruct) VDLRead(dec vdl.Decoder) error {
	*x = VomdataStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "EncodeDecodeData":
			if err := __VDLReadAnon_map_2(dec, &x.EncodeDecodeData); err != nil {
				return err
			}
		case "CompatData":
			if err := __VDLReadAnon_map_3(dec, &x.CompatData); err != nil {
				return err
			}
		case "ConvertData":
			if err := __VDLReadAnon_map_4(dec, &x.ConvertData); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_2(dec vdl.Decoder, x *map[byte][]*vdl.Value) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[byte][]*vdl.Value
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[byte][]*vdl.Value, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key byte
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			key = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem []*vdl.Value
		{
			if err := __VDLReadAnon_list_1(dec, &elem); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[byte][]*vdl.Value)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_3(dec vdl.Decoder, x *map[string][]*vdl.Type) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string][]*vdl.Type
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string][]*vdl.Type, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem []*vdl.Type
		{
			if err := __VDLReadAnon_list_5(dec, &elem); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string][]*vdl.Type)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_4(dec vdl.Decoder, x *map[string][]ConvertGroup) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string][]ConvertGroup
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string][]ConvertGroup, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem []ConvertGroup
		{
			if err := __VDLReadAnon_list_6(dec, &elem); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string][]ConvertGroup)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_list_5(dec vdl.Decoder, x *[]*vdl.Type) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]*vdl.Type, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem *vdl.Type
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if elem, err = dec.DecodeTypeObject(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLReadAnon_list_6(dec vdl.Decoder, x *[]ConvertGroup) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]ConvertGroup, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem ConvertGroup
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// Named Types
type NBool bool

func (NBool) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NBool"`
}) {
}

func (m *NBool) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBool(bool((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NBool) MakeVDLTarget() vdl.Target {
	return &NBoolTarget{Value: m}
}

type NBoolTarget struct {
	Value *NBool
	vdl.TargetBase
}

func (t *NBoolTarget) FromBool(src bool, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NBool)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = NBool(src)

	return nil
}

func (x NBool) VDLIsZero() bool {
	return bool(!x)
}

func (x NBool) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NBool)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeBool(bool(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NBool) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeBool()
	if err != nil {
		return err
	}
	*x = NBool(tmp)
	return dec.FinishValue()
}

type NString string

func (NString) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NString"`
}) {
}

func (m *NString) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromString(string((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NString) MakeVDLTarget() vdl.Target {
	return &NStringTarget{Value: m}
}

type NStringTarget struct {
	Value *NString
	vdl.TargetBase
}

func (t *NStringTarget) FromString(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NString)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = NString(src)

	return nil
}

func (x NString) VDLIsZero() bool {
	return x == ""
}

func (x NString) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NString)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(string(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NString) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeString()
	if err != nil {
		return err
	}
	*x = NString(tmp)
	return dec.FinishValue()
}

type NByteSlice []byte

func (NByteSlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByteSlice"`
}) {
}

func (m *NByteSlice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBytes([]byte((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NByteSlice) MakeVDLTarget() vdl.Target {
	return &NByteSliceTarget{Value: m}
}

type NByteSliceTarget struct {
	Value *NByteSlice
	vdl.TargetBase
}

func (t *NByteSliceTarget) FromBytes(src []byte, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NByteSlice)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if len(src) == 0 {
		*t.Value = nil
	} else {
		*t.Value = make([]byte, len(src))
		copy(*t.Value, src)
	}

	return nil
}

func (x NByteSlice) VDLIsZero() bool {
	return len(x) == 0
}

func (x NByteSlice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NByteSlice)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeBytes([]byte(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NByteSlice) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	var bytes []byte
	if err := dec.DecodeBytes(-1, &bytes); err != nil {
		return err
	}
	*x = bytes
	return dec.FinishValue()
}

type NByteArray [4]byte

func (NByteArray) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByteArray"`
}) {
}

func (m *NByteArray) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBytes([]byte((*m)[:]), tt); err != nil {
		return err
	}
	return nil
}

func (m *NByteArray) MakeVDLTarget() vdl.Target {
	return &NByteArrayTarget{Value: m}
}

type NByteArrayTarget struct {
	Value *NByteArray
	vdl.TargetBase
}

func (t *NByteArrayTarget) FromBytes(src []byte, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NByteArray)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	copy((*t.Value)[:], src)

	return nil
}

func (x NByteArray) VDLIsZero() bool {
	return x == NByteArray{}
}

func (x NByteArray) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NByteArray)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeBytes([]byte(x[:])); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NByteArray) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	bytes := x[:]
	if err := dec.DecodeBytes(4, &bytes); err != nil {
		return err
	}
	return dec.FinishValue()
}

type NByte byte

func (NByte) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NByte"`
}) {
}

func (m *NByte) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NByte) MakeVDLTarget() vdl.Target {
	return &NByteTarget{Value: m}
}

type NByteTarget struct {
	Value *NByte
	vdl.TargetBase
}

func (t *NByteTarget) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NByte(val)

	return nil
}
func (t *NByteTarget) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NByte(val)

	return nil
}
func (t *NByteTarget) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint8(src)
	if err != nil {
		return err
	}
	*t.Value = NByte(val)

	return nil
}

func (x NByte) VDLIsZero() bool {
	return x == 0
}

func (x NByte) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NByte)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NByte) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(8)
	if err != nil {
		return err
	}
	*x = NByte(tmp)
	return dec.FinishValue()
}

type NUint16 uint16

func (NUint16) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint16"`
}) {
}

func (m *NUint16) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NUint16) MakeVDLTarget() vdl.Target {
	return &NUint16Target{Value: m}
}

type NUint16Target struct {
	Value *NUint16
	vdl.TargetBase
}

func (t *NUint16Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NUint16(val)

	return nil
}
func (t *NUint16Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NUint16(val)

	return nil
}
func (t *NUint16Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint16(src)
	if err != nil {
		return err
	}
	*t.Value = NUint16(val)

	return nil
}

func (x NUint16) VDLIsZero() bool {
	return x == 0
}

func (x NUint16) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUint16)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NUint16) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(16)
	if err != nil {
		return err
	}
	*x = NUint16(tmp)
	return dec.FinishValue()
}

type NUint32 uint32

func (NUint32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint32"`
}) {
}

func (m *NUint32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NUint32) MakeVDLTarget() vdl.Target {
	return &NUint32Target{Value: m}
}

type NUint32Target struct {
	Value *NUint32
	vdl.TargetBase
}

func (t *NUint32Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NUint32(val)

	return nil
}
func (t *NUint32Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NUint32(val)

	return nil
}
func (t *NUint32Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint32(src)
	if err != nil {
		return err
	}
	*t.Value = NUint32(val)

	return nil
}

func (x NUint32) VDLIsZero() bool {
	return x == 0
}

func (x NUint32) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUint32)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NUint32) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(32)
	if err != nil {
		return err
	}
	*x = NUint32(tmp)
	return dec.FinishValue()
}

type NUint64 uint64

func (NUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NUint64"`
}) {
}

func (m *NUint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromUint(uint64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NUint64) MakeVDLTarget() vdl.Target {
	return &NUint64Target{Value: m}
}

type NUint64Target struct {
	Value *NUint64
	vdl.TargetBase
}

func (t *NUint64Target) FromUint(src uint64, tt *vdl.Type) error {

	*t.Value = NUint64(src)

	return nil
}
func (t *NUint64Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = NUint64(val)

	return nil
}
func (t *NUint64Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToUint64(src)
	if err != nil {
		return err
	}
	*t.Value = NUint64(val)

	return nil
}

func (x NUint64) VDLIsZero() bool {
	return x == 0
}

func (x NUint64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUint64)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeUint(uint64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NUint64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeUint(64)
	if err != nil {
		return err
	}
	*x = NUint64(tmp)
	return dec.FinishValue()
}

type NInt8 int8

func (NInt8) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt8"`
}) {
}

func (m *NInt8) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NInt8) MakeVDLTarget() vdl.Target {
	return &NInt8Target{Value: m}
}

type NInt8Target struct {
	Value *NInt8
	vdl.TargetBase
}

func (t *NInt8Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NInt8(val)

	return nil
}
func (t *NInt8Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NInt8(val)

	return nil
}
func (t *NInt8Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt8(src)
	if err != nil {
		return err
	}
	*t.Value = NInt8(val)

	return nil
}

func (x NInt8) VDLIsZero() bool {
	return x == 0
}

func (x NInt8) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NInt8)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeInt(int64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NInt8) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(8)
	if err != nil {
		return err
	}
	*x = NInt8(tmp)
	return dec.FinishValue()
}

type NInt16 int16

func (NInt16) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt16"`
}) {
}

func (m *NInt16) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NInt16) MakeVDLTarget() vdl.Target {
	return &NInt16Target{Value: m}
}

type NInt16Target struct {
	Value *NInt16
	vdl.TargetBase
}

func (t *NInt16Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NInt16(val)

	return nil
}
func (t *NInt16Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NInt16(val)

	return nil
}
func (t *NInt16Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt16(src)
	if err != nil {
		return err
	}
	*t.Value = NInt16(val)

	return nil
}

func (x NInt16) VDLIsZero() bool {
	return x == 0
}

func (x NInt16) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NInt16)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeInt(int64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NInt16) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(16)
	if err != nil {
		return err
	}
	*x = NInt16(tmp)
	return dec.FinishValue()
}

type NInt32 int32

func (NInt32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt32"`
}) {
}

func (m *NInt32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NInt32) MakeVDLTarget() vdl.Target {
	return &NInt32Target{Value: m}
}

type NInt32Target struct {
	Value *NInt32
	vdl.TargetBase
}

func (t *NInt32Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NInt32(val)

	return nil
}
func (t *NInt32Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NInt32(val)

	return nil
}
func (t *NInt32Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt32(src)
	if err != nil {
		return err
	}
	*t.Value = NInt32(val)

	return nil
}

func (x NInt32) VDLIsZero() bool {
	return x == 0
}

func (x NInt32) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NInt32)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeInt(int64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NInt32) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(32)
	if err != nil {
		return err
	}
	*x = NInt32(tmp)
	return dec.FinishValue()
}

type NInt64 int64

func (NInt64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NInt64"`
}) {
}

func (m *NInt64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromInt(int64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NInt64) MakeVDLTarget() vdl.Target {
	return &NInt64Target{Value: m}
}

type NInt64Target struct {
	Value *NInt64
	vdl.TargetBase
}

func (t *NInt64Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToInt64(src)
	if err != nil {
		return err
	}
	*t.Value = NInt64(val)

	return nil
}
func (t *NInt64Target) FromInt(src int64, tt *vdl.Type) error {

	*t.Value = NInt64(src)

	return nil
}
func (t *NInt64Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToInt64(src)
	if err != nil {
		return err
	}
	*t.Value = NInt64(val)

	return nil
}

func (x NInt64) VDLIsZero() bool {
	return x == 0
}

func (x NInt64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NInt64)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeInt(int64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NInt64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeInt(64)
	if err != nil {
		return err
	}
	*x = NInt64(tmp)
	return dec.FinishValue()
}

type NFloat32 float32

func (NFloat32) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NFloat32"`
}) {
}

func (m *NFloat32) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromFloat(float64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NFloat32) MakeVDLTarget() vdl.Target {
	return &NFloat32Target{Value: m}
}

type NFloat32Target struct {
	Value *NFloat32
	vdl.TargetBase
}

func (t *NFloat32Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat32(val)

	return nil
}
func (t *NFloat32Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat32(val)

	return nil
}
func (t *NFloat32Target) FromFloat(src float64, tt *vdl.Type) error {

	val, err := vdlconv.Float64ToFloat32(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat32(val)

	return nil
}

func (x NFloat32) VDLIsZero() bool {
	return x == 0
}

func (x NFloat32) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NFloat32)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeFloat(float64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NFloat32) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeFloat(32)
	if err != nil {
		return err
	}
	*x = NFloat32(tmp)
	return dec.FinishValue()
}

type NFloat64 float64

func (NFloat64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NFloat64"`
}) {
}

func (m *NFloat64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromFloat(float64((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *NFloat64) MakeVDLTarget() vdl.Target {
	return &NFloat64Target{Value: m}
}

type NFloat64Target struct {
	Value *NFloat64
	vdl.TargetBase
}

func (t *NFloat64Target) FromUint(src uint64, tt *vdl.Type) error {

	val, err := vdlconv.Uint64ToFloat64(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat64(val)

	return nil
}
func (t *NFloat64Target) FromInt(src int64, tt *vdl.Type) error {

	val, err := vdlconv.Int64ToFloat64(src)
	if err != nil {
		return err
	}
	*t.Value = NFloat64(val)

	return nil
}
func (t *NFloat64Target) FromFloat(src float64, tt *vdl.Type) error {

	*t.Value = NFloat64(src)

	return nil
}

func (x NFloat64) VDLIsZero() bool {
	return x == 0
}

func (x NFloat64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NFloat64)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeFloat(float64(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NFloat64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeFloat(64)
	if err != nil {
		return err
	}
	*x = NFloat64(tmp)
	return dec.FinishValue()
}

type NArray2Uint64 [2]uint64

func (NArray2Uint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NArray2Uint64"`
}) {
}

func (m *NArray2Uint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 2)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromUint(uint64(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NArray2Uint64) MakeVDLTarget() vdl.Target {
	return &NArray2Uint64Target{Value: m}
}

// NArray2Uint64
type NArray2Uint64Target struct {
	Value      *NArray2Uint64
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *NArray2Uint64Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*NArray2Uint64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *NArray2Uint64Target) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *NArray2Uint64Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *NArray2Uint64Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x NArray2Uint64) VDLIsZero() bool {
	return x == NArray2Uint64{}
}

func (x NArray2Uint64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NArray2Uint64)(nil))); err != nil {
		return err
	}
	for i := 0; i < 2; i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NArray2Uint64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, got %d, want %T", index, *x)
		case done:
			return dec.FinishValue()
		}
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if x[index], err = dec.DecodeUint(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		index++
	}
}

type NListUint64 []uint64

func (NListUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NListUint64"`
}) {
}

func (m *NListUint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromUint(uint64(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NListUint64) MakeVDLTarget() vdl.Target {
	return &NListUint64Target{Value: m}
}

// NListUint64
type NListUint64Target struct {
	Value      *NListUint64
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *NListUint64Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*NListUint64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(NListUint64, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *NListUint64Target) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *NListUint64Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *NListUint64Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x NListUint64) VDLIsZero() bool {
	return len(x) == 0
}

func (x NListUint64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NListUint64)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NListUint64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(NListUint64, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem uint64
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if elem, err = dec.DecodeUint(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type NSetUint64 map[uint64]struct{}

func (NSetUint64) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NSetUint64"`
}) {
}

func (m *NSetUint64) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NSetUint64) MakeVDLTarget() vdl.Target {
	return &NSetUint64Target{Value: m}
}

type NSetUint64Target struct {
	Value     *NSetUint64
	currKey   uint64
	keyTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *NSetUint64Target) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*NSetUint64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(NSetUint64)
	return t, nil
}
func (t *NSetUint64Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *NSetUint64Target) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *NSetUint64Target) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x NSetUint64) VDLIsZero() bool {
	return len(x) == 0
}

func (x NSetUint64) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NSetUint64)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NSetUint64) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap NSetUint64
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(NSetUint64, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(NSetUint64)
		}
		tmpMap[key] = struct{}{}
	}
}

type NMapUint64String map[uint64]string

func (NMapUint64String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NMapUint64String"`
}) {
}

func (m *NMapUint64String) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromString(string(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NMapUint64String) MakeVDLTarget() vdl.Target {
	return &NMapUint64StringTarget{Value: m}
}

type NMapUint64StringTarget struct {
	Value      *NMapUint64String
	currKey    uint64
	currElem   string
	keyTarget  vdl.Uint64Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *NMapUint64StringTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*NMapUint64String)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(NMapUint64String)
	return t, nil
}
func (t *NMapUint64StringTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *NMapUint64StringTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *NMapUint64StringTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *NMapUint64StringTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x NMapUint64String) VDLIsZero() bool {
	return len(x) == 0
}

func (x NMapUint64String) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NMapUint64String)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NMapUint64String) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap NMapUint64String
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(NMapUint64String, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(NMapUint64String)
		}
		tmpMap[key] = elem
	}
}

type NStruct struct {
	A bool
	B string
	C int64
}

func (NStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NStruct"`
}) {
}

func (m *NStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A == false)
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromBool(bool(m.A), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.B == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.B), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.C == int64(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("C"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("C")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromInt(int64(m.C), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *NStruct) MakeVDLTarget() vdl.Target {
	return &NStructTarget{Value: m}
}

type NStructTarget struct {
	Value   *NStruct
	aTarget vdl.BoolTarget
	bTarget vdl.StringTarget
	cTarget vdl.Int64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*NStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *NStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "C":
		t.cTarget.Value = &t.Value.C
		target, err := &t.cTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *NStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *NStructTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = false
		return nil
	case "B":
		t.Value.B = ""
		return nil
	case "C":
		t.Value.C = int64(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *NStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x NStruct) VDLIsZero() bool {
	return x == NStruct{}
}

func (x NStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.A {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.A); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.B != "" {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.B); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.C != 0 {
		if err := enc.NextField("C"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.C); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NStruct) VDLRead(dec vdl.Decoder) error {
	*x = NStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.A, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "B":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.B, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "C":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.C, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type NEnum int

const (
	NEnumA NEnum = iota
	NEnumB
	NEnumC
)

// NEnumAll holds all labels for NEnum.
var NEnumAll = [...]NEnum{NEnumA, NEnumB, NEnumC}

// NEnumFromString creates a NEnum from a string label.
func NEnumFromString(label string) (x NEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *NEnum) Set(label string) error {
	switch label {
	case "A", "a":
		*x = NEnumA
		return nil
	case "B", "b":
		*x = NEnumB
		return nil
	case "C", "c":
		*x = NEnumC
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.NEnum", label)
}

// String returns the string label of x.
func (x NEnum) String() string {
	switch x {
	case NEnumA:
		return "A"
	case NEnumB:
		return "B"
	case NEnumC:
		return "C"
	}
	return ""
}

func (NEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.NEnum"`
	Enum struct{ A, B, C string }
}) {
}

func (m *NEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *NEnum) MakeVDLTarget() vdl.Target {
	return &NEnumTarget{Value: m}
}

type NEnumTarget struct {
	Value *NEnum
	vdl.TargetBase
}

func (t *NEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*NEnum)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "A":
		*t.Value = 0
	case "B":
		*t.Value = 1
	case "C":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum NEnum", src)
	}

	return nil
}

func (x NEnum) VDLIsZero() bool {
	return x == NEnumA
}

func (x NEnum) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NEnum)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *NEnum) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type (
	// NUnion represents any single field of the NUnion union type.
	NUnion interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the NUnion union type.
		__VDLReflect(__NUnionReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// NUnionA represents field A of the NUnion union type.
	NUnionA struct{ Value bool }
	// NUnionB represents field B of the NUnion union type.
	NUnionB struct{ Value string }
	// NUnionC represents field C of the NUnion union type.
	NUnionC struct{ Value int64 }
	// __NUnionReflect describes the NUnion union type.
	__NUnionReflect struct {
		Name               string `vdl:"v.io/v23/vom/testdata/types.NUnion"`
		Type               NUnion
		UnionTargetFactory nUnionTargetFactory
		Union              struct {
			A NUnionA
			B NUnionB
			C NUnionC
		}
	}
)

func (x NUnionA) Index() int                   { return 0 }
func (x NUnionA) Interface() interface{}       { return x.Value }
func (x NUnionA) Name() string                 { return "A" }
func (x NUnionA) __VDLReflect(__NUnionReflect) {}

func (m NUnionA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromBool(bool(m.Value), tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NUnionA) MakeVDLTarget() vdl.Target {
	return nil
}

func (x NUnionB) Index() int                   { return 1 }
func (x NUnionB) Interface() interface{}       { return x.Value }
func (x NUnionB) Name() string                 { return "B" }
func (x NUnionB) __VDLReflect(__NUnionReflect) {}

func (m NUnionB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NUnionB) MakeVDLTarget() vdl.Target {
	return nil
}

func (x NUnionC) Index() int                   { return 2 }
func (x NUnionC) Interface() interface{}       { return x.Value }
func (x NUnionC) Name() string                 { return "C" }
func (x NUnionC) __VDLReflect(__NUnionReflect) {}

func (m NUnionC) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("C")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromInt(int64(m.Value), tt.NonOptional().Field(2).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m NUnionC) MakeVDLTarget() vdl.Target {
	return nil
}

type NUnionTarget struct {
	Value     *NUnion
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NUnionTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*NUnion)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *NUnionTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "A":
		val := false
		return nil, &vdl.BoolTarget{Value: &val}, nil
	case "B":
		val := ""
		return nil, &vdl.StringTarget{Value: &val}, nil
	case "C":
		val := int64(0)
		return nil, &vdl.Int64Target{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/vom/testdata/types.NUnion", name)
	}
}
func (t *NUnionTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "A":
		*t.Value = NUnionA{*(fieldTarget.(*vdl.BoolTarget)).Value}
	case "B":
		*t.Value = NUnionB{*(fieldTarget.(*vdl.StringTarget)).Value}
	case "C":
		*t.Value = NUnionC{*(fieldTarget.(*vdl.Int64Target)).Value}
	}
	return nil
}
func (t *NUnionTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type nUnionTargetFactory struct{}

func (t nUnionTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*NUnion); ok {
		return &NUnionTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *NUnion", union)
}

func (x NUnionA) VDLIsZero() bool {
	return !x.Value
}

func (x NUnionB) VDLIsZero() bool {
	return false
}

func (x NUnionC) VDLIsZero() bool {
	return false
}

func (x NUnionA) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("A"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.BoolType); err != nil {
		return err
	}
	if err := enc.EncodeBool(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x NUnionB) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("B"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.StringType); err != nil {
		return err
	}
	if err := enc.EncodeString(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x NUnionC) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*NUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("C"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.Int64Type); err != nil {
		return err
	}
	if err := enc.EncodeInt(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadNUnion(dec vdl.Decoder, x *NUnion) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "A":
		var field NUnionA
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeBool(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "B":
		var field NUnionB
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "C":
		var field NUnionC
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeInt(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

// Nested Custom Types
type MBool NBool

func (MBool) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MBool"`
}) {
}

func (m *MBool) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBool(bool((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *MBool) MakeVDLTarget() vdl.Target {
	return &MBoolTarget{Value: m}
}

type MBoolTarget struct {
	Value *MBool
	vdl.TargetBase
}

func (t *MBoolTarget) FromBool(src bool, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*MBool)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = MBool(src)

	return nil
}

func (x MBool) VDLIsZero() bool {
	return bool(!x)
}

func (x MBool) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MBool)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeBool(bool(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MBool) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	tmp, err := dec.DecodeBool()
	if err != nil {
		return err
	}
	*x = MBool(tmp)
	return dec.FinishValue()
}

type MStruct struct {
	A bool
	B NBool
	C MBool
	D *NStruct
	E *vdl.Type
	F *vdl.Value
}

func (MStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MStruct"`
}) {
}

func (m *MStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A == false)
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromBool(bool(m.A), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.B == NBool(false))
	if var7 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.C == MBool(false))
	if var10 {
		if err := fieldsTarget1.ZeroField("C"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("C")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.C.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.D == (*NStruct)(nil))
	if var13 {
		if err := fieldsTarget1.ZeroField("D"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("D")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.D.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var16 := (m.E == nil || m.E == vdl.AnyType)
	if var16 {
		if err := fieldsTarget1.ZeroField("E"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("E")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			typeObjectVal17 := m.E
			if typeObjectVal17 == nil {
				typeObjectVal17 = vdl.AnyType
			}
			if err := fieldTarget15.FromTypeObject(typeObjectVal17); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var20 := m.F == nil || (m.F.Kind() == vdl.Any && m.F.IsZero())
	if var20 {
		if err := fieldsTarget1.ZeroField("F"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("F")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := vdl.FromValue(fieldTarget19, m.F); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MStruct) MakeVDLTarget() vdl.Target {
	return &MStructTarget{Value: m}
}

type MStructTarget struct {
	Value   *MStruct
	aTarget vdl.BoolTarget
	bTarget NBoolTarget
	cTarget MBoolTarget
	dTarget __VDLTarget7_optional
	eTarget vdl.TypeObjectTarget

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *MStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*MStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *MStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "C":
		t.cTarget.Value = &t.Value.C
		target, err := &t.cTarget, error(nil)
		return nil, target, err
	case "D":
		t.dTarget.Value = &t.Value.D
		target, err := &t.dTarget, error(nil)
		return nil, target, err
	case "E":
		t.eTarget.Value = &t.Value.E
		target, err := &t.eTarget, error(nil)
		return nil, target, err
	case "F":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.F))
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *MStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *MStructTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = false
		return nil
	case "B":
		t.Value.B = NBool(false)
		return nil
	case "C":
		t.Value.C = MBool(false)
		return nil
	case "D":
		t.Value.D = (*NStruct)(nil)
		return nil
	case "E":
		t.Value.E = vdl.AnyType
		return nil
	case "F":
		t.Value.F = vdl.ZeroValue(vdl.AnyType)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *MStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional NStruct
type __VDLTarget7_optional struct {
	Value      **NStruct
	elemTarget NStructTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget7_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &NStruct{}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget7_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget7_optional) FromNil(tt *vdl.Type) error {
	*t.Value = (*NStruct)(nil)
	return nil
}

func (x MStruct) VDLIsZero() bool {
	if x.A {
		return false
	}
	if x.B {
		return false
	}
	if x.C {
		return false
	}
	if x.D != nil {
		return false
	}
	if x.E != nil && x.E != vdl.AnyType {
		return false
	}
	if x.F != nil && !x.F.VDLIsZero() {
		return false
	}
	return true
}

func (x MStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.A {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.A); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.B {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := x.B.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.C {
		if err := enc.NextField("C"); err != nil {
			return err
		}
		if err := x.C.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.D != nil {
		if err := enc.NextField("D"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()
		if err := enc.StartValue(vdl.TypeOf((*NStruct)(nil)).Elem()); err != nil {
			return err
		}
		if err := x.D.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.E != nil && x.E != vdl.AnyType {
		if err := enc.NextField("E"); err != nil {
			return err
		}
		if err := x.E.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.F != nil && !x.F.VDLIsZero() {
		if err := enc.NextField("F"); err != nil {
			return err
		}
		if err := x.F.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MStruct) VDLRead(dec vdl.Decoder) error {
	*x = MStruct{
		E: vdl.AnyType,
		F: vdl.ZeroValue(vdl.AnyType),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.A, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "B":
			if err := x.B.VDLRead(dec); err != nil {
				return err
			}
		case "C":
			if err := x.C.VDLRead(dec); err != nil {
				return err
			}
		case "D":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.D), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.D, dec.Type())
				}
				x.D = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.D = new(NStruct)
				dec.IgnoreNextStartValue()
				if err := x.D.VDLRead(dec); err != nil {
					return err
				}
			}
		case "E":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.E, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "F":
			x.F = new(vdl.Value)
			if err := x.F.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type MList []NListUint64

func (MList) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MList"`
}) {
}

func (m *MList) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MList) MakeVDLTarget() vdl.Target {
	return &MListTarget{Value: m}
}

// MList
type MListTarget struct {
	Value      *MList
	elemTarget NListUint64Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *MListTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*MList)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(MList, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *MListTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MListTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *MListTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x MList) VDLIsZero() bool {
	return len(x) == 0
}

func (x MList) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MList)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MList) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(MList, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem NListUint64
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type MMap map[NFloat32]NListUint64

func (MMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MMap"`
}) {
}

func (m *MMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MMap) MakeVDLTarget() vdl.Target {
	return &MMapTarget{Value: m}
}

type MMapTarget struct {
	Value      *MMap
	currKey    NFloat32
	currElem   NListUint64
	keyTarget  NFloat32Target
	elemTarget NListUint64Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*MMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MMap)
	return t, nil
}
func (t *MMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = NFloat32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = NListUint64(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x MMap) VDLIsZero() bool {
	return len(x) == 0
}

func (x MMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MMap)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MMap) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap MMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key NFloat32
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		var elem NListUint64
		{
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MMap)
		}
		tmpMap[key] = elem
	}
}

type MByteSlice []byte

func (MByteSlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MByteSlice"`
}) {
}

func (m *MByteSlice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromBytes([]byte((*m)), tt); err != nil {
		return err
	}
	return nil
}

func (m *MByteSlice) MakeVDLTarget() vdl.Target {
	return &MByteSliceTarget{Value: m}
}

type MByteSliceTarget struct {
	Value *MByteSlice
	vdl.TargetBase
}

func (t *MByteSliceTarget) FromBytes(src []byte, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*MByteSlice)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if len(src) == 0 {
		*t.Value = nil
	} else {
		*t.Value = make([]byte, len(src))
		copy(*t.Value, src)
	}

	return nil
}

func (x MByteSlice) VDLIsZero() bool {
	return len(x) == 0
}

func (x MByteSlice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MByteSlice)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeBytes([]byte(x)); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MByteSlice) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	var bytes []byte
	if err := dec.DecodeBytes(-1, &bytes); err != nil {
		return err
	}
	*x = bytes
	return dec.FinishValue()
}

type MInt8Slice []int8

func (MInt8Slice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MInt8Slice"`
}) {
}

func (m *MInt8Slice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromInt(int64(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MInt8Slice) MakeVDLTarget() vdl.Target {
	return &MInt8SliceTarget{Value: m}
}

// MInt8Slice
type MInt8SliceTarget struct {
	Value      *MInt8Slice
	elemTarget vdl.Int8Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *MInt8SliceTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*MInt8Slice)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(MInt8Slice, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *MInt8SliceTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MInt8SliceTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *MInt8SliceTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x MInt8Slice) VDLIsZero() bool {
	return len(x) == 0
}

func (x MInt8Slice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MInt8Slice)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int8Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x[i])); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MInt8Slice) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(MInt8Slice, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem int8
		if err := dec.StartValue(); err != nil {
			return err
		}
		tmp, err := dec.DecodeInt(8)
		if err != nil {
			return err
		}
		elem = int8(tmp)
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

// Recursive Type Definitions
type RecA []RecA

func (RecA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecA"`
}) {
}

func (m *RecA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecA) MakeVDLTarget() vdl.Target {
	return &RecATarget{Value: m}
}

// RecA
type RecATarget struct {
	Value *RecA

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RecATarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*RecA)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(RecA, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *RecATarget) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &RecATarget{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *RecATarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RecATarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x RecA) VDLIsZero() bool {
	return len(x) == 0
}

func (x RecA) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*RecA)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RecA) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(RecA, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem RecA
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type RecY []RecX

func (RecY) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecY"`
}) {
}

func (m *RecY) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecY) MakeVDLTarget() vdl.Target {
	return &RecYTarget{Value: m}
}

// RecY
type RecYTarget struct {
	Value *RecY

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RecYTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*RecY)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(RecY, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *RecYTarget) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &RecXTarget{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *RecYTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RecYTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

// RecX
type RecXTarget struct {
	Value *RecX

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RecXTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*RecX)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(RecX, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *RecXTarget) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &RecYTarget{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *RecXTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RecXTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x RecY) VDLIsZero() bool {
	return len(x) == 0
}

func (x RecY) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*RecY)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RecY) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(RecY, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem RecX
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type RecX []RecY

func (RecX) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecX"`
}) {
}

func (m *RecX) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecX) MakeVDLTarget() vdl.Target {
	return &RecXTarget{Value: m}
}

func (x RecX) VDLIsZero() bool {
	return len(x) == 0
}

func (x RecX) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*RecX)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RecX) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(RecX, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem RecY
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec4 []Rec1

func (Rec4) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec4"`
}) {
}

func (m *Rec4) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec4) MakeVDLTarget() vdl.Target {
	return &Rec4Target{Value: m}
}

// Rec4
type Rec4Target struct {
	Value *Rec4

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec4Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Rec4)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec4, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec4Target) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec1Target{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *Rec4Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec4Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Rec1
type Rec1Target struct {
	Value *Rec1

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec1Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Rec1)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec1, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec1Target) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec2Target{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *Rec1Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec1Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Rec2
type Rec2Target struct {
	Value *Rec2

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec2Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Rec2)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec2, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec2Target) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec3Target{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *Rec2Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec2Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Rec3
type Rec3Target struct {
	Value *Rec3

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Rec3Target) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Rec3)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(Rec3, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *Rec3Target) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec4Target{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *Rec3Target) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Rec3Target) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x Rec4) VDLIsZero() bool {
	return len(x) == 0
}

func (x Rec4) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec4)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec4) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(Rec4, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec1
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec3 []Rec4

func (Rec3) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec3"`
}) {
}

func (m *Rec3) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec3) MakeVDLTarget() vdl.Target {
	return &Rec3Target{Value: m}
}

func (x Rec3) VDLIsZero() bool {
	return len(x) == 0
}

func (x Rec3) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec3)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec3) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(Rec3, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec4
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec2 []Rec3

func (Rec2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec2"`
}) {
}

func (m *Rec2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec2) MakeVDLTarget() vdl.Target {
	return &Rec2Target{Value: m}
}

func (x Rec2) VDLIsZero() bool {
	return len(x) == 0
}

func (x Rec2) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec2)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec2) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(Rec2, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec3
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec1 []Rec2

func (Rec1) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1"`
}) {
}

func (m *Rec1) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := elem3.FillVDLTarget(elemTarget2, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1) MakeVDLTarget() vdl.Target {
	return &Rec1Target{Value: m}
}

func (x Rec1) VDLIsZero() bool {
	return len(x) == 0
}

func (x Rec1) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec1)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec1) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(Rec1, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec2
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type RecStruct struct {
	A *RecStruct
}

func (RecStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.RecStruct"`
}) {
}

func (m *RecStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A == (*RecStruct)(nil))
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.A.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RecStruct) MakeVDLTarget() vdl.Target {
	return &RecStructTarget{Value: m}
}

type RecStructTarget struct {
	Value *RecStruct

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *RecStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*RecStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *RecStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		target, err := &__VDLTarget8_optional{Value: &t.Value.A}, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *RecStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *RecStructTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = (*RecStruct)(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *RecStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional RecStruct
type __VDLTarget8_optional struct {
	Value **RecStruct

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget8_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &RecStruct{}
	}
	target, err := &RecStructTarget{Value: *t.Value}, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget8_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget8_optional) FromNil(tt *vdl.Type) error {
	*t.Value = (*RecStruct)(nil)
	return nil
}

func (x RecStruct) VDLIsZero() bool {
	return x == RecStruct{}
}

func (x RecStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*RecStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.A != nil {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()
		if err := enc.StartValue(vdl.TypeOf((*RecStruct)(nil)).Elem()); err != nil {
			return err
		}
		if err := x.A.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RecStruct) VDLRead(dec vdl.Decoder) error {
	*x = RecStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.A), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.A, dec.Type())
				}
				x.A = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.A = new(RecStruct)
				dec.IgnoreNextStartValue()
				if err := x.A.VDLRead(dec); err != nil {
					return err
				}
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Rec1234 struct {
	R1 Rec1
	R2 Rec2
	R3 Rec3
	R4 Rec4
}

func (Rec1234) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234"`
}) {
}

func (m *Rec1234) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.R1) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("R1"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("R1")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.R1.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.R2) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("R2"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("R2")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.R2.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var var10 bool
	if len(m.R3) == 0 {
		var10 = true
	}
	if var10 {
		if err := fieldsTarget1.ZeroField("R3"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("R3")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.R3.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var var13 bool
	if len(m.R4) == 0 {
		var13 = true
	}
	if var13 {
		if err := fieldsTarget1.ZeroField("R4"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("R4")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.R4.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234) MakeVDLTarget() vdl.Target {
	return &Rec1234Target{Value: m}
}

type Rec1234Target struct {
	Value    *Rec1234
	r1Target Rec1Target
	r2Target Rec2Target
	r3Target Rec3Target
	r4Target Rec4Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234Target) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Rec1234)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Rec1234Target) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "R1":
		t.r1Target.Value = &t.Value.R1
		target, err := &t.r1Target, error(nil)
		return nil, target, err
	case "R2":
		t.r2Target.Value = &t.Value.R2
		target, err := &t.r2Target, error(nil)
		return nil, target, err
	case "R3":
		t.r3Target.Value = &t.Value.R3
		target, err := &t.r3Target, error(nil)
		return nil, target, err
	case "R4":
		t.r4Target.Value = &t.Value.R4
		target, err := &t.r4Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *Rec1234Target) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234Target) ZeroField(name string) error {
	switch name {
	case "R1":
		t.Value.R1 = Rec1(nil)
		return nil
	case "R2":
		t.Value.R2 = Rec2(nil)
		return nil
	case "R3":
		t.Value.R3 = Rec3(nil)
		return nil
	case "R4":
		t.Value.R4 = Rec4(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *Rec1234Target) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x Rec1234) VDLIsZero() bool {
	if len(x.R1) != 0 {
		return false
	}
	if len(x.R2) != 0 {
		return false
	}
	if len(x.R3) != 0 {
		return false
	}
	if len(x.R4) != 0 {
		return false
	}
	return true
}

func (x Rec1234) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec1234)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.R1) != 0 {
		if err := enc.NextField("R1"); err != nil {
			return err
		}
		if err := x.R1.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.R2) != 0 {
		if err := enc.NextField("R2"); err != nil {
			return err
		}
		if err := x.R2.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.R3) != 0 {
		if err := enc.NextField("R3"); err != nil {
			return err
		}
		if err := x.R3.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.R4) != 0 {
		if err := enc.NextField("R4"); err != nil {
			return err
		}
		if err := x.R4.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec1234) VDLRead(dec vdl.Decoder) error {
	*x = Rec1234{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "R1":
			if err := x.R1.VDLRead(dec); err != nil {
				return err
			}
		case "R2":
			if err := x.R2.VDLRead(dec); err != nil {
				return err
			}
		case "R3":
			if err := x.R3.VDLRead(dec); err != nil {
				return err
			}
		case "R4":
			if err := x.R4.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Rec1234A struct {
	A       []Rec1234A
	Rec1234 []Rec1234
}

func (Rec1234A) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234A"`
}) {
}

func (m *Rec1234A) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.A) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget5, err := fieldTarget3.StartList(tt.NonOptional().Field(0).Type, len(m.A))
			if err != nil {
				return err
			}
			for i, elem7 := range m.A {
				elemTarget6, err := listTarget5.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem7.FillVDLTarget(elemTarget6, tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget5.FinishElem(elemTarget6); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishList(listTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var10 bool
	if len(m.Rec1234) == 0 {
		var10 = true
	}
	if var10 {
		if err := fieldsTarget1.ZeroField("Rec1234"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Rec1234")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget11, err := fieldTarget9.StartList(tt.NonOptional().Field(1).Type, len(m.Rec1234))
			if err != nil {
				return err
			}
			for i, elem13 := range m.Rec1234 {
				elemTarget12, err := listTarget11.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem13.FillVDLTarget(elemTarget12, tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget11.FinishElem(elemTarget12); err != nil {
					return err
				}
			}
			if err := fieldTarget9.FinishList(listTarget11); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234A) MakeVDLTarget() vdl.Target {
	return &Rec1234ATarget{Value: m}
}

type Rec1234ATarget struct {
	Value *Rec1234A

	rec1234Target __VDLTarget9_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234ATarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Rec1234A)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Rec1234ATarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		target, err := &__VDLTarget10_list{Value: &t.Value.A}, error(nil)
		return nil, target, err
	case "Rec1234":
		t.rec1234Target.Value = &t.Value.Rec1234
		target, err := &t.rec1234Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *Rec1234ATarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234ATarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = []Rec1234A(nil)
		return nil
	case "Rec1234":
		t.Value.Rec1234 = []Rec1234(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *Rec1234ATarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []Rec1234A
type __VDLTarget10_list struct {
	Value *[]Rec1234A

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget10_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Rec1234A)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Rec1234A, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget10_list) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec1234ATarget{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *__VDLTarget10_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget10_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// []Rec1234
type __VDLTarget9_list struct {
	Value      *[]Rec1234
	elemTarget Rec1234Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget9_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Rec1234)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Rec1234, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget9_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget9_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x Rec1234A) VDLIsZero() bool {
	if len(x.A) != 0 {
		return false
	}
	if len(x.Rec1234) != 0 {
		return false
	}
	return true
}

func (x Rec1234A) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec1234A)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.A) != 0 {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_7(enc, x.A); err != nil {
			return err
		}
	}
	if len(x.Rec1234) != 0 {
		if err := enc.NextField("Rec1234"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_8(enc, x.Rec1234); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_7(enc vdl.Encoder, x []Rec1234A) error {
	if err := enc.StartValue(vdl.TypeOf((*[]Rec1234A)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_8(enc vdl.Encoder, x []Rec1234) error {
	if err := enc.StartValue(vdl.TypeOf((*[]Rec1234)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec1234A) VDLRead(dec vdl.Decoder) error {
	*x = Rec1234A{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := __VDLReadAnon_list_7(dec, &x.A); err != nil {
				return err
			}
		case "Rec1234":
			if err := __VDLReadAnon_list_8(dec, &x.Rec1234); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_7(dec vdl.Decoder, x *[]Rec1234A) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]Rec1234A, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec1234A
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLReadAnon_list_8(dec vdl.Decoder, x *[]Rec1234) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]Rec1234, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec1234
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec1234B struct {
	B       []Rec1234B
	Rec1234 []Rec1234
}

func (Rec1234B) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234B"`
}) {
}

func (m *Rec1234B) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.B) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget5, err := fieldTarget3.StartList(tt.NonOptional().Field(0).Type, len(m.B))
			if err != nil {
				return err
			}
			for i, elem7 := range m.B {
				elemTarget6, err := listTarget5.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem7.FillVDLTarget(elemTarget6, tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget5.FinishElem(elemTarget6); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishList(listTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var10 bool
	if len(m.Rec1234) == 0 {
		var10 = true
	}
	if var10 {
		if err := fieldsTarget1.ZeroField("Rec1234"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Rec1234")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget11, err := fieldTarget9.StartList(tt.NonOptional().Field(1).Type, len(m.Rec1234))
			if err != nil {
				return err
			}
			for i, elem13 := range m.Rec1234 {
				elemTarget12, err := listTarget11.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem13.FillVDLTarget(elemTarget12, tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget11.FinishElem(elemTarget12); err != nil {
					return err
				}
			}
			if err := fieldTarget9.FinishList(listTarget11); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234B) MakeVDLTarget() vdl.Target {
	return &Rec1234BTarget{Value: m}
}

type Rec1234BTarget struct {
	Value *Rec1234B

	rec1234Target __VDLTarget9_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234BTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Rec1234B)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Rec1234BTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "B":
		target, err := &__VDLTarget11_list{Value: &t.Value.B}, error(nil)
		return nil, target, err
	case "Rec1234":
		t.rec1234Target.Value = &t.Value.Rec1234
		target, err := &t.rec1234Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *Rec1234BTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234BTarget) ZeroField(name string) error {
	switch name {
	case "B":
		t.Value.B = []Rec1234B(nil)
		return nil
	case "Rec1234":
		t.Value.Rec1234 = []Rec1234(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *Rec1234BTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []Rec1234B
type __VDLTarget11_list struct {
	Value *[]Rec1234B

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget11_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Rec1234B)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Rec1234B, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget11_list) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := &Rec1234BTarget{Value: &(*t.Value)[index]}, error(nil)
	return target, err
}
func (t *__VDLTarget11_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget11_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x Rec1234B) VDLIsZero() bool {
	if len(x.B) != 0 {
		return false
	}
	if len(x.Rec1234) != 0 {
		return false
	}
	return true
}

func (x Rec1234B) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec1234B)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.B) != 0 {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_9(enc, x.B); err != nil {
			return err
		}
	}
	if len(x.Rec1234) != 0 {
		if err := enc.NextField("Rec1234"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_8(enc, x.Rec1234); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_9(enc vdl.Encoder, x []Rec1234B) error {
	if err := enc.StartValue(vdl.TypeOf((*[]Rec1234B)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec1234B) VDLRead(dec vdl.Decoder) error {
	*x = Rec1234B{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "B":
			if err := __VDLReadAnon_list_9(dec, &x.B); err != nil {
				return err
			}
		case "Rec1234":
			if err := __VDLReadAnon_list_8(dec, &x.Rec1234); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_9(dec vdl.Decoder, x *[]Rec1234B) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]Rec1234B, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Rec1234B
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Rec1234All struct {
	A Rec1234A
	B Rec1234B
}

func (Rec1234All) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Rec1234All"`
}) {
}

func (m *Rec1234All) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := true
	var var5 bool
	if len(m.A.A) == 0 {
		var5 = true
	}
	var4 = var4 && var5
	var var6 bool
	if len(m.A.Rec1234) == 0 {
		var6 = true
	}
	var4 = var4 && var6
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.A.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var9 := true
	var var10 bool
	if len(m.B.B) == 0 {
		var10 = true
	}
	var9 = var9 && var10
	var var11 bool
	if len(m.B.Rec1234) == 0 {
		var11 = true
	}
	var9 = var9 && var11
	if var9 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.B.FillVDLTarget(fieldTarget8, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Rec1234All) MakeVDLTarget() vdl.Target {
	return &Rec1234AllTarget{Value: m}
}

type Rec1234AllTarget struct {
	Value   *Rec1234All
	aTarget Rec1234ATarget
	bTarget Rec1234BTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *Rec1234AllTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Rec1234All)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Rec1234AllTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *Rec1234AllTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *Rec1234AllTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = Rec1234A{}
		return nil
	case "B":
		t.Value.B = Rec1234B{}
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *Rec1234AllTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x Rec1234All) VDLIsZero() bool {
	if !x.A.VDLIsZero() {
		return false
	}
	if !x.B.VDLIsZero() {
		return false
	}
	return true
}

func (x Rec1234All) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Rec1234All)(nil)).Elem()); err != nil {
		return err
	}
	if !x.A.VDLIsZero() {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := x.A.VDLWrite(enc); err != nil {
			return err
		}
	}
	if !x.B.VDLIsZero() {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := x.B.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Rec1234All) VDLRead(dec vdl.Decoder) error {
	*x = Rec1234All{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := x.A.VDLRead(dec); err != nil {
				return err
			}
		case "B":
			if err := x.B.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// Additional types for compatibility and conversion checks
type ListString []string

func (ListString) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ListString"`
}) {
}

func (m *ListString) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromString(string(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ListString) MakeVDLTarget() vdl.Target {
	return &ListStringTarget{Value: m}
}

// ListString
type ListStringTarget struct {
	Value      *ListString
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *ListStringTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*ListString)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(ListString, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *ListStringTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *ListStringTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *ListStringTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x ListString) VDLIsZero() bool {
	return len(x) == 0
}

func (x ListString) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ListString)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ListString) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(ListString, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem string
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if elem, err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Array3String [3]string

func (Array3String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Array3String"`
}) {
}

func (m *Array3String) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 3)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromString(string(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Array3String) MakeVDLTarget() vdl.Target {
	return &Array3StringTarget{Value: m}
}

// Array3String
type Array3StringTarget struct {
	Value      *Array3String
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Array3StringTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Array3String)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Array3StringTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *Array3StringTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Array3StringTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x Array3String) VDLIsZero() bool {
	return x == Array3String{}
}

func (x Array3String) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Array3String)(nil))); err != nil {
		return err
	}
	for i := 0; i < 3; i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Array3String) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, got %d, want %T", index, *x)
		case done:
			return dec.FinishValue()
		}
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if x[index], err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		index++
	}
}

type Array4String [4]string

func (Array4String) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.Array4String"`
}) {
}

func (m *Array4String) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 4)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromString(string(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Array4String) MakeVDLTarget() vdl.Target {
	return &Array4StringTarget{Value: m}
}

// Array4String
type Array4StringTarget struct {
	Value      *Array4String
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *Array4StringTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*Array4String)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *Array4StringTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *Array4StringTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *Array4StringTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x Array4String) VDLIsZero() bool {
	return x == Array4String{}
}

func (x Array4String) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Array4String)(nil))); err != nil {
		return err
	}
	for i := 0; i < 4; i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x[i]); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Array4String) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, got %d, want %T", index, *x)
		case done:
			return dec.FinishValue()
		}
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if x[index], err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		index++
	}
}

type AbcStruct struct {
	A bool
	B string
	C int64
}

func (AbcStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AbcStruct"`
}) {
}

func (m *AbcStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A == false)
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromBool(bool(m.A), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.B == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.B), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.C == int64(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("C"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("C")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromInt(int64(m.C), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AbcStruct) MakeVDLTarget() vdl.Target {
	return &AbcStructTarget{Value: m}
}

type AbcStructTarget struct {
	Value   *AbcStruct
	aTarget vdl.BoolTarget
	bTarget vdl.StringTarget
	cTarget vdl.Int64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AbcStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*AbcStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *AbcStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "C":
		t.cTarget.Value = &t.Value.C
		target, err := &t.cTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *AbcStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AbcStructTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = false
		return nil
	case "B":
		t.Value.B = ""
		return nil
	case "C":
		t.Value.C = int64(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *AbcStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x AbcStruct) VDLIsZero() bool {
	return x == AbcStruct{}
}

func (x AbcStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AbcStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.A {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.A); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.B != "" {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.B); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.C != 0 {
		if err := enc.NextField("C"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.C); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AbcStruct) VDLRead(dec vdl.Decoder) error {
	*x = AbcStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.A, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "B":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.B, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "C":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.C, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type AdeStruct struct {
	A bool
	D *vdl.Value
	E *vdl.Type
}

func (AdeStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AdeStruct"`
}) {
}

func (m *AdeStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A == false)
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromBool(bool(m.A), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := m.D == nil || (m.D.Kind() == vdl.Any && m.D.IsZero())
	if var7 {
		if err := fieldsTarget1.ZeroField("D"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("D")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := vdl.FromValue(fieldTarget6, m.D); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.E == nil || m.E == vdl.AnyType)
	if var10 {
		if err := fieldsTarget1.ZeroField("E"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("E")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			typeObjectVal11 := m.E
			if typeObjectVal11 == nil {
				typeObjectVal11 = vdl.AnyType
			}
			if err := fieldTarget9.FromTypeObject(typeObjectVal11); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AdeStruct) MakeVDLTarget() vdl.Target {
	return &AdeStructTarget{Value: m}
}

type AdeStructTarget struct {
	Value   *AdeStruct
	aTarget vdl.BoolTarget

	eTarget vdl.TypeObjectTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AdeStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*AdeStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *AdeStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "D":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.D))
		return nil, target, err
	case "E":
		t.eTarget.Value = &t.Value.E
		target, err := &t.eTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *AdeStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AdeStructTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = false
		return nil
	case "D":
		t.Value.D = vdl.ZeroValue(vdl.AnyType)
		return nil
	case "E":
		t.Value.E = vdl.AnyType
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *AdeStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x AdeStruct) VDLIsZero() bool {
	if x.A {
		return false
	}
	if x.D != nil && !x.D.VDLIsZero() {
		return false
	}
	if x.E != nil && x.E != vdl.AnyType {
		return false
	}
	return true
}

func (x AdeStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AdeStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.A {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.A); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.D != nil && !x.D.VDLIsZero() {
		if err := enc.NextField("D"); err != nil {
			return err
		}
		if err := x.D.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.E != nil && x.E != vdl.AnyType {
		if err := enc.NextField("E"); err != nil {
			return err
		}
		if err := x.E.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AdeStruct) VDLRead(dec vdl.Decoder) error {
	*x = AdeStruct{
		D: vdl.ZeroValue(vdl.AnyType),
		E: vdl.AnyType,
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.A, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "D":
			x.D = new(vdl.Value)
			if err := x.D.VDLRead(dec); err != nil {
				return err
			}
		case "E":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.E, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type XyzStruct struct {
	X bool
	Y MBool
	Z string
}

func (XyzStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.XyzStruct"`
}) {
}

func (m *XyzStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.X == false)
	if var4 {
		if err := fieldsTarget1.ZeroField("X"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("X")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromBool(bool(m.X), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Y == MBool(false))
	if var7 {
		if err := fieldsTarget1.ZeroField("Y"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Y")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Y.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Z == "")
	if var10 {
		if err := fieldsTarget1.ZeroField("Z"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Z")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromString(string(m.Z), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *XyzStruct) MakeVDLTarget() vdl.Target {
	return &XyzStructTarget{Value: m}
}

type XyzStructTarget struct {
	Value   *XyzStruct
	xTarget vdl.BoolTarget
	yTarget MBoolTarget
	zTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *XyzStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*XyzStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *XyzStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "X":
		t.xTarget.Value = &t.Value.X
		target, err := &t.xTarget, error(nil)
		return nil, target, err
	case "Y":
		t.yTarget.Value = &t.Value.Y
		target, err := &t.yTarget, error(nil)
		return nil, target, err
	case "Z":
		t.zTarget.Value = &t.Value.Z
		target, err := &t.zTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *XyzStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *XyzStructTarget) ZeroField(name string) error {
	switch name {
	case "X":
		t.Value.X = false
		return nil
	case "Y":
		t.Value.Y = MBool(false)
		return nil
	case "Z":
		t.Value.Z = ""
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *XyzStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x XyzStruct) VDLIsZero() bool {
	return x == XyzStruct{}
}

func (x XyzStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*XyzStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.X {
		if err := enc.NextField("X"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.X); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Y {
		if err := enc.NextField("Y"); err != nil {
			return err
		}
		if err := x.Y.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Z != "" {
		if err := enc.NextField("Z"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Z); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *XyzStruct) VDLRead(dec vdl.Decoder) error {
	*x = XyzStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "X":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.X, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Y":
			if err := x.Y.VDLRead(dec); err != nil {
				return err
			}
		case "Z":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Z, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type YzStruct struct {
	Y NBool
	Z NString
}

func (YzStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.YzStruct"`
}) {
}

func (m *YzStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Y == NBool(false))
	if var4 {
		if err := fieldsTarget1.ZeroField("Y"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Y")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Y.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Z == NString(""))
	if var7 {
		if err := fieldsTarget1.ZeroField("Z"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Z")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Z.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *YzStruct) MakeVDLTarget() vdl.Target {
	return &YzStructTarget{Value: m}
}

type YzStructTarget struct {
	Value   *YzStruct
	yTarget NBoolTarget
	zTarget NStringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *YzStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*YzStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *YzStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Y":
		t.yTarget.Value = &t.Value.Y
		target, err := &t.yTarget, error(nil)
		return nil, target, err
	case "Z":
		t.zTarget.Value = &t.Value.Z
		target, err := &t.zTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *YzStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *YzStructTarget) ZeroField(name string) error {
	switch name {
	case "Y":
		t.Value.Y = NBool(false)
		return nil
	case "Z":
		t.Value.Z = NString("")
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *YzStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x YzStruct) VDLIsZero() bool {
	return x == YzStruct{}
}

func (x YzStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*YzStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.Y {
		if err := enc.NextField("Y"); err != nil {
			return err
		}
		if err := x.Y.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Z != "" {
		if err := enc.NextField("Z"); err != nil {
			return err
		}
		if err := x.Z.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *YzStruct) VDLRead(dec vdl.Decoder) error {
	*x = YzStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Y":
			if err := x.Y.VDLRead(dec); err != nil {
				return err
			}
		case "Z":
			if err := x.Z.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type ZStruct struct {
	Z string
}

func (ZStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.ZStruct"`
}) {
}

func (m *ZStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Z == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Z"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Z")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Z), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ZStruct) MakeVDLTarget() vdl.Target {
	return &ZStructTarget{Value: m}
}

type ZStructTarget struct {
	Value   *ZStruct
	zTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ZStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ZStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ZStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Z":
		t.zTarget.Value = &t.Value.Z
		target, err := &t.zTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ZStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ZStructTarget) ZeroField(name string) error {
	switch name {
	case "Z":
		t.Value.Z = ""
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ZStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x ZStruct) VDLIsZero() bool {
	return x == ZStruct{}
}

func (x ZStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ZStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.Z != "" {
		if err := enc.NextField("Z"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Z); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ZStruct) VDLRead(dec vdl.Decoder) error {
	*x = ZStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Z":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Z, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type MapOnlyStruct struct {
	Key1 int64
	Key2 uint32
}

func (MapOnlyStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyStruct"`
}) {
}

func (m *MapOnlyStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Key1 == int64(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("Key1"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key1")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromInt(int64(m.Key1), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Key2 == uint32(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Key2"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Key2")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromUint(uint64(m.Key2), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyStruct) MakeVDLTarget() vdl.Target {
	return &MapOnlyStructTarget{Value: m}
}

type MapOnlyStructTarget struct {
	Value      *MapOnlyStruct
	key1Target vdl.Int64Target
	key2Target vdl.Uint32Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *MapOnlyStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlyStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *MapOnlyStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key1":
		t.key1Target.Value = &t.Value.Key1
		target, err := &t.key1Target, error(nil)
		return nil, target, err
	case "Key2":
		t.key2Target.Value = &t.Value.Key2
		target, err := &t.key2Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *MapOnlyStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *MapOnlyStructTarget) ZeroField(name string) error {
	switch name {
	case "Key1":
		t.Value.Key1 = int64(0)
		return nil
	case "Key2":
		t.Value.Key2 = uint32(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *MapOnlyStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x MapOnlyStruct) VDLIsZero() bool {
	return x == MapOnlyStruct{}
}

func (x MapOnlyStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlyStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.Key1 != 0 {
		if err := enc.NextField("Key1"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.Key1); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Key2 != 0 {
		if err := enc.NextField("Key2"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Key2)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlyStruct) VDLRead(dec vdl.Decoder) error {
	*x = MapOnlyStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Key1":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Key1, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Key2":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			x.Key2 = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type StructOnlyMap map[string]uint64

func (StructOnlyMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructOnlyMap"`
}) {
}

func (m *StructOnlyMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromUint(uint64(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructOnlyMap) MakeVDLTarget() vdl.Target {
	return &StructOnlyMapTarget{Value: m}
}

type StructOnlyMapTarget struct {
	Value      *StructOnlyMap
	currKey    string
	currElem   uint64
	keyTarget  vdl.StringTarget
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *StructOnlyMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*StructOnlyMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(StructOnlyMap)
	return t, nil
}
func (t *StructOnlyMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *StructOnlyMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = uint64(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *StructOnlyMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *StructOnlyMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x StructOnlyMap) VDLIsZero() bool {
	return len(x) == 0
}

func (x StructOnlyMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*StructOnlyMap)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *StructOnlyMap) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap StructOnlyMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(StructOnlyMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(StructOnlyMap)
		}
		tmpMap[key] = elem
	}
}

type MapSetStruct struct {
	Feat bool
	Tire bool
	Eel  bool
}

func (MapSetStruct) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapSetStruct"`
}) {
}

func (m *MapSetStruct) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Feat == false)
	if var4 {
		if err := fieldsTarget1.ZeroField("Feat"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Feat")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromBool(bool(m.Feat), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Tire == false)
	if var7 {
		if err := fieldsTarget1.ZeroField("Tire"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Tire")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromBool(bool(m.Tire), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Eel == false)
	if var10 {
		if err := fieldsTarget1.ZeroField("Eel"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Eel")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromBool(bool(m.Eel), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapSetStruct) MakeVDLTarget() vdl.Target {
	return &MapSetStructTarget{Value: m}
}

type MapSetStructTarget struct {
	Value      *MapSetStruct
	featTarget vdl.BoolTarget
	tireTarget vdl.BoolTarget
	eelTarget  vdl.BoolTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *MapSetStructTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*MapSetStruct)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *MapSetStructTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Feat":
		t.featTarget.Value = &t.Value.Feat
		target, err := &t.featTarget, error(nil)
		return nil, target, err
	case "Tire":
		t.tireTarget.Value = &t.Value.Tire
		target, err := &t.tireTarget, error(nil)
		return nil, target, err
	case "Eel":
		t.eelTarget.Value = &t.Value.Eel
		target, err := &t.eelTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *MapSetStructTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *MapSetStructTarget) ZeroField(name string) error {
	switch name {
	case "Feat":
		t.Value.Feat = false
		return nil
	case "Tire":
		t.Value.Tire = false
		return nil
	case "Eel":
		t.Value.Eel = false
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *MapSetStructTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x MapSetStruct) VDLIsZero() bool {
	return x == MapSetStruct{}
}

func (x MapSetStruct) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapSetStruct)(nil)).Elem()); err != nil {
		return err
	}
	if x.Feat {
		if err := enc.NextField("Feat"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Feat); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Tire {
		if err := enc.NextField("Tire"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Tire); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Eel {
		if err := enc.NextField("Eel"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Eel); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapSetStruct) VDLRead(dec vdl.Decoder) error {
	*x = MapSetStruct{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Feat":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Feat, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Tire":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Tire, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Eel":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Eel, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type SetStructMap map[string]bool

func (SetStructMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetStructMap"`
}) {
}

func (m *SetStructMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromBool(bool(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetStructMap) MakeVDLTarget() vdl.Target {
	return &SetStructMapTarget{Value: m}
}

type SetStructMapTarget struct {
	Value      *SetStructMap
	currKey    string
	currElem   bool
	keyTarget  vdl.StringTarget
	elemTarget vdl.BoolTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SetStructMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*SetStructMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetStructMap)
	return t, nil
}
func (t *SetStructMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetStructMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = false
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *SetStructMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SetStructMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x SetStructMap) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetStructMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetStructMap)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetStructMap) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap SetStructMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetStructMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem bool
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetStructMap)
		}
		tmpMap[key] = elem
	}
}

type MapStructSet map[string]struct{}

func (MapStructSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapStructSet"`
}) {
}

func (m *MapStructSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapStructSet) MakeVDLTarget() vdl.Target {
	return &MapStructSetTarget{Value: m}
}

type MapStructSetTarget struct {
	Value     *MapStructSet
	currKey   string
	keyTarget vdl.StringTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *MapStructSetTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*MapStructSet)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapStructSet)
	return t, nil
}
func (t *MapStructSetTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapStructSetTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *MapStructSetTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x MapStructSet) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapStructSet) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapStructSet)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapStructSet) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap MapStructSet
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapStructSet, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapStructSet)
		}
		tmpMap[key] = struct{}{}
	}
}

type SetOnlyMap map[float64]bool

func (SetOnlyMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyMap"`
}) {
}

func (m *SetOnlyMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromFloat(float64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromBool(bool(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyMap) MakeVDLTarget() vdl.Target {
	return &SetOnlyMapTarget{Value: m}
}

type SetOnlyMapTarget struct {
	Value      *SetOnlyMap
	currKey    float64
	currElem   bool
	keyTarget  vdl.Float64Target
	elemTarget vdl.BoolTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SetOnlyMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*SetOnlyMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetOnlyMap)
	return t, nil
}
func (t *SetOnlyMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetOnlyMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = false
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *SetOnlyMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SetOnlyMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x SetOnlyMap) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetOnlyMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetOnlyMap)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetOnlyMap) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap SetOnlyMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetOnlyMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key float64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem bool
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetOnlyMap)
		}
		tmpMap[key] = elem
	}
}

type SometimesSetMap map[float64]*vdl.Value

func (SometimesSetMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SometimesSetMap"`
}) {
}

func (m *SometimesSetMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromFloat(float64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := vdl.FromValue(valueTarget4, value5); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SometimesSetMap) MakeVDLTarget() vdl.Target {
	return &SometimesSetMapTarget{Value: m}
}

type SometimesSetMapTarget struct {
	Value     *SometimesSetMap
	currKey   float64
	currElem  *vdl.Value
	keyTarget vdl.Float64Target

	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *SometimesSetMapTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*SometimesSetMap)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SometimesSetMap)
	return t, nil
}
func (t *SometimesSetMapTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SometimesSetMapTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = vdl.ZeroValue(vdl.AnyType)
	target, err := vdl.ReflectTarget(reflect.ValueOf(&t.currElem))
	return target, err
}
func (t *SometimesSetMapTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *SometimesSetMapTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x SometimesSetMap) VDLIsZero() bool {
	return len(x) == 0
}

func (x SometimesSetMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SometimesSetMap)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if elem == nil {
			if err := enc.NilValue(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := elem.VDLWrite(enc); err != nil {
				return err
			}
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SometimesSetMap) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap SometimesSetMap
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SometimesSetMap, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key float64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem *vdl.Value
		{
			elem = new(vdl.Value)
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SometimesSetMap)
		}
		tmpMap[key] = elem
	}
}

type MapOnlySet map[float64]struct{}

func (MapOnlySet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlySet"`
}) {
}

func (m *MapOnlySet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromFloat(float64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlySet) MakeVDLTarget() vdl.Target {
	return &MapOnlySetTarget{Value: m}
}

type MapOnlySetTarget struct {
	Value     *MapOnlySet
	currKey   float64
	keyTarget vdl.Float64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *MapOnlySetTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlySet)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapOnlySet)
	return t, nil
}
func (t *MapOnlySetTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapOnlySetTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *MapOnlySetTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x MapOnlySet) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapOnlySet) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlySet)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlySet) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap MapOnlySet
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapOnlySet, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key float64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapOnlySet)
		}
		tmpMap[key] = struct{}{}
	}
}

type SetOnlyA map[bool]struct{}

func (SetOnlyA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyA"`
}) {
}

func (m *SetOnlyA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromBool(bool(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyA) MakeVDLTarget() vdl.Target {
	return &SetOnlyATarget{Value: m}
}

type SetOnlyATarget struct {
	Value     *SetOnlyA
	currKey   bool
	keyTarget vdl.BoolTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyATarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*SetOnlyA)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetOnlyA)
	return t, nil
}
func (t *SetOnlyATarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = false
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetOnlyATarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyATarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x SetOnlyA) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetOnlyA) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetOnlyA)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetOnlyA) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap SetOnlyA
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetOnlyA, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key bool
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetOnlyA)
		}
		tmpMap[key] = struct{}{}
	}
}

type SetOnlyA2 map[NBool]struct{}

func (SetOnlyA2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyA2"`
}) {
}

func (m *SetOnlyA2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyA2) MakeVDLTarget() vdl.Target {
	return &SetOnlyA2Target{Value: m}
}

type SetOnlyA2Target struct {
	Value     *SetOnlyA2
	currKey   NBool
	keyTarget NBoolTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyA2Target) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*SetOnlyA2)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetOnlyA2)
	return t, nil
}
func (t *SetOnlyA2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = NBool(false)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetOnlyA2Target) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyA2Target) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x SetOnlyA2) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetOnlyA2) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetOnlyA2)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetOnlyA2) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap SetOnlyA2
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetOnlyA2, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key NBool
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetOnlyA2)
		}
		tmpMap[key] = struct{}{}
	}
}

type SetOnlyB map[int16]struct{}

func (SetOnlyB) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyB"`
}) {
}

func (m *SetOnlyB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromInt(int64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyB) MakeVDLTarget() vdl.Target {
	return &SetOnlyBTarget{Value: m}
}

type SetOnlyBTarget struct {
	Value     *SetOnlyB
	currKey   int16
	keyTarget vdl.Int16Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyBTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*SetOnlyB)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetOnlyB)
	return t, nil
}
func (t *SetOnlyBTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = int16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetOnlyBTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyBTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x SetOnlyB) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetOnlyB) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetOnlyB)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetOnlyB) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap SetOnlyB
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetOnlyB, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int16
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			key = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetOnlyB)
		}
		tmpMap[key] = struct{}{}
	}
}

type SetOnlyB2 map[NInt16]struct{}

func (SetOnlyB2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.SetOnlyB2"`
}) {
}

func (m *SetOnlyB2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	setTarget1, err := t.StartSet(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3 := range *m {
		keyTarget2, err := setTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, tt.NonOptional().Key()); err != nil {
			return err
		}
		if err := setTarget1.FinishKey(keyTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishSet(setTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SetOnlyB2) MakeVDLTarget() vdl.Target {
	return &SetOnlyB2Target{Value: m}
}

type SetOnlyB2Target struct {
	Value     *SetOnlyB2
	currKey   NInt16
	keyTarget NInt16Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *SetOnlyB2Target) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*SetOnlyB2)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(SetOnlyB2)
	return t, nil
}
func (t *SetOnlyB2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = NInt16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *SetOnlyB2Target) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *SetOnlyB2Target) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x SetOnlyB2) VDLIsZero() bool {
	return len(x) == 0
}

func (x SetOnlyB2) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*SetOnlyB2)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *SetOnlyB2) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap SetOnlyB2
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(SetOnlyB2, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key NInt16
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(SetOnlyB2)
		}
		tmpMap[key] = struct{}{}
	}
}

type MapOnlyA map[uint32]uint32

func (MapOnlyA) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyA"`
}) {
}

func (m *MapOnlyA) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromUint(uint64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromUint(uint64(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyA) MakeVDLTarget() vdl.Target {
	return &MapOnlyATarget{Value: m}
}

type MapOnlyATarget struct {
	Value      *MapOnlyA
	currKey    uint32
	currElem   uint32
	keyTarget  vdl.Uint32Target
	elemTarget vdl.Uint32Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyATarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlyA)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapOnlyA)
	return t, nil
}
func (t *MapOnlyATarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapOnlyATarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = uint32(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MapOnlyATarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyATarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x MapOnlyA) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapOnlyA) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlyA)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(elem)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlyA) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap MapOnlyA
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapOnlyA, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			key = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem uint32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			elem = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapOnlyA)
		}
		tmpMap[key] = elem
	}
}

type MapOnlyA2 map[int64]float64

func (MapOnlyA2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyA2"`
}) {
}

func (m *MapOnlyA2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromInt(int64(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromFloat(float64(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyA2) MakeVDLTarget() vdl.Target {
	return &MapOnlyA2Target{Value: m}
}

type MapOnlyA2Target struct {
	Value      *MapOnlyA2
	currKey    int64
	currElem   float64
	keyTarget  vdl.Int64Target
	elemTarget vdl.Float64Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyA2Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlyA2)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapOnlyA2)
	return t, nil
}
func (t *MapOnlyA2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapOnlyA2Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = float64(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MapOnlyA2Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyA2Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x MapOnlyA2) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapOnlyA2) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlyA2)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlyA2) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap MapOnlyA2
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapOnlyA2, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem float64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapOnlyA2)
		}
		tmpMap[key] = elem
	}
}

type MapOnlyB map[bool]string

func (MapOnlyB) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyB"`
}) {
}

func (m *MapOnlyB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromBool(bool(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}
		if err := valueTarget4.FromString(string(value5), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyB) MakeVDLTarget() vdl.Target {
	return &MapOnlyBTarget{Value: m}
}

type MapOnlyBTarget struct {
	Value      *MapOnlyB
	currKey    bool
	currElem   string
	keyTarget  vdl.BoolTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyBTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlyB)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapOnlyB)
	return t, nil
}
func (t *MapOnlyBTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = false
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapOnlyBTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MapOnlyBTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyBTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x MapOnlyB) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapOnlyB) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlyB)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlyB) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap MapOnlyB
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapOnlyB, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key bool
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapOnlyB)
		}
		tmpMap[key] = elem
	}
}

type MapOnlyB2 map[NBool]NString

func (MapOnlyB2) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.MapOnlyB2"`
}) {
}

func (m *MapOnlyB2) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}

		if err := key3.FillVDLTarget(keyTarget2, tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *MapOnlyB2) MakeVDLTarget() vdl.Target {
	return &MapOnlyB2Target{Value: m}
}

type MapOnlyB2Target struct {
	Value      *MapOnlyB2
	currKey    NBool
	currElem   NString
	keyTarget  NBoolTarget
	elemTarget NStringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *MapOnlyB2Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*MapOnlyB2)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(MapOnlyB2)
	return t, nil
}
func (t *MapOnlyB2Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = NBool(false)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *MapOnlyB2Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = NString("")
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *MapOnlyB2Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *MapOnlyB2Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x MapOnlyB2) VDLIsZero() bool {
	return len(x) == 0
}

func (x MapOnlyB2) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*MapOnlyB2)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *MapOnlyB2) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap MapOnlyB2
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(MapOnlyB2, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key NBool
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		var elem NString
		{
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(MapOnlyB2)
		}
		tmpMap[key] = elem
	}
}

type (
	// BdeUnion represents any single field of the BdeUnion union type.
	BdeUnion interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the BdeUnion union type.
		__VDLReflect(__BdeUnionReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// BdeUnionB represents field B of the BdeUnion union type.
	BdeUnionB struct{ Value string }
	// BdeUnionD represents field D of the BdeUnion union type.
	BdeUnionD struct{ Value *vdl.Value }
	// BdeUnionE represents field E of the BdeUnion union type.
	BdeUnionE struct{ Value *vdl.Type }
	// __BdeUnionReflect describes the BdeUnion union type.
	__BdeUnionReflect struct {
		Name               string `vdl:"v.io/v23/vom/testdata/types.BdeUnion"`
		Type               BdeUnion
		UnionTargetFactory bdeUnionTargetFactory
		Union              struct {
			B BdeUnionB
			D BdeUnionD
			E BdeUnionE
		}
	}
)

func (x BdeUnionB) Index() int                     { return 0 }
func (x BdeUnionB) Interface() interface{}         { return x.Value }
func (x BdeUnionB) Name() string                   { return "B" }
func (x BdeUnionB) __VDLReflect(__BdeUnionReflect) {}

func (m BdeUnionB) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m BdeUnionB) MakeVDLTarget() vdl.Target {
	return nil
}

func (x BdeUnionD) Index() int                     { return 1 }
func (x BdeUnionD) Interface() interface{}         { return x.Value }
func (x BdeUnionD) Name() string                   { return "D" }
func (x BdeUnionD) __VDLReflect(__BdeUnionReflect) {}

func (m BdeUnionD) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("D")
	if err != nil {
		return err
	}

	if err := vdl.FromValue(fieldTarget3, m.Value); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m BdeUnionD) MakeVDLTarget() vdl.Target {
	return nil
}

func (x BdeUnionE) Index() int                     { return 2 }
func (x BdeUnionE) Interface() interface{}         { return x.Value }
func (x BdeUnionE) Name() string                   { return "E" }
func (x BdeUnionE) __VDLReflect(__BdeUnionReflect) {}

func (m BdeUnionE) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("E")
	if err != nil {
		return err
	}
	typeObjectVal4 := m.Value
	if typeObjectVal4 == nil {
		typeObjectVal4 = vdl.AnyType
	}
	if err := fieldTarget3.FromTypeObject(typeObjectVal4); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m BdeUnionE) MakeVDLTarget() vdl.Target {
	return nil
}

type BdeUnionTarget struct {
	Value     *BdeUnion
	fieldName string
	anyValue  vdl.Value
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BdeUnionTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*BdeUnion)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *BdeUnionTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "B":
		val := ""
		return nil, &vdl.StringTarget{Value: &val}, nil
	case "D":
		t.anyValue = vdl.Value{}
		target, err := vdl.ValueTarget(&t.anyValue)
		return nil, target, err
	case "E":
		val := vdl.AnyType
		return nil, &vdl.TypeObjectTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/vom/testdata/types.BdeUnion", name)
	}
}
func (t *BdeUnionTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "B":
		*t.Value = BdeUnionB{*(fieldTarget.(*vdl.StringTarget)).Value}
	case "D":
		*t.Value = BdeUnionD{&t.anyValue}
	case "E":
		*t.Value = BdeUnionE{*(fieldTarget.(*vdl.TypeObjectTarget)).Value}
	}
	return nil
}
func (t *BdeUnionTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type bdeUnionTargetFactory struct{}

func (t bdeUnionTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*BdeUnion); ok {
		return &BdeUnionTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *BdeUnion", union)
}

func (x BdeUnionB) VDLIsZero() bool {
	return x.Value == ""
}

func (x BdeUnionD) VDLIsZero() bool {
	return false
}

func (x BdeUnionE) VDLIsZero() bool {
	return false
}

func (x BdeUnionB) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BdeUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("B"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.StringType); err != nil {
		return err
	}
	if err := enc.EncodeString(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x BdeUnionD) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BdeUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("D"); err != nil {
		return err
	}
	if x.Value == nil {
		if err := enc.NilValue(vdl.AnyType); err != nil {
			return err
		}
	} else {
		if err := x.Value.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x BdeUnionE) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BdeUnion)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("E"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadBdeUnion(dec vdl.Decoder, x *BdeUnion) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "B":
		var field BdeUnionB
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "D":
		var field BdeUnionD
		field.Value = new(vdl.Value)
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "E":
		var field BdeUnionE
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeTypeObject(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type BrieEnum int

const (
	BrieEnumGlee BrieEnum = iota
	BrieEnumBrie
	BrieEnumThree
)

// BrieEnumAll holds all labels for BrieEnum.
var BrieEnumAll = [...]BrieEnum{BrieEnumGlee, BrieEnumBrie, BrieEnumThree}

// BrieEnumFromString creates a BrieEnum from a string label.
func BrieEnumFromString(label string) (x BrieEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *BrieEnum) Set(label string) error {
	switch label {
	case "Glee", "glee":
		*x = BrieEnumGlee
		return nil
	case "Brie", "brie":
		*x = BrieEnumBrie
		return nil
	case "Three", "three":
		*x = BrieEnumThree
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.BrieEnum", label)
}

// String returns the string label of x.
func (x BrieEnum) String() string {
	switch x {
	case BrieEnumGlee:
		return "Glee"
	case BrieEnumBrie:
		return "Brie"
	case BrieEnumThree:
		return "Three"
	}
	return ""
}

func (BrieEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.BrieEnum"`
	Enum struct{ Glee, Brie, Three string }
}) {
}

func (m *BrieEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *BrieEnum) MakeVDLTarget() vdl.Target {
	return &BrieEnumTarget{Value: m}
}

type BrieEnumTarget struct {
	Value *BrieEnum
	vdl.TargetBase
}

func (t *BrieEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*BrieEnum)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Glee":
		*t.Value = 0
	case "Brie":
		*t.Value = 1
	case "Three":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum BrieEnum", src)
	}

	return nil
}

func (x BrieEnum) VDLIsZero() bool {
	return x == BrieEnumGlee
}

func (x BrieEnum) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BrieEnum)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BrieEnum) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type BeanEnum int

const (
	BeanEnumBean BeanEnum = iota
)

// BeanEnumAll holds all labels for BeanEnum.
var BeanEnumAll = [...]BeanEnum{BeanEnumBean}

// BeanEnumFromString creates a BeanEnum from a string label.
func BeanEnumFromString(label string) (x BeanEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *BeanEnum) Set(label string) error {
	switch label {
	case "Bean", "bean":
		*x = BeanEnumBean
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.BeanEnum", label)
}

// String returns the string label of x.
func (x BeanEnum) String() string {
	switch x {
	case BeanEnumBean:
		return "Bean"
	}
	return ""
}

func (BeanEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.BeanEnum"`
	Enum struct{ Bean string }
}) {
}

func (m *BeanEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *BeanEnum) MakeVDLTarget() vdl.Target {
	return &BeanEnumTarget{Value: m}
}

type BeanEnumTarget struct {
	Value *BeanEnum
	vdl.TargetBase
}

func (t *BeanEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*BeanEnum)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Bean":
		*t.Value = 0
	default:
		return fmt.Errorf("label %s not in enum BeanEnum", src)
	}

	return nil
}

func (x BeanEnum) VDLIsZero() bool {
	return x == BeanEnumBean
}

func (x BeanEnum) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BeanEnum)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BeanEnum) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type FoodEnum int

const (
	FoodEnumBean FoodEnum = iota
	FoodEnumBrie
	FoodEnumCherry
)

// FoodEnumAll holds all labels for FoodEnum.
var FoodEnumAll = [...]FoodEnum{FoodEnumBean, FoodEnumBrie, FoodEnumCherry}

// FoodEnumFromString creates a FoodEnum from a string label.
func FoodEnumFromString(label string) (x FoodEnum, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *FoodEnum) Set(label string) error {
	switch label {
	case "Bean", "bean":
		*x = FoodEnumBean
		return nil
	case "Brie", "brie":
		*x = FoodEnumBrie
		return nil
	case "Cherry", "cherry":
		*x = FoodEnumCherry
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in types.FoodEnum", label)
}

// String returns the string label of x.
func (x FoodEnum) String() string {
	switch x {
	case FoodEnumBean:
		return "Bean"
	case FoodEnumBrie:
		return "Brie"
	case FoodEnumCherry:
		return "Cherry"
	}
	return ""
}

func (FoodEnum) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.FoodEnum"`
	Enum struct{ Bean, Brie, Cherry string }
}) {
}

func (m *FoodEnum) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *FoodEnum) MakeVDLTarget() vdl.Target {
	return &FoodEnumTarget{Value: m}
}

type FoodEnumTarget struct {
	Value *FoodEnum
	vdl.TargetBase
}

func (t *FoodEnumTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*FoodEnum)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Bean":
		*t.Value = 0
	case "Brie":
		*t.Value = 1
	case "Cherry":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum FoodEnum", src)
	}

	return nil
}

func (x FoodEnum) VDLIsZero() bool {
	return x == FoodEnumBean
}

func (x FoodEnum) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*FoodEnum)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FoodEnum) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type StructAny struct {
	Any *vdl.Value
}

func (StructAny) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructAny"`
}) {
}

func (m *StructAny) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := m.Any == nil || (m.Any.Kind() == vdl.Any && m.Any.IsZero())
	if var4 {
		if err := fieldsTarget1.ZeroField("Any"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Any")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := vdl.FromValue(fieldTarget3, m.Any); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructAny) MakeVDLTarget() vdl.Target {
	return &StructAnyTarget{Value: m}
}

type StructAnyTarget struct {
	Value *StructAny

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *StructAnyTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*StructAny)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *StructAnyTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Any":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Any))
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *StructAnyTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *StructAnyTarget) ZeroField(name string) error {
	switch name {
	case "Any":
		t.Value.Any = vdl.ZeroValue(vdl.AnyType)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *StructAnyTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x StructAny) VDLIsZero() bool {
	if x.Any != nil && !x.Any.VDLIsZero() {
		return false
	}
	return true
}

func (x StructAny) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*StructAny)(nil)).Elem()); err != nil {
		return err
	}
	if x.Any != nil && !x.Any.VDLIsZero() {
		if err := enc.NextField("Any"); err != nil {
			return err
		}
		if err := x.Any.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *StructAny) VDLRead(dec vdl.Decoder) error {
	*x = StructAny{
		Any: vdl.ZeroValue(vdl.AnyType),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Any":
			x.Any = new(vdl.Value)
			if err := x.Any.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type StructMap struct {
	Map map[int64]int64
}

func (StructMap) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructMap"`
}) {
}

func (m *StructMap) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.Map) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("Map"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Map")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget5, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.Map))
			if err != nil {
				return err
			}
			for key7, value9 := range m.Map {
				keyTarget6, err := mapTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromInt(int64(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				valueTarget8, err := mapTarget5.FinishKeyStartField(keyTarget6)
				if err != nil {
					return err
				}
				if err := valueTarget8.FromInt(int64(value9), tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget5.FinishField(keyTarget6, valueTarget8); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishMap(mapTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructMap) MakeVDLTarget() vdl.Target {
	return &StructMapTarget{Value: m}
}

type StructMapTarget struct {
	Value     *StructMap
	mapTarget __VDLTarget12_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *StructMapTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*StructMap)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *StructMapTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Map":
		t.mapTarget.Value = &t.Value.Map
		target, err := &t.mapTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *StructMapTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *StructMapTarget) ZeroField(name string) error {
	switch name {
	case "Map":
		t.Value.Map = map[int64]int64(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *StructMapTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[int64]int64
type __VDLTarget12_map struct {
	Value      *map[int64]int64
	currKey    int64
	currElem   int64
	keyTarget  vdl.Int64Target
	elemTarget vdl.Int64Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget12_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int64]int64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int64]int64)
	return t, nil
}
func (t *__VDLTarget12_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget12_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = int64(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget12_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget12_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x StructMap) VDLIsZero() bool {
	if len(x.Map) != 0 {
		return false
	}
	return true
}

func (x StructMap) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*StructMap)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.Map) != 0 {
		if err := enc.NextField("Map"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_10(enc, x.Map); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_10(enc vdl.Encoder, x map[int64]int64) error {
	if err := enc.StartValue(vdl.TypeOf((*map[int64]int64)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *StructMap) VDLRead(dec vdl.Decoder) error {
	*x = StructMap{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Map":
			if err := __VDLReadAnon_map_10(dec, &x.Map); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_10(dec vdl.Decoder, x *map[int64]int64) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[int64]int64
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int64]int64, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem int64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[int64]int64)
		}
		tmpMap[key] = elem
	}
}

// Since the encoding changes if struct fields are zero values,
// test each of the kinds in a struct both as zero and non-zero values.
type StructManyTypes struct {
	Bool             bool
	AByte            byte
	Int16            int16
	Int32            int32
	Int64            int64
	Uint16           uint16
	Uint32           uint32
	Uint64           uint64
	String           string
	Bytes            []byte
	Float32          float32
	Float64          float64
	FoodEnum         FoodEnum
	NEnum            NEnum
	NListUint64      NListUint64
	NByteArray       NByteArray
	NArray2Uint64    NArray2Uint64
	NSetUint64       NSetUint64
	NMapUint64String NMapUint64String
	NStruct          NStruct
	NUnion           NUnion
	TypeObject       *vdl.Type
}

func (StructManyTypes) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.StructManyTypes"`
}) {
}

func (m *StructManyTypes) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Bool == false)
	if var4 {
		if err := fieldsTarget1.ZeroField("Bool"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Bool")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromBool(bool(m.Bool), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.AByte == byte(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("AByte"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("AByte")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromUint(uint64(m.AByte), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Int16 == int16(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("Int16"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Int16")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromInt(int64(m.Int16), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.Int32 == int32(0))
	if var13 {
		if err := fieldsTarget1.ZeroField("Int32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Int32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromInt(int64(m.Int32), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var16 := (m.Int64 == int64(0))
	if var16 {
		if err := fieldsTarget1.ZeroField("Int64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("Int64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget15.FromInt(int64(m.Int64), tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var19 := (m.Uint16 == uint16(0))
	if var19 {
		if err := fieldsTarget1.ZeroField("Uint16"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("Uint16")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget18.FromUint(uint64(m.Uint16), tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
				return err
			}
		}
	}
	var22 := (m.Uint32 == uint32(0))
	if var22 {
		if err := fieldsTarget1.ZeroField("Uint32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("Uint32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget21.FromUint(uint64(m.Uint32), tt.NonOptional().Field(6).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
				return err
			}
		}
	}
	var25 := (m.Uint64 == uint64(0))
	if var25 {
		if err := fieldsTarget1.ZeroField("Uint64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("Uint64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget24.FromUint(uint64(m.Uint64), tt.NonOptional().Field(7).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
				return err
			}
		}
	}
	var28 := (m.String == "")
	if var28 {
		if err := fieldsTarget1.ZeroField("String"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("String")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget27.FromString(string(m.String), tt.NonOptional().Field(8).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
				return err
			}
		}
	}
	var var31 bool
	if len(m.Bytes) == 0 {
		var31 = true
	}
	if var31 {
		if err := fieldsTarget1.ZeroField("Bytes"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget29, fieldTarget30, err := fieldsTarget1.StartField("Bytes")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := fieldTarget30.FromBytes([]byte(m.Bytes), tt.NonOptional().Field(9).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget29, fieldTarget30); err != nil {
				return err
			}
		}
	}
	var34 := (m.Float32 == float32(0))
	if var34 {
		if err := fieldsTarget1.ZeroField("Float32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget32, fieldTarget33, err := fieldsTarget1.StartField("Float32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget33.FromFloat(float64(m.Float32), tt.NonOptional().Field(10).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget32, fieldTarget33); err != nil {
				return err
			}
		}
	}
	var37 := (m.Float64 == float64(0))
	if var37 {
		if err := fieldsTarget1.ZeroField("Float64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget35, fieldTarget36, err := fieldsTarget1.StartField("Float64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget36.FromFloat(float64(m.Float64), tt.NonOptional().Field(11).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget35, fieldTarget36); err != nil {
				return err
			}
		}
	}
	var40 := (m.FoodEnum == FoodEnumBean)
	if var40 {
		if err := fieldsTarget1.ZeroField("FoodEnum"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget38, fieldTarget39, err := fieldsTarget1.StartField("FoodEnum")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.FoodEnum.FillVDLTarget(fieldTarget39, tt.NonOptional().Field(12).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget38, fieldTarget39); err != nil {
				return err
			}
		}
	}
	var43 := (m.NEnum == NEnumA)
	if var43 {
		if err := fieldsTarget1.ZeroField("NEnum"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget41, fieldTarget42, err := fieldsTarget1.StartField("NEnum")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.NEnum.FillVDLTarget(fieldTarget42, tt.NonOptional().Field(13).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget41, fieldTarget42); err != nil {
				return err
			}
		}
	}
	var var46 bool
	if len(m.NListUint64) == 0 {
		var46 = true
	}
	if var46 {
		if err := fieldsTarget1.ZeroField("NListUint64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget44, fieldTarget45, err := fieldsTarget1.StartField("NListUint64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.NListUint64.FillVDLTarget(fieldTarget45, tt.NonOptional().Field(14).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget44, fieldTarget45); err != nil {
				return err
			}
		}
	}
	var49 := (m.NByteArray == NByteArray{})
	if var49 {
		if err := fieldsTarget1.ZeroField("NByteArray"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget47, fieldTarget48, err := fieldsTarget1.StartField("NByteArray")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.NByteArray.FillVDLTarget(fieldTarget48, tt.NonOptional().Field(15).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget47, fieldTarget48); err != nil {
				return err
			}
		}
	}
	var52 := (m.NArray2Uint64 == NArray2Uint64{})
	if var52 {
		if err := fieldsTarget1.ZeroField("NArray2Uint64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget50, fieldTarget51, err := fieldsTarget1.StartField("NArray2Uint64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.NArray2Uint64.FillVDLTarget(fieldTarget51, tt.NonOptional().Field(16).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget50, fieldTarget51); err != nil {
				return err
			}
		}
	}
	var var55 bool
	if len(m.NSetUint64) == 0 {
		var55 = true
	}
	if var55 {
		if err := fieldsTarget1.ZeroField("NSetUint64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget53, fieldTarget54, err := fieldsTarget1.StartField("NSetUint64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.NSetUint64.FillVDLTarget(fieldTarget54, tt.NonOptional().Field(17).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget53, fieldTarget54); err != nil {
				return err
			}
		}
	}
	var var58 bool
	if len(m.NMapUint64String) == 0 {
		var58 = true
	}
	if var58 {
		if err := fieldsTarget1.ZeroField("NMapUint64String"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget56, fieldTarget57, err := fieldsTarget1.StartField("NMapUint64String")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.NMapUint64String.FillVDLTarget(fieldTarget57, tt.NonOptional().Field(18).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget56, fieldTarget57); err != nil {
				return err
			}
		}
	}
	var61 := (m.NStruct == NStruct{})
	if var61 {
		if err := fieldsTarget1.ZeroField("NStruct"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget59, fieldTarget60, err := fieldsTarget1.StartField("NStruct")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.NStruct.FillVDLTarget(fieldTarget60, tt.NonOptional().Field(19).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget59, fieldTarget60); err != nil {
				return err
			}
		}
	}
	var var64 bool
	if field, ok := m.NUnion.(NUnionA); ok {

		var65 := (field.Value == false)
		var64 = var65
	}
	if var64 {
		if err := fieldsTarget1.ZeroField("NUnion"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget62, fieldTarget63, err := fieldsTarget1.StartField("NUnion")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			unionValue66 := m.NUnion
			if unionValue66 == nil {
				unionValue66 = NUnionA{}
			}
			if err := unionValue66.FillVDLTarget(fieldTarget63, tt.NonOptional().Field(20).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget62, fieldTarget63); err != nil {
				return err
			}
		}
	}
	var69 := (m.TypeObject == nil || m.TypeObject == vdl.AnyType)
	if var69 {
		if err := fieldsTarget1.ZeroField("TypeObject"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget67, fieldTarget68, err := fieldsTarget1.StartField("TypeObject")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			typeObjectVal70 := m.TypeObject
			if typeObjectVal70 == nil {
				typeObjectVal70 = vdl.AnyType
			}
			if err := fieldTarget68.FromTypeObject(typeObjectVal70); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget67, fieldTarget68); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *StructManyTypes) MakeVDLTarget() vdl.Target {
	return &StructManyTypesTarget{Value: m}
}

type StructManyTypesTarget struct {
	Value                  *StructManyTypes
	boolTarget             vdl.BoolTarget
	aByteTarget            vdl.ByteTarget
	int16Target            vdl.Int16Target
	int32Target            vdl.Int32Target
	int64Target            vdl.Int64Target
	uint16Target           vdl.Uint16Target
	uint32Target           vdl.Uint32Target
	uint64Target           vdl.Uint64Target
	stringTarget           vdl.StringTarget
	bytesTarget            vdl.BytesTarget
	float32Target          vdl.Float32Target
	float64Target          vdl.Float64Target
	foodEnumTarget         FoodEnumTarget
	nEnumTarget            NEnumTarget
	nListUint64Target      NListUint64Target
	nByteArrayTarget       NByteArrayTarget
	nArray2Uint64Target    NArray2Uint64Target
	nSetUint64Target       NSetUint64Target
	nMapUint64StringTarget NMapUint64StringTarget
	nStructTarget          NStructTarget
	nUnionTarget           NUnionTarget
	typeObjectTarget       vdl.TypeObjectTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *StructManyTypesTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*StructManyTypes)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *StructManyTypesTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Bool":
		t.boolTarget.Value = &t.Value.Bool
		target, err := &t.boolTarget, error(nil)
		return nil, target, err
	case "AByte":
		t.aByteTarget.Value = &t.Value.AByte
		target, err := &t.aByteTarget, error(nil)
		return nil, target, err
	case "Int16":
		t.int16Target.Value = &t.Value.Int16
		target, err := &t.int16Target, error(nil)
		return nil, target, err
	case "Int32":
		t.int32Target.Value = &t.Value.Int32
		target, err := &t.int32Target, error(nil)
		return nil, target, err
	case "Int64":
		t.int64Target.Value = &t.Value.Int64
		target, err := &t.int64Target, error(nil)
		return nil, target, err
	case "Uint16":
		t.uint16Target.Value = &t.Value.Uint16
		target, err := &t.uint16Target, error(nil)
		return nil, target, err
	case "Uint32":
		t.uint32Target.Value = &t.Value.Uint32
		target, err := &t.uint32Target, error(nil)
		return nil, target, err
	case "Uint64":
		t.uint64Target.Value = &t.Value.Uint64
		target, err := &t.uint64Target, error(nil)
		return nil, target, err
	case "String":
		t.stringTarget.Value = &t.Value.String
		target, err := &t.stringTarget, error(nil)
		return nil, target, err
	case "Bytes":
		t.bytesTarget.Value = &t.Value.Bytes
		target, err := &t.bytesTarget, error(nil)
		return nil, target, err
	case "Float32":
		t.float32Target.Value = &t.Value.Float32
		target, err := &t.float32Target, error(nil)
		return nil, target, err
	case "Float64":
		t.float64Target.Value = &t.Value.Float64
		target, err := &t.float64Target, error(nil)
		return nil, target, err
	case "FoodEnum":
		t.foodEnumTarget.Value = &t.Value.FoodEnum
		target, err := &t.foodEnumTarget, error(nil)
		return nil, target, err
	case "NEnum":
		t.nEnumTarget.Value = &t.Value.NEnum
		target, err := &t.nEnumTarget, error(nil)
		return nil, target, err
	case "NListUint64":
		t.nListUint64Target.Value = &t.Value.NListUint64
		target, err := &t.nListUint64Target, error(nil)
		return nil, target, err
	case "NByteArray":
		t.nByteArrayTarget.Value = &t.Value.NByteArray
		target, err := &t.nByteArrayTarget, error(nil)
		return nil, target, err
	case "NArray2Uint64":
		t.nArray2Uint64Target.Value = &t.Value.NArray2Uint64
		target, err := &t.nArray2Uint64Target, error(nil)
		return nil, target, err
	case "NSetUint64":
		t.nSetUint64Target.Value = &t.Value.NSetUint64
		target, err := &t.nSetUint64Target, error(nil)
		return nil, target, err
	case "NMapUint64String":
		t.nMapUint64StringTarget.Value = &t.Value.NMapUint64String
		target, err := &t.nMapUint64StringTarget, error(nil)
		return nil, target, err
	case "NStruct":
		t.nStructTarget.Value = &t.Value.NStruct
		target, err := &t.nStructTarget, error(nil)
		return nil, target, err
	case "NUnion":
		t.nUnionTarget.Value = &t.Value.NUnion
		target, err := &t.nUnionTarget, error(nil)
		return nil, target, err
	case "TypeObject":
		t.typeObjectTarget.Value = &t.Value.TypeObject
		target, err := &t.typeObjectTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *StructManyTypesTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *StructManyTypesTarget) ZeroField(name string) error {
	switch name {
	case "Bool":
		t.Value.Bool = false
		return nil
	case "AByte":
		t.Value.AByte = byte(0)
		return nil
	case "Int16":
		t.Value.Int16 = int16(0)
		return nil
	case "Int32":
		t.Value.Int32 = int32(0)
		return nil
	case "Int64":
		t.Value.Int64 = int64(0)
		return nil
	case "Uint16":
		t.Value.Uint16 = uint16(0)
		return nil
	case "Uint32":
		t.Value.Uint32 = uint32(0)
		return nil
	case "Uint64":
		t.Value.Uint64 = uint64(0)
		return nil
	case "String":
		t.Value.String = ""
		return nil
	case "Bytes":
		t.Value.Bytes = []byte(nil)
		return nil
	case "Float32":
		t.Value.Float32 = float32(0)
		return nil
	case "Float64":
		t.Value.Float64 = float64(0)
		return nil
	case "FoodEnum":
		t.Value.FoodEnum = FoodEnumBean
		return nil
	case "NEnum":
		t.Value.NEnum = NEnumA
		return nil
	case "NListUint64":
		t.Value.NListUint64 = NListUint64(nil)
		return nil
	case "NByteArray":
		t.Value.NByteArray = NByteArray{}
		return nil
	case "NArray2Uint64":
		t.Value.NArray2Uint64 = NArray2Uint64{}
		return nil
	case "NSetUint64":
		t.Value.NSetUint64 = NSetUint64(nil)
		return nil
	case "NMapUint64String":
		t.Value.NMapUint64String = NMapUint64String(nil)
		return nil
	case "NStruct":
		t.Value.NStruct = NStruct{}
		return nil
	case "NUnion":
		t.Value.NUnion = NUnion(NUnionA{})
		return nil
	case "TypeObject":
		t.Value.TypeObject = vdl.AnyType
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *StructManyTypesTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x StructManyTypes) VDLIsZero() bool {
	if x.Bool {
		return false
	}
	if x.AByte != 0 {
		return false
	}
	if x.Int16 != 0 {
		return false
	}
	if x.Int32 != 0 {
		return false
	}
	if x.Int64 != 0 {
		return false
	}
	if x.Uint16 != 0 {
		return false
	}
	if x.Uint32 != 0 {
		return false
	}
	if x.Uint64 != 0 {
		return false
	}
	if x.String != "" {
		return false
	}
	if len(x.Bytes) != 0 {
		return false
	}
	if x.Float32 != 0 {
		return false
	}
	if x.Float64 != 0 {
		return false
	}
	if x.FoodEnum != FoodEnumBean {
		return false
	}
	if x.NEnum != NEnumA {
		return false
	}
	if len(x.NListUint64) != 0 {
		return false
	}
	if x.NByteArray != (NByteArray{}) {
		return false
	}
	if x.NArray2Uint64 != (NArray2Uint64{}) {
		return false
	}
	if len(x.NSetUint64) != 0 {
		return false
	}
	if len(x.NMapUint64String) != 0 {
		return false
	}
	if x.NStruct != (NStruct{}) {
		return false
	}
	if x.NUnion != nil && !x.NUnion.VDLIsZero() {
		return false
	}
	if x.TypeObject != nil && x.TypeObject != vdl.AnyType {
		return false
	}
	return true
}

func (x StructManyTypes) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*StructManyTypes)(nil)).Elem()); err != nil {
		return err
	}
	if x.Bool {
		if err := enc.NextField("Bool"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Bool); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.AByte != 0 {
		if err := enc.NextField("AByte"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.AByte)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Int16 != 0 {
		if err := enc.NextField("Int16"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x.Int16)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Int32 != 0 {
		if err := enc.NextField("Int32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int32Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x.Int32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Int64 != 0 {
		if err := enc.NextField("Int64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.Int64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Uint16 != 0 {
		if err := enc.NextField("Uint16"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint16Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Uint16)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Uint32 != 0 {
		if err := enc.NextField("Uint32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Uint32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Uint64 != 0 {
		if err := enc.NextField("Uint64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(x.Uint64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.String != "" {
		if err := enc.NextField("String"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.String); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if len(x.Bytes) != 0 {
		if err := enc.NextField("Bytes"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*[]byte)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeBytes(x.Bytes); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Float32 != 0 {
		if err := enc.NextField("Float32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float32Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(float64(x.Float32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Float64 != 0 {
		if err := enc.NextField("Float64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(x.Float64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.FoodEnum != FoodEnumBean {
		if err := enc.NextField("FoodEnum"); err != nil {
			return err
		}
		if err := x.FoodEnum.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.NEnum != NEnumA {
		if err := enc.NextField("NEnum"); err != nil {
			return err
		}
		if err := x.NEnum.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.NListUint64) != 0 {
		if err := enc.NextField("NListUint64"); err != nil {
			return err
		}
		if err := x.NListUint64.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.NByteArray != (NByteArray{}) {
		if err := enc.NextField("NByteArray"); err != nil {
			return err
		}
		if err := x.NByteArray.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.NArray2Uint64 != (NArray2Uint64{}) {
		if err := enc.NextField("NArray2Uint64"); err != nil {
			return err
		}
		if err := x.NArray2Uint64.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.NSetUint64) != 0 {
		if err := enc.NextField("NSetUint64"); err != nil {
			return err
		}
		if err := x.NSetUint64.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.NMapUint64String) != 0 {
		if err := enc.NextField("NMapUint64String"); err != nil {
			return err
		}
		if err := x.NMapUint64String.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.NStruct != (NStruct{}) {
		if err := enc.NextField("NStruct"); err != nil {
			return err
		}
		if err := x.NStruct.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.NUnion != nil && !x.NUnion.VDLIsZero() {
		if err := enc.NextField("NUnion"); err != nil {
			return err
		}
		if err := x.NUnion.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.TypeObject != nil && x.TypeObject != vdl.AnyType {
		if err := enc.NextField("TypeObject"); err != nil {
			return err
		}
		if err := x.TypeObject.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *StructManyTypes) VDLRead(dec vdl.Decoder) error {
	*x = StructManyTypes{
		NUnion:     NUnionA{},
		TypeObject: vdl.AnyType,
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Bool":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Bool, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "AByte":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.AByte = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Int16":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			x.Int16 = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Int32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.Int32 = int32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Int64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Int64, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Uint16":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			x.Uint16 = uint16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Uint32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			x.Uint32 = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Uint64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Uint64, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "String":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.String, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Bytes":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if err := dec.DecodeBytes(-1, &x.Bytes); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Float32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			x.Float32 = float32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Float64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Float64, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "FoodEnum":
			if err := x.FoodEnum.VDLRead(dec); err != nil {
				return err
			}
		case "NEnum":
			if err := x.NEnum.VDLRead(dec); err != nil {
				return err
			}
		case "NListUint64":
			if err := x.NListUint64.VDLRead(dec); err != nil {
				return err
			}
		case "NByteArray":
			if err := x.NByteArray.VDLRead(dec); err != nil {
				return err
			}
		case "NArray2Uint64":
			if err := x.NArray2Uint64.VDLRead(dec); err != nil {
				return err
			}
		case "NSetUint64":
			if err := x.NSetUint64.VDLRead(dec); err != nil {
				return err
			}
		case "NMapUint64String":
			if err := x.NMapUint64String.VDLRead(dec); err != nil {
				return err
			}
		case "NStruct":
			if err := x.NStruct.VDLRead(dec); err != nil {
				return err
			}
		case "NUnion":
			if err := VDLReadNUnion(dec, &x.NUnion); err != nil {
				return err
			}
		case "TypeObject":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.TypeObject, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type AnySlice []*vdl.Value

func (AnySlice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.AnySlice"`
}) {
}

func (m *AnySlice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, len((*m)))
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}

		if err := vdl.FromValue(elemTarget2, elem3); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AnySlice) MakeVDLTarget() vdl.Target {
	return &AnySliceTarget{Value: m}
}

// AnySlice
type AnySliceTarget struct {
	Value *AnySlice

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *AnySliceTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*AnySlice)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make(AnySlice, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *AnySliceTarget) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
	return target, err
}
func (t *AnySliceTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *AnySliceTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x AnySlice) VDLIsZero() bool {
	return len(x) == 0
}

func (x AnySlice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AnySlice)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if x[i] == nil {
			if err := enc.NilValue(vdl.AnyType); err != nil {
				return err
			}
		} else {
			if err := x[i].VDLWrite(enc); err != nil {
				return err
			}
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AnySlice) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make(AnySlice, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem *vdl.Value
		elem = new(vdl.Value)
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type LargeMessageType struct {
	Payload []byte
	Next    *LargeMessageType
}

func (LargeMessageType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.LargeMessageType"`
}) {
}

func (m *LargeMessageType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.Payload) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("Payload"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Payload")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := fieldTarget3.FromBytes([]byte(m.Payload), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Next == (*LargeMessageType)(nil))
	if var7 {
		if err := fieldsTarget1.ZeroField("Next"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Next")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Next.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LargeMessageType) MakeVDLTarget() vdl.Target {
	return &LargeMessageTypeTarget{Value: m}
}

type LargeMessageTypeTarget struct {
	Value         *LargeMessageType
	payloadTarget vdl.BytesTarget

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LargeMessageTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LargeMessageType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LargeMessageTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Payload":
		t.payloadTarget.Value = &t.Value.Payload
		target, err := &t.payloadTarget, error(nil)
		return nil, target, err
	case "Next":
		target, err := &__VDLTarget13_optional{Value: &t.Value.Next}, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *LargeMessageTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LargeMessageTypeTarget) ZeroField(name string) error {
	switch name {
	case "Payload":
		t.Value.Payload = []byte(nil)
		return nil
	case "Next":
		t.Value.Next = (*LargeMessageType)(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *LargeMessageTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional LargeMessageType
type __VDLTarget13_optional struct {
	Value **LargeMessageType

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget13_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &LargeMessageType{}
	}
	target, err := &LargeMessageTypeTarget{Value: *t.Value}, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget13_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget13_optional) FromNil(tt *vdl.Type) error {
	*t.Value = (*LargeMessageType)(nil)
	return nil
}

func (x LargeMessageType) VDLIsZero() bool {
	if len(x.Payload) != 0 {
		return false
	}
	if x.Next != nil {
		return false
	}
	return true
}

func (x LargeMessageType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*LargeMessageType)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.Payload) != 0 {
		if err := enc.NextField("Payload"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.TypeOf((*[]byte)(nil))); err != nil {
			return err
		}
		if err := enc.EncodeBytes(x.Payload); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Next != nil {
		if err := enc.NextField("Next"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()
		if err := enc.StartValue(vdl.TypeOf((*LargeMessageType)(nil)).Elem()); err != nil {
			return err
		}
		if err := x.Next.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *LargeMessageType) VDLRead(dec vdl.Decoder) error {
	*x = LargeMessageType{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Payload":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if err := dec.DecodeBytes(-1, &x.Payload); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Next":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.Next), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.Next, dec.Type())
				}
				x.Next = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.Next = new(LargeMessageType)
				dec.IgnoreNextStartValue()
				if err := x.Next.VDLRead(dec); err != nil {
					return err
				}
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type LargeAnyMessageType struct {
	Payload *vdl.Value
	Next    *LargeAnyMessageType
}

func (LargeAnyMessageType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/vom/testdata/types.LargeAnyMessageType"`
}) {
}

func (m *LargeAnyMessageType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := m.Payload == nil || (m.Payload.Kind() == vdl.Any && m.Payload.IsZero())
	if var4 {
		if err := fieldsTarget1.ZeroField("Payload"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Payload")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := vdl.FromValue(fieldTarget3, m.Payload); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Next == (*LargeAnyMessageType)(nil))
	if var7 {
		if err := fieldsTarget1.ZeroField("Next"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Next")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Next.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *LargeAnyMessageType) MakeVDLTarget() vdl.Target {
	return &LargeAnyMessageTypeTarget{Value: m}
}

type LargeAnyMessageTypeTarget struct {
	Value *LargeAnyMessageType

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *LargeAnyMessageTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*LargeAnyMessageType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *LargeAnyMessageTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Payload":
		target, err := vdl.ReflectTarget(reflect.ValueOf(&t.Value.Payload))
		return nil, target, err
	case "Next":
		target, err := &__VDLTarget14_optional{Value: &t.Value.Next}, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *LargeAnyMessageTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *LargeAnyMessageTypeTarget) ZeroField(name string) error {
	switch name {
	case "Payload":
		t.Value.Payload = vdl.ZeroValue(vdl.AnyType)
		return nil
	case "Next":
		t.Value.Next = (*LargeAnyMessageType)(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *LargeAnyMessageTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional LargeAnyMessageType
type __VDLTarget14_optional struct {
	Value **LargeAnyMessageType

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget14_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &LargeAnyMessageType{
			Payload: vdl.ZeroValue(vdl.AnyType),
		}
	}
	target, err := &LargeAnyMessageTypeTarget{Value: *t.Value}, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget14_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget14_optional) FromNil(tt *vdl.Type) error {
	*t.Value = (*LargeAnyMessageType)(nil)
	return nil
}

func (x LargeAnyMessageType) VDLIsZero() bool {
	if x.Payload != nil && !x.Payload.VDLIsZero() {
		return false
	}
	if x.Next != nil {
		return false
	}
	return true
}

func (x LargeAnyMessageType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*LargeAnyMessageType)(nil)).Elem()); err != nil {
		return err
	}
	if x.Payload != nil && !x.Payload.VDLIsZero() {
		if err := enc.NextField("Payload"); err != nil {
			return err
		}
		if err := x.Payload.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Next != nil {
		if err := enc.NextField("Next"); err != nil {
			return err
		}
		enc.SetNextStartValueIsOptional()
		if err := enc.StartValue(vdl.TypeOf((*LargeAnyMessageType)(nil)).Elem()); err != nil {
			return err
		}
		if err := x.Next.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *LargeAnyMessageType) VDLRead(dec vdl.Decoder) error {
	*x = LargeAnyMessageType{
		Payload: vdl.ZeroValue(vdl.AnyType),
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Payload":
			x.Payload = new(vdl.Value)
			if err := x.Payload.VDLRead(dec); err != nil {
				return err
			}
		case "Next":
			if err := dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x.Next), dec.Type()) {
					return fmt.Errorf("incompatible optional %T, from %v", x.Next, dec.Type())
				}
				x.Next = nil
				if err := dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.Next = new(LargeAnyMessageType)
				dec.IgnoreNextStartValue()
				if err := x.Next.VDLRead(dec); err != nil {
					return err
				}
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*TestCase)(nil))
	vdl.Register((*ConvertGroup)(nil))
	vdl.Register((*VomdataStruct)(nil))
	vdl.Register((*NBool)(nil))
	vdl.Register((*NString)(nil))
	vdl.Register((*NByteSlice)(nil))
	vdl.Register((*NByteArray)(nil))
	vdl.Register((*NByte)(nil))
	vdl.Register((*NUint16)(nil))
	vdl.Register((*NUint32)(nil))
	vdl.Register((*NUint64)(nil))
	vdl.Register((*NInt8)(nil))
	vdl.Register((*NInt16)(nil))
	vdl.Register((*NInt32)(nil))
	vdl.Register((*NInt64)(nil))
	vdl.Register((*NFloat32)(nil))
	vdl.Register((*NFloat64)(nil))
	vdl.Register((*NArray2Uint64)(nil))
	vdl.Register((*NListUint64)(nil))
	vdl.Register((*NSetUint64)(nil))
	vdl.Register((*NMapUint64String)(nil))
	vdl.Register((*NStruct)(nil))
	vdl.Register((*NEnum)(nil))
	vdl.Register((*NUnion)(nil))
	vdl.Register((*MBool)(nil))
	vdl.Register((*MStruct)(nil))
	vdl.Register((*MList)(nil))
	vdl.Register((*MMap)(nil))
	vdl.Register((*MByteSlice)(nil))
	vdl.Register((*MInt8Slice)(nil))
	vdl.Register((*RecA)(nil))
	vdl.Register((*RecY)(nil))
	vdl.Register((*RecX)(nil))
	vdl.Register((*Rec4)(nil))
	vdl.Register((*Rec3)(nil))
	vdl.Register((*Rec2)(nil))
	vdl.Register((*Rec1)(nil))
	vdl.Register((*RecStruct)(nil))
	vdl.Register((*Rec1234)(nil))
	vdl.Register((*Rec1234A)(nil))
	vdl.Register((*Rec1234B)(nil))
	vdl.Register((*Rec1234All)(nil))
	vdl.Register((*ListString)(nil))
	vdl.Register((*Array3String)(nil))
	vdl.Register((*Array4String)(nil))
	vdl.Register((*AbcStruct)(nil))
	vdl.Register((*AdeStruct)(nil))
	vdl.Register((*XyzStruct)(nil))
	vdl.Register((*YzStruct)(nil))
	vdl.Register((*ZStruct)(nil))
	vdl.Register((*MapOnlyStruct)(nil))
	vdl.Register((*StructOnlyMap)(nil))
	vdl.Register((*MapSetStruct)(nil))
	vdl.Register((*SetStructMap)(nil))
	vdl.Register((*MapStructSet)(nil))
	vdl.Register((*SetOnlyMap)(nil))
	vdl.Register((*SometimesSetMap)(nil))
	vdl.Register((*MapOnlySet)(nil))
	vdl.Register((*SetOnlyA)(nil))
	vdl.Register((*SetOnlyA2)(nil))
	vdl.Register((*SetOnlyB)(nil))
	vdl.Register((*SetOnlyB2)(nil))
	vdl.Register((*MapOnlyA)(nil))
	vdl.Register((*MapOnlyA2)(nil))
	vdl.Register((*MapOnlyB)(nil))
	vdl.Register((*MapOnlyB2)(nil))
	vdl.Register((*BdeUnion)(nil))
	vdl.Register((*BrieEnum)(nil))
	vdl.Register((*BeanEnum)(nil))
	vdl.Register((*FoodEnum)(nil))
	vdl.Register((*StructAny)(nil))
	vdl.Register((*StructMap)(nil))
	vdl.Register((*StructManyTypes)(nil))
	vdl.Register((*AnySlice)(nil))
	vdl.Register((*LargeMessageType)(nil))
	vdl.Register((*LargeAnyMessageType)(nil))

	return struct{}{}
}
