package vom

import (
	"bytes"
	"encoding/json"
	"testing"

	"veyron.io/veyron/veyron2/verror"
)

// TestObjToJSON checks for expected JSON output for a range of objects.
func TestObjToJSON(t *testing.T) {
	type testCase struct {
		in  interface{}
		out string // array of possible outputs
	}

	anInt := 4
	aString := "str"
	aStringPtr := &aString

	var nullInterface interface{}
	var nullPtr *int

	tests := []testCase{
		testCase{int(0), "0"},
		testCase{int8(1), "1"},
		testCase{int16(2), "2"},
		testCase{int32(3), "3"},
		testCase{int64(4), "4"},
		testCase{uint(0), "0"},
		testCase{uint8(1), "1"},
		testCase{uint16(2), "2"},
		testCase{uint32(3), "3"},
		testCase{uint64(4), "4"},
		testCase{uintptr(4), "4"},
		testCase{float32(1.5), "1.5"},
		testCase{float32(3.141592), "3.141592025756836"},
		testCase{false, "false"},
		testCase{true, "true"},
		testCase{"str", "\"str\""},
		testCase{nil, "null"},
		testCase{verror.BadProtocolf("errorText"), "{\"iD\":\"veyron.io/veyron/veyron2/verror.BadProtocol\", \"msg\":\"errorText\"}"},
		testCase{[]int{4, 3}, "[4, 3]"},
		testCase{[]float64{}, "[]"},
		testCase{[]interface{}{1, "One"}, "[1, \"One\"]"},
		testCase{[1]string{"A"}, "[\"A\"]"},
		testCase{[0]string{}, "[]"},
		testCase{[2]interface{}{1, "One"}, "[1, \"One\"]"},
		testCase{struct {
			X int
			Y string
		}{4, "A"}, "{\"x\": 4, \"y\": \"A\"}"},
		testCase{struct {
			x int
			Y string
		}{2, "B"}, "{\"y\": \"B\"}"},
		testCase{struct {
		}{}, "{}"},
		testCase{struct {
			X interface{}
		}{nil}, "{\"x\": null}"},
		testCase{map[string]string{"A": "B", "C": "D"}, "{\"A\": \"B\", \"C\": \"D\"}"},
		testCase{map[float32]int{3.2: 4, 9: 5, 10: 6}, "{\"3.200000047683716\": 4, \"9\": 5, \"10\": 6}"},
		testCase{map[struct {
			X int
			Y bool
		}]int{struct {
			X int
			Y bool
		}{2, true}: 5}, "{\"{\\\"x\\\": 2, \\\"y\\\": true}\": 5}"},
		testCase{map[**string]string{&aStringPtr: "B"}, "{\"str\": \"B\"}"},
		testCase{map[error]string{verror.NoExistf("errorText"): "errorText"},
			`{"{\"iD\": \"veyron.io/veyron/veyron2/verror.NotFound\", \"msg\": \"errorText\"}": "errorText"}`},
		testCase{map[interface{}]interface{}{4: 1.7, "A": true}, "{\"4\": 1.7, \"\\\"A\\\"\": true}"},
		testCase{&anInt, "4"},
		testCase{&aStringPtr, "\"str\""},
		testCase{nullInterface, "null"},
		testCase{nullPtr, "null"},
	}

	for _, test := range tests {
		var buf bytes.Buffer
		err := ObjToJSON(&buf, ValueOf(test.in))
		if err != nil {
			t.Errorf("error converting %v to JSON: %v", test.in, err)
			continue
		}
		if err := equivalentJSON(test.out, buf.String()); err != nil {
			t.Error(err)
		}
	}
}

// TestObjToJSONErrors tests that the correct error messages are generated by ObjToJSON upon hitting
// error conditions.
func TestObjToJSONErrors(t *testing.T) {
	type testCase struct {
		in       interface{}
		errorMsg string
	}

	type recursiveStruct struct {
		Rs  *recursiveStruct
		Val int
	}
	recursive := recursiveStruct{Val: 4}
	recursive.Rs = &recursive
	recursiveLongerCycle := recursiveStruct{Rs: &recursiveStruct{Val: 1}, Val: 2}
	recursiveLongerCycle.Rs.Rs = &recursiveLongerCycle
	rsmap := map[recursiveStruct]int{recursive: 0}

	type dagTest struct {
		First  *dagTest
		Second *dagTest
	}
	root := dagTest{}
	dag := dagTest{&root, &root}

	tests := []testCase{
		testCase{recursive, "can only convert trees to JSON"},
		testCase{recursiveLongerCycle, "can only convert trees to JSON"},
		testCase{rsmap, "can only convert trees to JSON"},
		testCase{dag, "can only convert trees to JSON"},
	}

	for _, test := range tests {
		var buf bytes.Buffer
		err := ObjToJSON(&buf, ValueOf(test.in))
		if err == nil {
			t.Errorf("expected error when converting %v to JSON", test.in)
			continue
		}

		if err.Error() != test.errorMsg {
			t.Errorf("unexpected error message on input %v. Expected %v, got %v.", test.in, test.errorMsg, err.Error())
		}
	}
}

// innerBenchmark is a benchmark that is shared between two implementations of JSON encoding.
func innerBenchmark(n int, toJSON func(interface{}) string) {
	tests := []interface{}{
		struct {
			X int
			Y string
			z int
			m map[string][]int
		}{3, "X", 0, map[string][]int{
			"A": []int{4, 3},
			"B": []int{8, 3, 2, 1, 2, 3, 5, 8},
			"C": []int{4, 9, 3, 2, 9, 5, 3},
			"D": []int{4, 5, 2, 6, 9, 3},
			"E": []int{4, 2, 4, 2, 3, 3},
		}},
		(interface{})(4),
		[1000]bool{true, false},
		struct {
			A int
			B float64
			C float64
			D float64
			E float64
			F string
		}{},
	}
	for _, test := range tests {
		for i := 0; i < n; i++ {
			toJSON(test)
		}
	}
}

// BenchmarkObjToJSON tests the performance of ObjToJSON on a number of inputs.
func BenchmarkObjToJSON(b *testing.B) {
	innerBenchmark(b.N, func(in interface{}) string {
		var buf bytes.Buffer
		ObjToJSON(&buf, ValueOf(in))
		return buf.String()
	})
}

// BenchmarkEncodingJSON tests the performance of encoding/json on a number of inputs.
func BenchmarkEncodingJSON(b *testing.B) {
	innerBenchmark(b.N, func(in interface{}) string {
		byt, _ := json.Marshal(in)
		return string(byt)
	})
}
