// Copyright 2016 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Generator for VOM benchmarks.

// The following generates the benchmarks
//go:generate $JIRI_ROOT/release/go/src/v.io/v23/vom/internal/gen/gen.sh

package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
)

func main() {
	flag.Parse()
	file, err := os.Create(flag.Arg(0))
	if err != nil {
		panic(err)
	}

	file.WriteString(`// Copyright 2016 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Do not modify! This file is generated by:
// jiri go generate v.io/v23/vom/internal/gen

package internal

import (
	"testing"
	"errors"
	"time"

	"v.io/v23/rpc"
	"v.io/v23/vom"
	"v.io/v23/vtrace"
	"v.io/v23/uniqueid"
	"v.io/v23/security"
	wiretime "v.io/v23/vdlroot/time"
)

	`)
	for _, entry := range benchmarks {
		file.WriteString(genBenchmark(entry))
	}
	file.Close()
	exec.Command("go", "go")
}

// TODO(bprosnitz) Also generate JSON benchmarks with both our JSON encoder / decoder
// and the built-in go one for comparison.
type GeneratorEntry struct {
	Name         string
	ReflectValue string
	ReflectType  string
	GenValue     string
	GenType      string
}

var benchmarks []GeneratorEntry = []GeneratorEntry{
	{
		Name:         `Number`,
		ReflectValue: `XNumber(2)`,
		ReflectType:  `XNumber`,
		GenValue:     `VNumber(2)`,
		GenType:      `VNumber`,
	},
	{
		Name:         `SmallString`,
		ReflectValue: `XString("abc")`,
		ReflectType:  `XString`,
		GenValue:     `VString("abc")`,
		GenType:      `VString`,
	},
	{
		Name:         `LargeString`,
		ReflectValue: `XString(createString(65536))`,
		ReflectType:  `XString`,
		GenValue:     `VString(createString(65536))`,
		GenType:      `VString`,
	},
	{
		Name:     `Enum`,
		GenValue: `VEnumA`,
		GenType:  `VEnum`,
	},
	{
		Name:         `SmallByteList`,
		ReflectValue: `XByteList{1, 2, 3}`,
		ReflectType:  `XByteList`,
		GenValue:     `VByteList{1, 2, 3}`,
		GenType:      `VByteList`,
	},
	{
		Name:         `LargeByteList`,
		ReflectValue: `XByteList(createByteList(65536))`,
		ReflectType:  `XByteList`,
		GenValue:     `VByteList(createByteList(65536))`,
		GenType:      `VByteList`,
	},
	{
		Name:         `ByteArray`,
		ReflectValue: `XByteArray{1, 2, 3}`,
		ReflectType:  `XByteArray`,
		GenValue:     `VByteArray{1, 2, 3}`,
		GenType:      `VByteArray`,
	},
	{
		Name:         `Array`,
		ReflectValue: `XArray{1, 2, 3}`,
		ReflectType:  `XArray`,
		GenValue:     `VArray{1, 2, 3}`,
		GenType:      `VArray`,
	},
	{
		Name:         `SmallList`,
		ReflectValue: `XList{1, 2, 3}`,
		ReflectType:  `XList`,
		GenValue:     `VList{1, 2, 3}`,
		GenType:      `VList`,
	},
	{
		Name:         `LargeList`,
		ReflectValue: `XList(createList(65536))`,
		ReflectType:  `XList`,
		GenValue:     `VList(createList(65536))`,
		GenType:      `VList`,
	},
	// We will be handling data structures with a lot of anys for JSON:
	{
		Name:         `SmallListAny`,
		ReflectValue: `XListAny{vom.RawBytesOf(1), vom.RawBytesOf(2), vom.RawBytesOf(3)}`,
		ReflectType:  `XListAny`,
		GenValue:     `VListAny{vom.RawBytesOf(1), vom.RawBytesOf(2), vom.RawBytesOf(3)}`,
		GenType:      `VListAny`,
	},
	{
		Name:         `LargeListAny`,
		ReflectValue: `XListAny(createListAny(65536))`,
		ReflectType:  `XListAny`,
		GenValue:     `VListAny(createListAny(65536))`,
		GenType:      `VListAny`,
	},
	{
		Name:     `Set`,
		GenValue: `VSet{"A": struct{}{}, "B": struct{}{}, "C": struct{}{}}`,
		GenType:  `VSet`,
	},
	{
		Name:         `Map`,
		ReflectValue: `XMap{"A": true, "B": false, "C": true}`,
		ReflectType:  `XMap`,
		GenValue:     `VMap{"A": true, "B": false, "C": true}`,
		GenType:      `VMap`,
	},
	{
		Name:         `SmallStruct`,
		ReflectValue: `XSmallStruct{1, "A", true}`,
		ReflectType:  `XSmallStruct`,
		GenValue:     `VSmallStruct{1, "A", true}`,
		GenType:      `VSmallStruct`,
	},
	{
		Name:         `LargeStruct`,
		ReflectValue: `VLargeStruct{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50}`,
		ReflectType:  `VLargeStruct`,
		GenValue:     `VLargeStruct{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50}`,
		GenType:      `VLargeStruct`,
	},
	{
		Name:         `LargeStructZeroFields`,
		ReflectValue: `VLargeStruct{}`,
		ReflectType:  `VLargeStruct`,
		GenValue:     `VLargeStruct{}`,
		GenType:      `VLargeStruct`,
	},
	{
		Name:     `SmallUnion`,
		GenValue: `VSmallUnionA{1}`,
		GenType:  `VSmallUnion`,
	},

	{
		Name:         `Time`,
		ReflectValue: `time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)`,
		ReflectType:  `time.Time`,
	},

	{
		Name:         `Blessings`,
		ReflectValue: `createTypicalBlessings()`,
		ReflectType:  `security.Blessings`,
	},
	{
		Name:     `RpcRequestZero`,
		GenValue: `rpc.Request{}`,
		GenType:  `rpc.Request`,
	},
	{
		Name: `RpcRequestFull`,
		GenValue: `rpc.Request{
	Suffix: "a suffix",
	Method: "a method",
	NumPosArgs: 23,
	EndStreamArgs: true,
	Deadline: wiretime.Deadline{
		time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC),
	},
	GrantedBlessings: createTypicalBlessings(),
	TraceRequest: vtrace.Request{
		SpanId: uniqueid.Id{1,2,3,4},
		TraceId: uniqueid.Id{5,6,7,8},
		Flags: vtrace.CollectInMemory,
		LogLevel: 3,
	},
	Language: "en-us",
}`,
		GenType: `rpc.Request`,
	},
	{
		Name:     `RpcResponseZero`,
		GenValue: `rpc.Response{}`,
		GenType:  `rpc.Response`,
	},
	{
		Name: `RpcResponseFull`,
		GenValue: `rpc.Response{
	Error: errors.New("testerror"),
	EndStreamResults: true,
	NumPosResults: 4,
	TraceResponse: vtrace.Response{
		Flags: vtrace.CollectInMemory,
		Trace: vtrace.TraceRecord{
			Id: uniqueid.Id{1,2,3,4},
			Spans: []vtrace.SpanRecord{
				vtrace.SpanRecord{
					Id: uniqueid.Id{1,2,3,4},
					Parent: uniqueid.Id{4,3,2,1},
					Name: "span name",
					Start: time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC),
					End: time.Date(2009, time.November, 11, 23, 0, 0, 0, time.UTC),
					Annotations: []vtrace.Annotation{
						vtrace.Annotation {
							When: time.Date(2009, time.November, 10, 23, 0, 0, 4, time.UTC),
							Message: "Annotation Message",
						},
					},
				},
			},
		},
	},
}`,
		GenType: `rpc.Response`,
	},
}

func genDecodeBenchmark(name string, value string, t string, isReflect bool) string {
	var extra string
	if isReflect {
		extra = "Reflect"
	}
	return fmt.Sprintf(`
func Benchmark%[1]sSingleShotDecode%[2]s(b *testing.B) {
	var tofill %[4]s
	benchmarkSingleShotDecode(b, &tofill, %[3]s)
}
func Benchmark%[1]sRepeatedDecode%[2]s(b *testing.B) {
	var tofill %[4]s
	benchmarkRepeatedDecode(b, &tofill, %[3]s)
}`, name, extra, value, t)
}

func genEncodeBenchmark(name string, value string, isReflect bool) string {
	var extra string
	if isReflect {
		extra = "Reflect"
	}
	return fmt.Sprintf(`
func Benchmark%[1]sSingleShotEncode%[2]s(b *testing.B) {
	 benchmarkSingleShotEncode(b, %[3]s)
}
func Benchmark%[1]sRepeatedEncode%[2]s(b *testing.B) {
	benchmarkRepeatedEncode(b, %[3]s)
}`, name, extra, value)
}

func genBenchmark(entry GeneratorEntry) string {
	var str string
	if entry.ReflectValue != "" {
		str += genEncodeBenchmark(entry.Name, entry.ReflectValue, true)
		str += genDecodeBenchmark(entry.Name, entry.ReflectValue, entry.ReflectType, true)
	}
	if entry.GenValue != "" {
		str += genEncodeBenchmark(entry.Name, entry.GenValue, false)
		str += genDecodeBenchmark(entry.Name, entry.GenValue, entry.GenType, false)
	}
	return str
}
