package ipc

import "veyron.io/veyron/veyron2/wiretype"

// InterfaceSig describes the signature of an interface.
type InterfaceSig struct {
	Name    string
	PkgPath string
	Doc     string
	Embeds  []EmbedSig  // No special ordering.
	Methods []MethodSig // Ordered by method name.
}

// EmbedSig describes the signature of an embedded interface.
type EmbedSig struct {
	Name    string
	PkgPath string
	Doc     string
}

// MethodSig describes the signature of an interface method.
type MethodSig struct {
	Name    string
	Doc     string
	InArgs  []ArgSig // Input arguments
	OutArgs []ArgSig // Output arguments
	// TODO(toddw): Remove Has{In,Out}StreamHACK when optional is available.
	InStreamHACK     ArgSig // Input stream
	OutStreamHACK    ArgSig // Output stream
	HasInStreamHACK  bool   // Does InStreamHack contain valid data?
	HasOutStreamHACK bool   // Does OutStreamHack contain valid data?
	Tags             []any  // Method tags
}

// ArgSig describes the signature of a single argument.
type ArgSig struct {
	Name string
	Doc  string
	Type typeobject // Type of the argument.
}

// DEPRECATED(toddw): REMOVE THE BELOW SUPPORT

// ServiceSignature represents the signature of the service. This includes type information needed
// to resolve the method argument types.
// TODO(bprosnitz) Rename this and move it to wiretype.
type ServiceSignature struct {
	TypeDefs []any // A slice of wiretype structures form the type definition.
	Methods  map[string]MethodSignature
}

// MethodSignature represents the structure for passing around method
// signatures. This is usually sent in a ServiceSignature.
type MethodSignature struct {
	InArgs, OutArgs     []MethodArgument // Positional Argument information.
	InStream, OutStream wiretype.TypeID  // Type of streaming arguments (or TypeIDInvalid if none). The type IDs here use the definitions in ServiceSigature.TypeDefs.
}

// MethodArgument represents the argument to a method in a method signature.
type MethodArgument struct {
	Name string // Argument name
	Type wiretype.TypeID
}
