// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: nosql

package nosql

import (
	"fmt"
	"reflect"
	"time"
	"v.io/v23/services/syncbase/nosql"
	"v.io/v23/vdl"
	time_2 "v.io/v23/vdlroot/time"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// Value contains a specific version of data for the row under conflict along
// with the write timestamp and hints associated with the version.
// State defines whether the value is empty or not. It can be empty for
// reasons like Deleted or Unknown.
// WriteTs is the write timestamp for this value.
type Value struct {
	State   nosql.ValueState
	Val     []byte
	WriteTs time.Time
	// TODO(jlodhia): Since field Selection cannot be package private in VDL,
	// review the ConflictResolution API to see if we should keep this field
	// or not.
	Selection nosql.ValueSelection
}

func (Value) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/nosql.Value"`
}) {
}

func (m *Value) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("State")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.State.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Val")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := fieldTarget5.FromBytes([]byte(m.Val), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	var wireValue6 time_2.Time
	if err := time_2.TimeFromNative(&wireValue6, m.WriteTs); err != nil {
		return err
	}

	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("WriteTs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue6.FillVDLTarget(fieldTarget8, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("Selection")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Selection.FillVDLTarget(fieldTarget10, tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Value) MakeVDLTarget() vdl.Target {
	return &ValueTarget{Value: m}
}

type ValueTarget struct {
	Value           *Value
	stateTarget     nosql.ValueStateTarget
	valTarget       vdl.BytesTarget
	writeTsTarget   time_2.TimeTarget
	selectionTarget nosql.ValueSelectionTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ValueTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Value)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ValueTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "State":
		t.stateTarget.Value = &t.Value.State
		target, err := &t.stateTarget, error(nil)
		return nil, target, err
	case "Val":
		t.valTarget.Value = &t.Value.Val
		target, err := &t.valTarget, error(nil)
		return nil, target, err
	case "WriteTs":
		t.writeTsTarget.Value = &t.Value.WriteTs
		target, err := &t.writeTsTarget, error(nil)
		return nil, target, err
	case "Selection":
		t.selectionTarget.Value = &t.Value.Selection
		target, err := &t.selectionTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/nosql.Value", name)
	}
}
func (t *ValueTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ValueTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// ConflictRow represents a row under conflict.
// Key is the key for the row.
// LocalValue is the value present in the local db.
// RemoteValue is the value received via sync.
// AncestorValue is the value for the key which is the lowest common
// ancestor of the two values represented by LocalValue and RemoteValue.
// AncestorValue's state is NoExists if the ConflictRow is a part of the read set.
// BatchIds is a list of ids of all the batches that this row belongs to.
type ConflictRow struct {
	Key           string
	LocalValue    Value
	RemoteValue   Value
	AncestorValue Value
	BatchIds      []uint64
}

func (ConflictRow) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/nosql.ConflictRow"`
}) {
}

func (m *ConflictRow) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Key), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("LocalValue")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.LocalValue.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("RemoteValue")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.RemoteValue.FillVDLTarget(fieldTarget7, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("AncestorValue")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.AncestorValue.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("BatchIds")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget12, err := fieldTarget11.StartList(tt.NonOptional().Field(4).Type, len(m.BatchIds))
		if err != nil {
			return err
		}
		for i, elem14 := range m.BatchIds {
			elemTarget13, err := listTarget12.StartElem(i)
			if err != nil {
				return err
			}
			if err := elemTarget13.FromUint(uint64(elem14), tt.NonOptional().Field(4).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget12.FinishElem(elemTarget13); err != nil {
				return err
			}
		}
		if err := fieldTarget11.FinishList(listTarget12); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConflictRow) MakeVDLTarget() vdl.Target {
	return &ConflictRowTarget{Value: m}
}

type ConflictRowTarget struct {
	Value               *ConflictRow
	keyTarget           vdl.StringTarget
	localValueTarget    ValueTarget
	remoteValueTarget   ValueTarget
	ancestorValueTarget ValueTarget
	batchIdsTarget      __VDLTarget1_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictRowTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConflictRow)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictRowTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	case "LocalValue":
		t.localValueTarget.Value = &t.Value.LocalValue
		target, err := &t.localValueTarget, error(nil)
		return nil, target, err
	case "RemoteValue":
		t.remoteValueTarget.Value = &t.Value.RemoteValue
		target, err := &t.remoteValueTarget, error(nil)
		return nil, target, err
	case "AncestorValue":
		t.ancestorValueTarget.Value = &t.Value.AncestorValue
		target, err := &t.ancestorValueTarget, error(nil)
		return nil, target, err
	case "BatchIds":
		t.batchIdsTarget.Value = &t.Value.BatchIds
		target, err := &t.batchIdsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/nosql.ConflictRow", name)
	}
}
func (t *ConflictRowTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictRowTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []uint64
type __VDLTarget1_list struct {
	Value      *[]uint64
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]uint64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]uint64, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// ConflictRowSet contains a set of rows under conflict. It provides two different
// ways to access the same set.
// ByKey is a map of ConflictRows keyed by the row key.
// ByBatch is a map of []ConflictRows keyed by batch id. This map lets the client
// access all ConflictRows within this set that contain a given hint.
type ConflictRowSet struct {
	ByKey   map[string]ConflictRow
	ByBatch map[uint64][]ConflictRow
}

func (ConflictRowSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/nosql.ConflictRowSet"`
}) {
}

func (m *ConflictRowSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ByKey")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.ByKey))
		if err != nil {
			return err
		}
		for key6, value8 := range m.ByKey {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromString(string(key6), tt.NonOptional().Field(0).Type.Key()); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}

			if err := value8.FillVDLTarget(valueTarget7, tt.NonOptional().Field(0).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("ByBatch")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget11, err := fieldTarget10.StartMap(tt.NonOptional().Field(1).Type, len(m.ByBatch))
		if err != nil {
			return err
		}
		for key13, value15 := range m.ByBatch {
			keyTarget12, err := mapTarget11.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget12.FromUint(uint64(key13), tt.NonOptional().Field(1).Type.Key()); err != nil {
				return err
			}
			valueTarget14, err := mapTarget11.FinishKeyStartField(keyTarget12)
			if err != nil {
				return err
			}

			listTarget16, err := valueTarget14.StartList(tt.NonOptional().Field(1).Type.Elem(), len(value15))
			if err != nil {
				return err
			}
			for i, elem18 := range value15 {
				elemTarget17, err := listTarget16.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem18.FillVDLTarget(elemTarget17, tt.NonOptional().Field(1).Type.Elem().Elem()); err != nil {
					return err
				}
				if err := listTarget16.FinishElem(elemTarget17); err != nil {
					return err
				}
			}
			if err := valueTarget14.FinishList(listTarget16); err != nil {
				return err
			}
			if err := mapTarget11.FinishField(keyTarget12, valueTarget14); err != nil {
				return err
			}
		}
		if err := fieldTarget10.FinishMap(mapTarget11); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConflictRowSet) MakeVDLTarget() vdl.Target {
	return &ConflictRowSetTarget{Value: m}
}

type ConflictRowSetTarget struct {
	Value         *ConflictRowSet
	byKeyTarget   __VDLTarget2_map
	byBatchTarget __VDLTarget3_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictRowSetTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConflictRowSet)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictRowSetTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ByKey":
		t.byKeyTarget.Value = &t.Value.ByKey
		target, err := &t.byKeyTarget, error(nil)
		return nil, target, err
	case "ByBatch":
		t.byBatchTarget.Value = &t.Value.ByBatch
		target, err := &t.byBatchTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/nosql.ConflictRowSet", name)
	}
}
func (t *ConflictRowSetTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictRowSetTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[string]ConflictRow
type __VDLTarget2_map struct {
	Value      *map[string]ConflictRow
	currKey    string
	currElem   ConflictRow
	keyTarget  vdl.StringTarget
	elemTarget ConflictRowTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget2_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]ConflictRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]ConflictRow)
	return t, nil
}
func (t *__VDLTarget2_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().(ConflictRow)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget2_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint64][]ConflictRow
type __VDLTarget3_map struct {
	Value      *map[uint64][]ConflictRow
	currKey    uint64
	currElem   []ConflictRow
	keyTarget  vdl.Uint64Target
	elemTarget __VDLTarget4_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget3_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64][]ConflictRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64][]ConflictRow)
	return t, nil
}
func (t *__VDLTarget3_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().([]ConflictRow)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget3_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []ConflictRow
type __VDLTarget4_list struct {
	Value      *[]ConflictRow
	elemTarget ConflictRowTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget4_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]ConflictRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]ConflictRow, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget4_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget4_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// ConflictScanSet contains a set of scans under conflict.
// ByBatch is a map of array of ScanOps keyed by batch id.
type ConflictScanSet struct {
	ByBatch map[uint64][]nosql.ScanOp
}

func (ConflictScanSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/nosql.ConflictScanSet"`
}) {
}

func (m *ConflictScanSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ByBatch")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.ByBatch))
		if err != nil {
			return err
		}
		for key6, value8 := range m.ByBatch {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromUint(uint64(key6), tt.NonOptional().Field(0).Type.Key()); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}

			listTarget9, err := valueTarget7.StartList(tt.NonOptional().Field(0).Type.Elem(), len(value8))
			if err != nil {
				return err
			}
			for i, elem11 := range value8 {
				elemTarget10, err := listTarget9.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem11.FillVDLTarget(elemTarget10, tt.NonOptional().Field(0).Type.Elem().Elem()); err != nil {
					return err
				}
				if err := listTarget9.FinishElem(elemTarget10); err != nil {
					return err
				}
			}
			if err := valueTarget7.FinishList(listTarget9); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConflictScanSet) MakeVDLTarget() vdl.Target {
	return &ConflictScanSetTarget{Value: m}
}

type ConflictScanSetTarget struct {
	Value         *ConflictScanSet
	byBatchTarget __VDLTarget5_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictScanSetTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConflictScanSet)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictScanSetTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ByBatch":
		t.byBatchTarget.Value = &t.Value.ByBatch
		target, err := &t.byBatchTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/nosql.ConflictScanSet", name)
	}
}
func (t *ConflictScanSetTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictScanSetTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[uint64][]nosql.ScanOp
type __VDLTarget5_map struct {
	Value      *map[uint64][]nosql.ScanOp
	currKey    uint64
	currElem   []nosql.ScanOp
	keyTarget  vdl.Uint64Target
	elemTarget __VDLTarget6_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget5_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64][]nosql.ScanOp)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64][]nosql.ScanOp)
	return t, nil
}
func (t *__VDLTarget5_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []nosql.ScanOp(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget5_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []nosql.ScanOp
type __VDLTarget6_list struct {
	Value      *[]nosql.ScanOp
	elemTarget nosql.ScanOpTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget6_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]nosql.ScanOp)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]nosql.ScanOp, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget6_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget6_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget6_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Conflict contains information to fully specify a conflict. Since syncbase
// supports batches there can be one or more rows within the batch that has a
// conflict. Each of these rows will be sent together as part of a single
// conflict. Each row contains an Id of the batch to which it belongs,
// enabling the client to group together rows that are part of a batch. Note
// that a single row can be part of more than one batch.
//
// WriteSet contains rows that were written.
// ReadSet contains rows that were read within a batch corresponding to a row
// within the write set.
// ScanSet contains scans performed within a batch corresponding to a row
// within the write set.
// Batches is a map of unique ids to BatchInfo objects. The id is unique only in
// the context of a given conflict and is otherwise meaningless.
type Conflict struct {
	ReadSet  *ConflictRowSet
	WriteSet *ConflictRowSet
	ScanSet  *ConflictScanSet
	Batches  map[uint64]nosql.BatchInfo
}

func (Conflict) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/nosql.Conflict"`
}) {
}

func (m *Conflict) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ReadSet")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.ReadSet == nil {
			if err := fieldTarget3.FromNil(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			if err := m.ReadSet.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("WriteSet")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.WriteSet == nil {
			if err := fieldTarget5.FromNil(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {
			if err := m.WriteSet.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("ScanSet")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.ScanSet == nil {
			if err := fieldTarget7.FromNil(tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		} else {
			if err := m.ScanSet.FillVDLTarget(fieldTarget7, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Batches")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget10, err := fieldTarget9.StartMap(tt.NonOptional().Field(3).Type, len(m.Batches))
		if err != nil {
			return err
		}
		for key12, value14 := range m.Batches {
			keyTarget11, err := mapTarget10.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget11.FromUint(uint64(key12), tt.NonOptional().Field(3).Type.Key()); err != nil {
				return err
			}
			valueTarget13, err := mapTarget10.FinishKeyStartField(keyTarget11)
			if err != nil {
				return err
			}

			if err := value14.FillVDLTarget(valueTarget13, tt.NonOptional().Field(3).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget10.FinishField(keyTarget11, valueTarget13); err != nil {
				return err
			}
		}
		if err := fieldTarget9.FinishMap(mapTarget10); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Conflict) MakeVDLTarget() vdl.Target {
	return &ConflictTarget{Value: m}
}

type ConflictTarget struct {
	Value          *Conflict
	readSetTarget  __VDLTarget7_optional
	writeSetTarget __VDLTarget7_optional
	scanSetTarget  __VDLTarget8_optional
	batchesTarget  __VDLTarget9_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Conflict)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ReadSet":
		t.readSetTarget.Value = &t.Value.ReadSet
		target, err := &t.readSetTarget, error(nil)
		return nil, target, err
	case "WriteSet":
		t.writeSetTarget.Value = &t.Value.WriteSet
		target, err := &t.writeSetTarget, error(nil)
		return nil, target, err
	case "ScanSet":
		t.scanSetTarget.Value = &t.Value.ScanSet
		target, err := &t.scanSetTarget, error(nil)
		return nil, target, err
	case "Batches":
		t.batchesTarget.Value = &t.Value.Batches
		target, err := &t.batchesTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/nosql.Conflict", name)
	}
}
func (t *ConflictTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional ConflictRowSet
type __VDLTarget7_optional struct {
	Value      **ConflictRowSet
	elemTarget ConflictRowSetTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget7_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &ConflictRowSet{}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget7_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget7_optional) FromNil(tt *vdl.Type) error {

	*t.Value = nil

	return nil
}

// Optional ConflictScanSet
type __VDLTarget8_optional struct {
	Value      **ConflictScanSet
	elemTarget ConflictScanSetTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget8_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &ConflictScanSet{}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget8_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget8_optional) FromNil(tt *vdl.Type) error {

	*t.Value = nil

	return nil
}

// map[uint64]nosql.BatchInfo
type __VDLTarget9_map struct {
	Value      *map[uint64]nosql.BatchInfo
	currKey    uint64
	currElem   nosql.BatchInfo
	keyTarget  vdl.Uint64Target
	elemTarget nosql.BatchInfoTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget9_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64]nosql.BatchInfo)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64]nosql.BatchInfo)
	return t, nil
}
func (t *__VDLTarget9_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = nosql.BatchInfo{}
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget9_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// ResolvedRow represents a result of resolution of a row under conflict.
// Key is the key for the row.
// Result is the result of the conflict resolution. Delete is represented
// by nil.
type ResolvedRow struct {
	Key    string
	Result *Value
}

func (ResolvedRow) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/nosql.ResolvedRow"`
}) {
}

func (m *ResolvedRow) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Key), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Result")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if m.Result == nil {
			if err := fieldTarget5.FromNil(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {
			if err := m.Result.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ResolvedRow) MakeVDLTarget() vdl.Target {
	return &ResolvedRowTarget{Value: m}
}

type ResolvedRowTarget struct {
	Value        *ResolvedRow
	keyTarget    vdl.StringTarget
	resultTarget __VDLTarget10_optional
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ResolvedRowTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ResolvedRow)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ResolvedRowTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	case "Result":
		t.resultTarget.Value = &t.Value.Result
		target, err := &t.resultTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/nosql.ResolvedRow", name)
	}
}
func (t *ResolvedRowTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ResolvedRowTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Optional Value
type __VDLTarget10_optional struct {
	Value      **Value
	elemTarget ValueTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget10_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &Value{}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget10_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget10_optional) FromNil(tt *vdl.Type) error {

	*t.Value = nil

	return nil
}

// Resolution contains the application’s reply to a conflict. It must contain a
// resolved value for each conflict row within the WriteSet of the given
// conflict.
// ResultSet is a map of row key to ResolvedRow.
type Resolution struct {
	ResultSet map[string]ResolvedRow
}

func (Resolution) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/nosql.Resolution"`
}) {
}

func (m *Resolution) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ResultSet")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.ResultSet))
		if err != nil {
			return err
		}
		for key6, value8 := range m.ResultSet {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromString(string(key6), tt.NonOptional().Field(0).Type.Key()); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}

			if err := value8.FillVDLTarget(valueTarget7, tt.NonOptional().Field(0).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Resolution) MakeVDLTarget() vdl.Target {
	return &ResolutionTarget{Value: m}
}

type ResolutionTarget struct {
	Value           *Resolution
	resultSetTarget __VDLTarget11_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ResolutionTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Resolution)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ResolutionTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ResultSet":
		t.resultSetTarget.Value = &t.Value.ResultSet
		target, err := &t.resultSetTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/nosql.Resolution", name)
	}
}
func (t *ResolutionTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ResolutionTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[string]ResolvedRow
type __VDLTarget11_map struct {
	Value      *map[string]ResolvedRow
	currKey    string
	currElem   ResolvedRow
	keyTarget  vdl.StringTarget
	elemTarget ResolvedRowTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget11_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]ResolvedRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]ResolvedRow)
	return t, nil
}
func (t *__VDLTarget11_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget11_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().(ResolvedRow)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget11_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget11_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// Create zero values for each type.
var (
	__VDLZeroValue           = Value{}
	__VDLZeroConflictRow     = ConflictRow{}
	__VDLZeroConflictRowSet  = ConflictRowSet{}
	__VDLZeroConflictScanSet = ConflictScanSet{}
	__VDLZeroConflict        = Conflict{}
	__VDLZeroResolvedRow     = ResolvedRow{}
	__VDLZeroResolution      = Resolution{}
)

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}

	// Register types.
	vdl.Register((*Value)(nil))
	vdl.Register((*ConflictRow)(nil))
	vdl.Register((*ConflictRowSet)(nil))
	vdl.Register((*ConflictScanSet)(nil))
	vdl.Register((*Conflict)(nil))
	vdl.Register((*ResolvedRow)(nil))
	vdl.Register((*Resolution)(nil))

	return struct{}{}
}
