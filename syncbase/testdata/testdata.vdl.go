// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: testdata

package testdata

import (
	"fmt"
	"time"
	"v.io/v23/vdl"
	time_2 "v.io/v23/vdlroot/time"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

type AddressInfo struct {
	Street string
	City   string
	State  string
	Zip    string
}

func (AddressInfo) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.AddressInfo"`
}) {
}

func (m *AddressInfo) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Street == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Street"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Street")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Street), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.City == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("City"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("City")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.City), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.State == "")
	if var10 {
		if err := fieldsTarget1.ZeroField("State"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("State")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromString(string(m.State), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.Zip == "")
	if var13 {
		if err := fieldsTarget1.ZeroField("Zip"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Zip")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromString(string(m.Zip), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AddressInfo) MakeVDLTarget() vdl.Target {
	return &AddressInfoTarget{Value: m}
}

type AddressInfoTarget struct {
	Value        *AddressInfo
	streetTarget vdl.StringTarget
	cityTarget   vdl.StringTarget
	stateTarget  vdl.StringTarget
	zipTarget    vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AddressInfoTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*AddressInfo)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *AddressInfoTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Street":
		t.streetTarget.Value = &t.Value.Street
		target, err := &t.streetTarget, error(nil)
		return nil, target, err
	case "City":
		t.cityTarget.Value = &t.Value.City
		target, err := &t.cityTarget, error(nil)
		return nil, target, err
	case "State":
		t.stateTarget.Value = &t.Value.State
		target, err := &t.stateTarget, error(nil)
		return nil, target, err
	case "Zip":
		t.zipTarget.Value = &t.Value.Zip
		target, err := &t.zipTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.AddressInfo", name)
	}
}
func (t *AddressInfoTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AddressInfoTarget) ZeroField(name string) error {
	switch name {
	case "Street":
		t.Value.Street = ""
		return nil
	case "City":
		t.Value.City = ""
		return nil
	case "State":
		t.Value.State = ""
		return nil
	case "Zip":
		t.Value.Zip = ""
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.AddressInfo", name)
	}
}
func (t *AddressInfoTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *AddressInfo) VDLRead(dec vdl.Decoder) error {
	*x = AddressInfo{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Street":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Street, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "City":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.City, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "State":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.State, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Zip":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Zip, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type CreditAgency int

const (
	CreditAgencyEquifax CreditAgency = iota
	CreditAgencyExperian
	CreditAgencyTransUnion
)

// CreditAgencyAll holds all labels for CreditAgency.
var CreditAgencyAll = [...]CreditAgency{CreditAgencyEquifax, CreditAgencyExperian, CreditAgencyTransUnion}

// CreditAgencyFromString creates a CreditAgency from a string label.
func CreditAgencyFromString(label string) (x CreditAgency, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *CreditAgency) Set(label string) error {
	switch label {
	case "Equifax", "equifax":
		*x = CreditAgencyEquifax
		return nil
	case "Experian", "experian":
		*x = CreditAgencyExperian
		return nil
	case "TransUnion", "transunion":
		*x = CreditAgencyTransUnion
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.CreditAgency", label)
}

// String returns the string label of x.
func (x CreditAgency) String() string {
	switch x {
	case CreditAgencyEquifax:
		return "Equifax"
	case CreditAgencyExperian:
		return "Experian"
	case CreditAgencyTransUnion:
		return "TransUnion"
	}
	return ""
}

func (CreditAgency) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.CreditAgency"`
	Enum struct{ Equifax, Experian, TransUnion string }
}) {
}

func (m *CreditAgency) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *CreditAgency) MakeVDLTarget() vdl.Target {
	return &CreditAgencyTarget{Value: m}
}

type CreditAgencyTarget struct {
	Value *CreditAgency
	vdl.TargetBase
}

func (t *CreditAgencyTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*CreditAgency)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Equifax":
		*t.Value = 0
	case "Experian":
		*t.Value = 1
	case "TransUnion":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum CreditAgency", src)
	}

	return nil
}

func (x *CreditAgency) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err = x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type ExperianRating int

const (
	ExperianRatingGood ExperianRating = iota
	ExperianRatingBad
)

// ExperianRatingAll holds all labels for ExperianRating.
var ExperianRatingAll = [...]ExperianRating{ExperianRatingGood, ExperianRatingBad}

// ExperianRatingFromString creates a ExperianRating from a string label.
func ExperianRatingFromString(label string) (x ExperianRating, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ExperianRating) Set(label string) error {
	switch label {
	case "Good", "good":
		*x = ExperianRatingGood
		return nil
	case "Bad", "bad":
		*x = ExperianRatingBad
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.ExperianRating", label)
}

// String returns the string label of x.
func (x ExperianRating) String() string {
	switch x {
	case ExperianRatingGood:
		return "Good"
	case ExperianRatingBad:
		return "Bad"
	}
	return ""
}

func (ExperianRating) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.ExperianRating"`
	Enum struct{ Good, Bad string }
}) {
}

func (m *ExperianRating) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *ExperianRating) MakeVDLTarget() vdl.Target {
	return &ExperianRatingTarget{Value: m}
}

type ExperianRatingTarget struct {
	Value *ExperianRating
	vdl.TargetBase
}

func (t *ExperianRatingTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*ExperianRating)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Good":
		*t.Value = 0
	case "Bad":
		*t.Value = 1
	default:
		return fmt.Errorf("label %s not in enum ExperianRating", src)
	}

	return nil
}

func (x *ExperianRating) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err = x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type EquifaxCreditReport struct {
	Rating byte
}

func (EquifaxCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.EquifaxCreditReport"`
}) {
}

func (m *EquifaxCreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Rating == byte(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("Rating"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rating")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromUint(uint64(m.Rating), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *EquifaxCreditReport) MakeVDLTarget() vdl.Target {
	return &EquifaxCreditReportTarget{Value: m}
}

type EquifaxCreditReportTarget struct {
	Value        *EquifaxCreditReport
	ratingTarget vdl.ByteTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *EquifaxCreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*EquifaxCreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *EquifaxCreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Rating":
		t.ratingTarget.Value = &t.Value.Rating
		target, err := &t.ratingTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.EquifaxCreditReport", name)
	}
}
func (t *EquifaxCreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *EquifaxCreditReportTarget) ZeroField(name string) error {
	switch name {
	case "Rating":
		t.Value.Rating = byte(0)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.EquifaxCreditReport", name)
	}
}
func (t *EquifaxCreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *EquifaxCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = EquifaxCreditReport{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Rating":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.Rating = byte(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type ExperianCreditReport struct {
	Rating ExperianRating
}

func (ExperianCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.ExperianCreditReport"`
}) {
}

func (m *ExperianCreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Rating == ExperianRatingGood)
	if var4 {
		if err := fieldsTarget1.ZeroField("Rating"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rating")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Rating.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ExperianCreditReport) MakeVDLTarget() vdl.Target {
	return &ExperianCreditReportTarget{Value: m}
}

type ExperianCreditReportTarget struct {
	Value        *ExperianCreditReport
	ratingTarget ExperianRatingTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ExperianCreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ExperianCreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ExperianCreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Rating":
		t.ratingTarget.Value = &t.Value.Rating
		target, err := &t.ratingTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.ExperianCreditReport", name)
	}
}
func (t *ExperianCreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ExperianCreditReportTarget) ZeroField(name string) error {
	switch name {
	case "Rating":
		t.Value.Rating = ExperianRatingGood
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.ExperianCreditReport", name)
	}
}
func (t *ExperianCreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *ExperianCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = ExperianCreditReport{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Rating":
			match++
			if err = x.Rating.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type TransUnionCreditReport struct {
	Rating int16
}

func (TransUnionCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.TransUnionCreditReport"`
}) {
}

func (m *TransUnionCreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Rating == int16(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("Rating"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rating")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromInt(int64(m.Rating), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TransUnionCreditReport) MakeVDLTarget() vdl.Target {
	return &TransUnionCreditReportTarget{Value: m}
}

type TransUnionCreditReportTarget struct {
	Value        *TransUnionCreditReport
	ratingTarget vdl.Int16Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TransUnionCreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*TransUnionCreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *TransUnionCreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Rating":
		t.ratingTarget.Value = &t.Value.Rating
		target, err := &t.ratingTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.TransUnionCreditReport", name)
	}
}
func (t *TransUnionCreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TransUnionCreditReportTarget) ZeroField(name string) error {
	switch name {
	case "Rating":
		t.Value.Rating = int16(0)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.TransUnionCreditReport", name)
	}
}
func (t *TransUnionCreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *TransUnionCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = TransUnionCreditReport{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Rating":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			x.Rating = int16(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type (
	// AgencyReport represents any single field of the AgencyReport union type.
	AgencyReport interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the AgencyReport union type.
		__VDLReflect(__AgencyReportReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// AgencyReportEquifaxReport represents field EquifaxReport of the AgencyReport union type.
	AgencyReportEquifaxReport struct{ Value EquifaxCreditReport }
	// AgencyReportExperianReport represents field ExperianReport of the AgencyReport union type.
	AgencyReportExperianReport struct{ Value ExperianCreditReport }
	// AgencyReportTransUnionReport represents field TransUnionReport of the AgencyReport union type.
	AgencyReportTransUnionReport struct{ Value TransUnionCreditReport }
	// __AgencyReportReflect describes the AgencyReport union type.
	__AgencyReportReflect struct {
		Name               string `vdl:"v.io/v23/syncbase/testdata.AgencyReport"`
		Type               AgencyReport
		UnionTargetFactory agencyReportTargetFactory
		Union              struct {
			EquifaxReport    AgencyReportEquifaxReport
			ExperianReport   AgencyReportExperianReport
			TransUnionReport AgencyReportTransUnionReport
		}
	}
)

func (x AgencyReportEquifaxReport) Index() int                         { return 0 }
func (x AgencyReportEquifaxReport) Interface() interface{}             { return x.Value }
func (x AgencyReportEquifaxReport) Name() string                       { return "EquifaxReport" }
func (x AgencyReportEquifaxReport) __VDLReflect(__AgencyReportReflect) {}

func (m AgencyReportEquifaxReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("EquifaxReport")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m AgencyReportEquifaxReport) MakeVDLTarget() vdl.Target {
	return nil
}

func (x AgencyReportExperianReport) Index() int                         { return 1 }
func (x AgencyReportExperianReport) Interface() interface{}             { return x.Value }
func (x AgencyReportExperianReport) Name() string                       { return "ExperianReport" }
func (x AgencyReportExperianReport) __VDLReflect(__AgencyReportReflect) {}

func (m AgencyReportExperianReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ExperianReport")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m AgencyReportExperianReport) MakeVDLTarget() vdl.Target {
	return nil
}

func (x AgencyReportTransUnionReport) Index() int                         { return 2 }
func (x AgencyReportTransUnionReport) Interface() interface{}             { return x.Value }
func (x AgencyReportTransUnionReport) Name() string                       { return "TransUnionReport" }
func (x AgencyReportTransUnionReport) __VDLReflect(__AgencyReportReflect) {}

func (m AgencyReportTransUnionReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("TransUnionReport")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(2).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m AgencyReportTransUnionReport) MakeVDLTarget() vdl.Target {
	return nil
}

type AgencyReportTarget struct {
	Value     *AgencyReport
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AgencyReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*AgencyReport)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *AgencyReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "EquifaxReport":
		val := EquifaxCreditReport{}
		return nil, &EquifaxCreditReportTarget{Value: &val}, nil
	case "ExperianReport":
		val := ExperianCreditReport{}
		return nil, &ExperianCreditReportTarget{Value: &val}, nil
	case "TransUnionReport":
		val := TransUnionCreditReport{}
		return nil, &TransUnionCreditReportTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/syncbase/testdata.AgencyReport", name)
	}
}
func (t *AgencyReportTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "EquifaxReport":
		*t.Value = AgencyReportEquifaxReport{*(fieldTarget.(*EquifaxCreditReportTarget)).Value}
	case "ExperianReport":
		*t.Value = AgencyReportExperianReport{*(fieldTarget.(*ExperianCreditReportTarget)).Value}
	case "TransUnionReport":
		*t.Value = AgencyReportTransUnionReport{*(fieldTarget.(*TransUnionCreditReportTarget)).Value}
	}
	return nil
}
func (t *AgencyReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type agencyReportTargetFactory struct{}

func (t agencyReportTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*AgencyReport); ok {
		return &AgencyReportTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *AgencyReport", union)
}

func VDLReadAgencyReport(dec vdl.Decoder, x *AgencyReport) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", *x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "EquifaxReport":
		var field AgencyReportEquifaxReport
		if err = field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "ExperianReport":
		var field AgencyReportExperianReport
		if err = field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "TransUnionReport":
		var field AgencyReportTransUnionReport
		if err = field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type CreditReport struct {
	Agency CreditAgency
	Report AgencyReport
}

func (CreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.CreditReport"`
}) {
}

func (m *CreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Agency == CreditAgencyEquifax)
	if var4 {
		if err := fieldsTarget1.ZeroField("Agency"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Agency")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Agency.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if field, ok := m.Report.(AgencyReportEquifaxReport); ok {

		var8 := (field.Value == EquifaxCreditReport{})
		var7 = var8
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("Report"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Report")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			unionValue9 := m.Report
			if unionValue9 == nil {
				unionValue9 = AgencyReportEquifaxReport{}
			}
			if err := unionValue9.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *CreditReport) MakeVDLTarget() vdl.Target {
	return &CreditReportTarget{Value: m}
}

type CreditReportTarget struct {
	Value        *CreditReport
	agencyTarget CreditAgencyTarget
	reportTarget AgencyReportTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*CreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Agency":
		t.agencyTarget.Value = &t.Value.Agency
		target, err := &t.agencyTarget, error(nil)
		return nil, target, err
	case "Report":
		t.reportTarget.Value = &t.Value.Report
		target, err := &t.reportTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.CreditReport", name)
	}
}
func (t *CreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CreditReportTarget) ZeroField(name string) error {
	switch name {
	case "Agency":
		t.Value.Agency = CreditAgencyEquifax
		return nil
	case "Report":
		t.Value.Report = AgencyReport(AgencyReportEquifaxReport{})
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.CreditReport", name)
	}
}
func (t *CreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *CreditReport) VDLRead(dec vdl.Decoder) error {
	*x = CreditReport{
		Report: AgencyReportEquifaxReport{},
	}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Agency":
			match++
			if err = x.Agency.VDLRead(dec); err != nil {
				return err
			}
		case "Report":
			match++
			if err = VDLReadAgencyReport(dec, &x.Report); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Customer struct {
	Name    string
	Id      int64
	Active  bool
	Address AddressInfo
	Credit  CreditReport
}

func (Customer) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.Customer"`
}) {
}

func (m *Customer) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Id == int64(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Id"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Id")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromInt(int64(m.Id), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Active == false)
	if var10 {
		if err := fieldsTarget1.ZeroField("Active"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Active")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromBool(bool(m.Active), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.Address == AddressInfo{})
	if var13 {
		if err := fieldsTarget1.ZeroField("Address"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Address")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Address.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var16 := (m.Credit == CreditReport{
		Report: AgencyReportEquifaxReport{},
	})
	if var16 {
		if err := fieldsTarget1.ZeroField("Credit"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("Credit")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Credit.FillVDLTarget(fieldTarget15, tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Customer) MakeVDLTarget() vdl.Target {
	return &CustomerTarget{Value: m}
}

type CustomerTarget struct {
	Value         *Customer
	nameTarget    vdl.StringTarget
	idTarget      vdl.Int64Target
	activeTarget  vdl.BoolTarget
	addressTarget AddressInfoTarget
	creditTarget  CreditReportTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CustomerTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Customer)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CustomerTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Id":
		t.idTarget.Value = &t.Value.Id
		target, err := &t.idTarget, error(nil)
		return nil, target, err
	case "Active":
		t.activeTarget.Value = &t.Value.Active
		target, err := &t.activeTarget, error(nil)
		return nil, target, err
	case "Address":
		t.addressTarget.Value = &t.Value.Address
		target, err := &t.addressTarget, error(nil)
		return nil, target, err
	case "Credit":
		t.creditTarget.Value = &t.Value.Credit
		target, err := &t.creditTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.Customer", name)
	}
}
func (t *CustomerTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CustomerTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Id":
		t.Value.Id = int64(0)
		return nil
	case "Active":
		t.Value.Active = false
		return nil
	case "Address":
		t.Value.Address = AddressInfo{}
		return nil
	case "Credit":
		t.Value.Credit = CreditReport{
			Report: AgencyReportEquifaxReport{},
		}
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.Customer", name)
	}
}
func (t *CustomerTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *Customer) VDLRead(dec vdl.Decoder) error {
	*x = Customer{
		Credit: CreditReport{
			Report: AgencyReportEquifaxReport{},
		},
	}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Name":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Id":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Id, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Active":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Active, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Address":
			match++
			if err = x.Address.VDLRead(dec); err != nil {
				return err
			}
		case "Credit":
			match++
			if err = x.Credit.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Invoice struct {
	CustId      int64
	InvoiceNum  int64
	InvoiceDate time.Time
	Amount      int64
	ShipTo      AddressInfo
}

func (Invoice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.Invoice"`
}) {
}

func (m *Invoice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.CustId == int64(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("CustId"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("CustId")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromInt(int64(m.CustId), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.InvoiceNum == int64(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("InvoiceNum"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("InvoiceNum")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromInt(int64(m.InvoiceNum), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var wireValue8 time_2.Time
	if err := time_2.TimeFromNative(&wireValue8, m.InvoiceDate); err != nil {
		return err
	}

	var11 := (wireValue8 == time_2.Time{})
	if var11 {
		if err := fieldsTarget1.ZeroField("InvoiceDate"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("InvoiceDate")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue8.FillVDLTarget(fieldTarget10, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
				return err
			}
		}
	}
	var14 := (m.Amount == int64(0))
	if var14 {
		if err := fieldsTarget1.ZeroField("Amount"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("Amount")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget13.FromInt(int64(m.Amount), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
				return err
			}
		}
	}
	var17 := (m.ShipTo == AddressInfo{})
	if var17 {
		if err := fieldsTarget1.ZeroField("ShipTo"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget15, fieldTarget16, err := fieldsTarget1.StartField("ShipTo")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.ShipTo.FillVDLTarget(fieldTarget16, tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget15, fieldTarget16); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Invoice) MakeVDLTarget() vdl.Target {
	return &InvoiceTarget{Value: m}
}

type InvoiceTarget struct {
	Value             *Invoice
	custIdTarget      vdl.Int64Target
	invoiceNumTarget  vdl.Int64Target
	invoiceDateTarget time_2.TimeTarget
	amountTarget      vdl.Int64Target
	shipToTarget      AddressInfoTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *InvoiceTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Invoice)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *InvoiceTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "CustId":
		t.custIdTarget.Value = &t.Value.CustId
		target, err := &t.custIdTarget, error(nil)
		return nil, target, err
	case "InvoiceNum":
		t.invoiceNumTarget.Value = &t.Value.InvoiceNum
		target, err := &t.invoiceNumTarget, error(nil)
		return nil, target, err
	case "InvoiceDate":
		t.invoiceDateTarget.Value = &t.Value.InvoiceDate
		target, err := &t.invoiceDateTarget, error(nil)
		return nil, target, err
	case "Amount":
		t.amountTarget.Value = &t.Value.Amount
		target, err := &t.amountTarget, error(nil)
		return nil, target, err
	case "ShipTo":
		t.shipToTarget.Value = &t.Value.ShipTo
		target, err := &t.shipToTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.Invoice", name)
	}
}
func (t *InvoiceTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *InvoiceTarget) ZeroField(name string) error {
	switch name {
	case "CustId":
		t.Value.CustId = int64(0)
		return nil
	case "InvoiceNum":
		t.Value.InvoiceNum = int64(0)
		return nil
	case "InvoiceDate":
		t.Value.InvoiceDate = func() time.Time {
			var native time.Time
			if err := vdl.Convert(&native, time_2.Time{}); err != nil {
				panic(err)
			}
			return native
		}()
		return nil
	case "Amount":
		t.Value.Amount = int64(0)
		return nil
	case "ShipTo":
		t.Value.ShipTo = AddressInfo{}
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.Invoice", name)
	}
}
func (t *InvoiceTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *Invoice) VDLRead(dec vdl.Decoder) error {
	*x = Invoice{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "CustId":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.CustId, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "InvoiceNum":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.InvoiceNum, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "InvoiceDate":
			match++
			var wire time_2.Time
			if err = wire.VDLRead(dec); err != nil {
				return err
			}
			if err = time_2.TimeToNative(wire, &x.InvoiceDate); err != nil {
				return err
			}
		case "Amount":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Amount, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "ShipTo":
			match++
			if err = x.ShipTo.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Numbers struct {
	B    byte
	Ui16 uint16
	Ui32 uint32
	Ui64 uint64
	I16  int16
	I32  int32
	I64  int64
	F32  float32
	F64  float64
}

func (Numbers) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.Numbers"`
}) {
}

func (m *Numbers) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.B == byte(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromUint(uint64(m.B), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Ui16 == uint16(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Ui16"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Ui16")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromUint(uint64(m.Ui16), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Ui32 == uint32(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("Ui32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Ui32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromUint(uint64(m.Ui32), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.Ui64 == uint64(0))
	if var13 {
		if err := fieldsTarget1.ZeroField("Ui64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Ui64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromUint(uint64(m.Ui64), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var16 := (m.I16 == int16(0))
	if var16 {
		if err := fieldsTarget1.ZeroField("I16"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("I16")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget15.FromInt(int64(m.I16), tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var19 := (m.I32 == int32(0))
	if var19 {
		if err := fieldsTarget1.ZeroField("I32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("I32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget18.FromInt(int64(m.I32), tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
				return err
			}
		}
	}
	var22 := (m.I64 == int64(0))
	if var22 {
		if err := fieldsTarget1.ZeroField("I64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("I64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget21.FromInt(int64(m.I64), tt.NonOptional().Field(6).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
				return err
			}
		}
	}
	var25 := (m.F32 == float32(0))
	if var25 {
		if err := fieldsTarget1.ZeroField("F32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("F32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget24.FromFloat(float64(m.F32), tt.NonOptional().Field(7).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
				return err
			}
		}
	}
	var28 := (m.F64 == float64(0))
	if var28 {
		if err := fieldsTarget1.ZeroField("F64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("F64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget27.FromFloat(float64(m.F64), tt.NonOptional().Field(8).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Numbers) MakeVDLTarget() vdl.Target {
	return &NumbersTarget{Value: m}
}

type NumbersTarget struct {
	Value      *Numbers
	bTarget    vdl.ByteTarget
	ui16Target vdl.Uint16Target
	ui32Target vdl.Uint32Target
	ui64Target vdl.Uint64Target
	i16Target  vdl.Int16Target
	i32Target  vdl.Int32Target
	i64Target  vdl.Int64Target
	f32Target  vdl.Float32Target
	f64Target  vdl.Float64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NumbersTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Numbers)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *NumbersTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "Ui16":
		t.ui16Target.Value = &t.Value.Ui16
		target, err := &t.ui16Target, error(nil)
		return nil, target, err
	case "Ui32":
		t.ui32Target.Value = &t.Value.Ui32
		target, err := &t.ui32Target, error(nil)
		return nil, target, err
	case "Ui64":
		t.ui64Target.Value = &t.Value.Ui64
		target, err := &t.ui64Target, error(nil)
		return nil, target, err
	case "I16":
		t.i16Target.Value = &t.Value.I16
		target, err := &t.i16Target, error(nil)
		return nil, target, err
	case "I32":
		t.i32Target.Value = &t.Value.I32
		target, err := &t.i32Target, error(nil)
		return nil, target, err
	case "I64":
		t.i64Target.Value = &t.Value.I64
		target, err := &t.i64Target, error(nil)
		return nil, target, err
	case "F32":
		t.f32Target.Value = &t.Value.F32
		target, err := &t.f32Target, error(nil)
		return nil, target, err
	case "F64":
		t.f64Target.Value = &t.Value.F64
		target, err := &t.f64Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.Numbers", name)
	}
}
func (t *NumbersTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *NumbersTarget) ZeroField(name string) error {
	switch name {
	case "B":
		t.Value.B = byte(0)
		return nil
	case "Ui16":
		t.Value.Ui16 = uint16(0)
		return nil
	case "Ui32":
		t.Value.Ui32 = uint32(0)
		return nil
	case "Ui64":
		t.Value.Ui64 = uint64(0)
		return nil
	case "I16":
		t.Value.I16 = int16(0)
		return nil
	case "I32":
		t.Value.I32 = int32(0)
		return nil
	case "I64":
		t.Value.I64 = int64(0)
		return nil
	case "F32":
		t.Value.F32 = float32(0)
		return nil
	case "F64":
		t.Value.F64 = float64(0)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.Numbers", name)
	}
}
func (t *NumbersTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *Numbers) VDLRead(dec vdl.Decoder) error {
	*x = Numbers{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "B":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.B = byte(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Ui16":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			x.Ui16 = uint16(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Ui32":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			x.Ui32 = uint32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Ui64":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Ui64, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "I16":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			x.I16 = int16(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "I32":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.I32 = int32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "I64":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.I64, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "F32":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			x.F32 = float32(tmp)
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "F64":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.F64, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type (
	// TitleOrValueType represents any single field of the TitleOrValueType union type.
	TitleOrValueType interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the TitleOrValueType union type.
		__VDLReflect(__TitleOrValueTypeReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// TitleOrValueTypeTitle represents field Title of the TitleOrValueType union type.
	TitleOrValueTypeTitle struct{ Value string }
	// TitleOrValueTypeValue represents field Value of the TitleOrValueType union type.
	TitleOrValueTypeValue struct{ Value int64 }
	// __TitleOrValueTypeReflect describes the TitleOrValueType union type.
	__TitleOrValueTypeReflect struct {
		Name               string `vdl:"v.io/v23/syncbase/testdata.TitleOrValueType"`
		Type               TitleOrValueType
		UnionTargetFactory titleOrValueTypeTargetFactory
		Union              struct {
			Title TitleOrValueTypeTitle
			Value TitleOrValueTypeValue
		}
	}
)

func (x TitleOrValueTypeTitle) Index() int                             { return 0 }
func (x TitleOrValueTypeTitle) Interface() interface{}                 { return x.Value }
func (x TitleOrValueTypeTitle) Name() string                           { return "Title" }
func (x TitleOrValueTypeTitle) __VDLReflect(__TitleOrValueTypeReflect) {}

func (m TitleOrValueTypeTitle) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Title")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m TitleOrValueTypeTitle) MakeVDLTarget() vdl.Target {
	return nil
}

func (x TitleOrValueTypeValue) Index() int                             { return 1 }
func (x TitleOrValueTypeValue) Interface() interface{}                 { return x.Value }
func (x TitleOrValueTypeValue) Name() string                           { return "Value" }
func (x TitleOrValueTypeValue) __VDLReflect(__TitleOrValueTypeReflect) {}

func (m TitleOrValueTypeValue) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Value")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromInt(int64(m.Value), tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m TitleOrValueTypeValue) MakeVDLTarget() vdl.Target {
	return nil
}

type TitleOrValueTypeTarget struct {
	Value     *TitleOrValueType
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TitleOrValueTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*TitleOrValueType)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *TitleOrValueTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "Title":
		val := ""
		return nil, &vdl.StringTarget{Value: &val}, nil
	case "Value":
		val := int64(0)
		return nil, &vdl.Int64Target{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/syncbase/testdata.TitleOrValueType", name)
	}
}
func (t *TitleOrValueTypeTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "Title":
		*t.Value = TitleOrValueTypeTitle{*(fieldTarget.(*vdl.StringTarget)).Value}
	case "Value":
		*t.Value = TitleOrValueTypeValue{*(fieldTarget.(*vdl.Int64Target)).Value}
	}
	return nil
}
func (t *TitleOrValueTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type titleOrValueTypeTargetFactory struct{}

func (t titleOrValueTypeTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*TitleOrValueType); ok {
		return &TitleOrValueTypeTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *TitleOrValueType", union)
}

func VDLReadTitleOrValueType(dec vdl.Decoder, x *TitleOrValueType) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", *x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "Title":
		var field TitleOrValueTypeTitle
		if err = dec.StartValue(); err != nil {
			return err
		}
		if field.Value, err = dec.DecodeString(); err != nil {
			return err
		}
		if err = dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "Value":
		var field TitleOrValueTypeValue
		if err = dec.StartValue(); err != nil {
			return err
		}
		if field.Value, err = dec.DecodeInt(64); err != nil {
			return err
		}
		if err = dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type BazType struct {
	Name         string
	TitleOrValue TitleOrValueType
}

func (BazType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.BazType"`
}) {
}

func (m *BazType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if field, ok := m.TitleOrValue.(TitleOrValueTypeTitle); ok {

		var8 := (field.Value == "")
		var7 = var8
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("TitleOrValue"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("TitleOrValue")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			unionValue9 := m.TitleOrValue
			if unionValue9 == nil {
				unionValue9 = TitleOrValueTypeTitle{}
			}
			if err := unionValue9.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BazType) MakeVDLTarget() vdl.Target {
	return &BazTypeTarget{Value: m}
}

type BazTypeTarget struct {
	Value              *BazType
	nameTarget         vdl.StringTarget
	titleOrValueTarget TitleOrValueTypeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BazTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*BazType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *BazTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "TitleOrValue":
		t.titleOrValueTarget.Value = &t.Value.TitleOrValue
		target, err := &t.titleOrValueTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.BazType", name)
	}
}
func (t *BazTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BazTypeTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "TitleOrValue":
		t.Value.TitleOrValue = TitleOrValueType(TitleOrValueTypeTitle{})
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.BazType", name)
	}
}
func (t *BazTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *BazType) VDLRead(dec vdl.Decoder) error {
	*x = BazType{
		TitleOrValue: TitleOrValueTypeTitle{},
	}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Name":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "TitleOrValue":
			match++
			if err = VDLReadTitleOrValueType(dec, &x.TitleOrValue); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type BarType struct {
	Baz BazType
}

func (BarType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.BarType"`
}) {
}

func (m *BarType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Baz == BazType{
		TitleOrValue: TitleOrValueTypeTitle{},
	})
	if var4 {
		if err := fieldsTarget1.ZeroField("Baz"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Baz")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Baz.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BarType) MakeVDLTarget() vdl.Target {
	return &BarTypeTarget{Value: m}
}

type BarTypeTarget struct {
	Value     *BarType
	bazTarget BazTypeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BarTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*BarType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *BarTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Baz":
		t.bazTarget.Value = &t.Value.Baz
		target, err := &t.bazTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.BarType", name)
	}
}
func (t *BarTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BarTypeTarget) ZeroField(name string) error {
	switch name {
	case "Baz":
		t.Value.Baz = BazType{
			TitleOrValue: TitleOrValueTypeTitle{},
		}
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.BarType", name)
	}
}
func (t *BarTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *BarType) VDLRead(dec vdl.Decoder) error {
	*x = BarType{
		Baz: BazType{
			TitleOrValue: TitleOrValueTypeTitle{},
		},
	}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Baz":
			match++
			if err = x.Baz.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type FooType struct {
	Bar BarType
}

func (FooType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.FooType"`
}) {
}

func (m *FooType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Bar == BarType{
		Baz: BazType{
			TitleOrValue: TitleOrValueTypeTitle{},
		},
	})
	if var4 {
		if err := fieldsTarget1.ZeroField("Bar"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Bar")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Bar.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *FooType) MakeVDLTarget() vdl.Target {
	return &FooTypeTarget{Value: m}
}

type FooTypeTarget struct {
	Value     *FooType
	barTarget BarTypeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *FooTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*FooType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *FooTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Bar":
		t.barTarget.Value = &t.Value.Bar
		target, err := &t.barTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.FooType", name)
	}
}
func (t *FooTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *FooTypeTarget) ZeroField(name string) error {
	switch name {
	case "Bar":
		t.Value.Bar = BarType{
			Baz: BazType{
				TitleOrValue: TitleOrValueTypeTitle{},
			},
		}
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.FooType", name)
	}
}
func (t *FooTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *FooType) VDLRead(dec vdl.Decoder) error {
	*x = FooType{
		Bar: BarType{
			Baz: BazType{
				TitleOrValue: TitleOrValueTypeTitle{},
			},
		},
	}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Bar":
			match++
			if err = x.Bar.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type ArrayOfFour [4]string

func (ArrayOfFour) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.ArrayOfFour"`
}) {
}

func (m *ArrayOfFour) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 4)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromString(string(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ArrayOfFour) MakeVDLTarget() vdl.Target {
	return &ArrayOfFourTarget{Value: m}
}

// ArrayOfFour
type ArrayOfFourTarget struct {
	Value      *ArrayOfFour
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *ArrayOfFourTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*ArrayOfFour)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ArrayOfFourTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *ArrayOfFourTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *ArrayOfFourTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x *ArrayOfFour) VDLRead(dec vdl.Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, got %d, want %T", index, *x)
		case done:
			return dec.FinishValue()
		}
		var elem string
		if err = dec.StartValue(); err != nil {
			return err
		}
		if elem, err = dec.DecodeString(); err != nil {
			return err
		}
		if err = dec.FinishValue(); err != nil {
			return err
		}
		x[index] = elem
		index++
	}
}

type KeyIndexData struct {
	A ArrayOfFour
	L []string
	M map[int64]string
	S map[string]struct{}
}

func (KeyIndexData) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.KeyIndexData"`
}) {
}

func (m *KeyIndexData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A == ArrayOfFour{})
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.A.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.L) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("L"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("L")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget8, err := fieldTarget6.StartList(tt.NonOptional().Field(1).Type, len(m.L))
			if err != nil {
				return err
			}
			for i, elem10 := range m.L {
				elemTarget9, err := listTarget8.StartElem(i)
				if err != nil {
					return err
				}
				if err := elemTarget9.FromString(string(elem10), tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget8.FinishElem(elemTarget9); err != nil {
					return err
				}
			}
			if err := fieldTarget6.FinishList(listTarget8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var var13 bool
	if len(m.M) == 0 {
		var13 = true
	}
	if var13 {
		if err := fieldsTarget1.ZeroField("M"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("M")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget14, err := fieldTarget12.StartMap(tt.NonOptional().Field(2).Type, len(m.M))
			if err != nil {
				return err
			}
			for key16, value18 := range m.M {
				keyTarget15, err := mapTarget14.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget15.FromInt(int64(key16), tt.NonOptional().Field(2).Type.Key()); err != nil {
					return err
				}
				valueTarget17, err := mapTarget14.FinishKeyStartField(keyTarget15)
				if err != nil {
					return err
				}
				if err := valueTarget17.FromString(string(value18), tt.NonOptional().Field(2).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget14.FinishField(keyTarget15, valueTarget17); err != nil {
					return err
				}
			}
			if err := fieldTarget12.FinishMap(mapTarget14); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var var21 bool
	if len(m.S) == 0 {
		var21 = true
	}
	if var21 {
		if err := fieldsTarget1.ZeroField("S"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget19, fieldTarget20, err := fieldsTarget1.StartField("S")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget22, err := fieldTarget20.StartSet(tt.NonOptional().Field(3).Type, len(m.S))
			if err != nil {
				return err
			}
			for key24 := range m.S {
				keyTarget23, err := setTarget22.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget23.FromString(string(key24), tt.NonOptional().Field(3).Type.Key()); err != nil {
					return err
				}
				if err := setTarget22.FinishKey(keyTarget23); err != nil {
					return err
				}
			}
			if err := fieldTarget20.FinishSet(setTarget22); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget19, fieldTarget20); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *KeyIndexData) MakeVDLTarget() vdl.Target {
	return &KeyIndexDataTarget{Value: m}
}

type KeyIndexDataTarget struct {
	Value   *KeyIndexData
	aTarget ArrayOfFourTarget
	lTarget vdl.StringSliceTarget
	mTarget __VDLTarget1_map
	sTarget __VDLTarget2_set
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *KeyIndexDataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*KeyIndexData)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *KeyIndexDataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "L":
		t.lTarget.Value = &t.Value.L
		target, err := &t.lTarget, error(nil)
		return nil, target, err
	case "M":
		t.mTarget.Value = &t.Value.M
		target, err := &t.mTarget, error(nil)
		return nil, target, err
	case "S":
		t.sTarget.Value = &t.Value.S
		target, err := &t.sTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.KeyIndexData", name)
	}
}
func (t *KeyIndexDataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *KeyIndexDataTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = ArrayOfFour{}
		return nil
	case "L":
		t.Value.L = []string(nil)
		return nil
	case "M":
		t.Value.M = map[int64]string(nil)
		return nil
	case "S":
		t.Value.S = map[string]struct{}(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.KeyIndexData", name)
	}
}
func (t *KeyIndexDataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[int64]string
type __VDLTarget1_map struct {
	Value      *map[int64]string
	currKey    int64
	currElem   string
	keyTarget  vdl.Int64Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget1_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int64]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int64]string)
	return t, nil
}
func (t *__VDLTarget1_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget1_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[string]struct{}
type __VDLTarget2_set struct {
	Value     *map[string]struct{}
	currKey   string
	keyTarget vdl.StringTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget2_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]struct{})
	return t, nil
}
func (t *__VDLTarget2_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget2_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x *KeyIndexData) VDLRead(dec vdl.Decoder) error {
	*x = KeyIndexData{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "A":
			match++
			if err = x.A.VDLRead(dec); err != nil {
				return err
			}
		case "L":
			match++
			if err = __VDLRead1_list(dec, &x.L); err != nil {
				return err
			}
		case "M":
			match++
			if err = __VDLRead2_map(dec, &x.M); err != nil {
				return err
			}
		case "S":
			match++
			if err = __VDLRead3_set(dec, &x.S); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead1_list(dec vdl.Decoder, x *[]string) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
	case len > 0:
		*x = make([]string, 0, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem string
		if err = dec.StartValue(); err != nil {
			return err
		}
		if elem, err = dec.DecodeString(); err != nil {
			return err
		}
		if err = dec.FinishValue(); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLRead2_map(dec vdl.Decoder, x *map[int64]string) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
		return dec.FinishValue()
	case len > 0:
		*x = make(map[int64]string, len)
	default:
		*x = make(map[int64]string)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var key int64
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		(*x)[key] = elem
	}
}

func __VDLRead3_set(dec vdl.Decoder, x *map[string]struct{}) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
		return dec.FinishValue()
	case len > 0:
		*x = make(map[string]struct{}, len)
	default:
		*x = make(map[string]struct{})
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var key string
		{
			if err = dec.StartValue(); err != nil {
				return err
			}
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		}
		(*x)[key] = struct{}{}
	}
}

type BigData struct {
	Key string // A dup of the key stored in the value.
}

func (BigData) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase/testdata.BigData"`
}) {
}

func (m *BigData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Key == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Key"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Key), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BigData) MakeVDLTarget() vdl.Target {
	return &BigDataTarget{Value: m}
}

type BigDataTarget struct {
	Value     *BigData
	keyTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BigDataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*BigData)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *BigDataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.BigData", name)
	}
}
func (t *BigDataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BigDataTarget) ZeroField(name string) error {
	switch name {
	case "Key":
		t.Value.Key = ""
		return nil
	default:
		return fmt.Errorf("field %s not in struct v.io/v23/syncbase/testdata.BigData", name)
	}
}
func (t *BigDataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *BigData) VDLRead(dec vdl.Decoder) error {
	*x = BigData{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Key":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*AddressInfo)(nil))
	vdl.Register((*CreditAgency)(nil))
	vdl.Register((*ExperianRating)(nil))
	vdl.Register((*EquifaxCreditReport)(nil))
	vdl.Register((*ExperianCreditReport)(nil))
	vdl.Register((*TransUnionCreditReport)(nil))
	vdl.Register((*AgencyReport)(nil))
	vdl.Register((*CreditReport)(nil))
	vdl.Register((*Customer)(nil))
	vdl.Register((*Invoice)(nil))
	vdl.Register((*Numbers)(nil))
	vdl.Register((*TitleOrValueType)(nil))
	vdl.Register((*BazType)(nil))
	vdl.Register((*BarType)(nil))
	vdl.Register((*FooType)(nil))
	vdl.Register((*ArrayOfFour)(nil))
	vdl.Register((*KeyIndexData)(nil))
	vdl.Register((*BigData)(nil))

	return struct{}{}
}
