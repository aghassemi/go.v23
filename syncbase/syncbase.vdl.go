// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: syncbase

package syncbase

import (
	"fmt"
	"reflect"
	"time"
	"v.io/v23/services/syncbase"
	"v.io/v23/vdl"
	time_2 "v.io/v23/vdlroot/time"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// Value contains a specific version of data for the row under conflict along
// with the write timestamp and hints associated with the version.
// State defines whether the value is empty or not. It can be empty for
// reasons like Deleted or Unknown.
// WriteTs is the write timestamp for this value.
type Value struct {
	State   syncbase.ValueState
	Val     []byte
	WriteTs time.Time
	// TODO(jlodhia): Since field Selection cannot be package private in VDL,
	// review the ConflictResolution API to see if we should keep this field
	// or not.
	Selection syncbase.ValueSelection
}

func (Value) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.Value"`
}) {
}

func (m *Value) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("State")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := (m.State == syncbase.ValueStateExists)
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {

			if err := m.State.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Val")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var7 bool
		if len(m.Val) == 0 {
			var7 = true
		}
		if var7 {
			if err := fieldTarget6.FromZero(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {

			if err := fieldTarget6.FromBytes([]byte(m.Val), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
			return err
		}
	}
	var wireValue8 time_2.Time
	if err := time_2.TimeFromNative(&wireValue8, m.WriteTs); err != nil {
		return err
	}

	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("WriteTs")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var11 := (wireValue8 == time_2.Time{})
		if var11 {
			if err := fieldTarget10.FromZero(tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		} else {

			if err := wireValue8.FillVDLTarget(fieldTarget10, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("Selection")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var14 := (m.Selection == syncbase.ValueSelectionLocal)
		if var14 {
			if err := fieldTarget13.FromZero(tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		} else {

			if err := m.Selection.FillVDLTarget(fieldTarget13, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Value) MakeVDLTarget() vdl.Target {
	return &ValueTarget{Value: m}
}

type ValueTarget struct {
	Value           *Value
	stateTarget     syncbase.ValueStateTarget
	valTarget       vdl.BytesTarget
	writeTsTarget   time_2.TimeTarget
	selectionTarget syncbase.ValueSelectionTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ValueTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Value)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ValueTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "State":
		t.stateTarget.Value = &t.Value.State
		target, err := &t.stateTarget, error(nil)
		return nil, target, err
	case "Val":
		t.valTarget.Value = &t.Value.Val
		target, err := &t.valTarget, error(nil)
		return nil, target, err
	case "WriteTs":
		t.writeTsTarget.Value = &t.Value.WriteTs
		target, err := &t.writeTsTarget, error(nil)
		return nil, target, err
	case "Selection":
		t.selectionTarget.Value = &t.Value.Selection
		target, err := &t.selectionTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase.Value", name)
	}
}
func (t *ValueTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ValueTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *ValueTarget) FromZero(tt *vdl.Type) error {
	*t.Value = Value{}
	return nil
}

// ConflictRow represents a row under conflict.
// Key is the key for the row.
// LocalValue is the value present in the local db.
// RemoteValue is the value received via sync.
// AncestorValue is the value for the key which is the lowest common
// ancestor of the two values represented by LocalValue and RemoteValue.
// AncestorValue's state is NoExists if the ConflictRow is a part of the read set.
// BatchIds is a list of ids of all the batches that this row belongs to.
type ConflictRow struct {
	Key           string
	LocalValue    Value
	RemoteValue   Value
	AncestorValue Value
	BatchIds      []uint64
}

func (ConflictRow) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.ConflictRow"`
}) {
}

func (m *ConflictRow) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := (m.Key == "")
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget3.FromString(string(m.Key), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("LocalValue")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var7 := true
		var8 := (m.LocalValue.State == syncbase.ValueStateExists)
		var7 = var7 && var8
		var var9 bool
		if len(m.LocalValue.Val) == 0 {
			var9 = true
		}
		var7 = var7 && var9
		var wireValue10 time_2.Time
		if err := time_2.TimeFromNative(&wireValue10, m.LocalValue.WriteTs); err != nil {
			return fmt.Errorf("error converting m.LocalValue.WriteTs to wiretype")
		}

		var11 := (wireValue10 == time_2.Time{})
		var7 = var7 && var11
		var12 := (m.LocalValue.Selection == syncbase.ValueSelectionLocal)
		var7 = var7 && var12
		if var7 {
			if err := fieldTarget6.FromZero(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {

			if err := m.LocalValue.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
			return err
		}
	}
	keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("RemoteValue")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var15 := true
		var16 := (m.RemoteValue.State == syncbase.ValueStateExists)
		var15 = var15 && var16
		var var17 bool
		if len(m.RemoteValue.Val) == 0 {
			var17 = true
		}
		var15 = var15 && var17
		var wireValue18 time_2.Time
		if err := time_2.TimeFromNative(&wireValue18, m.RemoteValue.WriteTs); err != nil {
			return fmt.Errorf("error converting m.RemoteValue.WriteTs to wiretype")
		}

		var19 := (wireValue18 == time_2.Time{})
		var15 = var15 && var19
		var20 := (m.RemoteValue.Selection == syncbase.ValueSelectionLocal)
		var15 = var15 && var20
		if var15 {
			if err := fieldTarget14.FromZero(tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		} else {

			if err := m.RemoteValue.FillVDLTarget(fieldTarget14, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
			return err
		}
	}
	keyTarget21, fieldTarget22, err := fieldsTarget1.StartField("AncestorValue")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var23 := true
		var24 := (m.AncestorValue.State == syncbase.ValueStateExists)
		var23 = var23 && var24
		var var25 bool
		if len(m.AncestorValue.Val) == 0 {
			var25 = true
		}
		var23 = var23 && var25
		var wireValue26 time_2.Time
		if err := time_2.TimeFromNative(&wireValue26, m.AncestorValue.WriteTs); err != nil {
			return fmt.Errorf("error converting m.AncestorValue.WriteTs to wiretype")
		}

		var27 := (wireValue26 == time_2.Time{})
		var23 = var23 && var27
		var28 := (m.AncestorValue.Selection == syncbase.ValueSelectionLocal)
		var23 = var23 && var28
		if var23 {
			if err := fieldTarget22.FromZero(tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		} else {

			if err := m.AncestorValue.FillVDLTarget(fieldTarget22, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget21, fieldTarget22); err != nil {
			return err
		}
	}
	keyTarget29, fieldTarget30, err := fieldsTarget1.StartField("BatchIds")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var31 bool
		if len(m.BatchIds) == 0 {
			var31 = true
		}
		if var31 {
			if err := fieldTarget30.FromZero(tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
		} else {

			listTarget32, err := fieldTarget30.StartList(tt.NonOptional().Field(4).Type, len(m.BatchIds))
			if err != nil {
				return err
			}
			for i, elem34 := range m.BatchIds {
				elemTarget33, err := listTarget32.StartElem(i)
				if err != nil {
					return err
				}
				if err := elemTarget33.FromUint(uint64(elem34), tt.NonOptional().Field(4).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget32.FinishElem(elemTarget33); err != nil {
					return err
				}
			}
			if err := fieldTarget30.FinishList(listTarget32); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget29, fieldTarget30); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConflictRow) MakeVDLTarget() vdl.Target {
	return &ConflictRowTarget{Value: m}
}

type ConflictRowTarget struct {
	Value               *ConflictRow
	keyTarget           vdl.StringTarget
	localValueTarget    ValueTarget
	remoteValueTarget   ValueTarget
	ancestorValueTarget ValueTarget
	batchIdsTarget      __VDLTarget1_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictRowTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConflictRow)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictRowTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	case "LocalValue":
		t.localValueTarget.Value = &t.Value.LocalValue
		target, err := &t.localValueTarget, error(nil)
		return nil, target, err
	case "RemoteValue":
		t.remoteValueTarget.Value = &t.Value.RemoteValue
		target, err := &t.remoteValueTarget, error(nil)
		return nil, target, err
	case "AncestorValue":
		t.ancestorValueTarget.Value = &t.Value.AncestorValue
		target, err := &t.ancestorValueTarget, error(nil)
		return nil, target, err
	case "BatchIds":
		t.batchIdsTarget.Value = &t.Value.BatchIds
		target, err := &t.batchIdsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase.ConflictRow", name)
	}
}
func (t *ConflictRowTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictRowTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *ConflictRowTarget) FromZero(tt *vdl.Type) error {
	*t.Value = ConflictRow{}
	return nil
}

// []uint64
type __VDLTarget1_list struct {
	Value      *[]uint64
	elemTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]uint64)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]uint64, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}
func (t *__VDLTarget1_list) FromZero(tt *vdl.Type) error {
	*t.Value = []uint64(nil)
	return nil
}

// ConflictRowSet contains a set of rows under conflict. It provides two different
// ways to access the same set.
// ByKey is a map of ConflictRows keyed by the row key.
// ByBatch is a map of []ConflictRows keyed by batch id. This map lets the client
// access all ConflictRows within this set that contain a given hint.
type ConflictRowSet struct {
	ByKey   map[string]ConflictRow
	ByBatch map[uint64][]ConflictRow
}

func (ConflictRowSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.ConflictRowSet"`
}) {
}

func (m *ConflictRowSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ByKey")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var4 bool
		if len(m.ByKey) == 0 {
			var4 = true
		}
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {

			mapTarget5, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.ByKey))
			if err != nil {
				return err
			}
			for key7, value9 := range m.ByKey {
				keyTarget6, err := mapTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromString(string(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				valueTarget8, err := mapTarget5.FinishKeyStartField(keyTarget6)
				if err != nil {
					return err
				}

				if err := value9.FillVDLTarget(valueTarget8, tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget5.FinishField(keyTarget6, valueTarget8); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishMap(mapTarget5); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("ByBatch")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var12 bool
		if len(m.ByBatch) == 0 {
			var12 = true
		}
		if var12 {
			if err := fieldTarget11.FromZero(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {

			mapTarget13, err := fieldTarget11.StartMap(tt.NonOptional().Field(1).Type, len(m.ByBatch))
			if err != nil {
				return err
			}
			for key15, value17 := range m.ByBatch {
				keyTarget14, err := mapTarget13.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget14.FromUint(uint64(key15), tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				valueTarget16, err := mapTarget13.FinishKeyStartField(keyTarget14)
				if err != nil {
					return err
				}

				listTarget18, err := valueTarget16.StartList(tt.NonOptional().Field(1).Type.Elem(), len(value17))
				if err != nil {
					return err
				}
				for i, elem20 := range value17 {
					elemTarget19, err := listTarget18.StartElem(i)
					if err != nil {
						return err
					}

					if err := elem20.FillVDLTarget(elemTarget19, tt.NonOptional().Field(1).Type.Elem().Elem()); err != nil {
						return err
					}
					if err := listTarget18.FinishElem(elemTarget19); err != nil {
						return err
					}
				}
				if err := valueTarget16.FinishList(listTarget18); err != nil {
					return err
				}
				if err := mapTarget13.FinishField(keyTarget14, valueTarget16); err != nil {
					return err
				}
			}
			if err := fieldTarget11.FinishMap(mapTarget13); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConflictRowSet) MakeVDLTarget() vdl.Target {
	return &ConflictRowSetTarget{Value: m}
}

type ConflictRowSetTarget struct {
	Value         *ConflictRowSet
	byKeyTarget   __VDLTarget2_map
	byBatchTarget __VDLTarget3_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictRowSetTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConflictRowSet)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictRowSetTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ByKey":
		t.byKeyTarget.Value = &t.Value.ByKey
		target, err := &t.byKeyTarget, error(nil)
		return nil, target, err
	case "ByBatch":
		t.byBatchTarget.Value = &t.Value.ByBatch
		target, err := &t.byBatchTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase.ConflictRowSet", name)
	}
}
func (t *ConflictRowSetTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictRowSetTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *ConflictRowSetTarget) FromZero(tt *vdl.Type) error {
	*t.Value = ConflictRowSet{}
	return nil
}

// map[string]ConflictRow
type __VDLTarget2_map struct {
	Value      *map[string]ConflictRow
	currKey    string
	currElem   ConflictRow
	keyTarget  vdl.StringTarget
	elemTarget ConflictRowTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget2_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]ConflictRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]ConflictRow)
	return t, nil
}
func (t *__VDLTarget2_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().(ConflictRow)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget2_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}
func (t *__VDLTarget2_map) FromZero(tt *vdl.Type) error {
	*t.Value = map[string]ConflictRow(nil)
	return nil
}

// map[uint64][]ConflictRow
type __VDLTarget3_map struct {
	Value      *map[uint64][]ConflictRow
	currKey    uint64
	currElem   []ConflictRow
	keyTarget  vdl.Uint64Target
	elemTarget __VDLTarget4_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget3_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64][]ConflictRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64][]ConflictRow)
	return t, nil
}
func (t *__VDLTarget3_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().([]ConflictRow)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget3_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}
func (t *__VDLTarget3_map) FromZero(tt *vdl.Type) error {
	*t.Value = map[uint64][]ConflictRow(nil)
	return nil
}

// []ConflictRow
type __VDLTarget4_list struct {
	Value      *[]ConflictRow
	elemTarget ConflictRowTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget4_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]ConflictRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]ConflictRow, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget4_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget4_list) FinishList(elem vdl.ListTarget) error {

	return nil
}
func (t *__VDLTarget4_list) FromZero(tt *vdl.Type) error {
	*t.Value = []ConflictRow(nil)
	return nil
}

// ConflictScanSet contains a set of scans under conflict.
// ByBatch is a map of array of ScanOps keyed by batch id.
type ConflictScanSet struct {
	ByBatch map[uint64][]syncbase.ScanOp
}

func (ConflictScanSet) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.ConflictScanSet"`
}) {
}

func (m *ConflictScanSet) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ByBatch")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var4 bool
		if len(m.ByBatch) == 0 {
			var4 = true
		}
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {

			mapTarget5, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.ByBatch))
			if err != nil {
				return err
			}
			for key7, value9 := range m.ByBatch {
				keyTarget6, err := mapTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromUint(uint64(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				valueTarget8, err := mapTarget5.FinishKeyStartField(keyTarget6)
				if err != nil {
					return err
				}

				listTarget10, err := valueTarget8.StartList(tt.NonOptional().Field(0).Type.Elem(), len(value9))
				if err != nil {
					return err
				}
				for i, elem12 := range value9 {
					elemTarget11, err := listTarget10.StartElem(i)
					if err != nil {
						return err
					}

					if err := elem12.FillVDLTarget(elemTarget11, tt.NonOptional().Field(0).Type.Elem().Elem()); err != nil {
						return err
					}
					if err := listTarget10.FinishElem(elemTarget11); err != nil {
						return err
					}
				}
				if err := valueTarget8.FinishList(listTarget10); err != nil {
					return err
				}
				if err := mapTarget5.FinishField(keyTarget6, valueTarget8); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishMap(mapTarget5); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ConflictScanSet) MakeVDLTarget() vdl.Target {
	return &ConflictScanSetTarget{Value: m}
}

type ConflictScanSetTarget struct {
	Value         *ConflictScanSet
	byBatchTarget __VDLTarget5_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictScanSetTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ConflictScanSet)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictScanSetTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ByBatch":
		t.byBatchTarget.Value = &t.Value.ByBatch
		target, err := &t.byBatchTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase.ConflictScanSet", name)
	}
}
func (t *ConflictScanSetTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictScanSetTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *ConflictScanSetTarget) FromZero(tt *vdl.Type) error {
	*t.Value = ConflictScanSet{}
	return nil
}

// map[uint64][]syncbase.ScanOp
type __VDLTarget5_map struct {
	Value      *map[uint64][]syncbase.ScanOp
	currKey    uint64
	currElem   []syncbase.ScanOp
	keyTarget  vdl.Uint64Target
	elemTarget __VDLTarget6_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget5_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64][]syncbase.ScanOp)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64][]syncbase.ScanOp)
	return t, nil
}
func (t *__VDLTarget5_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []syncbase.ScanOp(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget5_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}
func (t *__VDLTarget5_map) FromZero(tt *vdl.Type) error {
	*t.Value = map[uint64][]syncbase.ScanOp(nil)
	return nil
}

// []syncbase.ScanOp
type __VDLTarget6_list struct {
	Value      *[]syncbase.ScanOp
	elemTarget syncbase.ScanOpTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget6_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]syncbase.ScanOp)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]syncbase.ScanOp, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget6_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget6_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget6_list) FinishList(elem vdl.ListTarget) error {

	return nil
}
func (t *__VDLTarget6_list) FromZero(tt *vdl.Type) error {
	*t.Value = []syncbase.ScanOp(nil)
	return nil
}

// Conflict contains information to fully specify a conflict. Since syncbase
// supports batches there can be one or more rows within the batch that has a
// conflict. Each of these rows will be sent together as part of a single
// conflict. Each row contains an Id of the batch to which it belongs,
// enabling the client to group together rows that are part of a batch. Note
// that a single row can be part of more than one batch.
//
// WriteSet contains rows that were written.
// ReadSet contains rows that were read within a batch corresponding to a row
// within the write set.
// ScanSet contains scans performed within a batch corresponding to a row
// within the write set.
// Batches is a map of unique ids to BatchInfo objects. The id is unique only in
// the context of a given conflict and is otherwise meaningless.
type Conflict struct {
	ReadSet  *ConflictRowSet
	WriteSet *ConflictRowSet
	ScanSet  *ConflictScanSet
	Batches  map[uint64]syncbase.BatchInfo
}

func (Conflict) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.Conflict"`
}) {
}

func (m *Conflict) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ReadSet")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := (m.ReadSet == (*ConflictRowSet)(nil))
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {

			if err := m.ReadSet.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("WriteSet")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var7 := (m.WriteSet == (*ConflictRowSet)(nil))
		if var7 {
			if err := fieldTarget6.FromZero(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {

			if err := m.WriteSet.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("ScanSet")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var10 := (m.ScanSet == (*ConflictScanSet)(nil))
		if var10 {
			if err := fieldTarget9.FromZero(tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		} else {

			if err := m.ScanSet.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Batches")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var13 bool
		if len(m.Batches) == 0 {
			var13 = true
		}
		if var13 {
			if err := fieldTarget12.FromZero(tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
		} else {

			mapTarget14, err := fieldTarget12.StartMap(tt.NonOptional().Field(3).Type, len(m.Batches))
			if err != nil {
				return err
			}
			for key16, value18 := range m.Batches {
				keyTarget15, err := mapTarget14.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget15.FromUint(uint64(key16), tt.NonOptional().Field(3).Type.Key()); err != nil {
					return err
				}
				valueTarget17, err := mapTarget14.FinishKeyStartField(keyTarget15)
				if err != nil {
					return err
				}

				if err := value18.FillVDLTarget(valueTarget17, tt.NonOptional().Field(3).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget14.FinishField(keyTarget15, valueTarget17); err != nil {
					return err
				}
			}
			if err := fieldTarget12.FinishMap(mapTarget14); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Conflict) MakeVDLTarget() vdl.Target {
	return &ConflictTarget{Value: m}
}

type ConflictTarget struct {
	Value          *Conflict
	readSetTarget  __VDLTarget7_optional
	writeSetTarget __VDLTarget7_optional
	scanSetTarget  __VDLTarget8_optional
	batchesTarget  __VDLTarget9_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConflictTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Conflict)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ConflictTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ReadSet":
		t.readSetTarget.Value = &t.Value.ReadSet
		target, err := &t.readSetTarget, error(nil)
		return nil, target, err
	case "WriteSet":
		t.writeSetTarget.Value = &t.Value.WriteSet
		target, err := &t.writeSetTarget, error(nil)
		return nil, target, err
	case "ScanSet":
		t.scanSetTarget.Value = &t.Value.ScanSet
		target, err := &t.scanSetTarget, error(nil)
		return nil, target, err
	case "Batches":
		t.batchesTarget.Value = &t.Value.Batches
		target, err := &t.batchesTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase.Conflict", name)
	}
}
func (t *ConflictTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConflictTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *ConflictTarget) FromZero(tt *vdl.Type) error {
	*t.Value = Conflict{}
	return nil
}

// Optional ConflictRowSet
type __VDLTarget7_optional struct {
	Value      **ConflictRowSet
	elemTarget ConflictRowSetTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget7_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &ConflictRowSet{}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget7_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget7_optional) FromZero(tt *vdl.Type) error {
	*t.Value = (*ConflictRowSet)(nil)
	return nil
}

// Optional ConflictScanSet
type __VDLTarget8_optional struct {
	Value      **ConflictScanSet
	elemTarget ConflictScanSetTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget8_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &ConflictScanSet{}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget8_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget8_optional) FromZero(tt *vdl.Type) error {
	*t.Value = (*ConflictScanSet)(nil)
	return nil
}

// map[uint64]syncbase.BatchInfo
type __VDLTarget9_map struct {
	Value      *map[uint64]syncbase.BatchInfo
	currKey    uint64
	currElem   syncbase.BatchInfo
	keyTarget  vdl.Uint64Target
	elemTarget syncbase.BatchInfoTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget9_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64]syncbase.BatchInfo)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64]syncbase.BatchInfo)
	return t, nil
}
func (t *__VDLTarget9_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = syncbase.BatchInfo{}
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget9_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}
func (t *__VDLTarget9_map) FromZero(tt *vdl.Type) error {
	*t.Value = map[uint64]syncbase.BatchInfo(nil)
	return nil
}

// ResolvedRow represents a result of resolution of a row under conflict.
// Key is the key for the row.
// Result is the result of the conflict resolution. Delete is represented
// by nil.
type ResolvedRow struct {
	Key    string
	Result *Value
}

func (ResolvedRow) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.ResolvedRow"`
}) {
}

func (m *ResolvedRow) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var4 := (m.Key == "")
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {
			if err := fieldTarget3.FromString(string(m.Key), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Result")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var7 := (m.Result == (*Value)(nil))
		if var7 {
			if err := fieldTarget6.FromZero(tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		} else {

			if err := m.Result.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ResolvedRow) MakeVDLTarget() vdl.Target {
	return &ResolvedRowTarget{Value: m}
}

type ResolvedRowTarget struct {
	Value        *ResolvedRow
	keyTarget    vdl.StringTarget
	resultTarget __VDLTarget10_optional
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ResolvedRowTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ResolvedRow)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ResolvedRowTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	case "Result":
		t.resultTarget.Value = &t.Value.Result
		target, err := &t.resultTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase.ResolvedRow", name)
	}
}
func (t *ResolvedRowTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ResolvedRowTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *ResolvedRowTarget) FromZero(tt *vdl.Type) error {
	*t.Value = ResolvedRow{}
	return nil
}

// Optional Value
type __VDLTarget10_optional struct {
	Value      **Value
	elemTarget ValueTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget10_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &Value{}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget10_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget10_optional) FromZero(tt *vdl.Type) error {
	*t.Value = (*Value)(nil)
	return nil
}

// Resolution contains the application’s reply to a conflict. It must contain a
// resolved value for each conflict row within the WriteSet of the given
// conflict.
// ResultSet is a map of row key to ResolvedRow.
type Resolution struct {
	ResultSet map[string]ResolvedRow
}

func (Resolution) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/syncbase.Resolution"`
}) {
}

func (m *Resolution) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ResultSet")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		var var4 bool
		if len(m.ResultSet) == 0 {
			var4 = true
		}
		if var4 {
			if err := fieldTarget3.FromZero(tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
		} else {

			mapTarget5, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.ResultSet))
			if err != nil {
				return err
			}
			for key7, value9 := range m.ResultSet {
				keyTarget6, err := mapTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromString(string(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				valueTarget8, err := mapTarget5.FinishKeyStartField(keyTarget6)
				if err != nil {
					return err
				}

				if err := value9.FillVDLTarget(valueTarget8, tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget5.FinishField(keyTarget6, valueTarget8); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishMap(mapTarget5); err != nil {
				return err
			}
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Resolution) MakeVDLTarget() vdl.Target {
	return &ResolutionTarget{Value: m}
}

type ResolutionTarget struct {
	Value           *Resolution
	resultSetTarget __VDLTarget11_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ResolutionTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Resolution)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ResolutionTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "ResultSet":
		t.resultSetTarget.Value = &t.Value.ResultSet
		target, err := &t.resultSetTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/syncbase.Resolution", name)
	}
}
func (t *ResolutionTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ResolutionTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *ResolutionTarget) FromZero(tt *vdl.Type) error {
	*t.Value = Resolution{}
	return nil
}

// map[string]ResolvedRow
type __VDLTarget11_map struct {
	Value      *map[string]ResolvedRow
	currKey    string
	currElem   ResolvedRow
	keyTarget  vdl.StringTarget
	elemTarget ResolvedRowTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget11_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]ResolvedRow)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]ResolvedRow)
	return t, nil
}
func (t *__VDLTarget11_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget11_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = reflect.Zero(reflect.TypeOf(t.currElem)).Interface().(ResolvedRow)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget11_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget11_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}
func (t *__VDLTarget11_map) FromZero(tt *vdl.Type) error {
	*t.Value = map[string]ResolvedRow(nil)
	return nil
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*Value)(nil))
	vdl.Register((*ConflictRow)(nil))
	vdl.Register((*ConflictRowSet)(nil))
	vdl.Register((*ConflictScanSet)(nil))
	vdl.Register((*Conflict)(nil))
	vdl.Register((*ResolvedRow)(nil))
	vdl.Register((*Resolution)(nil))

	return struct{}{}
}
