// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: testdata

package testdata

import (
	"fmt"
	"reflect"
	"time"
	"v.io/v23/vdl"
	time_2 "v.io/v23/vdlroot/time"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

type AddressInfo struct {
	Street string
	City   string
	State  string
	Zip    string
}

func (AddressInfo) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.AddressInfo"`
}) {
}

func (m *AddressInfo) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Street")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Street), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("City")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.City), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("State")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromString(string(m.State), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Zip")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget9.FromString(string(m.Zip), tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AddressInfo) MakeVDLTarget() vdl.Target {
	return &AddressInfoTarget{Value: m}
}

type AddressInfoTarget struct {
	Value        *AddressInfo
	streetTarget vdl.StringTarget
	cityTarget   vdl.StringTarget
	stateTarget  vdl.StringTarget
	zipTarget    vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AddressInfoTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*AddressInfo)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *AddressInfoTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Street":
		t.streetTarget.Value = &t.Value.Street
		target, err := &t.streetTarget, error(nil)
		return nil, target, err
	case "City":
		t.cityTarget.Value = &t.Value.City
		target, err := &t.cityTarget, error(nil)
		return nil, target, err
	case "State":
		t.stateTarget.Value = &t.Value.State
		target, err := &t.stateTarget, error(nil)
		return nil, target, err
	case "Zip":
		t.zipTarget.Value = &t.Value.Zip
		target, err := &t.zipTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.AddressInfo", name)
	}
}
func (t *AddressInfoTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AddressInfoTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type CreditAgency int

const (
	CreditAgencyEquifax CreditAgency = iota
	CreditAgencyExperian
	CreditAgencyTransUnion
)

// CreditAgencyAll holds all labels for CreditAgency.
var CreditAgencyAll = [...]CreditAgency{CreditAgencyEquifax, CreditAgencyExperian, CreditAgencyTransUnion}

// CreditAgencyFromString creates a CreditAgency from a string label.
func CreditAgencyFromString(label string) (x CreditAgency, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *CreditAgency) Set(label string) error {
	switch label {
	case "Equifax", "equifax":
		*x = CreditAgencyEquifax
		return nil
	case "Experian", "experian":
		*x = CreditAgencyExperian
		return nil
	case "TransUnion", "transunion":
		*x = CreditAgencyTransUnion
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.CreditAgency", label)
}

// String returns the string label of x.
func (x CreditAgency) String() string {
	switch x {
	case CreditAgencyEquifax:
		return "Equifax"
	case CreditAgencyExperian:
		return "Experian"
	case CreditAgencyTransUnion:
		return "TransUnion"
	}
	return ""
}

func (CreditAgency) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.CreditAgency"`
	Enum struct{ Equifax, Experian, TransUnion string }
}) {
}

func (m *CreditAgency) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *CreditAgency) MakeVDLTarget() vdl.Target {
	return &CreditAgencyTarget{Value: m}
}

type CreditAgencyTarget struct {
	Value *CreditAgency
	vdl.TargetBase
}

func (t *CreditAgencyTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*CreditAgency)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Equifax":
		*t.Value = 0
	case "Experian":
		*t.Value = 1
	case "TransUnion":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum v.io/v23/query/engine/internal/testdata.CreditAgency", src)
	}

	return nil
}

type ExperianRating int

const (
	ExperianRatingGood ExperianRating = iota
	ExperianRatingBad
)

// ExperianRatingAll holds all labels for ExperianRating.
var ExperianRatingAll = [...]ExperianRating{ExperianRatingGood, ExperianRatingBad}

// ExperianRatingFromString creates a ExperianRating from a string label.
func ExperianRatingFromString(label string) (x ExperianRating, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ExperianRating) Set(label string) error {
	switch label {
	case "Good", "good":
		*x = ExperianRatingGood
		return nil
	case "Bad", "bad":
		*x = ExperianRatingBad
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.ExperianRating", label)
}

// String returns the string label of x.
func (x ExperianRating) String() string {
	switch x {
	case ExperianRatingGood:
		return "Good"
	case ExperianRatingBad:
		return "Bad"
	}
	return ""
}

func (ExperianRating) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ExperianRating"`
	Enum struct{ Good, Bad string }
}) {
}

func (m *ExperianRating) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *ExperianRating) MakeVDLTarget() vdl.Target {
	return &ExperianRatingTarget{Value: m}
}

type ExperianRatingTarget struct {
	Value *ExperianRating
	vdl.TargetBase
}

func (t *ExperianRatingTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*ExperianRating)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Good":
		*t.Value = 0
	case "Bad":
		*t.Value = 1
	default:
		return fmt.Errorf("label %s not in enum v.io/v23/query/engine/internal/testdata.ExperianRating", src)
	}

	return nil
}

type RatingsArray [4]int16

func (RatingsArray) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.RatingsArray"`
}) {
}

func (m *RatingsArray) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 4)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromInt(int64(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RatingsArray) MakeVDLTarget() vdl.Target {
	return &RatingsArrayTarget{Value: m}
}

// RatingsArray
type RatingsArrayTarget struct {
	Value      *RatingsArray
	elemTarget vdl.Int16Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RatingsArrayTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*RatingsArray)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *RatingsArrayTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *RatingsArrayTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RatingsArrayTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

type EquifaxCreditReport struct {
	Rating           byte
	FourScoreRatings RatingsArray
}

func (EquifaxCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.EquifaxCreditReport"`
}) {
}

func (m *EquifaxCreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rating")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromUint(uint64(m.Rating), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("FourScoreRatings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.FourScoreRatings.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *EquifaxCreditReport) MakeVDLTarget() vdl.Target {
	return &EquifaxCreditReportTarget{Value: m}
}

type EquifaxCreditReportTarget struct {
	Value                  *EquifaxCreditReport
	ratingTarget           vdl.ByteTarget
	fourScoreRatingsTarget RatingsArrayTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *EquifaxCreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*EquifaxCreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *EquifaxCreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Rating":
		t.ratingTarget.Value = &t.Value.Rating
		target, err := &t.ratingTarget, error(nil)
		return nil, target, err
	case "FourScoreRatings":
		t.fourScoreRatingsTarget.Value = &t.Value.FourScoreRatings
		target, err := &t.fourScoreRatingsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.EquifaxCreditReport", name)
	}
}
func (t *EquifaxCreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *EquifaxCreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type Tdh int

const (
	TdhTom Tdh = iota
	TdhDick
	TdhHarry
)

// TdhAll holds all labels for Tdh.
var TdhAll = [...]Tdh{TdhTom, TdhDick, TdhHarry}

// TdhFromString creates a Tdh from a string label.
func TdhFromString(label string) (x Tdh, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *Tdh) Set(label string) error {
	switch label {
	case "Tom", "tom":
		*x = TdhTom
		return nil
	case "Dick", "dick":
		*x = TdhDick
		return nil
	case "Harry", "harry":
		*x = TdhHarry
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.Tdh", label)
}

// String returns the string label of x.
func (x Tdh) String() string {
	switch x {
	case TdhTom:
		return "Tom"
	case TdhDick:
		return "Dick"
	case TdhHarry:
		return "Harry"
	}
	return ""
}

func (Tdh) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Tdh"`
	Enum struct{ Tom, Dick, Harry string }
}) {
}

func (m *Tdh) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *Tdh) MakeVDLTarget() vdl.Target {
	return &TdhTarget{Value: m}
}

type TdhTarget struct {
	Value *Tdh
	vdl.TargetBase
}

func (t *TdhTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*Tdh)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Tom":
		*t.Value = 0
	case "Dick":
		*t.Value = 1
	case "Harry":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum v.io/v23/query/engine/internal/testdata.Tdh", src)
	}

	return nil
}

type ExperianCreditReport struct {
	Rating       ExperianRating
	TdhApprovals map[Tdh]struct{}
	Auditor      Tdh
}

func (ExperianCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ExperianCreditReport"`
}) {
}

func (m *ExperianCreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rating")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Rating.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("TdhApprovals")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget6, err := fieldTarget5.StartSet(tt.NonOptional().Field(1).Type, len(m.TdhApprovals))
		if err != nil {
			return err
		}
		for key8 := range m.TdhApprovals {
			keyTarget7, err := setTarget6.StartKey()
			if err != nil {
				return err
			}

			if err := key8.FillVDLTarget(keyTarget7, tt.NonOptional().Field(1).Type.Key()); err != nil {
				return err
			}
			if err := setTarget6.FinishKey(keyTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget5.FinishSet(setTarget6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("Auditor")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Auditor.FillVDLTarget(fieldTarget10, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ExperianCreditReport) MakeVDLTarget() vdl.Target {
	return &ExperianCreditReportTarget{Value: m}
}

type ExperianCreditReportTarget struct {
	Value              *ExperianCreditReport
	ratingTarget       ExperianRatingTarget
	tdhApprovalsTarget __VDLTarget1_set
	auditorTarget      TdhTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ExperianCreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ExperianCreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ExperianCreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Rating":
		t.ratingTarget.Value = &t.Value.Rating
		target, err := &t.ratingTarget, error(nil)
		return nil, target, err
	case "TdhApprovals":
		t.tdhApprovalsTarget.Value = &t.Value.TdhApprovals
		target, err := &t.tdhApprovalsTarget, error(nil)
		return nil, target, err
	case "Auditor":
		t.auditorTarget.Value = &t.Value.Auditor
		target, err := &t.auditorTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.ExperianCreditReport", name)
	}
}
func (t *ExperianCreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ExperianCreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[Tdh]struct{}
type __VDLTarget1_set struct {
	Value     *map[Tdh]struct{}
	currKey   Tdh
	keyTarget TdhTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget1_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[Tdh]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[Tdh]struct{})
	return t, nil
}
func (t *__VDLTarget1_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = TdhTom
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget1_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type TransUnionCreditReport struct {
	Rating          int16
	PreviousRatings map[string]int16
}

func (TransUnionCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.TransUnionCreditReport"`
}) {
}

func (m *TransUnionCreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rating")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromInt(int64(m.Rating), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("PreviousRatings")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget6, err := fieldTarget5.StartMap(tt.NonOptional().Field(1).Type, len(m.PreviousRatings))
		if err != nil {
			return err
		}
		for key8, value10 := range m.PreviousRatings {
			keyTarget7, err := mapTarget6.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget7.FromString(string(key8), tt.NonOptional().Field(1).Type.Key()); err != nil {
				return err
			}
			valueTarget9, err := mapTarget6.FinishKeyStartField(keyTarget7)
			if err != nil {
				return err
			}
			if err := valueTarget9.FromInt(int64(value10), tt.NonOptional().Field(1).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget6.FinishField(keyTarget7, valueTarget9); err != nil {
				return err
			}
		}
		if err := fieldTarget5.FinishMap(mapTarget6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TransUnionCreditReport) MakeVDLTarget() vdl.Target {
	return &TransUnionCreditReportTarget{Value: m}
}

type TransUnionCreditReportTarget struct {
	Value                 *TransUnionCreditReport
	ratingTarget          vdl.Int16Target
	previousRatingsTarget __VDLTarget2_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TransUnionCreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*TransUnionCreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *TransUnionCreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Rating":
		t.ratingTarget.Value = &t.Value.Rating
		target, err := &t.ratingTarget, error(nil)
		return nil, target, err
	case "PreviousRatings":
		t.previousRatingsTarget.Value = &t.Value.PreviousRatings
		target, err := &t.previousRatingsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.TransUnionCreditReport", name)
	}
}
func (t *TransUnionCreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TransUnionCreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[string]int16
type __VDLTarget2_map struct {
	Value      *map[string]int16
	currKey    string
	currElem   int16
	keyTarget  vdl.StringTarget
	elemTarget vdl.Int16Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget2_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]int16)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]int16)
	return t, nil
}
func (t *__VDLTarget2_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = int16(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget2_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type (
	// AgencyReport represents any single field of the AgencyReport union type.
	AgencyReport interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the AgencyReport union type.
		__VDLReflect(__AgencyReportReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// AgencyReportEquifaxReport represents field EquifaxReport of the AgencyReport union type.
	AgencyReportEquifaxReport struct{ Value EquifaxCreditReport }
	// AgencyReportExperianReport represents field ExperianReport of the AgencyReport union type.
	AgencyReportExperianReport struct{ Value ExperianCreditReport }
	// AgencyReportTransUnionReport represents field TransUnionReport of the AgencyReport union type.
	AgencyReportTransUnionReport struct{ Value TransUnionCreditReport }
	// __AgencyReportReflect describes the AgencyReport union type.
	__AgencyReportReflect struct {
		Name               string `vdl:"v.io/v23/query/engine/internal/testdata.AgencyReport"`
		Type               AgencyReport
		UnionTargetFactory agencyReportTargetFactory
		Union              struct {
			EquifaxReport    AgencyReportEquifaxReport
			ExperianReport   AgencyReportExperianReport
			TransUnionReport AgencyReportTransUnionReport
		}
	}
)

func (x AgencyReportEquifaxReport) Index() int                         { return 0 }
func (x AgencyReportEquifaxReport) Interface() interface{}             { return x.Value }
func (x AgencyReportEquifaxReport) Name() string                       { return "EquifaxReport" }
func (x AgencyReportEquifaxReport) __VDLReflect(__AgencyReportReflect) {}

func (m AgencyReportEquifaxReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("EquifaxReport")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m AgencyReportEquifaxReport) MakeVDLTarget() vdl.Target {
	return nil
}

func (x AgencyReportExperianReport) Index() int                         { return 1 }
func (x AgencyReportExperianReport) Interface() interface{}             { return x.Value }
func (x AgencyReportExperianReport) Name() string                       { return "ExperianReport" }
func (x AgencyReportExperianReport) __VDLReflect(__AgencyReportReflect) {}

func (m AgencyReportExperianReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ExperianReport")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m AgencyReportExperianReport) MakeVDLTarget() vdl.Target {
	return nil
}

func (x AgencyReportTransUnionReport) Index() int                         { return 2 }
func (x AgencyReportTransUnionReport) Interface() interface{}             { return x.Value }
func (x AgencyReportTransUnionReport) Name() string                       { return "TransUnionReport" }
func (x AgencyReportTransUnionReport) __VDLReflect(__AgencyReportReflect) {}

func (m AgencyReportTransUnionReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("TransUnionReport")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(2).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m AgencyReportTransUnionReport) MakeVDLTarget() vdl.Target {
	return nil
}

type AgencyReportTarget struct {
	Value     *AgencyReport
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AgencyReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*AgencyReport)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *AgencyReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "EquifaxReport":
		val := EquifaxCreditReport{}
		return nil, &EquifaxCreditReportTarget{Value: &val}, nil
	case "ExperianReport":
		val := ExperianCreditReport{}
		return nil, &ExperianCreditReportTarget{Value: &val}, nil
	case "TransUnionReport":
		val := TransUnionCreditReport{}
		return nil, &TransUnionCreditReportTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/query/engine/internal/testdata.AgencyReport", name)
	}
}
func (t *AgencyReportTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "EquifaxReport":
		*t.Value = AgencyReportEquifaxReport{*(fieldTarget.(*EquifaxCreditReportTarget)).Value}
	case "ExperianReport":
		*t.Value = AgencyReportExperianReport{*(fieldTarget.(*ExperianCreditReportTarget)).Value}
	case "TransUnionReport":
		*t.Value = AgencyReportTransUnionReport{*(fieldTarget.(*TransUnionCreditReportTarget)).Value}
	}
	return nil
}
func (t *AgencyReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type agencyReportTargetFactory struct{}

func (t agencyReportTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*AgencyReport); ok {
		return &AgencyReportTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *AgencyReport", union)
}

type CreditReport struct {
	Agency CreditAgency
	Report AgencyReport
}

func (CreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.CreditReport"`
}) {
}

func (m *CreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Agency")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Agency.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Report")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		unionValue6 := m.Report
		if unionValue6 == nil {
			unionValue6 = AgencyReportEquifaxReport{}
		}
		if err := unionValue6.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *CreditReport) MakeVDLTarget() vdl.Target {
	return &CreditReportTarget{Value: m}
}

type CreditReportTarget struct {
	Value        *CreditReport
	agencyTarget CreditAgencyTarget
	reportTarget AgencyReportTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*CreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Agency":
		t.agencyTarget.Value = &t.Value.Agency
		target, err := &t.agencyTarget, error(nil)
		return nil, target, err
	case "Report":
		t.reportTarget.Value = &t.Value.Report
		target, err := &t.reportTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.CreditReport", name)
	}
}
func (t *CreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type Customer struct {
	Name              string
	Id                int64
	Active            bool
	Address           AddressInfo
	PreviousAddresses []AddressInfo
	Credit            CreditReport
}

func (Customer) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Customer"`
}) {
}

func (m *Customer) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Id")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromInt(int64(m.Id), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Active")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromBool(bool(m.Active), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Address")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Address.FillVDLTarget(fieldTarget9, tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("PreviousAddresses")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget12, err := fieldTarget11.StartList(tt.NonOptional().Field(4).Type, len(m.PreviousAddresses))
		if err != nil {
			return err
		}
		for i, elem14 := range m.PreviousAddresses {
			elemTarget13, err := listTarget12.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem14.FillVDLTarget(elemTarget13, tt.NonOptional().Field(4).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget12.FinishElem(elemTarget13); err != nil {
				return err
			}
		}
		if err := fieldTarget11.FinishList(listTarget12); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget15, fieldTarget16, err := fieldsTarget1.StartField("Credit")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Credit.FillVDLTarget(fieldTarget16, tt.NonOptional().Field(5).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget15, fieldTarget16); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Customer) MakeVDLTarget() vdl.Target {
	return &CustomerTarget{Value: m}
}

type CustomerTarget struct {
	Value                   *Customer
	nameTarget              vdl.StringTarget
	idTarget                vdl.Int64Target
	activeTarget            vdl.BoolTarget
	addressTarget           AddressInfoTarget
	previousAddressesTarget __VDLTarget3_list
	creditTarget            CreditReportTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CustomerTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Customer)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CustomerTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Id":
		t.idTarget.Value = &t.Value.Id
		target, err := &t.idTarget, error(nil)
		return nil, target, err
	case "Active":
		t.activeTarget.Value = &t.Value.Active
		target, err := &t.activeTarget, error(nil)
		return nil, target, err
	case "Address":
		t.addressTarget.Value = &t.Value.Address
		target, err := &t.addressTarget, error(nil)
		return nil, target, err
	case "PreviousAddresses":
		t.previousAddressesTarget.Value = &t.Value.PreviousAddresses
		target, err := &t.previousAddressesTarget, error(nil)
		return nil, target, err
	case "Credit":
		t.creditTarget.Value = &t.Value.Credit
		target, err := &t.creditTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.Customer", name)
	}
}
func (t *CustomerTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CustomerTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []AddressInfo
type __VDLTarget3_list struct {
	Value      *[]AddressInfo
	elemTarget AddressInfoTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget3_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]AddressInfo)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]AddressInfo, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget3_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget3_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

type Invoice struct {
	CustId      int64
	InvoiceNum  int64
	InvoiceDate time.Time
	Amount      int64
	ShipTo      AddressInfo
}

func (Invoice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Invoice"`
}) {
}

func (m *Invoice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("CustId")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromInt(int64(m.CustId), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("InvoiceNum")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromInt(int64(m.InvoiceNum), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	var wireValue6 time_2.Time
	if err := time_2.TimeFromNative(&wireValue6, m.InvoiceDate); err != nil {
		return err
	}

	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("InvoiceDate")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue6.FillVDLTarget(fieldTarget8, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("Amount")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget10.FromInt(int64(m.Amount), tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("ShipTo")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.ShipTo.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(4).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Invoice) MakeVDLTarget() vdl.Target {
	return &InvoiceTarget{Value: m}
}

type InvoiceTarget struct {
	Value             *Invoice
	custIdTarget      vdl.Int64Target
	invoiceNumTarget  vdl.Int64Target
	invoiceDateTarget time_2.TimeTarget
	amountTarget      vdl.Int64Target
	shipToTarget      AddressInfoTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *InvoiceTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Invoice)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *InvoiceTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "CustId":
		t.custIdTarget.Value = &t.Value.CustId
		target, err := &t.custIdTarget, error(nil)
		return nil, target, err
	case "InvoiceNum":
		t.invoiceNumTarget.Value = &t.Value.InvoiceNum
		target, err := &t.invoiceNumTarget, error(nil)
		return nil, target, err
	case "InvoiceDate":
		t.invoiceDateTarget.Value = &t.Value.InvoiceDate
		target, err := &t.invoiceDateTarget, error(nil)
		return nil, target, err
	case "Amount":
		t.amountTarget.Value = &t.Value.Amount
		target, err := &t.amountTarget, error(nil)
		return nil, target, err
	case "ShipTo":
		t.shipToTarget.Value = &t.Value.ShipTo
		target, err := &t.shipToTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.Invoice", name)
	}
}
func (t *InvoiceTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *InvoiceTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type Numbers struct {
	B    byte
	Ui16 uint16
	Ui32 uint32
	Ui64 uint64
	I16  int16
	I32  int32
	I64  int64
	F32  float32
	F64  float64
	C64  complex64
	C128 complex128
}

func (Numbers) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Numbers"`
}) {
}

func (m *Numbers) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromUint(uint64(m.B), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Ui16")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromUint(uint64(m.Ui16), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("Ui32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget7.FromUint(uint64(m.Ui32), tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
			return err
		}
	}
	keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Ui64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget9.FromUint(uint64(m.Ui64), tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
			return err
		}
	}
	keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("I16")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget11.FromInt(int64(m.I16), tt.NonOptional().Field(4).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("I32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget13.FromInt(int64(m.I32), tt.NonOptional().Field(5).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("I64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget15.FromInt(int64(m.I64), tt.NonOptional().Field(6).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	keyTarget16, fieldTarget17, err := fieldsTarget1.StartField("F32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget17.FromFloat(float64(m.F32), tt.NonOptional().Field(7).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget16, fieldTarget17); err != nil {
			return err
		}
	}
	keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("F64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget19.FromFloat(float64(m.F64), tt.NonOptional().Field(8).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
			return err
		}
	}
	keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("C64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget21.FromComplex(complex128(m.C64), tt.NonOptional().Field(9).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
			return err
		}
	}
	keyTarget22, fieldTarget23, err := fieldsTarget1.StartField("C128")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget23.FromComplex(complex128(m.C128), tt.NonOptional().Field(10).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget22, fieldTarget23); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Numbers) MakeVDLTarget() vdl.Target {
	return &NumbersTarget{Value: m}
}

type NumbersTarget struct {
	Value      *Numbers
	bTarget    vdl.ByteTarget
	ui16Target vdl.Uint16Target
	ui32Target vdl.Uint32Target
	ui64Target vdl.Uint64Target
	i16Target  vdl.Int16Target
	i32Target  vdl.Int32Target
	i64Target  vdl.Int64Target
	f32Target  vdl.Float32Target
	f64Target  vdl.Float64Target
	c64Target  vdl.Complex64Target
	c128Target vdl.Complex128Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NumbersTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Numbers)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *NumbersTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "Ui16":
		t.ui16Target.Value = &t.Value.Ui16
		target, err := &t.ui16Target, error(nil)
		return nil, target, err
	case "Ui32":
		t.ui32Target.Value = &t.Value.Ui32
		target, err := &t.ui32Target, error(nil)
		return nil, target, err
	case "Ui64":
		t.ui64Target.Value = &t.Value.Ui64
		target, err := &t.ui64Target, error(nil)
		return nil, target, err
	case "I16":
		t.i16Target.Value = &t.Value.I16
		target, err := &t.i16Target, error(nil)
		return nil, target, err
	case "I32":
		t.i32Target.Value = &t.Value.I32
		target, err := &t.i32Target, error(nil)
		return nil, target, err
	case "I64":
		t.i64Target.Value = &t.Value.I64
		target, err := &t.i64Target, error(nil)
		return nil, target, err
	case "F32":
		t.f32Target.Value = &t.Value.F32
		target, err := &t.f32Target, error(nil)
		return nil, target, err
	case "F64":
		t.f64Target.Value = &t.Value.F64
		target, err := &t.f64Target, error(nil)
		return nil, target, err
	case "C64":
		t.c64Target.Value = &t.Value.C64
		target, err := &t.c64Target, error(nil)
		return nil, target, err
	case "C128":
		t.c128Target.Value = &t.Value.C128
		target, err := &t.c128Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.Numbers", name)
	}
}
func (t *NumbersTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *NumbersTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type (
	// TitleOrValueType represents any single field of the TitleOrValueType union type.
	TitleOrValueType interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the TitleOrValueType union type.
		__VDLReflect(__TitleOrValueTypeReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
	}
	// TitleOrValueTypeTitle represents field Title of the TitleOrValueType union type.
	TitleOrValueTypeTitle struct{ Value string }
	// TitleOrValueTypeValue represents field Value of the TitleOrValueType union type.
	TitleOrValueTypeValue struct{ Value int64 }
	// __TitleOrValueTypeReflect describes the TitleOrValueType union type.
	__TitleOrValueTypeReflect struct {
		Name               string `vdl:"v.io/v23/query/engine/internal/testdata.TitleOrValueType"`
		Type               TitleOrValueType
		UnionTargetFactory titleOrValueTypeTargetFactory
		Union              struct {
			Title TitleOrValueTypeTitle
			Value TitleOrValueTypeValue
		}
	}
)

func (x TitleOrValueTypeTitle) Index() int                             { return 0 }
func (x TitleOrValueTypeTitle) Interface() interface{}                 { return x.Value }
func (x TitleOrValueTypeTitle) Name() string                           { return "Title" }
func (x TitleOrValueTypeTitle) __VDLReflect(__TitleOrValueTypeReflect) {}

func (m TitleOrValueTypeTitle) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Title")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m TitleOrValueTypeTitle) MakeVDLTarget() vdl.Target {
	return nil
}

func (x TitleOrValueTypeValue) Index() int                             { return 1 }
func (x TitleOrValueTypeValue) Interface() interface{}                 { return x.Value }
func (x TitleOrValueTypeValue) Name() string                           { return "Value" }
func (x TitleOrValueTypeValue) __VDLReflect(__TitleOrValueTypeReflect) {}

func (m TitleOrValueTypeValue) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Value")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromInt(int64(m.Value), tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m TitleOrValueTypeValue) MakeVDLTarget() vdl.Target {
	return nil
}

type TitleOrValueTypeTarget struct {
	Value     *TitleOrValueType
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TitleOrValueTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*TitleOrValueType)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *TitleOrValueTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "Title":
		val := ""
		return nil, &vdl.StringTarget{Value: &val}, nil
	case "Value":
		val := int64(0)
		return nil, &vdl.Int64Target{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/query/engine/internal/testdata.TitleOrValueType", name)
	}
}
func (t *TitleOrValueTypeTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "Title":
		*t.Value = TitleOrValueTypeTitle{*(fieldTarget.(*vdl.StringTarget)).Value}
	case "Value":
		*t.Value = TitleOrValueTypeValue{*(fieldTarget.(*vdl.Int64Target)).Value}
	}
	return nil
}
func (t *TitleOrValueTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type titleOrValueTypeTargetFactory struct{}

func (t titleOrValueTypeTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*TitleOrValueType); ok {
		return &TitleOrValueTypeTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *TitleOrValueType", union)
}

type BazType struct {
	Name         string
	TitleOrValue TitleOrValueType
}

func (BazType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BazType"`
}) {
}

func (m *BazType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("TitleOrValue")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		unionValue6 := m.TitleOrValue
		if unionValue6 == nil {
			unionValue6 = TitleOrValueTypeTitle{}
		}
		if err := unionValue6.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BazType) MakeVDLTarget() vdl.Target {
	return &BazTypeTarget{Value: m}
}

type BazTypeTarget struct {
	Value              *BazType
	nameTarget         vdl.StringTarget
	titleOrValueTarget TitleOrValueTypeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BazTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*BazType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *BazTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "TitleOrValue":
		t.titleOrValueTarget.Value = &t.Value.TitleOrValue
		target, err := &t.titleOrValueTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.BazType", name)
	}
}
func (t *BazTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BazTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type BarType struct {
	Baz BazType
}

func (BarType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BarType"`
}) {
}

func (m *BarType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Baz")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Baz.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BarType) MakeVDLTarget() vdl.Target {
	return &BarTypeTarget{Value: m}
}

type BarTypeTarget struct {
	Value     *BarType
	bazTarget BazTypeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BarTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*BarType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *BarTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Baz":
		t.bazTarget.Value = &t.Value.Baz
		target, err := &t.bazTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.BarType", name)
	}
}
func (t *BarTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BarTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type FooType struct {
	Bar BarType
}

func (FooType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FooType"`
}) {
}

func (m *FooType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Bar")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Bar.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *FooType) MakeVDLTarget() vdl.Target {
	return &FooTypeTarget{Value: m}
}

type FooTypeTarget struct {
	Value     *FooType
	barTarget BarTypeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *FooTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*FooType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *FooTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Bar":
		t.barTarget.Value = &t.Value.Bar
		target, err := &t.barTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.FooType", name)
	}
}
func (t *FooTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *FooTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type K struct {
	A byte
	B string
}

func (K) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.K"`
}) {
}

func (m *K) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromUint(uint64(m.A), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.B), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *K) MakeVDLTarget() vdl.Target {
	return &KTarget{Value: m}
}

type KTarget struct {
	Value   *K
	aTarget vdl.ByteTarget
	bTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *KTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*K)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *KTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.K", name)
	}
}
func (t *KTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *KTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type V struct {
	A string
	B float32
}

func (V) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.V"`
}) {
}

func (m *V) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.A), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromFloat(float64(m.B), tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *V) MakeVDLTarget() vdl.Target {
	return &VTarget{Value: m}
}

type VTarget struct {
	Value   *V
	aTarget vdl.StringTarget
	bTarget vdl.Float32Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *VTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*V)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *VTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.V", name)
	}
}
func (t *VTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *VTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type FunWithMaps struct {
	Key       K
	Map       map[K]V
	Confusing map[int16][]map[string]struct{}
}

func (FunWithMaps) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FunWithMaps"`
}) {
}

func (m *FunWithMaps) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Key.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Map")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget6, err := fieldTarget5.StartMap(tt.NonOptional().Field(1).Type, len(m.Map))
		if err != nil {
			return err
		}
		for key8, value10 := range m.Map {
			keyTarget7, err := mapTarget6.StartKey()
			if err != nil {
				return err
			}

			if err := key8.FillVDLTarget(keyTarget7, tt.NonOptional().Field(1).Type.Key()); err != nil {
				return err
			}
			valueTarget9, err := mapTarget6.FinishKeyStartField(keyTarget7)
			if err != nil {
				return err
			}

			if err := value10.FillVDLTarget(valueTarget9, tt.NonOptional().Field(1).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget6.FinishField(keyTarget7, valueTarget9); err != nil {
				return err
			}
		}
		if err := fieldTarget5.FinishMap(mapTarget6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Confusing")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget13, err := fieldTarget12.StartMap(tt.NonOptional().Field(2).Type, len(m.Confusing))
		if err != nil {
			return err
		}
		for key15, value17 := range m.Confusing {
			keyTarget14, err := mapTarget13.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget14.FromInt(int64(key15), tt.NonOptional().Field(2).Type.Key()); err != nil {
				return err
			}
			valueTarget16, err := mapTarget13.FinishKeyStartField(keyTarget14)
			if err != nil {
				return err
			}

			listTarget18, err := valueTarget16.StartList(tt.NonOptional().Field(2).Type.Elem(), len(value17))
			if err != nil {
				return err
			}
			for i, elem20 := range value17 {
				elemTarget19, err := listTarget18.StartElem(i)
				if err != nil {
					return err
				}

				setTarget21, err := elemTarget19.StartSet(tt.NonOptional().Field(2).Type.Elem().Elem(), len(elem20))
				if err != nil {
					return err
				}
				for key23 := range elem20 {
					keyTarget22, err := setTarget21.StartKey()
					if err != nil {
						return err
					}
					if err := keyTarget22.FromString(string(key23), tt.NonOptional().Field(2).Type.Elem().Elem().Key()); err != nil {
						return err
					}
					if err := setTarget21.FinishKey(keyTarget22); err != nil {
						return err
					}
				}
				if err := elemTarget19.FinishSet(setTarget21); err != nil {
					return err
				}
				if err := listTarget18.FinishElem(elemTarget19); err != nil {
					return err
				}
			}
			if err := valueTarget16.FinishList(listTarget18); err != nil {
				return err
			}
			if err := mapTarget13.FinishField(keyTarget14, valueTarget16); err != nil {
				return err
			}
		}
		if err := fieldTarget12.FinishMap(mapTarget13); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *FunWithMaps) MakeVDLTarget() vdl.Target {
	return &FunWithMapsTarget{Value: m}
}

type FunWithMapsTarget struct {
	Value           *FunWithMaps
	keyTarget       KTarget
	mapTarget       __VDLTarget4_map
	confusingTarget __VDLTarget5_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *FunWithMapsTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*FunWithMaps)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *FunWithMapsTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	case "Map":
		t.mapTarget.Value = &t.Value.Map
		target, err := &t.mapTarget, error(nil)
		return nil, target, err
	case "Confusing":
		t.confusingTarget.Value = &t.Value.Confusing
		target, err := &t.confusingTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.FunWithMaps", name)
	}
}
func (t *FunWithMapsTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *FunWithMapsTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[K]V
type __VDLTarget4_map struct {
	Value      *map[K]V
	currKey    K
	currElem   V
	keyTarget  KTarget
	elemTarget VTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget4_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[K]V)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[K]V)
	return t, nil
}
func (t *__VDLTarget4_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = K{}
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = V{}
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget4_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int16][]map[string]struct{}
type __VDLTarget5_map struct {
	Value      *map[int16][]map[string]struct{}
	currKey    int16
	currElem   []map[string]struct{}
	keyTarget  vdl.Int16Target
	elemTarget __VDLTarget6_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget5_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int16][]map[string]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int16][]map[string]struct{})
	return t, nil
}
func (t *__VDLTarget5_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []map[string]struct{}(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget5_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []map[string]struct{}
type __VDLTarget6_list struct {
	Value      *[]map[string]struct{}
	elemTarget __VDLTarget7_set
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget6_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]map[string]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]map[string]struct{}, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget6_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget6_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget6_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// map[string]struct{}
type __VDLTarget7_set struct {
	Value     *map[string]struct{}
	currKey   string
	keyTarget vdl.StringTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget7_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]struct{})
	return t, nil
}
func (t *__VDLTarget7_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget7_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget7_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type FunWithTypes struct {
	T1 *vdl.Type
	T2 *vdl.Type
}

func (FunWithTypes) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FunWithTypes"`
}) {
}

func (m *FunWithTypes) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("T1")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		typeObjectVal4 := m.T1
		if typeObjectVal4 == nil {
			typeObjectVal4 = vdl.AnyType
		}
		if err := fieldTarget3.FromTypeObject(typeObjectVal4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("T2")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		typeObjectVal7 := m.T2
		if typeObjectVal7 == nil {
			typeObjectVal7 = vdl.AnyType
		}
		if err := fieldTarget6.FromTypeObject(typeObjectVal7); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *FunWithTypes) MakeVDLTarget() vdl.Target {
	return &FunWithTypesTarget{Value: m}
}

type FunWithTypesTarget struct {
	Value    *FunWithTypes
	t1Target vdl.TypeObjectTarget
	t2Target vdl.TypeObjectTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *FunWithTypesTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*FunWithTypes)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *FunWithTypesTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "T1":
		t.t1Target.Value = &t.Value.T1
		target, err := &t.t1Target, error(nil)
		return nil, target, err
	case "T2":
		t.t2Target.Value = &t.Value.T2
		target, err := &t.t2Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.FunWithTypes", name)
	}
}
func (t *FunWithTypesTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *FunWithTypesTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type ManyMaps struct {
	B    map[bool]string
	By   map[byte]string
	U16  map[uint16]string
	U32  map[uint32]string
	U64  map[uint64]string
	I16  map[int16]string
	I32  map[int32]string
	I64  map[int64]string
	F32  map[float32]string
	F64  map[float64]string
	C64  map[complex64]string
	C128 map[complex128]string
	S    map[string]string
	Ms   map[string]map[string]string
	T    map[time.Time]string
}

func (ManyMaps) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ManyMaps"`
}) {
}

func (m *ManyMaps) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.B))
		if err != nil {
			return err
		}
		for key6, value8 := range m.B {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromBool(bool(key6), tt.NonOptional().Field(0).Type.Key()); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}
			if err := valueTarget7.FromString(string(value8), tt.NonOptional().Field(0).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("By")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget11, err := fieldTarget10.StartMap(tt.NonOptional().Field(1).Type, len(m.By))
		if err != nil {
			return err
		}
		for key13, value15 := range m.By {
			keyTarget12, err := mapTarget11.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget12.FromUint(uint64(key13), tt.NonOptional().Field(1).Type.Key()); err != nil {
				return err
			}
			valueTarget14, err := mapTarget11.FinishKeyStartField(keyTarget12)
			if err != nil {
				return err
			}
			if err := valueTarget14.FromString(string(value15), tt.NonOptional().Field(1).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget11.FinishField(keyTarget12, valueTarget14); err != nil {
				return err
			}
		}
		if err := fieldTarget10.FinishMap(mapTarget11); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	keyTarget16, fieldTarget17, err := fieldsTarget1.StartField("U16")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget18, err := fieldTarget17.StartMap(tt.NonOptional().Field(2).Type, len(m.U16))
		if err != nil {
			return err
		}
		for key20, value22 := range m.U16 {
			keyTarget19, err := mapTarget18.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget19.FromUint(uint64(key20), tt.NonOptional().Field(2).Type.Key()); err != nil {
				return err
			}
			valueTarget21, err := mapTarget18.FinishKeyStartField(keyTarget19)
			if err != nil {
				return err
			}
			if err := valueTarget21.FromString(string(value22), tt.NonOptional().Field(2).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget18.FinishField(keyTarget19, valueTarget21); err != nil {
				return err
			}
		}
		if err := fieldTarget17.FinishMap(mapTarget18); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget16, fieldTarget17); err != nil {
			return err
		}
	}
	keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("U32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget25, err := fieldTarget24.StartMap(tt.NonOptional().Field(3).Type, len(m.U32))
		if err != nil {
			return err
		}
		for key27, value29 := range m.U32 {
			keyTarget26, err := mapTarget25.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget26.FromUint(uint64(key27), tt.NonOptional().Field(3).Type.Key()); err != nil {
				return err
			}
			valueTarget28, err := mapTarget25.FinishKeyStartField(keyTarget26)
			if err != nil {
				return err
			}
			if err := valueTarget28.FromString(string(value29), tt.NonOptional().Field(3).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget25.FinishField(keyTarget26, valueTarget28); err != nil {
				return err
			}
		}
		if err := fieldTarget24.FinishMap(mapTarget25); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
			return err
		}
	}
	keyTarget30, fieldTarget31, err := fieldsTarget1.StartField("U64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget32, err := fieldTarget31.StartMap(tt.NonOptional().Field(4).Type, len(m.U64))
		if err != nil {
			return err
		}
		for key34, value36 := range m.U64 {
			keyTarget33, err := mapTarget32.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget33.FromUint(uint64(key34), tt.NonOptional().Field(4).Type.Key()); err != nil {
				return err
			}
			valueTarget35, err := mapTarget32.FinishKeyStartField(keyTarget33)
			if err != nil {
				return err
			}
			if err := valueTarget35.FromString(string(value36), tt.NonOptional().Field(4).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget32.FinishField(keyTarget33, valueTarget35); err != nil {
				return err
			}
		}
		if err := fieldTarget31.FinishMap(mapTarget32); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget30, fieldTarget31); err != nil {
			return err
		}
	}
	keyTarget37, fieldTarget38, err := fieldsTarget1.StartField("I16")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget39, err := fieldTarget38.StartMap(tt.NonOptional().Field(5).Type, len(m.I16))
		if err != nil {
			return err
		}
		for key41, value43 := range m.I16 {
			keyTarget40, err := mapTarget39.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget40.FromInt(int64(key41), tt.NonOptional().Field(5).Type.Key()); err != nil {
				return err
			}
			valueTarget42, err := mapTarget39.FinishKeyStartField(keyTarget40)
			if err != nil {
				return err
			}
			if err := valueTarget42.FromString(string(value43), tt.NonOptional().Field(5).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget39.FinishField(keyTarget40, valueTarget42); err != nil {
				return err
			}
		}
		if err := fieldTarget38.FinishMap(mapTarget39); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget37, fieldTarget38); err != nil {
			return err
		}
	}
	keyTarget44, fieldTarget45, err := fieldsTarget1.StartField("I32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget46, err := fieldTarget45.StartMap(tt.NonOptional().Field(6).Type, len(m.I32))
		if err != nil {
			return err
		}
		for key48, value50 := range m.I32 {
			keyTarget47, err := mapTarget46.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget47.FromInt(int64(key48), tt.NonOptional().Field(6).Type.Key()); err != nil {
				return err
			}
			valueTarget49, err := mapTarget46.FinishKeyStartField(keyTarget47)
			if err != nil {
				return err
			}
			if err := valueTarget49.FromString(string(value50), tt.NonOptional().Field(6).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget46.FinishField(keyTarget47, valueTarget49); err != nil {
				return err
			}
		}
		if err := fieldTarget45.FinishMap(mapTarget46); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget44, fieldTarget45); err != nil {
			return err
		}
	}
	keyTarget51, fieldTarget52, err := fieldsTarget1.StartField("I64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget53, err := fieldTarget52.StartMap(tt.NonOptional().Field(7).Type, len(m.I64))
		if err != nil {
			return err
		}
		for key55, value57 := range m.I64 {
			keyTarget54, err := mapTarget53.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget54.FromInt(int64(key55), tt.NonOptional().Field(7).Type.Key()); err != nil {
				return err
			}
			valueTarget56, err := mapTarget53.FinishKeyStartField(keyTarget54)
			if err != nil {
				return err
			}
			if err := valueTarget56.FromString(string(value57), tt.NonOptional().Field(7).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget53.FinishField(keyTarget54, valueTarget56); err != nil {
				return err
			}
		}
		if err := fieldTarget52.FinishMap(mapTarget53); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget51, fieldTarget52); err != nil {
			return err
		}
	}
	keyTarget58, fieldTarget59, err := fieldsTarget1.StartField("F32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget60, err := fieldTarget59.StartMap(tt.NonOptional().Field(8).Type, len(m.F32))
		if err != nil {
			return err
		}
		for key62, value64 := range m.F32 {
			keyTarget61, err := mapTarget60.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget61.FromFloat(float64(key62), tt.NonOptional().Field(8).Type.Key()); err != nil {
				return err
			}
			valueTarget63, err := mapTarget60.FinishKeyStartField(keyTarget61)
			if err != nil {
				return err
			}
			if err := valueTarget63.FromString(string(value64), tt.NonOptional().Field(8).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget60.FinishField(keyTarget61, valueTarget63); err != nil {
				return err
			}
		}
		if err := fieldTarget59.FinishMap(mapTarget60); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget58, fieldTarget59); err != nil {
			return err
		}
	}
	keyTarget65, fieldTarget66, err := fieldsTarget1.StartField("F64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget67, err := fieldTarget66.StartMap(tt.NonOptional().Field(9).Type, len(m.F64))
		if err != nil {
			return err
		}
		for key69, value71 := range m.F64 {
			keyTarget68, err := mapTarget67.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget68.FromFloat(float64(key69), tt.NonOptional().Field(9).Type.Key()); err != nil {
				return err
			}
			valueTarget70, err := mapTarget67.FinishKeyStartField(keyTarget68)
			if err != nil {
				return err
			}
			if err := valueTarget70.FromString(string(value71), tt.NonOptional().Field(9).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget67.FinishField(keyTarget68, valueTarget70); err != nil {
				return err
			}
		}
		if err := fieldTarget66.FinishMap(mapTarget67); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget65, fieldTarget66); err != nil {
			return err
		}
	}
	keyTarget72, fieldTarget73, err := fieldsTarget1.StartField("C64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget74, err := fieldTarget73.StartMap(tt.NonOptional().Field(10).Type, len(m.C64))
		if err != nil {
			return err
		}
		for key76, value78 := range m.C64 {
			keyTarget75, err := mapTarget74.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget75.FromComplex(complex128(key76), tt.NonOptional().Field(10).Type.Key()); err != nil {
				return err
			}
			valueTarget77, err := mapTarget74.FinishKeyStartField(keyTarget75)
			if err != nil {
				return err
			}
			if err := valueTarget77.FromString(string(value78), tt.NonOptional().Field(10).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget74.FinishField(keyTarget75, valueTarget77); err != nil {
				return err
			}
		}
		if err := fieldTarget73.FinishMap(mapTarget74); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget72, fieldTarget73); err != nil {
			return err
		}
	}
	keyTarget79, fieldTarget80, err := fieldsTarget1.StartField("C128")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget81, err := fieldTarget80.StartMap(tt.NonOptional().Field(11).Type, len(m.C128))
		if err != nil {
			return err
		}
		for key83, value85 := range m.C128 {
			keyTarget82, err := mapTarget81.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget82.FromComplex(complex128(key83), tt.NonOptional().Field(11).Type.Key()); err != nil {
				return err
			}
			valueTarget84, err := mapTarget81.FinishKeyStartField(keyTarget82)
			if err != nil {
				return err
			}
			if err := valueTarget84.FromString(string(value85), tt.NonOptional().Field(11).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget81.FinishField(keyTarget82, valueTarget84); err != nil {
				return err
			}
		}
		if err := fieldTarget80.FinishMap(mapTarget81); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget79, fieldTarget80); err != nil {
			return err
		}
	}
	keyTarget86, fieldTarget87, err := fieldsTarget1.StartField("S")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget88, err := fieldTarget87.StartMap(tt.NonOptional().Field(12).Type, len(m.S))
		if err != nil {
			return err
		}
		for key90, value92 := range m.S {
			keyTarget89, err := mapTarget88.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget89.FromString(string(key90), tt.NonOptional().Field(12).Type.Key()); err != nil {
				return err
			}
			valueTarget91, err := mapTarget88.FinishKeyStartField(keyTarget89)
			if err != nil {
				return err
			}
			if err := valueTarget91.FromString(string(value92), tt.NonOptional().Field(12).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget88.FinishField(keyTarget89, valueTarget91); err != nil {
				return err
			}
		}
		if err := fieldTarget87.FinishMap(mapTarget88); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget86, fieldTarget87); err != nil {
			return err
		}
	}
	keyTarget93, fieldTarget94, err := fieldsTarget1.StartField("Ms")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget95, err := fieldTarget94.StartMap(tt.NonOptional().Field(13).Type, len(m.Ms))
		if err != nil {
			return err
		}
		for key97, value99 := range m.Ms {
			keyTarget96, err := mapTarget95.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget96.FromString(string(key97), tt.NonOptional().Field(13).Type.Key()); err != nil {
				return err
			}
			valueTarget98, err := mapTarget95.FinishKeyStartField(keyTarget96)
			if err != nil {
				return err
			}

			mapTarget100, err := valueTarget98.StartMap(tt.NonOptional().Field(13).Type.Elem(), len(value99))
			if err != nil {
				return err
			}
			for key102, value104 := range value99 {
				keyTarget101, err := mapTarget100.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget101.FromString(string(key102), tt.NonOptional().Field(13).Type.Elem().Key()); err != nil {
					return err
				}
				valueTarget103, err := mapTarget100.FinishKeyStartField(keyTarget101)
				if err != nil {
					return err
				}
				if err := valueTarget103.FromString(string(value104), tt.NonOptional().Field(13).Type.Elem().Elem()); err != nil {
					return err
				}
				if err := mapTarget100.FinishField(keyTarget101, valueTarget103); err != nil {
					return err
				}
			}
			if err := valueTarget98.FinishMap(mapTarget100); err != nil {
				return err
			}
			if err := mapTarget95.FinishField(keyTarget96, valueTarget98); err != nil {
				return err
			}
		}
		if err := fieldTarget94.FinishMap(mapTarget95); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget93, fieldTarget94); err != nil {
			return err
		}
	}
	keyTarget105, fieldTarget106, err := fieldsTarget1.StartField("T")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget107, err := fieldTarget106.StartMap(tt.NonOptional().Field(14).Type, len(m.T))
		if err != nil {
			return err
		}
		for key109, value111 := range m.T {
			keyTarget108, err := mapTarget107.StartKey()
			if err != nil {
				return err
			}

			var wireValue112 time_2.Time
			if err := time_2.TimeFromNative(&wireValue112, key109); err != nil {
				return err
			}

			if err := wireValue112.FillVDLTarget(keyTarget108, tt.NonOptional().Field(14).Type.Key()); err != nil {
				return err
			}
			valueTarget110, err := mapTarget107.FinishKeyStartField(keyTarget108)
			if err != nil {
				return err
			}
			if err := valueTarget110.FromString(string(value111), tt.NonOptional().Field(14).Type.Elem()); err != nil {
				return err
			}
			if err := mapTarget107.FinishField(keyTarget108, valueTarget110); err != nil {
				return err
			}
		}
		if err := fieldTarget106.FinishMap(mapTarget107); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget105, fieldTarget106); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ManyMaps) MakeVDLTarget() vdl.Target {
	return &ManyMapsTarget{Value: m}
}

type ManyMapsTarget struct {
	Value      *ManyMaps
	bTarget    __VDLTarget8_map
	byTarget   __VDLTarget9_map
	u16Target  __VDLTarget10_map
	u32Target  __VDLTarget11_map
	u64Target  __VDLTarget12_map
	i16Target  __VDLTarget13_map
	i32Target  __VDLTarget14_map
	i64Target  __VDLTarget15_map
	f32Target  __VDLTarget16_map
	f64Target  __VDLTarget17_map
	c64Target  __VDLTarget18_map
	c128Target __VDLTarget19_map
	sTarget    __VDLTarget20_map
	msTarget   __VDLTarget21_map
	tTarget    __VDLTarget22_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ManyMapsTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ManyMaps)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ManyMapsTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "By":
		t.byTarget.Value = &t.Value.By
		target, err := &t.byTarget, error(nil)
		return nil, target, err
	case "U16":
		t.u16Target.Value = &t.Value.U16
		target, err := &t.u16Target, error(nil)
		return nil, target, err
	case "U32":
		t.u32Target.Value = &t.Value.U32
		target, err := &t.u32Target, error(nil)
		return nil, target, err
	case "U64":
		t.u64Target.Value = &t.Value.U64
		target, err := &t.u64Target, error(nil)
		return nil, target, err
	case "I16":
		t.i16Target.Value = &t.Value.I16
		target, err := &t.i16Target, error(nil)
		return nil, target, err
	case "I32":
		t.i32Target.Value = &t.Value.I32
		target, err := &t.i32Target, error(nil)
		return nil, target, err
	case "I64":
		t.i64Target.Value = &t.Value.I64
		target, err := &t.i64Target, error(nil)
		return nil, target, err
	case "F32":
		t.f32Target.Value = &t.Value.F32
		target, err := &t.f32Target, error(nil)
		return nil, target, err
	case "F64":
		t.f64Target.Value = &t.Value.F64
		target, err := &t.f64Target, error(nil)
		return nil, target, err
	case "C64":
		t.c64Target.Value = &t.Value.C64
		target, err := &t.c64Target, error(nil)
		return nil, target, err
	case "C128":
		t.c128Target.Value = &t.Value.C128
		target, err := &t.c128Target, error(nil)
		return nil, target, err
	case "S":
		t.sTarget.Value = &t.Value.S
		target, err := &t.sTarget, error(nil)
		return nil, target, err
	case "Ms":
		t.msTarget.Value = &t.Value.Ms
		target, err := &t.msTarget, error(nil)
		return nil, target, err
	case "T":
		t.tTarget.Value = &t.Value.T
		target, err := &t.tTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.ManyMaps", name)
	}
}
func (t *ManyMapsTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ManyMapsTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[bool]string
type __VDLTarget8_map struct {
	Value      *map[bool]string
	currKey    bool
	currElem   string
	keyTarget  vdl.BoolTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget8_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[bool]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[bool]string)
	return t, nil
}
func (t *__VDLTarget8_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = false
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget8_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget8_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget8_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[byte]string
type __VDLTarget9_map struct {
	Value      *map[byte]string
	currKey    byte
	currElem   string
	keyTarget  vdl.ByteTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget9_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[byte]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[byte]string)
	return t, nil
}
func (t *__VDLTarget9_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = byte(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget9_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint16]string
type __VDLTarget10_map struct {
	Value      *map[uint16]string
	currKey    uint16
	currElem   string
	keyTarget  vdl.Uint16Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget10_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint16]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint16]string)
	return t, nil
}
func (t *__VDLTarget10_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget10_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget10_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget10_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint32]string
type __VDLTarget11_map struct {
	Value      *map[uint32]string
	currKey    uint32
	currElem   string
	keyTarget  vdl.Uint32Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget11_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint32]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint32]string)
	return t, nil
}
func (t *__VDLTarget11_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget11_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget11_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget11_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint64]string
type __VDLTarget12_map struct {
	Value      *map[uint64]string
	currKey    uint64
	currElem   string
	keyTarget  vdl.Uint64Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget12_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64]string)
	return t, nil
}
func (t *__VDLTarget12_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget12_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget12_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget12_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int16]string
type __VDLTarget13_map struct {
	Value      *map[int16]string
	currKey    int16
	currElem   string
	keyTarget  vdl.Int16Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget13_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int16]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int16]string)
	return t, nil
}
func (t *__VDLTarget13_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget13_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget13_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget13_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int32]string
type __VDLTarget14_map struct {
	Value      *map[int32]string
	currKey    int32
	currElem   string
	keyTarget  vdl.Int32Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget14_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int32]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int32]string)
	return t, nil
}
func (t *__VDLTarget14_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget14_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget14_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget14_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int64]string
type __VDLTarget15_map struct {
	Value      *map[int64]string
	currKey    int64
	currElem   string
	keyTarget  vdl.Int64Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget15_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int64]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int64]string)
	return t, nil
}
func (t *__VDLTarget15_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget15_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget15_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget15_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[float32]string
type __VDLTarget16_map struct {
	Value      *map[float32]string
	currKey    float32
	currElem   string
	keyTarget  vdl.Float32Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget16_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[float32]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[float32]string)
	return t, nil
}
func (t *__VDLTarget16_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = float32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget16_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget16_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget16_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[float64]string
type __VDLTarget17_map struct {
	Value      *map[float64]string
	currKey    float64
	currElem   string
	keyTarget  vdl.Float64Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget17_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[float64]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[float64]string)
	return t, nil
}
func (t *__VDLTarget17_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget17_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget17_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget17_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[complex64]string
type __VDLTarget18_map struct {
	Value      *map[complex64]string
	currKey    complex64
	currElem   string
	keyTarget  vdl.Complex64Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget18_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[complex64]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[complex64]string)
	return t, nil
}
func (t *__VDLTarget18_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = complex64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget18_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget18_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget18_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[complex128]string
type __VDLTarget19_map struct {
	Value      *map[complex128]string
	currKey    complex128
	currElem   string
	keyTarget  vdl.Complex128Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget19_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[complex128]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[complex128]string)
	return t, nil
}
func (t *__VDLTarget19_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = complex128(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget19_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget19_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget19_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[string]string
type __VDLTarget20_map struct {
	Value      *map[string]string
	currKey    string
	currElem   string
	keyTarget  vdl.StringTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget20_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]string)
	return t, nil
}
func (t *__VDLTarget20_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget20_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget20_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget20_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[string]map[string]string
type __VDLTarget21_map struct {
	Value      *map[string]map[string]string
	currKey    string
	currElem   map[string]string
	keyTarget  vdl.StringTarget
	elemTarget __VDLTarget20_map
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget21_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]map[string]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]map[string]string)
	return t, nil
}
func (t *__VDLTarget21_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget21_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = map[string]string(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget21_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget21_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[time.Time]string
type __VDLTarget22_map struct {
	Value      *map[time.Time]string
	currKey    time.Time
	currElem   string
	keyTarget  time_2.TimeTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget22_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[time.Time]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[time.Time]string)
	return t, nil
}
func (t *__VDLTarget22_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = reflect.Zero(reflect.TypeOf(t.currKey)).Interface().(time.Time)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget22_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget22_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget22_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type ManySets struct {
	B    map[bool]struct{}
	By   map[byte]struct{}
	U16  map[uint16]struct{}
	U32  map[uint32]struct{}
	U64  map[uint64]struct{}
	I16  map[int16]struct{}
	I32  map[int32]struct{}
	I64  map[int64]struct{}
	F32  map[float32]struct{}
	F64  map[float64]struct{}
	C64  map[complex64]struct{}
	C128 map[complex128]struct{}
	S    map[string]struct{}
	T    map[time.Time]struct{}
}

func (ManySets) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ManySets"`
}) {
}

func (m *ManySets) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget4, err := fieldTarget3.StartSet(tt.NonOptional().Field(0).Type, len(m.B))
		if err != nil {
			return err
		}
		for key6 := range m.B {
			keyTarget5, err := setTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromBool(bool(key6), tt.NonOptional().Field(0).Type.Key()); err != nil {
				return err
			}
			if err := setTarget4.FinishKey(keyTarget5); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishSet(setTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("By")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget9, err := fieldTarget8.StartSet(tt.NonOptional().Field(1).Type, len(m.By))
		if err != nil {
			return err
		}
		for key11 := range m.By {
			keyTarget10, err := setTarget9.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget10.FromUint(uint64(key11), tt.NonOptional().Field(1).Type.Key()); err != nil {
				return err
			}
			if err := setTarget9.FinishKey(keyTarget10); err != nil {
				return err
			}
		}
		if err := fieldTarget8.FinishSet(setTarget9); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("U16")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget14, err := fieldTarget13.StartSet(tt.NonOptional().Field(2).Type, len(m.U16))
		if err != nil {
			return err
		}
		for key16 := range m.U16 {
			keyTarget15, err := setTarget14.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget15.FromUint(uint64(key16), tt.NonOptional().Field(2).Type.Key()); err != nil {
				return err
			}
			if err := setTarget14.FinishKey(keyTarget15); err != nil {
				return err
			}
		}
		if err := fieldTarget13.FinishSet(setTarget14); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("U32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget19, err := fieldTarget18.StartSet(tt.NonOptional().Field(3).Type, len(m.U32))
		if err != nil {
			return err
		}
		for key21 := range m.U32 {
			keyTarget20, err := setTarget19.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget20.FromUint(uint64(key21), tt.NonOptional().Field(3).Type.Key()); err != nil {
				return err
			}
			if err := setTarget19.FinishKey(keyTarget20); err != nil {
				return err
			}
		}
		if err := fieldTarget18.FinishSet(setTarget19); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
			return err
		}
	}
	keyTarget22, fieldTarget23, err := fieldsTarget1.StartField("U64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget24, err := fieldTarget23.StartSet(tt.NonOptional().Field(4).Type, len(m.U64))
		if err != nil {
			return err
		}
		for key26 := range m.U64 {
			keyTarget25, err := setTarget24.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget25.FromUint(uint64(key26), tt.NonOptional().Field(4).Type.Key()); err != nil {
				return err
			}
			if err := setTarget24.FinishKey(keyTarget25); err != nil {
				return err
			}
		}
		if err := fieldTarget23.FinishSet(setTarget24); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget22, fieldTarget23); err != nil {
			return err
		}
	}
	keyTarget27, fieldTarget28, err := fieldsTarget1.StartField("I16")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget29, err := fieldTarget28.StartSet(tt.NonOptional().Field(5).Type, len(m.I16))
		if err != nil {
			return err
		}
		for key31 := range m.I16 {
			keyTarget30, err := setTarget29.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget30.FromInt(int64(key31), tt.NonOptional().Field(5).Type.Key()); err != nil {
				return err
			}
			if err := setTarget29.FinishKey(keyTarget30); err != nil {
				return err
			}
		}
		if err := fieldTarget28.FinishSet(setTarget29); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget27, fieldTarget28); err != nil {
			return err
		}
	}
	keyTarget32, fieldTarget33, err := fieldsTarget1.StartField("I32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget34, err := fieldTarget33.StartSet(tt.NonOptional().Field(6).Type, len(m.I32))
		if err != nil {
			return err
		}
		for key36 := range m.I32 {
			keyTarget35, err := setTarget34.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget35.FromInt(int64(key36), tt.NonOptional().Field(6).Type.Key()); err != nil {
				return err
			}
			if err := setTarget34.FinishKey(keyTarget35); err != nil {
				return err
			}
		}
		if err := fieldTarget33.FinishSet(setTarget34); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget32, fieldTarget33); err != nil {
			return err
		}
	}
	keyTarget37, fieldTarget38, err := fieldsTarget1.StartField("I64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget39, err := fieldTarget38.StartSet(tt.NonOptional().Field(7).Type, len(m.I64))
		if err != nil {
			return err
		}
		for key41 := range m.I64 {
			keyTarget40, err := setTarget39.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget40.FromInt(int64(key41), tt.NonOptional().Field(7).Type.Key()); err != nil {
				return err
			}
			if err := setTarget39.FinishKey(keyTarget40); err != nil {
				return err
			}
		}
		if err := fieldTarget38.FinishSet(setTarget39); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget37, fieldTarget38); err != nil {
			return err
		}
	}
	keyTarget42, fieldTarget43, err := fieldsTarget1.StartField("F32")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget44, err := fieldTarget43.StartSet(tt.NonOptional().Field(8).Type, len(m.F32))
		if err != nil {
			return err
		}
		for key46 := range m.F32 {
			keyTarget45, err := setTarget44.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget45.FromFloat(float64(key46), tt.NonOptional().Field(8).Type.Key()); err != nil {
				return err
			}
			if err := setTarget44.FinishKey(keyTarget45); err != nil {
				return err
			}
		}
		if err := fieldTarget43.FinishSet(setTarget44); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget42, fieldTarget43); err != nil {
			return err
		}
	}
	keyTarget47, fieldTarget48, err := fieldsTarget1.StartField("F64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget49, err := fieldTarget48.StartSet(tt.NonOptional().Field(9).Type, len(m.F64))
		if err != nil {
			return err
		}
		for key51 := range m.F64 {
			keyTarget50, err := setTarget49.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget50.FromFloat(float64(key51), tt.NonOptional().Field(9).Type.Key()); err != nil {
				return err
			}
			if err := setTarget49.FinishKey(keyTarget50); err != nil {
				return err
			}
		}
		if err := fieldTarget48.FinishSet(setTarget49); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget47, fieldTarget48); err != nil {
			return err
		}
	}
	keyTarget52, fieldTarget53, err := fieldsTarget1.StartField("C64")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget54, err := fieldTarget53.StartSet(tt.NonOptional().Field(10).Type, len(m.C64))
		if err != nil {
			return err
		}
		for key56 := range m.C64 {
			keyTarget55, err := setTarget54.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget55.FromComplex(complex128(key56), tt.NonOptional().Field(10).Type.Key()); err != nil {
				return err
			}
			if err := setTarget54.FinishKey(keyTarget55); err != nil {
				return err
			}
		}
		if err := fieldTarget53.FinishSet(setTarget54); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget52, fieldTarget53); err != nil {
			return err
		}
	}
	keyTarget57, fieldTarget58, err := fieldsTarget1.StartField("C128")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget59, err := fieldTarget58.StartSet(tt.NonOptional().Field(11).Type, len(m.C128))
		if err != nil {
			return err
		}
		for key61 := range m.C128 {
			keyTarget60, err := setTarget59.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget60.FromComplex(complex128(key61), tt.NonOptional().Field(11).Type.Key()); err != nil {
				return err
			}
			if err := setTarget59.FinishKey(keyTarget60); err != nil {
				return err
			}
		}
		if err := fieldTarget58.FinishSet(setTarget59); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget57, fieldTarget58); err != nil {
			return err
		}
	}
	keyTarget62, fieldTarget63, err := fieldsTarget1.StartField("S")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget64, err := fieldTarget63.StartSet(tt.NonOptional().Field(12).Type, len(m.S))
		if err != nil {
			return err
		}
		for key66 := range m.S {
			keyTarget65, err := setTarget64.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget65.FromString(string(key66), tt.NonOptional().Field(12).Type.Key()); err != nil {
				return err
			}
			if err := setTarget64.FinishKey(keyTarget65); err != nil {
				return err
			}
		}
		if err := fieldTarget63.FinishSet(setTarget64); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget62, fieldTarget63); err != nil {
			return err
		}
	}
	keyTarget67, fieldTarget68, err := fieldsTarget1.StartField("T")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget69, err := fieldTarget68.StartSet(tt.NonOptional().Field(13).Type, len(m.T))
		if err != nil {
			return err
		}
		for key71 := range m.T {
			keyTarget70, err := setTarget69.StartKey()
			if err != nil {
				return err
			}

			var wireValue72 time_2.Time
			if err := time_2.TimeFromNative(&wireValue72, key71); err != nil {
				return err
			}

			if err := wireValue72.FillVDLTarget(keyTarget70, tt.NonOptional().Field(13).Type.Key()); err != nil {
				return err
			}
			if err := setTarget69.FinishKey(keyTarget70); err != nil {
				return err
			}
		}
		if err := fieldTarget68.FinishSet(setTarget69); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget67, fieldTarget68); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ManySets) MakeVDLTarget() vdl.Target {
	return &ManySetsTarget{Value: m}
}

type ManySetsTarget struct {
	Value      *ManySets
	bTarget    __VDLTarget23_set
	byTarget   __VDLTarget24_set
	u16Target  __VDLTarget25_set
	u32Target  __VDLTarget26_set
	u64Target  __VDLTarget27_set
	i16Target  __VDLTarget28_set
	i32Target  __VDLTarget29_set
	i64Target  __VDLTarget30_set
	f32Target  __VDLTarget31_set
	f64Target  __VDLTarget32_set
	c64Target  __VDLTarget33_set
	c128Target __VDLTarget34_set
	sTarget    __VDLTarget7_set
	tTarget    __VDLTarget35_set
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ManySetsTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ManySets)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ManySetsTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "By":
		t.byTarget.Value = &t.Value.By
		target, err := &t.byTarget, error(nil)
		return nil, target, err
	case "U16":
		t.u16Target.Value = &t.Value.U16
		target, err := &t.u16Target, error(nil)
		return nil, target, err
	case "U32":
		t.u32Target.Value = &t.Value.U32
		target, err := &t.u32Target, error(nil)
		return nil, target, err
	case "U64":
		t.u64Target.Value = &t.Value.U64
		target, err := &t.u64Target, error(nil)
		return nil, target, err
	case "I16":
		t.i16Target.Value = &t.Value.I16
		target, err := &t.i16Target, error(nil)
		return nil, target, err
	case "I32":
		t.i32Target.Value = &t.Value.I32
		target, err := &t.i32Target, error(nil)
		return nil, target, err
	case "I64":
		t.i64Target.Value = &t.Value.I64
		target, err := &t.i64Target, error(nil)
		return nil, target, err
	case "F32":
		t.f32Target.Value = &t.Value.F32
		target, err := &t.f32Target, error(nil)
		return nil, target, err
	case "F64":
		t.f64Target.Value = &t.Value.F64
		target, err := &t.f64Target, error(nil)
		return nil, target, err
	case "C64":
		t.c64Target.Value = &t.Value.C64
		target, err := &t.c64Target, error(nil)
		return nil, target, err
	case "C128":
		t.c128Target.Value = &t.Value.C128
		target, err := &t.c128Target, error(nil)
		return nil, target, err
	case "S":
		t.sTarget.Value = &t.Value.S
		target, err := &t.sTarget, error(nil)
		return nil, target, err
	case "T":
		t.tTarget.Value = &t.Value.T
		target, err := &t.tTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.ManySets", name)
	}
}
func (t *ManySetsTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ManySetsTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[bool]struct{}
type __VDLTarget23_set struct {
	Value     *map[bool]struct{}
	currKey   bool
	keyTarget vdl.BoolTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget23_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[bool]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[bool]struct{})
	return t, nil
}
func (t *__VDLTarget23_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = false
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget23_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget23_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[byte]struct{}
type __VDLTarget24_set struct {
	Value     *map[byte]struct{}
	currKey   byte
	keyTarget vdl.ByteTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget24_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[byte]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[byte]struct{})
	return t, nil
}
func (t *__VDLTarget24_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = byte(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget24_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget24_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint16]struct{}
type __VDLTarget25_set struct {
	Value     *map[uint16]struct{}
	currKey   uint16
	keyTarget vdl.Uint16Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget25_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint16]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint16]struct{})
	return t, nil
}
func (t *__VDLTarget25_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget25_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget25_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint32]struct{}
type __VDLTarget26_set struct {
	Value     *map[uint32]struct{}
	currKey   uint32
	keyTarget vdl.Uint32Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget26_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint32]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint32]struct{})
	return t, nil
}
func (t *__VDLTarget26_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget26_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget26_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint64]struct{}
type __VDLTarget27_set struct {
	Value     *map[uint64]struct{}
	currKey   uint64
	keyTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget27_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64]struct{})
	return t, nil
}
func (t *__VDLTarget27_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget27_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget27_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int16]struct{}
type __VDLTarget28_set struct {
	Value     *map[int16]struct{}
	currKey   int16
	keyTarget vdl.Int16Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget28_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[int16]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int16]struct{})
	return t, nil
}
func (t *__VDLTarget28_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = int16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget28_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget28_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int32]struct{}
type __VDLTarget29_set struct {
	Value     *map[int32]struct{}
	currKey   int32
	keyTarget vdl.Int32Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget29_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[int32]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int32]struct{})
	return t, nil
}
func (t *__VDLTarget29_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = int32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget29_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget29_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int64]struct{}
type __VDLTarget30_set struct {
	Value     *map[int64]struct{}
	currKey   int64
	keyTarget vdl.Int64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget30_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[int64]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int64]struct{})
	return t, nil
}
func (t *__VDLTarget30_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget30_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget30_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[float32]struct{}
type __VDLTarget31_set struct {
	Value     *map[float32]struct{}
	currKey   float32
	keyTarget vdl.Float32Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget31_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[float32]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[float32]struct{})
	return t, nil
}
func (t *__VDLTarget31_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = float32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget31_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget31_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[float64]struct{}
type __VDLTarget32_set struct {
	Value     *map[float64]struct{}
	currKey   float64
	keyTarget vdl.Float64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget32_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[float64]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[float64]struct{})
	return t, nil
}
func (t *__VDLTarget32_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget32_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget32_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[complex64]struct{}
type __VDLTarget33_set struct {
	Value     *map[complex64]struct{}
	currKey   complex64
	keyTarget vdl.Complex64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget33_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[complex64]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[complex64]struct{})
	return t, nil
}
func (t *__VDLTarget33_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = complex64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget33_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget33_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[complex128]struct{}
type __VDLTarget34_set struct {
	Value     *map[complex128]struct{}
	currKey   complex128
	keyTarget vdl.Complex128Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget34_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[complex128]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[complex128]struct{})
	return t, nil
}
func (t *__VDLTarget34_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = complex128(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget34_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget34_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[time.Time]struct{}
type __VDLTarget35_set struct {
	Value     *map[time.Time]struct{}
	currKey   time.Time
	keyTarget time_2.TimeTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget35_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[time.Time]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[time.Time]struct{})
	return t, nil
}
func (t *__VDLTarget35_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = reflect.Zero(reflect.TypeOf(t.currKey)).Interface().(time.Time)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget35_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget35_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

type BigData struct {
	Key string // A dup of the key stored in the value.
}

func (BigData) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BigData"`
}) {
}

func (m *BigData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Key), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BigData) MakeVDLTarget() vdl.Target {
	return &BigDataTarget{Value: m}
}

type BigDataTarget struct {
	Value     *BigData
	keyTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BigDataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*BigData)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *BigDataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/query/engine/internal/testdata.BigData", name)
	}
}
func (t *BigDataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BigDataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Create zero values for each type.
var (
	__VDLZeroAddressInfo            = AddressInfo{}
	__VDLZeroCreditAgency           = CreditAgencyEquifax
	__VDLZeroExperianRating         = ExperianRatingGood
	__VDLZeroRatingsArray           = RatingsArray{}
	__VDLZeroEquifaxCreditReport    = EquifaxCreditReport{}
	__VDLZeroTdh                    = TdhTom
	__VDLZeroExperianCreditReport   = ExperianCreditReport{}
	__VDLZeroTransUnionCreditReport = TransUnionCreditReport{}
	__VDLZeroAgencyReport           = AgencyReport(AgencyReportEquifaxReport{})
	__VDLZeroCreditReport           = CreditReport{
		Report: AgencyReportEquifaxReport{},
	}
	__VDLZeroCustomer = Customer{
		Credit: CreditReport{
			Report: AgencyReportEquifaxReport{},
		},
	}
	__VDLZeroInvoice          = Invoice{}
	__VDLZeroNumbers          = Numbers{}
	__VDLZeroTitleOrValueType = TitleOrValueType(TitleOrValueTypeTitle{})
	__VDLZeroBazType          = BazType{
		TitleOrValue: TitleOrValueTypeTitle{},
	}
	__VDLZeroBarType = BarType{
		Baz: BazType{
			TitleOrValue: TitleOrValueTypeTitle{},
		},
	}
	__VDLZeroFooType = FooType{
		Bar: BarType{
			Baz: BazType{
				TitleOrValue: TitleOrValueTypeTitle{},
			},
		},
	}
	__VDLZeroK            = K{}
	__VDLZeroV            = V{}
	__VDLZeroFunWithMaps  = FunWithMaps{}
	__VDLZeroFunWithTypes = FunWithTypes{
		T1: vdl.AnyType,
		T2: vdl.AnyType,
	}
	__VDLZeroManyMaps = ManyMaps{}
	__VDLZeroManySets = ManySets{}
	__VDLZeroBigData  = BigData{}
)

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}

	// Register types.
	vdl.Register((*AddressInfo)(nil))
	vdl.Register((*CreditAgency)(nil))
	vdl.Register((*ExperianRating)(nil))
	vdl.Register((*RatingsArray)(nil))
	vdl.Register((*EquifaxCreditReport)(nil))
	vdl.Register((*Tdh)(nil))
	vdl.Register((*ExperianCreditReport)(nil))
	vdl.Register((*TransUnionCreditReport)(nil))
	vdl.Register((*AgencyReport)(nil))
	vdl.Register((*CreditReport)(nil))
	vdl.Register((*Customer)(nil))
	vdl.Register((*Invoice)(nil))
	vdl.Register((*Numbers)(nil))
	vdl.Register((*TitleOrValueType)(nil))
	vdl.Register((*BazType)(nil))
	vdl.Register((*BarType)(nil))
	vdl.Register((*FooType)(nil))
	vdl.Register((*K)(nil))
	vdl.Register((*V)(nil))
	vdl.Register((*FunWithMaps)(nil))
	vdl.Register((*FunWithTypes)(nil))
	vdl.Register((*ManyMaps)(nil))
	vdl.Register((*ManySets)(nil))
	vdl.Register((*BigData)(nil))

	return struct{}{}
}
