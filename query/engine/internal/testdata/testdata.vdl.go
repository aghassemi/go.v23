// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: testdata

package testdata

import (
	"fmt"
	"reflect"
	"time"
	"v.io/v23/vdl"
	vdltime "v.io/v23/vdlroot/time"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

type AddressInfo struct {
	Street string
	City   string
	State  string
	Zip    string
}

func (AddressInfo) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.AddressInfo"`
}) {
}

func (m *AddressInfo) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Street == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Street"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Street")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Street), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.City == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("City"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("City")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.City), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.State == "")
	if var10 {
		if err := fieldsTarget1.ZeroField("State"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("State")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromString(string(m.State), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.Zip == "")
	if var13 {
		if err := fieldsTarget1.ZeroField("Zip"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Zip")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromString(string(m.Zip), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *AddressInfo) MakeVDLTarget() vdl.Target {
	return &AddressInfoTarget{Value: m}
}

type AddressInfoTarget struct {
	Value        *AddressInfo
	streetTarget vdl.StringTarget
	cityTarget   vdl.StringTarget
	stateTarget  vdl.StringTarget
	zipTarget    vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AddressInfoTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*AddressInfo)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *AddressInfoTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Street":
		t.streetTarget.Value = &t.Value.Street
		target, err := &t.streetTarget, error(nil)
		return nil, target, err
	case "City":
		t.cityTarget.Value = &t.Value.City
		target, err := &t.cityTarget, error(nil)
		return nil, target, err
	case "State":
		t.stateTarget.Value = &t.Value.State
		target, err := &t.stateTarget, error(nil)
		return nil, target, err
	case "Zip":
		t.zipTarget.Value = &t.Value.Zip
		target, err := &t.zipTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *AddressInfoTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *AddressInfoTarget) ZeroField(name string) error {
	switch name {
	case "Street":
		t.Value.Street = ""
		return nil
	case "City":
		t.Value.City = ""
		return nil
	case "State":
		t.Value.State = ""
		return nil
	case "Zip":
		t.Value.Zip = ""
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *AddressInfoTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x AddressInfo) VDLIsZero() bool {
	return x == AddressInfo{}
}

func (x AddressInfo) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AddressInfo)(nil)).Elem()); err != nil {
		return err
	}
	if x.Street != "" {
		if err := enc.NextField("Street"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Street); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.City != "" {
		if err := enc.NextField("City"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.City); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.State != "" {
		if err := enc.NextField("State"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.State); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Zip != "" {
		if err := enc.NextField("Zip"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Zip); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *AddressInfo) VDLRead(dec vdl.Decoder) error {
	*x = AddressInfo{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Street":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Street, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "City":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.City, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "State":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.State, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Zip":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Zip, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type CreditAgency int

const (
	CreditAgencyEquifax CreditAgency = iota
	CreditAgencyExperian
	CreditAgencyTransUnion
)

// CreditAgencyAll holds all labels for CreditAgency.
var CreditAgencyAll = [...]CreditAgency{CreditAgencyEquifax, CreditAgencyExperian, CreditAgencyTransUnion}

// CreditAgencyFromString creates a CreditAgency from a string label.
func CreditAgencyFromString(label string) (x CreditAgency, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *CreditAgency) Set(label string) error {
	switch label {
	case "Equifax", "equifax":
		*x = CreditAgencyEquifax
		return nil
	case "Experian", "experian":
		*x = CreditAgencyExperian
		return nil
	case "TransUnion", "transunion":
		*x = CreditAgencyTransUnion
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.CreditAgency", label)
}

// String returns the string label of x.
func (x CreditAgency) String() string {
	switch x {
	case CreditAgencyEquifax:
		return "Equifax"
	case CreditAgencyExperian:
		return "Experian"
	case CreditAgencyTransUnion:
		return "TransUnion"
	}
	return ""
}

func (CreditAgency) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.CreditAgency"`
	Enum struct{ Equifax, Experian, TransUnion string }
}) {
}

func (m *CreditAgency) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *CreditAgency) MakeVDLTarget() vdl.Target {
	return &CreditAgencyTarget{Value: m}
}

type CreditAgencyTarget struct {
	Value *CreditAgency
	vdl.TargetBase
}

func (t *CreditAgencyTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*CreditAgency)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Equifax":
		*t.Value = 0
	case "Experian":
		*t.Value = 1
	case "TransUnion":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum CreditAgency", src)
	}

	return nil
}

func (x CreditAgency) VDLIsZero() bool {
	return x == CreditAgencyEquifax
}

func (x CreditAgency) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*CreditAgency)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *CreditAgency) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type ExperianRating int

const (
	ExperianRatingGood ExperianRating = iota
	ExperianRatingBad
)

// ExperianRatingAll holds all labels for ExperianRating.
var ExperianRatingAll = [...]ExperianRating{ExperianRatingGood, ExperianRatingBad}

// ExperianRatingFromString creates a ExperianRating from a string label.
func ExperianRatingFromString(label string) (x ExperianRating, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ExperianRating) Set(label string) error {
	switch label {
	case "Good", "good":
		*x = ExperianRatingGood
		return nil
	case "Bad", "bad":
		*x = ExperianRatingBad
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.ExperianRating", label)
}

// String returns the string label of x.
func (x ExperianRating) String() string {
	switch x {
	case ExperianRatingGood:
		return "Good"
	case ExperianRatingBad:
		return "Bad"
	}
	return ""
}

func (ExperianRating) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ExperianRating"`
	Enum struct{ Good, Bad string }
}) {
}

func (m *ExperianRating) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *ExperianRating) MakeVDLTarget() vdl.Target {
	return &ExperianRatingTarget{Value: m}
}

type ExperianRatingTarget struct {
	Value *ExperianRating
	vdl.TargetBase
}

func (t *ExperianRatingTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*ExperianRating)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Good":
		*t.Value = 0
	case "Bad":
		*t.Value = 1
	default:
		return fmt.Errorf("label %s not in enum ExperianRating", src)
	}

	return nil
}

func (x ExperianRating) VDLIsZero() bool {
	return x == ExperianRatingGood
}

func (x ExperianRating) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ExperianRating)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ExperianRating) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type RatingsArray [4]int16

func (RatingsArray) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.RatingsArray"`
}) {
}

func (m *RatingsArray) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	listTarget1, err := t.StartList(tt, 4)
	if err != nil {
		return err
	}
	for i, elem3 := range *m {
		elemTarget2, err := listTarget1.StartElem(i)
		if err != nil {
			return err
		}
		if err := elemTarget2.FromInt(int64(elem3), tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := listTarget1.FinishElem(elemTarget2); err != nil {
			return err
		}
	}
	if err := t.FinishList(listTarget1); err != nil {
		return err
	}
	return nil
}

func (m *RatingsArray) MakeVDLTarget() vdl.Target {
	return &RatingsArrayTarget{Value: m}
}

// RatingsArray
type RatingsArrayTarget struct {
	Value      *RatingsArray
	elemTarget vdl.Int16Target
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *RatingsArrayTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*RatingsArray)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *RatingsArrayTarget) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *RatingsArrayTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *RatingsArrayTarget) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x RatingsArray) VDLIsZero() bool {
	return x == RatingsArray{}
}

func (x RatingsArray) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*RatingsArray)(nil))); err != nil {
		return err
	}
	for i := 0; i < 4; i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x[i])); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *RatingsArray) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible array %T, from %v", *x, dec.Type())
	}
	index := 0
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done != (index >= len(*x)):
			return fmt.Errorf("array len mismatch, got %d, want %T", index, *x)
		case done:
			return dec.FinishValue()
		}
		if err := dec.StartValue(); err != nil {
			return err
		}
		tmp, err := dec.DecodeInt(16)
		if err != nil {
			return err
		}
		x[index] = int16(tmp)
		if err := dec.FinishValue(); err != nil {
			return err
		}
		index++
	}
}

type EquifaxCreditReport struct {
	Rating           byte
	FourScoreRatings RatingsArray
}

func (EquifaxCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.EquifaxCreditReport"`
}) {
}

func (m *EquifaxCreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Rating == byte(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("Rating"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rating")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromUint(uint64(m.Rating), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.FourScoreRatings == RatingsArray{})
	if var7 {
		if err := fieldsTarget1.ZeroField("FourScoreRatings"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("FourScoreRatings")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.FourScoreRatings.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *EquifaxCreditReport) MakeVDLTarget() vdl.Target {
	return &EquifaxCreditReportTarget{Value: m}
}

type EquifaxCreditReportTarget struct {
	Value                  *EquifaxCreditReport
	ratingTarget           vdl.ByteTarget
	fourScoreRatingsTarget RatingsArrayTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *EquifaxCreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*EquifaxCreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *EquifaxCreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Rating":
		t.ratingTarget.Value = &t.Value.Rating
		target, err := &t.ratingTarget, error(nil)
		return nil, target, err
	case "FourScoreRatings":
		t.fourScoreRatingsTarget.Value = &t.Value.FourScoreRatings
		target, err := &t.fourScoreRatingsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *EquifaxCreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *EquifaxCreditReportTarget) ZeroField(name string) error {
	switch name {
	case "Rating":
		t.Value.Rating = byte(0)
		return nil
	case "FourScoreRatings":
		t.Value.FourScoreRatings = RatingsArray{}
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *EquifaxCreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x EquifaxCreditReport) VDLIsZero() bool {
	return x == EquifaxCreditReport{}
}

func (x EquifaxCreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*EquifaxCreditReport)(nil)).Elem()); err != nil {
		return err
	}
	if x.Rating != 0 {
		if err := enc.NextField("Rating"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Rating)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.FourScoreRatings != (RatingsArray{}) {
		if err := enc.NextField("FourScoreRatings"); err != nil {
			return err
		}
		if err := x.FourScoreRatings.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *EquifaxCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = EquifaxCreditReport{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Rating":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.Rating = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "FourScoreRatings":
			if err := x.FourScoreRatings.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Tdh int

const (
	TdhTom Tdh = iota
	TdhDick
	TdhHarry
)

// TdhAll holds all labels for Tdh.
var TdhAll = [...]Tdh{TdhTom, TdhDick, TdhHarry}

// TdhFromString creates a Tdh from a string label.
func TdhFromString(label string) (x Tdh, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *Tdh) Set(label string) error {
	switch label {
	case "Tom", "tom":
		*x = TdhTom
		return nil
	case "Dick", "dick":
		*x = TdhDick
		return nil
	case "Harry", "harry":
		*x = TdhHarry
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in testdata.Tdh", label)
}

// String returns the string label of x.
func (x Tdh) String() string {
	switch x {
	case TdhTom:
		return "Tom"
	case TdhDick:
		return "Dick"
	case TdhHarry:
		return "Harry"
	}
	return ""
}

func (Tdh) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Tdh"`
	Enum struct{ Tom, Dick, Harry string }
}) {
}

func (m *Tdh) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), tt); err != nil {
		return err
	}
	return nil
}

func (m *Tdh) MakeVDLTarget() vdl.Target {
	return &TdhTarget{Value: m}
}

type TdhTarget struct {
	Value *Tdh
	vdl.TargetBase
}

func (t *TdhTarget) FromEnumLabel(src string, tt *vdl.Type) error {

	if ttWant := vdl.TypeOf((*Tdh)(nil)); !vdl.Compatible(tt, ttWant) {
		return fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	switch src {
	case "Tom":
		*t.Value = 0
	case "Dick":
		*t.Value = 1
	case "Harry":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum Tdh", src)
	}

	return nil
}

func (x Tdh) VDLIsZero() bool {
	return x == TdhTom
}

func (x Tdh) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Tdh)(nil))); err != nil {
		return err
	}
	if err := enc.EncodeString(x.String()); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Tdh) VDLRead(dec vdl.Decoder) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err := x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

type ExperianCreditReport struct {
	Rating       ExperianRating
	TdhApprovals map[Tdh]struct{}
	Auditor      Tdh
}

func (ExperianCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ExperianCreditReport"`
}) {
}

func (m *ExperianCreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Rating == ExperianRatingGood)
	if var4 {
		if err := fieldsTarget1.ZeroField("Rating"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rating")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Rating.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.TdhApprovals) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("TdhApprovals"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("TdhApprovals")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget8, err := fieldTarget6.StartSet(tt.NonOptional().Field(1).Type, len(m.TdhApprovals))
			if err != nil {
				return err
			}
			for key10 := range m.TdhApprovals {
				keyTarget9, err := setTarget8.StartKey()
				if err != nil {
					return err
				}

				if err := key10.FillVDLTarget(keyTarget9, tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				if err := setTarget8.FinishKey(keyTarget9); err != nil {
					return err
				}
			}
			if err := fieldTarget6.FinishSet(setTarget8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var13 := (m.Auditor == TdhTom)
	if var13 {
		if err := fieldsTarget1.ZeroField("Auditor"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Auditor")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Auditor.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ExperianCreditReport) MakeVDLTarget() vdl.Target {
	return &ExperianCreditReportTarget{Value: m}
}

type ExperianCreditReportTarget struct {
	Value              *ExperianCreditReport
	ratingTarget       ExperianRatingTarget
	tdhApprovalsTarget __VDLTarget1_set
	auditorTarget      TdhTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ExperianCreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ExperianCreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ExperianCreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Rating":
		t.ratingTarget.Value = &t.Value.Rating
		target, err := &t.ratingTarget, error(nil)
		return nil, target, err
	case "TdhApprovals":
		t.tdhApprovalsTarget.Value = &t.Value.TdhApprovals
		target, err := &t.tdhApprovalsTarget, error(nil)
		return nil, target, err
	case "Auditor":
		t.auditorTarget.Value = &t.Value.Auditor
		target, err := &t.auditorTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ExperianCreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ExperianCreditReportTarget) ZeroField(name string) error {
	switch name {
	case "Rating":
		t.Value.Rating = ExperianRatingGood
		return nil
	case "TdhApprovals":
		t.Value.TdhApprovals = map[Tdh]struct{}(nil)
		return nil
	case "Auditor":
		t.Value.Auditor = TdhTom
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ExperianCreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[Tdh]struct{}
type __VDLTarget1_set struct {
	Value     *map[Tdh]struct{}
	currKey   Tdh
	keyTarget TdhTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget1_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[Tdh]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[Tdh]struct{})
	return t, nil
}
func (t *__VDLTarget1_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = TdhTom
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget1_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x ExperianCreditReport) VDLIsZero() bool {
	if x.Rating != ExperianRatingGood {
		return false
	}
	if len(x.TdhApprovals) != 0 {
		return false
	}
	if x.Auditor != TdhTom {
		return false
	}
	return true
}

func (x ExperianCreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ExperianCreditReport)(nil)).Elem()); err != nil {
		return err
	}
	if x.Rating != ExperianRatingGood {
		if err := enc.NextField("Rating"); err != nil {
			return err
		}
		if err := x.Rating.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.TdhApprovals) != 0 {
		if err := enc.NextField("TdhApprovals"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_1(enc, x.TdhApprovals); err != nil {
			return err
		}
	}
	if x.Auditor != TdhTom {
		if err := enc.NextField("Auditor"); err != nil {
			return err
		}
		if err := x.Auditor.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_1(enc vdl.Encoder, x map[Tdh]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[Tdh]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ExperianCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = ExperianCreditReport{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Rating":
			if err := x.Rating.VDLRead(dec); err != nil {
				return err
			}
		case "TdhApprovals":
			if err := __VDLReadAnon_set_1(dec, &x.TdhApprovals); err != nil {
				return err
			}
		case "Auditor":
			if err := x.Auditor.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_set_1(dec vdl.Decoder, x *map[Tdh]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[Tdh]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[Tdh]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key Tdh
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[Tdh]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

type TransUnionCreditReport struct {
	Rating          int16
	PreviousRatings map[string]int16
}

func (TransUnionCreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.TransUnionCreditReport"`
}) {
}

func (m *TransUnionCreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Rating == int16(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("Rating"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Rating")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromInt(int64(m.Rating), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.PreviousRatings) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("PreviousRatings"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("PreviousRatings")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget8, err := fieldTarget6.StartMap(tt.NonOptional().Field(1).Type, len(m.PreviousRatings))
			if err != nil {
				return err
			}
			for key10, value12 := range m.PreviousRatings {
				keyTarget9, err := mapTarget8.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget9.FromString(string(key10), tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				valueTarget11, err := mapTarget8.FinishKeyStartField(keyTarget9)
				if err != nil {
					return err
				}
				if err := valueTarget11.FromInt(int64(value12), tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget8.FinishField(keyTarget9, valueTarget11); err != nil {
					return err
				}
			}
			if err := fieldTarget6.FinishMap(mapTarget8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *TransUnionCreditReport) MakeVDLTarget() vdl.Target {
	return &TransUnionCreditReportTarget{Value: m}
}

type TransUnionCreditReportTarget struct {
	Value                 *TransUnionCreditReport
	ratingTarget          vdl.Int16Target
	previousRatingsTarget __VDLTarget2_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TransUnionCreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*TransUnionCreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *TransUnionCreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Rating":
		t.ratingTarget.Value = &t.Value.Rating
		target, err := &t.ratingTarget, error(nil)
		return nil, target, err
	case "PreviousRatings":
		t.previousRatingsTarget.Value = &t.Value.PreviousRatings
		target, err := &t.previousRatingsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *TransUnionCreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *TransUnionCreditReportTarget) ZeroField(name string) error {
	switch name {
	case "Rating":
		t.Value.Rating = int16(0)
		return nil
	case "PreviousRatings":
		t.Value.PreviousRatings = map[string]int16(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *TransUnionCreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[string]int16
type __VDLTarget2_map struct {
	Value      *map[string]int16
	currKey    string
	currElem   int16
	keyTarget  vdl.StringTarget
	elemTarget vdl.Int16Target
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget2_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]int16)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]int16)
	return t, nil
}
func (t *__VDLTarget2_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = int16(0)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget2_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget2_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x TransUnionCreditReport) VDLIsZero() bool {
	if x.Rating != 0 {
		return false
	}
	if len(x.PreviousRatings) != 0 {
		return false
	}
	return true
}

func (x TransUnionCreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*TransUnionCreditReport)(nil)).Elem()); err != nil {
		return err
	}
	if x.Rating != 0 {
		if err := enc.NextField("Rating"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x.Rating)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if len(x.PreviousRatings) != 0 {
		if err := enc.NextField("PreviousRatings"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_2(enc, x.PreviousRatings); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_2(enc vdl.Encoder, x map[string]int16) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string]int16)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(elem)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *TransUnionCreditReport) VDLRead(dec vdl.Decoder) error {
	*x = TransUnionCreditReport{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Rating":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			x.Rating = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "PreviousRatings":
			if err := __VDLReadAnon_map_2(dec, &x.PreviousRatings); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_2(dec vdl.Decoder, x *map[string]int16) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string]int16
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]int16, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem int16
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			elem = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string]int16)
		}
		tmpMap[key] = elem
	}
}

type (
	// AgencyReport represents any single field of the AgencyReport union type.
	AgencyReport interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the AgencyReport union type.
		__VDLReflect(__AgencyReportReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// AgencyReportEquifaxReport represents field EquifaxReport of the AgencyReport union type.
	AgencyReportEquifaxReport struct{ Value EquifaxCreditReport }
	// AgencyReportExperianReport represents field ExperianReport of the AgencyReport union type.
	AgencyReportExperianReport struct{ Value ExperianCreditReport }
	// AgencyReportTransUnionReport represents field TransUnionReport of the AgencyReport union type.
	AgencyReportTransUnionReport struct{ Value TransUnionCreditReport }
	// __AgencyReportReflect describes the AgencyReport union type.
	__AgencyReportReflect struct {
		Name               string `vdl:"v.io/v23/query/engine/internal/testdata.AgencyReport"`
		Type               AgencyReport
		UnionTargetFactory agencyReportTargetFactory
		Union              struct {
			EquifaxReport    AgencyReportEquifaxReport
			ExperianReport   AgencyReportExperianReport
			TransUnionReport AgencyReportTransUnionReport
		}
	}
)

func (x AgencyReportEquifaxReport) Index() int                         { return 0 }
func (x AgencyReportEquifaxReport) Interface() interface{}             { return x.Value }
func (x AgencyReportEquifaxReport) Name() string                       { return "EquifaxReport" }
func (x AgencyReportEquifaxReport) __VDLReflect(__AgencyReportReflect) {}

func (m AgencyReportEquifaxReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("EquifaxReport")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m AgencyReportEquifaxReport) MakeVDLTarget() vdl.Target {
	return nil
}

func (x AgencyReportExperianReport) Index() int                         { return 1 }
func (x AgencyReportExperianReport) Interface() interface{}             { return x.Value }
func (x AgencyReportExperianReport) Name() string                       { return "ExperianReport" }
func (x AgencyReportExperianReport) __VDLReflect(__AgencyReportReflect) {}

func (m AgencyReportExperianReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("ExperianReport")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m AgencyReportExperianReport) MakeVDLTarget() vdl.Target {
	return nil
}

func (x AgencyReportTransUnionReport) Index() int                         { return 2 }
func (x AgencyReportTransUnionReport) Interface() interface{}             { return x.Value }
func (x AgencyReportTransUnionReport) Name() string                       { return "TransUnionReport" }
func (x AgencyReportTransUnionReport) __VDLReflect(__AgencyReportReflect) {}

func (m AgencyReportTransUnionReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("TransUnionReport")
	if err != nil {
		return err
	}

	if err := m.Value.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(2).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m AgencyReportTransUnionReport) MakeVDLTarget() vdl.Target {
	return nil
}

type AgencyReportTarget struct {
	Value     *AgencyReport
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *AgencyReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*AgencyReport)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *AgencyReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "EquifaxReport":
		val := EquifaxCreditReport{}
		return nil, &EquifaxCreditReportTarget{Value: &val}, nil
	case "ExperianReport":
		val := ExperianCreditReport{}
		return nil, &ExperianCreditReportTarget{Value: &val}, nil
	case "TransUnionReport":
		val := TransUnionCreditReport{}
		return nil, &TransUnionCreditReportTarget{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/query/engine/internal/testdata.AgencyReport", name)
	}
}
func (t *AgencyReportTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "EquifaxReport":
		*t.Value = AgencyReportEquifaxReport{*(fieldTarget.(*EquifaxCreditReportTarget)).Value}
	case "ExperianReport":
		*t.Value = AgencyReportExperianReport{*(fieldTarget.(*ExperianCreditReportTarget)).Value}
	case "TransUnionReport":
		*t.Value = AgencyReportTransUnionReport{*(fieldTarget.(*TransUnionCreditReportTarget)).Value}
	}
	return nil
}
func (t *AgencyReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type agencyReportTargetFactory struct{}

func (t agencyReportTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*AgencyReport); ok {
		return &AgencyReportTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *AgencyReport", union)
}

func (x AgencyReportEquifaxReport) VDLIsZero() bool {
	return x.Value == EquifaxCreditReport{}
}

func (x AgencyReportExperianReport) VDLIsZero() bool {
	return false
}

func (x AgencyReportTransUnionReport) VDLIsZero() bool {
	return false
}

func (x AgencyReportEquifaxReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AgencyReport)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("EquifaxReport"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x AgencyReportExperianReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AgencyReport)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("ExperianReport"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x AgencyReportTransUnionReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*AgencyReport)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("TransUnionReport"); err != nil {
		return err
	}
	if err := x.Value.VDLWrite(enc); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadAgencyReport(dec vdl.Decoder, x *AgencyReport) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "EquifaxReport":
		var field AgencyReportEquifaxReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "ExperianReport":
		var field AgencyReportExperianReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "TransUnionReport":
		var field AgencyReportTransUnionReport
		if err := field.Value.VDLRead(dec); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type CreditReport struct {
	Agency CreditAgency
	Report AgencyReport
}

func (CreditReport) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.CreditReport"`
}) {
}

func (m *CreditReport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Agency == CreditAgencyEquifax)
	if var4 {
		if err := fieldsTarget1.ZeroField("Agency"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Agency")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Agency.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if field, ok := m.Report.(AgencyReportEquifaxReport); ok {

		var8 := (field.Value == EquifaxCreditReport{})
		var7 = var8
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("Report"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Report")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			unionValue9 := m.Report
			if unionValue9 == nil {
				unionValue9 = AgencyReportEquifaxReport{}
			}
			if err := unionValue9.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *CreditReport) MakeVDLTarget() vdl.Target {
	return &CreditReportTarget{Value: m}
}

type CreditReportTarget struct {
	Value        *CreditReport
	agencyTarget CreditAgencyTarget
	reportTarget AgencyReportTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CreditReportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*CreditReport)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CreditReportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Agency":
		t.agencyTarget.Value = &t.Value.Agency
		target, err := &t.agencyTarget, error(nil)
		return nil, target, err
	case "Report":
		t.reportTarget.Value = &t.Value.Report
		target, err := &t.reportTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *CreditReportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CreditReportTarget) ZeroField(name string) error {
	switch name {
	case "Agency":
		t.Value.Agency = CreditAgencyEquifax
		return nil
	case "Report":
		t.Value.Report = AgencyReport(AgencyReportEquifaxReport{})
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *CreditReportTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x CreditReport) VDLIsZero() bool {
	if x.Agency != CreditAgencyEquifax {
		return false
	}
	if x.Report != nil && !x.Report.VDLIsZero() {
		return false
	}
	return true
}

func (x CreditReport) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*CreditReport)(nil)).Elem()); err != nil {
		return err
	}
	if x.Agency != CreditAgencyEquifax {
		if err := enc.NextField("Agency"); err != nil {
			return err
		}
		if err := x.Agency.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Report != nil && !x.Report.VDLIsZero() {
		if err := enc.NextField("Report"); err != nil {
			return err
		}
		if err := x.Report.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *CreditReport) VDLRead(dec vdl.Decoder) error {
	*x = CreditReport{
		Report: AgencyReportEquifaxReport{},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Agency":
			if err := x.Agency.VDLRead(dec); err != nil {
				return err
			}
		case "Report":
			if err := VDLReadAgencyReport(dec, &x.Report); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Customer struct {
	Name              string
	Id                int64
	Active            bool
	Address           AddressInfo
	PreviousAddresses []AddressInfo
	Credit            CreditReport
}

func (Customer) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Customer"`
}) {
}

func (m *Customer) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Id == int64(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Id"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Id")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromInt(int64(m.Id), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Active == false)
	if var10 {
		if err := fieldsTarget1.ZeroField("Active"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Active")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromBool(bool(m.Active), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.Address == AddressInfo{})
	if var13 {
		if err := fieldsTarget1.ZeroField("Address"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Address")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Address.FillVDLTarget(fieldTarget12, tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var var16 bool
	if len(m.PreviousAddresses) == 0 {
		var16 = true
	}
	if var16 {
		if err := fieldsTarget1.ZeroField("PreviousAddresses"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("PreviousAddresses")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget17, err := fieldTarget15.StartList(tt.NonOptional().Field(4).Type, len(m.PreviousAddresses))
			if err != nil {
				return err
			}
			for i, elem19 := range m.PreviousAddresses {
				elemTarget18, err := listTarget17.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem19.FillVDLTarget(elemTarget18, tt.NonOptional().Field(4).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget17.FinishElem(elemTarget18); err != nil {
					return err
				}
			}
			if err := fieldTarget15.FinishList(listTarget17); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var22 := true
	var23 := (m.Credit.Agency == CreditAgencyEquifax)
	var22 = var22 && var23
	var var24 bool
	if field, ok := m.Credit.Report.(AgencyReportEquifaxReport); ok {

		var25 := (field.Value == EquifaxCreditReport{})
		var24 = var25
	}
	var22 = var22 && var24
	if var22 {
		if err := fieldsTarget1.ZeroField("Credit"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("Credit")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Credit.FillVDLTarget(fieldTarget21, tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Customer) MakeVDLTarget() vdl.Target {
	return &CustomerTarget{Value: m}
}

type CustomerTarget struct {
	Value                   *Customer
	nameTarget              vdl.StringTarget
	idTarget                vdl.Int64Target
	activeTarget            vdl.BoolTarget
	addressTarget           AddressInfoTarget
	previousAddressesTarget __VDLTarget3_list
	creditTarget            CreditReportTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *CustomerTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Customer)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *CustomerTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Id":
		t.idTarget.Value = &t.Value.Id
		target, err := &t.idTarget, error(nil)
		return nil, target, err
	case "Active":
		t.activeTarget.Value = &t.Value.Active
		target, err := &t.activeTarget, error(nil)
		return nil, target, err
	case "Address":
		t.addressTarget.Value = &t.Value.Address
		target, err := &t.addressTarget, error(nil)
		return nil, target, err
	case "PreviousAddresses":
		t.previousAddressesTarget.Value = &t.Value.PreviousAddresses
		target, err := &t.previousAddressesTarget, error(nil)
		return nil, target, err
	case "Credit":
		t.creditTarget.Value = &t.Value.Credit
		target, err := &t.creditTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *CustomerTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *CustomerTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Id":
		t.Value.Id = int64(0)
		return nil
	case "Active":
		t.Value.Active = false
		return nil
	case "Address":
		t.Value.Address = AddressInfo{}
		return nil
	case "PreviousAddresses":
		t.Value.PreviousAddresses = []AddressInfo(nil)
		return nil
	case "Credit":
		t.Value.Credit = CreditReport{
			Report: AgencyReportEquifaxReport{},
		}
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *CustomerTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []AddressInfo
type __VDLTarget3_list struct {
	Value      *[]AddressInfo
	elemTarget AddressInfoTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget3_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]AddressInfo)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]AddressInfo, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget3_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget3_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget3_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x Customer) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if x.Id != 0 {
		return false
	}
	if x.Active {
		return false
	}
	if x.Address != (AddressInfo{}) {
		return false
	}
	if len(x.PreviousAddresses) != 0 {
		return false
	}
	if !x.Credit.VDLIsZero() {
		return false
	}
	return true
}

func (x Customer) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Customer)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Id != 0 {
		if err := enc.NextField("Id"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.Id); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Active {
		if err := enc.NextField("Active"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(x.Active); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Address != (AddressInfo{}) {
		if err := enc.NextField("Address"); err != nil {
			return err
		}
		if err := x.Address.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.PreviousAddresses) != 0 {
		if err := enc.NextField("PreviousAddresses"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_3(enc, x.PreviousAddresses); err != nil {
			return err
		}
	}
	if !x.Credit.VDLIsZero() {
		if err := enc.NextField("Credit"); err != nil {
			return err
		}
		if err := x.Credit.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_3(enc vdl.Encoder, x []AddressInfo) error {
	if err := enc.StartValue(vdl.TypeOf((*[]AddressInfo)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := x[i].VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Customer) VDLRead(dec vdl.Decoder) error {
	*x = Customer{
		Credit: CreditReport{
			Report: AgencyReportEquifaxReport{},
		},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Id":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Id, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Active":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Active, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Address":
			if err := x.Address.VDLRead(dec); err != nil {
				return err
			}
		case "PreviousAddresses":
			if err := __VDLReadAnon_list_3(dec, &x.PreviousAddresses); err != nil {
				return err
			}
		case "Credit":
			if err := x.Credit.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_list_3(dec vdl.Decoder, x *[]AddressInfo) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]AddressInfo, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem AddressInfo
		if err := elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

type Invoice struct {
	CustId      int64
	InvoiceNum  int64
	InvoiceDate time.Time
	Amount      int64
	ShipTo      AddressInfo
}

func (Invoice) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Invoice"`
}) {
}

func (m *Invoice) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.CustId == int64(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("CustId"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("CustId")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromInt(int64(m.CustId), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.InvoiceNum == int64(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("InvoiceNum"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("InvoiceNum")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromInt(int64(m.InvoiceNum), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var wireValue8 vdltime.Time
	if err := vdltime.TimeFromNative(&wireValue8, m.InvoiceDate); err != nil {
		return err
	}

	var11 := (wireValue8 == vdltime.Time{})
	if var11 {
		if err := fieldsTarget1.ZeroField("InvoiceDate"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("InvoiceDate")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := wireValue8.FillVDLTarget(fieldTarget10, tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
				return err
			}
		}
	}
	var14 := (m.Amount == int64(0))
	if var14 {
		if err := fieldsTarget1.ZeroField("Amount"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("Amount")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget13.FromInt(int64(m.Amount), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
				return err
			}
		}
	}
	var17 := (m.ShipTo == AddressInfo{})
	if var17 {
		if err := fieldsTarget1.ZeroField("ShipTo"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget15, fieldTarget16, err := fieldsTarget1.StartField("ShipTo")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.ShipTo.FillVDLTarget(fieldTarget16, tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget15, fieldTarget16); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Invoice) MakeVDLTarget() vdl.Target {
	return &InvoiceTarget{Value: m}
}

type InvoiceTarget struct {
	Value             *Invoice
	custIdTarget      vdl.Int64Target
	invoiceNumTarget  vdl.Int64Target
	invoiceDateTarget vdltime.TimeTarget
	amountTarget      vdl.Int64Target
	shipToTarget      AddressInfoTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *InvoiceTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Invoice)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *InvoiceTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "CustId":
		t.custIdTarget.Value = &t.Value.CustId
		target, err := &t.custIdTarget, error(nil)
		return nil, target, err
	case "InvoiceNum":
		t.invoiceNumTarget.Value = &t.Value.InvoiceNum
		target, err := &t.invoiceNumTarget, error(nil)
		return nil, target, err
	case "InvoiceDate":
		t.invoiceDateTarget.Value = &t.Value.InvoiceDate
		target, err := &t.invoiceDateTarget, error(nil)
		return nil, target, err
	case "Amount":
		t.amountTarget.Value = &t.Value.Amount
		target, err := &t.amountTarget, error(nil)
		return nil, target, err
	case "ShipTo":
		t.shipToTarget.Value = &t.Value.ShipTo
		target, err := &t.shipToTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *InvoiceTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *InvoiceTarget) ZeroField(name string) error {
	switch name {
	case "CustId":
		t.Value.CustId = int64(0)
		return nil
	case "InvoiceNum":
		t.Value.InvoiceNum = int64(0)
		return nil
	case "InvoiceDate":
		t.Value.InvoiceDate = time.Time{}
		return nil
	case "Amount":
		t.Value.Amount = int64(0)
		return nil
	case "ShipTo":
		t.Value.ShipTo = AddressInfo{}
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *InvoiceTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x Invoice) VDLIsZero() bool {
	if x.CustId != 0 {
		return false
	}
	if x.InvoiceNum != 0 {
		return false
	}
	if !x.InvoiceDate.IsZero() {
		return false
	}
	if x.Amount != 0 {
		return false
	}
	if x.ShipTo != (AddressInfo{}) {
		return false
	}
	return true
}

func (x Invoice) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Invoice)(nil)).Elem()); err != nil {
		return err
	}
	if x.CustId != 0 {
		if err := enc.NextField("CustId"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.CustId); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.InvoiceNum != 0 {
		if err := enc.NextField("InvoiceNum"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.InvoiceNum); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if !x.InvoiceDate.IsZero() {
		if err := enc.NextField("InvoiceDate"); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, x.InvoiceDate); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.Amount != 0 {
		if err := enc.NextField("Amount"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.Amount); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.ShipTo != (AddressInfo{}) {
		if err := enc.NextField("ShipTo"); err != nil {
			return err
		}
		if err := x.ShipTo.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Invoice) VDLRead(dec vdl.Decoder) error {
	*x = Invoice{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "CustId":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.CustId, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "InvoiceNum":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.InvoiceNum, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "InvoiceDate":
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &x.InvoiceDate); err != nil {
				return err
			}
		case "Amount":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Amount, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "ShipTo":
			if err := x.ShipTo.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type Numbers struct {
	B    byte
	Ui16 uint16
	Ui32 uint32
	Ui64 uint64
	I16  int16
	I32  int32
	I64  int64
	F32  float32
	F64  float64
}

func (Numbers) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.Numbers"`
}) {
}

func (m *Numbers) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.B == byte(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromUint(uint64(m.B), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Ui16 == uint16(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("Ui16"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Ui16")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromUint(uint64(m.Ui16), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Ui32 == uint32(0))
	if var10 {
		if err := fieldsTarget1.ZeroField("Ui32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Ui32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromUint(uint64(m.Ui32), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var13 := (m.Ui64 == uint64(0))
	if var13 {
		if err := fieldsTarget1.ZeroField("Ui64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Ui64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget12.FromUint(uint64(m.Ui64), tt.NonOptional().Field(3).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var16 := (m.I16 == int16(0))
	if var16 {
		if err := fieldsTarget1.ZeroField("I16"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("I16")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget15.FromInt(int64(m.I16), tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var19 := (m.I32 == int32(0))
	if var19 {
		if err := fieldsTarget1.ZeroField("I32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("I32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget18.FromInt(int64(m.I32), tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
				return err
			}
		}
	}
	var22 := (m.I64 == int64(0))
	if var22 {
		if err := fieldsTarget1.ZeroField("I64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("I64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget21.FromInt(int64(m.I64), tt.NonOptional().Field(6).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
				return err
			}
		}
	}
	var25 := (m.F32 == float32(0))
	if var25 {
		if err := fieldsTarget1.ZeroField("F32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("F32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget24.FromFloat(float64(m.F32), tt.NonOptional().Field(7).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
				return err
			}
		}
	}
	var28 := (m.F64 == float64(0))
	if var28 {
		if err := fieldsTarget1.ZeroField("F64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("F64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget27.FromFloat(float64(m.F64), tt.NonOptional().Field(8).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Numbers) MakeVDLTarget() vdl.Target {
	return &NumbersTarget{Value: m}
}

type NumbersTarget struct {
	Value      *Numbers
	bTarget    vdl.ByteTarget
	ui16Target vdl.Uint16Target
	ui32Target vdl.Uint32Target
	ui64Target vdl.Uint64Target
	i16Target  vdl.Int16Target
	i32Target  vdl.Int32Target
	i64Target  vdl.Int64Target
	f32Target  vdl.Float32Target
	f64Target  vdl.Float64Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *NumbersTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Numbers)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *NumbersTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "Ui16":
		t.ui16Target.Value = &t.Value.Ui16
		target, err := &t.ui16Target, error(nil)
		return nil, target, err
	case "Ui32":
		t.ui32Target.Value = &t.Value.Ui32
		target, err := &t.ui32Target, error(nil)
		return nil, target, err
	case "Ui64":
		t.ui64Target.Value = &t.Value.Ui64
		target, err := &t.ui64Target, error(nil)
		return nil, target, err
	case "I16":
		t.i16Target.Value = &t.Value.I16
		target, err := &t.i16Target, error(nil)
		return nil, target, err
	case "I32":
		t.i32Target.Value = &t.Value.I32
		target, err := &t.i32Target, error(nil)
		return nil, target, err
	case "I64":
		t.i64Target.Value = &t.Value.I64
		target, err := &t.i64Target, error(nil)
		return nil, target, err
	case "F32":
		t.f32Target.Value = &t.Value.F32
		target, err := &t.f32Target, error(nil)
		return nil, target, err
	case "F64":
		t.f64Target.Value = &t.Value.F64
		target, err := &t.f64Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *NumbersTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *NumbersTarget) ZeroField(name string) error {
	switch name {
	case "B":
		t.Value.B = byte(0)
		return nil
	case "Ui16":
		t.Value.Ui16 = uint16(0)
		return nil
	case "Ui32":
		t.Value.Ui32 = uint32(0)
		return nil
	case "Ui64":
		t.Value.Ui64 = uint64(0)
		return nil
	case "I16":
		t.Value.I16 = int16(0)
		return nil
	case "I32":
		t.Value.I32 = int32(0)
		return nil
	case "I64":
		t.Value.I64 = int64(0)
		return nil
	case "F32":
		t.Value.F32 = float32(0)
		return nil
	case "F64":
		t.Value.F64 = float64(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *NumbersTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x Numbers) VDLIsZero() bool {
	return x == Numbers{}
}

func (x Numbers) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*Numbers)(nil)).Elem()); err != nil {
		return err
	}
	if x.B != 0 {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.B)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Ui16 != 0 {
		if err := enc.NextField("Ui16"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint16Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Ui16)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Ui32 != 0 {
		if err := enc.NextField("Ui32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.Ui32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.Ui64 != 0 {
		if err := enc.NextField("Ui64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(x.Ui64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.I16 != 0 {
		if err := enc.NextField("I16"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x.I16)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.I32 != 0 {
		if err := enc.NextField("I32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int32Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(x.I32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.I64 != 0 {
		if err := enc.NextField("I64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(x.I64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.F32 != 0 {
		if err := enc.NextField("F32"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float32Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(float64(x.F32)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.F64 != 0 {
		if err := enc.NextField("F64"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(x.F64); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *Numbers) VDLRead(dec vdl.Decoder) error {
	*x = Numbers{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "B":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.B = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Ui16":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			x.Ui16 = uint16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Ui32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			x.Ui32 = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "Ui64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Ui64, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "I16":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			x.I16 = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "I32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			x.I32 = int32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "I64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.I64, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "F32":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			x.F32 = float32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "F64":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.F64, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type (
	// TitleOrValueType represents any single field of the TitleOrValueType union type.
	TitleOrValueType interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the TitleOrValueType union type.
		__VDLReflect(__TitleOrValueTypeReflect)
		FillVDLTarget(vdl.Target, *vdl.Type) error
		VDLIsZero() bool
		VDLWrite(vdl.Encoder) error
	}
	// TitleOrValueTypeTitle represents field Title of the TitleOrValueType union type.
	TitleOrValueTypeTitle struct{ Value string }
	// TitleOrValueTypeValue represents field Value of the TitleOrValueType union type.
	TitleOrValueTypeValue struct{ Value int64 }
	// __TitleOrValueTypeReflect describes the TitleOrValueType union type.
	__TitleOrValueTypeReflect struct {
		Name               string `vdl:"v.io/v23/query/engine/internal/testdata.TitleOrValueType"`
		Type               TitleOrValueType
		UnionTargetFactory titleOrValueTypeTargetFactory
		Union              struct {
			Title TitleOrValueTypeTitle
			Value TitleOrValueTypeValue
		}
	}
)

func (x TitleOrValueTypeTitle) Index() int                             { return 0 }
func (x TitleOrValueTypeTitle) Interface() interface{}                 { return x.Value }
func (x TitleOrValueTypeTitle) Name() string                           { return "Title" }
func (x TitleOrValueTypeTitle) __VDLReflect(__TitleOrValueTypeReflect) {}

func (m TitleOrValueTypeTitle) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Title")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromString(string(m.Value), tt.NonOptional().Field(0).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m TitleOrValueTypeTitle) MakeVDLTarget() vdl.Target {
	return nil
}

func (x TitleOrValueTypeValue) Index() int                             { return 1 }
func (x TitleOrValueTypeValue) Interface() interface{}                 { return x.Value }
func (x TitleOrValueTypeValue) Name() string                           { return "Value" }
func (x TitleOrValueTypeValue) __VDLReflect(__TitleOrValueTypeReflect) {}

func (m TitleOrValueTypeValue) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Value")
	if err != nil {
		return err
	}
	if err := fieldTarget3.FromInt(int64(m.Value), tt.NonOptional().Field(1).Type); err != nil {
		return err
	}
	if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
		return err
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}

	return nil
}

func (m TitleOrValueTypeValue) MakeVDLTarget() vdl.Target {
	return nil
}

type TitleOrValueTypeTarget struct {
	Value     *TitleOrValueType
	fieldName string

	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *TitleOrValueTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if ttWant := vdl.TypeOf((*TitleOrValueType)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}

	return t, nil
}
func (t *TitleOrValueTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	t.fieldName = name
	switch name {
	case "Title":
		val := ""
		return nil, &vdl.StringTarget{Value: &val}, nil
	case "Value":
		val := int64(0)
		return nil, &vdl.Int64Target{Value: &val}, nil
	default:
		return nil, nil, fmt.Errorf("field %s not in union v.io/v23/query/engine/internal/testdata.TitleOrValueType", name)
	}
}
func (t *TitleOrValueTypeTarget) FinishField(_, fieldTarget vdl.Target) error {
	switch t.fieldName {
	case "Title":
		*t.Value = TitleOrValueTypeTitle{*(fieldTarget.(*vdl.StringTarget)).Value}
	case "Value":
		*t.Value = TitleOrValueTypeValue{*(fieldTarget.(*vdl.Int64Target)).Value}
	}
	return nil
}
func (t *TitleOrValueTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

type titleOrValueTypeTargetFactory struct{}

func (t titleOrValueTypeTargetFactory) VDLMakeUnionTarget(union interface{}) (vdl.Target, error) {
	if typedUnion, ok := union.(*TitleOrValueType); ok {
		return &TitleOrValueTypeTarget{Value: typedUnion}, nil
	}
	return nil, fmt.Errorf("got %T, want *TitleOrValueType", union)
}

func (x TitleOrValueTypeTitle) VDLIsZero() bool {
	return x.Value == ""
}

func (x TitleOrValueTypeValue) VDLIsZero() bool {
	return false
}

func (x TitleOrValueTypeTitle) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*TitleOrValueType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("Title"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.StringType); err != nil {
		return err
	}
	if err := enc.EncodeString(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x TitleOrValueTypeValue) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*TitleOrValueType)(nil))); err != nil {
		return err
	}
	if err := enc.NextField("Value"); err != nil {
		return err
	}
	if err := enc.StartValue(vdl.Int64Type); err != nil {
		return err
	}
	if err := enc.EncodeInt(x.Value); err != nil {
		return err
	}
	if err := enc.FinishValue(); err != nil {
		return err
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func VDLReadTitleOrValueType(dec vdl.Decoder, x *TitleOrValueType) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(x), dec.Type()) {
		return fmt.Errorf("incompatible union %T, from %v", x, dec.Type())
	}
	f, err := dec.NextField()
	if err != nil {
		return err
	}
	switch f {
	case "Title":
		var field TitleOrValueTypeTitle
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeString(); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "Value":
		var field TitleOrValueTypeValue
		if err := dec.StartValue(); err != nil {
			return err
		}
		var err error
		if field.Value, err = dec.DecodeInt(64); err != nil {
			return err
		}
		if err := dec.FinishValue(); err != nil {
			return err
		}
		*x = field
	case "":
		return fmt.Errorf("missing field in union %T, from %v", x, dec.Type())
	default:
		return fmt.Errorf("field %q not in union %T, from %v", f, x, dec.Type())
	}
	switch f, err := dec.NextField(); {
	case err != nil:
		return err
	case f != "":
		return fmt.Errorf("extra field %q in union %T, from %v", f, x, dec.Type())
	}
	return dec.FinishValue()
}

type BazType struct {
	Name         string
	TitleOrValue TitleOrValueType
}

func (BazType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BazType"`
}) {
}

func (m *BazType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if field, ok := m.TitleOrValue.(TitleOrValueTypeTitle); ok {

		var8 := (field.Value == "")
		var7 = var8
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("TitleOrValue"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("TitleOrValue")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			unionValue9 := m.TitleOrValue
			if unionValue9 == nil {
				unionValue9 = TitleOrValueTypeTitle{}
			}
			if err := unionValue9.FillVDLTarget(fieldTarget6, tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BazType) MakeVDLTarget() vdl.Target {
	return &BazTypeTarget{Value: m}
}

type BazTypeTarget struct {
	Value              *BazType
	nameTarget         vdl.StringTarget
	titleOrValueTarget TitleOrValueTypeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BazTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*BazType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *BazTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "TitleOrValue":
		t.titleOrValueTarget.Value = &t.Value.TitleOrValue
		target, err := &t.titleOrValueTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *BazTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BazTypeTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "TitleOrValue":
		t.Value.TitleOrValue = TitleOrValueType(TitleOrValueTypeTitle{})
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *BazTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x BazType) VDLIsZero() bool {
	if x.Name != "" {
		return false
	}
	if x.TitleOrValue != nil && !x.TitleOrValue.VDLIsZero() {
		return false
	}
	return true
}

func (x BazType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BazType)(nil)).Elem()); err != nil {
		return err
	}
	if x.Name != "" {
		if err := enc.NextField("Name"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Name); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.TitleOrValue != nil && !x.TitleOrValue.VDLIsZero() {
		if err := enc.NextField("TitleOrValue"); err != nil {
			return err
		}
		if err := x.TitleOrValue.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BazType) VDLRead(dec vdl.Decoder) error {
	*x = BazType{
		TitleOrValue: TitleOrValueTypeTitle{},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Name":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "TitleOrValue":
			if err := VDLReadTitleOrValueType(dec, &x.TitleOrValue); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type BarType struct {
	Baz BazType
}

func (BarType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BarType"`
}) {
}

func (m *BarType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Baz == BazType{
		TitleOrValue: TitleOrValueTypeTitle{},
	})
	if var4 {
		if err := fieldsTarget1.ZeroField("Baz"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Baz")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Baz.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BarType) MakeVDLTarget() vdl.Target {
	return &BarTypeTarget{Value: m}
}

type BarTypeTarget struct {
	Value     *BarType
	bazTarget BazTypeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BarTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*BarType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *BarTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Baz":
		t.bazTarget.Value = &t.Value.Baz
		target, err := &t.bazTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *BarTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BarTypeTarget) ZeroField(name string) error {
	switch name {
	case "Baz":
		t.Value.Baz = BazType{
			TitleOrValue: TitleOrValueTypeTitle{},
		}
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *BarTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x BarType) VDLIsZero() bool {
	if !x.Baz.VDLIsZero() {
		return false
	}
	return true
}

func (x BarType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BarType)(nil)).Elem()); err != nil {
		return err
	}
	if !x.Baz.VDLIsZero() {
		if err := enc.NextField("Baz"); err != nil {
			return err
		}
		if err := x.Baz.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BarType) VDLRead(dec vdl.Decoder) error {
	*x = BarType{
		Baz: BazType{
			TitleOrValue: TitleOrValueTypeTitle{},
		},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Baz":
			if err := x.Baz.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type FooType struct {
	Bar BarType
}

func (FooType) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FooType"`
}) {
}

func (m *FooType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Bar == BarType{
		Baz: BazType{
			TitleOrValue: TitleOrValueTypeTitle{},
		},
	})
	if var4 {
		if err := fieldsTarget1.ZeroField("Bar"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Bar")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Bar.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *FooType) MakeVDLTarget() vdl.Target {
	return &FooTypeTarget{Value: m}
}

type FooTypeTarget struct {
	Value     *FooType
	barTarget BarTypeTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *FooTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*FooType)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *FooTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Bar":
		t.barTarget.Value = &t.Value.Bar
		target, err := &t.barTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *FooTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *FooTypeTarget) ZeroField(name string) error {
	switch name {
	case "Bar":
		t.Value.Bar = BarType{
			Baz: BazType{
				TitleOrValue: TitleOrValueTypeTitle{},
			},
		}
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *FooTypeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x FooType) VDLIsZero() bool {
	if !x.Bar.VDLIsZero() {
		return false
	}
	return true
}

func (x FooType) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*FooType)(nil)).Elem()); err != nil {
		return err
	}
	if !x.Bar.VDLIsZero() {
		if err := enc.NextField("Bar"); err != nil {
			return err
		}
		if err := x.Bar.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FooType) VDLRead(dec vdl.Decoder) error {
	*x = FooType{
		Bar: BarType{
			Baz: BazType{
				TitleOrValue: TitleOrValueTypeTitle{},
			},
		},
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Bar":
			if err := x.Bar.VDLRead(dec); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type K struct {
	A byte
	B string
}

func (K) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.K"`
}) {
}

func (m *K) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A == byte(0))
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromUint(uint64(m.A), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.B == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.B), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *K) MakeVDLTarget() vdl.Target {
	return &KTarget{Value: m}
}

type KTarget struct {
	Value   *K
	aTarget vdl.ByteTarget
	bTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *KTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*K)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *KTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *KTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *KTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = byte(0)
		return nil
	case "B":
		t.Value.B = ""
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *KTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x K) VDLIsZero() bool {
	return x == K{}
}

func (x K) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*K)(nil)).Elem()); err != nil {
		return err
	}
	if x.A != 0 {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(x.A)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.B != "" {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.B); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *K) VDLRead(dec vdl.Decoder) error {
	*x = K{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			x.A = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "B":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.B, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type V struct {
	A string
	B float32
}

func (V) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.V"`
}) {
}

func (m *V) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.A == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("A"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("A")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.A), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.B == float32(0))
	if var7 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromFloat(float64(m.B), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *V) MakeVDLTarget() vdl.Target {
	return &VTarget{Value: m}
}

type VTarget struct {
	Value   *V
	aTarget vdl.StringTarget
	bTarget vdl.Float32Target
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *VTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*V)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *VTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "A":
		t.aTarget.Value = &t.Value.A
		target, err := &t.aTarget, error(nil)
		return nil, target, err
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *VTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *VTarget) ZeroField(name string) error {
	switch name {
	case "A":
		t.Value.A = ""
		return nil
	case "B":
		t.Value.B = float32(0)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *VTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x V) VDLIsZero() bool {
	return x == V{}
}

func (x V) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*V)(nil)).Elem()); err != nil {
		return err
	}
	if x.A != "" {
		if err := enc.NextField("A"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.A); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if x.B != 0 {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float32Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(float64(x.B)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *V) VDLRead(dec vdl.Decoder) error {
	*x = V{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "A":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.A, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "B":
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			x.B = float32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type FunWithMaps struct {
	Key       K
	Map       map[K]V
	Confusing map[int16][]map[string]struct{}
}

func (FunWithMaps) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FunWithMaps"`
}) {
}

func (m *FunWithMaps) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Key == K{})
	if var4 {
		if err := fieldsTarget1.ZeroField("Key"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.Key.FillVDLTarget(fieldTarget3, tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var7 bool
	if len(m.Map) == 0 {
		var7 = true
	}
	if var7 {
		if err := fieldsTarget1.ZeroField("Map"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Map")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget8, err := fieldTarget6.StartMap(tt.NonOptional().Field(1).Type, len(m.Map))
			if err != nil {
				return err
			}
			for key10, value12 := range m.Map {
				keyTarget9, err := mapTarget8.StartKey()
				if err != nil {
					return err
				}

				if err := key10.FillVDLTarget(keyTarget9, tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				valueTarget11, err := mapTarget8.FinishKeyStartField(keyTarget9)
				if err != nil {
					return err
				}

				if err := value12.FillVDLTarget(valueTarget11, tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget8.FinishField(keyTarget9, valueTarget11); err != nil {
					return err
				}
			}
			if err := fieldTarget6.FinishMap(mapTarget8); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var var15 bool
	if len(m.Confusing) == 0 {
		var15 = true
	}
	if var15 {
		if err := fieldsTarget1.ZeroField("Confusing"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget13, fieldTarget14, err := fieldsTarget1.StartField("Confusing")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget16, err := fieldTarget14.StartMap(tt.NonOptional().Field(2).Type, len(m.Confusing))
			if err != nil {
				return err
			}
			for key18, value20 := range m.Confusing {
				keyTarget17, err := mapTarget16.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget17.FromInt(int64(key18), tt.NonOptional().Field(2).Type.Key()); err != nil {
					return err
				}
				valueTarget19, err := mapTarget16.FinishKeyStartField(keyTarget17)
				if err != nil {
					return err
				}

				listTarget21, err := valueTarget19.StartList(tt.NonOptional().Field(2).Type.Elem(), len(value20))
				if err != nil {
					return err
				}
				for i, elem23 := range value20 {
					elemTarget22, err := listTarget21.StartElem(i)
					if err != nil {
						return err
					}

					setTarget24, err := elemTarget22.StartSet(tt.NonOptional().Field(2).Type.Elem().Elem(), len(elem23))
					if err != nil {
						return err
					}
					for key26 := range elem23 {
						keyTarget25, err := setTarget24.StartKey()
						if err != nil {
							return err
						}
						if err := keyTarget25.FromString(string(key26), tt.NonOptional().Field(2).Type.Elem().Elem().Key()); err != nil {
							return err
						}
						if err := setTarget24.FinishKey(keyTarget25); err != nil {
							return err
						}
					}
					if err := elemTarget22.FinishSet(setTarget24); err != nil {
						return err
					}
					if err := listTarget21.FinishElem(elemTarget22); err != nil {
						return err
					}
				}
				if err := valueTarget19.FinishList(listTarget21); err != nil {
					return err
				}
				if err := mapTarget16.FinishField(keyTarget17, valueTarget19); err != nil {
					return err
				}
			}
			if err := fieldTarget14.FinishMap(mapTarget16); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget13, fieldTarget14); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *FunWithMaps) MakeVDLTarget() vdl.Target {
	return &FunWithMapsTarget{Value: m}
}

type FunWithMapsTarget struct {
	Value           *FunWithMaps
	keyTarget       KTarget
	mapTarget       __VDLTarget4_map
	confusingTarget __VDLTarget5_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *FunWithMapsTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*FunWithMaps)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *FunWithMapsTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	case "Map":
		t.mapTarget.Value = &t.Value.Map
		target, err := &t.mapTarget, error(nil)
		return nil, target, err
	case "Confusing":
		t.confusingTarget.Value = &t.Value.Confusing
		target, err := &t.confusingTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *FunWithMapsTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *FunWithMapsTarget) ZeroField(name string) error {
	switch name {
	case "Key":
		t.Value.Key = K{}
		return nil
	case "Map":
		t.Value.Map = map[K]V(nil)
		return nil
	case "Confusing":
		t.Value.Confusing = map[int16][]map[string]struct{}(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *FunWithMapsTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[K]V
type __VDLTarget4_map struct {
	Value      *map[K]V
	currKey    K
	currElem   V
	keyTarget  KTarget
	elemTarget VTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget4_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[K]V)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[K]V)
	return t, nil
}
func (t *__VDLTarget4_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = K{}
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = V{}
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget4_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int16][]map[string]struct{}
type __VDLTarget5_map struct {
	Value      *map[int16][]map[string]struct{}
	currKey    int16
	currElem   []map[string]struct{}
	keyTarget  vdl.Int16Target
	elemTarget __VDLTarget6_list
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget5_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int16][]map[string]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int16][]map[string]struct{})
	return t, nil
}
func (t *__VDLTarget5_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = []map[string]struct{}(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget5_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// []map[string]struct{}
type __VDLTarget6_list struct {
	Value      *[]map[string]struct{}
	elemTarget __VDLTarget7_set
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget6_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]map[string]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]map[string]struct{}, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget6_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget6_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget6_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// map[string]struct{}
type __VDLTarget7_set struct {
	Value     *map[string]struct{}
	currKey   string
	keyTarget vdl.StringTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget7_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]struct{})
	return t, nil
}
func (t *__VDLTarget7_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget7_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget7_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x FunWithMaps) VDLIsZero() bool {
	if x.Key != (K{}) {
		return false
	}
	if len(x.Map) != 0 {
		return false
	}
	if len(x.Confusing) != 0 {
		return false
	}
	return true
}

func (x FunWithMaps) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*FunWithMaps)(nil)).Elem()); err != nil {
		return err
	}
	if x.Key != (K{}) {
		if err := enc.NextField("Key"); err != nil {
			return err
		}
		if err := x.Key.VDLWrite(enc); err != nil {
			return err
		}
	}
	if len(x.Map) != 0 {
		if err := enc.NextField("Map"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_4(enc, x.Map); err != nil {
			return err
		}
	}
	if len(x.Confusing) != 0 {
		if err := enc.NextField("Confusing"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_5(enc, x.Confusing); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_4(enc vdl.Encoder, x map[K]V) error {
	if err := enc.StartValue(vdl.TypeOf((*map[K]V)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := key.VDLWrite(enc); err != nil {
			return err
		}
		if err := elem.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_5(enc vdl.Encoder, x map[int16][]map[string]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[int16][]map[string]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := __VDLWriteAnon_list_6(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_list_6(enc vdl.Encoder, x []map[string]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*[]map[string]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for i := 0; i < len(x); i++ {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_7(enc, x[i]); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_7(enc vdl.Encoder, x map[string]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FunWithMaps) VDLRead(dec vdl.Decoder) error {
	*x = FunWithMaps{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Key":
			if err := x.Key.VDLRead(dec); err != nil {
				return err
			}
		case "Map":
			if err := __VDLReadAnon_map_4(dec, &x.Map); err != nil {
				return err
			}
		case "Confusing":
			if err := __VDLReadAnon_map_5(dec, &x.Confusing); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_4(dec vdl.Decoder, x *map[K]V) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[K]V
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[K]V, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key K
		{
			if err := key.VDLRead(dec); err != nil {
				return err
			}
		}
		var elem V
		{
			if err := elem.VDLRead(dec); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[K]V)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_5(dec vdl.Decoder, x *map[int16][]map[string]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[int16][]map[string]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int16][]map[string]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int16
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			key = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem []map[string]struct{}
		{
			if err := __VDLReadAnon_list_6(dec, &elem); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[int16][]map[string]struct{})
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_list_6(dec vdl.Decoder, x *[]map[string]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len > 0:
		*x = make([]map[string]struct{}, 0, len)
	default:
		*x = nil
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem map[string]struct{}
		if err := __VDLReadAnon_set_7(dec, &elem); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLReadAnon_set_7(dec vdl.Decoder, x *map[string]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

type FunWithTypes struct {
	T1 *vdl.Type
	T2 *vdl.Type
}

func (FunWithTypes) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.FunWithTypes"`
}) {
}

func (m *FunWithTypes) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.T1 == nil || m.T1 == vdl.AnyType)
	if var4 {
		if err := fieldsTarget1.ZeroField("T1"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("T1")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			typeObjectVal5 := m.T1
			if typeObjectVal5 == nil {
				typeObjectVal5 = vdl.AnyType
			}
			if err := fieldTarget3.FromTypeObject(typeObjectVal5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var8 := (m.T2 == nil || m.T2 == vdl.AnyType)
	if var8 {
		if err := fieldsTarget1.ZeroField("T2"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget6, fieldTarget7, err := fieldsTarget1.StartField("T2")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			typeObjectVal9 := m.T2
			if typeObjectVal9 == nil {
				typeObjectVal9 = vdl.AnyType
			}
			if err := fieldTarget7.FromTypeObject(typeObjectVal9); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget6, fieldTarget7); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *FunWithTypes) MakeVDLTarget() vdl.Target {
	return &FunWithTypesTarget{Value: m}
}

type FunWithTypesTarget struct {
	Value    *FunWithTypes
	t1Target vdl.TypeObjectTarget
	t2Target vdl.TypeObjectTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *FunWithTypesTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*FunWithTypes)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *FunWithTypesTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "T1":
		t.t1Target.Value = &t.Value.T1
		target, err := &t.t1Target, error(nil)
		return nil, target, err
	case "T2":
		t.t2Target.Value = &t.Value.T2
		target, err := &t.t2Target, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *FunWithTypesTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *FunWithTypesTarget) ZeroField(name string) error {
	switch name {
	case "T1":
		t.Value.T1 = vdl.AnyType
		return nil
	case "T2":
		t.Value.T2 = vdl.AnyType
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *FunWithTypesTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x FunWithTypes) VDLIsZero() bool {
	if x.T1 != nil && x.T1 != vdl.AnyType {
		return false
	}
	if x.T2 != nil && x.T2 != vdl.AnyType {
		return false
	}
	return true
}

func (x FunWithTypes) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*FunWithTypes)(nil)).Elem()); err != nil {
		return err
	}
	if x.T1 != nil && x.T1 != vdl.AnyType {
		if err := enc.NextField("T1"); err != nil {
			return err
		}
		if err := x.T1.VDLWrite(enc); err != nil {
			return err
		}
	}
	if x.T2 != nil && x.T2 != vdl.AnyType {
		if err := enc.NextField("T2"); err != nil {
			return err
		}
		if err := x.T2.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *FunWithTypes) VDLRead(dec vdl.Decoder) error {
	*x = FunWithTypes{
		T1: vdl.AnyType,
		T2: vdl.AnyType,
	}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "T1":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.T1, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		case "T2":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.T2, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

type ManyMaps struct {
	B   map[bool]string
	By  map[byte]string
	U16 map[uint16]string
	U32 map[uint32]string
	U64 map[uint64]string
	I16 map[int16]string
	I32 map[int32]string
	I64 map[int64]string
	F32 map[float32]string
	F64 map[float64]string
	S   map[string]string
	Ms  map[string]map[string]string
	T   map[time.Time]string
}

func (ManyMaps) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ManyMaps"`
}) {
}

func (m *ManyMaps) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.B) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget5, err := fieldTarget3.StartMap(tt.NonOptional().Field(0).Type, len(m.B))
			if err != nil {
				return err
			}
			for key7, value9 := range m.B {
				keyTarget6, err := mapTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromBool(bool(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				valueTarget8, err := mapTarget5.FinishKeyStartField(keyTarget6)
				if err != nil {
					return err
				}
				if err := valueTarget8.FromString(string(value9), tt.NonOptional().Field(0).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget5.FinishField(keyTarget6, valueTarget8); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishMap(mapTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var12 bool
	if len(m.By) == 0 {
		var12 = true
	}
	if var12 {
		if err := fieldsTarget1.ZeroField("By"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget10, fieldTarget11, err := fieldsTarget1.StartField("By")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget13, err := fieldTarget11.StartMap(tt.NonOptional().Field(1).Type, len(m.By))
			if err != nil {
				return err
			}
			for key15, value17 := range m.By {
				keyTarget14, err := mapTarget13.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget14.FromUint(uint64(key15), tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				valueTarget16, err := mapTarget13.FinishKeyStartField(keyTarget14)
				if err != nil {
					return err
				}
				if err := valueTarget16.FromString(string(value17), tt.NonOptional().Field(1).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget13.FinishField(keyTarget14, valueTarget16); err != nil {
					return err
				}
			}
			if err := fieldTarget11.FinishMap(mapTarget13); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget10, fieldTarget11); err != nil {
				return err
			}
		}
	}
	var var20 bool
	if len(m.U16) == 0 {
		var20 = true
	}
	if var20 {
		if err := fieldsTarget1.ZeroField("U16"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget18, fieldTarget19, err := fieldsTarget1.StartField("U16")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget21, err := fieldTarget19.StartMap(tt.NonOptional().Field(2).Type, len(m.U16))
			if err != nil {
				return err
			}
			for key23, value25 := range m.U16 {
				keyTarget22, err := mapTarget21.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget22.FromUint(uint64(key23), tt.NonOptional().Field(2).Type.Key()); err != nil {
					return err
				}
				valueTarget24, err := mapTarget21.FinishKeyStartField(keyTarget22)
				if err != nil {
					return err
				}
				if err := valueTarget24.FromString(string(value25), tt.NonOptional().Field(2).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget21.FinishField(keyTarget22, valueTarget24); err != nil {
					return err
				}
			}
			if err := fieldTarget19.FinishMap(mapTarget21); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget18, fieldTarget19); err != nil {
				return err
			}
		}
	}
	var var28 bool
	if len(m.U32) == 0 {
		var28 = true
	}
	if var28 {
		if err := fieldsTarget1.ZeroField("U32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("U32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget29, err := fieldTarget27.StartMap(tt.NonOptional().Field(3).Type, len(m.U32))
			if err != nil {
				return err
			}
			for key31, value33 := range m.U32 {
				keyTarget30, err := mapTarget29.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget30.FromUint(uint64(key31), tt.NonOptional().Field(3).Type.Key()); err != nil {
					return err
				}
				valueTarget32, err := mapTarget29.FinishKeyStartField(keyTarget30)
				if err != nil {
					return err
				}
				if err := valueTarget32.FromString(string(value33), tt.NonOptional().Field(3).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget29.FinishField(keyTarget30, valueTarget32); err != nil {
					return err
				}
			}
			if err := fieldTarget27.FinishMap(mapTarget29); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
				return err
			}
		}
	}
	var var36 bool
	if len(m.U64) == 0 {
		var36 = true
	}
	if var36 {
		if err := fieldsTarget1.ZeroField("U64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget34, fieldTarget35, err := fieldsTarget1.StartField("U64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget37, err := fieldTarget35.StartMap(tt.NonOptional().Field(4).Type, len(m.U64))
			if err != nil {
				return err
			}
			for key39, value41 := range m.U64 {
				keyTarget38, err := mapTarget37.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget38.FromUint(uint64(key39), tt.NonOptional().Field(4).Type.Key()); err != nil {
					return err
				}
				valueTarget40, err := mapTarget37.FinishKeyStartField(keyTarget38)
				if err != nil {
					return err
				}
				if err := valueTarget40.FromString(string(value41), tt.NonOptional().Field(4).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget37.FinishField(keyTarget38, valueTarget40); err != nil {
					return err
				}
			}
			if err := fieldTarget35.FinishMap(mapTarget37); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget34, fieldTarget35); err != nil {
				return err
			}
		}
	}
	var var44 bool
	if len(m.I16) == 0 {
		var44 = true
	}
	if var44 {
		if err := fieldsTarget1.ZeroField("I16"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget42, fieldTarget43, err := fieldsTarget1.StartField("I16")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget45, err := fieldTarget43.StartMap(tt.NonOptional().Field(5).Type, len(m.I16))
			if err != nil {
				return err
			}
			for key47, value49 := range m.I16 {
				keyTarget46, err := mapTarget45.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget46.FromInt(int64(key47), tt.NonOptional().Field(5).Type.Key()); err != nil {
					return err
				}
				valueTarget48, err := mapTarget45.FinishKeyStartField(keyTarget46)
				if err != nil {
					return err
				}
				if err := valueTarget48.FromString(string(value49), tt.NonOptional().Field(5).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget45.FinishField(keyTarget46, valueTarget48); err != nil {
					return err
				}
			}
			if err := fieldTarget43.FinishMap(mapTarget45); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget42, fieldTarget43); err != nil {
				return err
			}
		}
	}
	var var52 bool
	if len(m.I32) == 0 {
		var52 = true
	}
	if var52 {
		if err := fieldsTarget1.ZeroField("I32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget50, fieldTarget51, err := fieldsTarget1.StartField("I32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget53, err := fieldTarget51.StartMap(tt.NonOptional().Field(6).Type, len(m.I32))
			if err != nil {
				return err
			}
			for key55, value57 := range m.I32 {
				keyTarget54, err := mapTarget53.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget54.FromInt(int64(key55), tt.NonOptional().Field(6).Type.Key()); err != nil {
					return err
				}
				valueTarget56, err := mapTarget53.FinishKeyStartField(keyTarget54)
				if err != nil {
					return err
				}
				if err := valueTarget56.FromString(string(value57), tt.NonOptional().Field(6).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget53.FinishField(keyTarget54, valueTarget56); err != nil {
					return err
				}
			}
			if err := fieldTarget51.FinishMap(mapTarget53); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget50, fieldTarget51); err != nil {
				return err
			}
		}
	}
	var var60 bool
	if len(m.I64) == 0 {
		var60 = true
	}
	if var60 {
		if err := fieldsTarget1.ZeroField("I64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget58, fieldTarget59, err := fieldsTarget1.StartField("I64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget61, err := fieldTarget59.StartMap(tt.NonOptional().Field(7).Type, len(m.I64))
			if err != nil {
				return err
			}
			for key63, value65 := range m.I64 {
				keyTarget62, err := mapTarget61.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget62.FromInt(int64(key63), tt.NonOptional().Field(7).Type.Key()); err != nil {
					return err
				}
				valueTarget64, err := mapTarget61.FinishKeyStartField(keyTarget62)
				if err != nil {
					return err
				}
				if err := valueTarget64.FromString(string(value65), tt.NonOptional().Field(7).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget61.FinishField(keyTarget62, valueTarget64); err != nil {
					return err
				}
			}
			if err := fieldTarget59.FinishMap(mapTarget61); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget58, fieldTarget59); err != nil {
				return err
			}
		}
	}
	var var68 bool
	if len(m.F32) == 0 {
		var68 = true
	}
	if var68 {
		if err := fieldsTarget1.ZeroField("F32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget66, fieldTarget67, err := fieldsTarget1.StartField("F32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget69, err := fieldTarget67.StartMap(tt.NonOptional().Field(8).Type, len(m.F32))
			if err != nil {
				return err
			}
			for key71, value73 := range m.F32 {
				keyTarget70, err := mapTarget69.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget70.FromFloat(float64(key71), tt.NonOptional().Field(8).Type.Key()); err != nil {
					return err
				}
				valueTarget72, err := mapTarget69.FinishKeyStartField(keyTarget70)
				if err != nil {
					return err
				}
				if err := valueTarget72.FromString(string(value73), tt.NonOptional().Field(8).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget69.FinishField(keyTarget70, valueTarget72); err != nil {
					return err
				}
			}
			if err := fieldTarget67.FinishMap(mapTarget69); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget66, fieldTarget67); err != nil {
				return err
			}
		}
	}
	var var76 bool
	if len(m.F64) == 0 {
		var76 = true
	}
	if var76 {
		if err := fieldsTarget1.ZeroField("F64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget74, fieldTarget75, err := fieldsTarget1.StartField("F64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget77, err := fieldTarget75.StartMap(tt.NonOptional().Field(9).Type, len(m.F64))
			if err != nil {
				return err
			}
			for key79, value81 := range m.F64 {
				keyTarget78, err := mapTarget77.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget78.FromFloat(float64(key79), tt.NonOptional().Field(9).Type.Key()); err != nil {
					return err
				}
				valueTarget80, err := mapTarget77.FinishKeyStartField(keyTarget78)
				if err != nil {
					return err
				}
				if err := valueTarget80.FromString(string(value81), tt.NonOptional().Field(9).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget77.FinishField(keyTarget78, valueTarget80); err != nil {
					return err
				}
			}
			if err := fieldTarget75.FinishMap(mapTarget77); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget74, fieldTarget75); err != nil {
				return err
			}
		}
	}
	var var84 bool
	if len(m.S) == 0 {
		var84 = true
	}
	if var84 {
		if err := fieldsTarget1.ZeroField("S"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget82, fieldTarget83, err := fieldsTarget1.StartField("S")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget85, err := fieldTarget83.StartMap(tt.NonOptional().Field(10).Type, len(m.S))
			if err != nil {
				return err
			}
			for key87, value89 := range m.S {
				keyTarget86, err := mapTarget85.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget86.FromString(string(key87), tt.NonOptional().Field(10).Type.Key()); err != nil {
					return err
				}
				valueTarget88, err := mapTarget85.FinishKeyStartField(keyTarget86)
				if err != nil {
					return err
				}
				if err := valueTarget88.FromString(string(value89), tt.NonOptional().Field(10).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget85.FinishField(keyTarget86, valueTarget88); err != nil {
					return err
				}
			}
			if err := fieldTarget83.FinishMap(mapTarget85); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget82, fieldTarget83); err != nil {
				return err
			}
		}
	}
	var var92 bool
	if len(m.Ms) == 0 {
		var92 = true
	}
	if var92 {
		if err := fieldsTarget1.ZeroField("Ms"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget90, fieldTarget91, err := fieldsTarget1.StartField("Ms")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget93, err := fieldTarget91.StartMap(tt.NonOptional().Field(11).Type, len(m.Ms))
			if err != nil {
				return err
			}
			for key95, value97 := range m.Ms {
				keyTarget94, err := mapTarget93.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget94.FromString(string(key95), tt.NonOptional().Field(11).Type.Key()); err != nil {
					return err
				}
				valueTarget96, err := mapTarget93.FinishKeyStartField(keyTarget94)
				if err != nil {
					return err
				}

				mapTarget98, err := valueTarget96.StartMap(tt.NonOptional().Field(11).Type.Elem(), len(value97))
				if err != nil {
					return err
				}
				for key100, value102 := range value97 {
					keyTarget99, err := mapTarget98.StartKey()
					if err != nil {
						return err
					}
					if err := keyTarget99.FromString(string(key100), tt.NonOptional().Field(11).Type.Elem().Key()); err != nil {
						return err
					}
					valueTarget101, err := mapTarget98.FinishKeyStartField(keyTarget99)
					if err != nil {
						return err
					}
					if err := valueTarget101.FromString(string(value102), tt.NonOptional().Field(11).Type.Elem().Elem()); err != nil {
						return err
					}
					if err := mapTarget98.FinishField(keyTarget99, valueTarget101); err != nil {
						return err
					}
				}
				if err := valueTarget96.FinishMap(mapTarget98); err != nil {
					return err
				}
				if err := mapTarget93.FinishField(keyTarget94, valueTarget96); err != nil {
					return err
				}
			}
			if err := fieldTarget91.FinishMap(mapTarget93); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget90, fieldTarget91); err != nil {
				return err
			}
		}
	}
	var var105 bool
	if len(m.T) == 0 {
		var105 = true
	}
	if var105 {
		if err := fieldsTarget1.ZeroField("T"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget103, fieldTarget104, err := fieldsTarget1.StartField("T")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			mapTarget106, err := fieldTarget104.StartMap(tt.NonOptional().Field(12).Type, len(m.T))
			if err != nil {
				return err
			}
			for key108, value110 := range m.T {
				keyTarget107, err := mapTarget106.StartKey()
				if err != nil {
					return err
				}

				var wireValue111 vdltime.Time
				if err := vdltime.TimeFromNative(&wireValue111, key108); err != nil {
					return err
				}

				if err := wireValue111.FillVDLTarget(keyTarget107, tt.NonOptional().Field(12).Type.Key()); err != nil {
					return err
				}
				valueTarget109, err := mapTarget106.FinishKeyStartField(keyTarget107)
				if err != nil {
					return err
				}
				if err := valueTarget109.FromString(string(value110), tt.NonOptional().Field(12).Type.Elem()); err != nil {
					return err
				}
				if err := mapTarget106.FinishField(keyTarget107, valueTarget109); err != nil {
					return err
				}
			}
			if err := fieldTarget104.FinishMap(mapTarget106); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget103, fieldTarget104); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ManyMaps) MakeVDLTarget() vdl.Target {
	return &ManyMapsTarget{Value: m}
}

type ManyMapsTarget struct {
	Value     *ManyMaps
	bTarget   __VDLTarget8_map
	byTarget  __VDLTarget9_map
	u16Target __VDLTarget10_map
	u32Target __VDLTarget11_map
	u64Target __VDLTarget12_map
	i16Target __VDLTarget13_map
	i32Target __VDLTarget14_map
	i64Target __VDLTarget15_map
	f32Target __VDLTarget16_map
	f64Target __VDLTarget17_map
	sTarget   __VDLTarget18_map
	msTarget  __VDLTarget19_map
	tTarget   __VDLTarget20_map
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ManyMapsTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ManyMaps)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ManyMapsTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "By":
		t.byTarget.Value = &t.Value.By
		target, err := &t.byTarget, error(nil)
		return nil, target, err
	case "U16":
		t.u16Target.Value = &t.Value.U16
		target, err := &t.u16Target, error(nil)
		return nil, target, err
	case "U32":
		t.u32Target.Value = &t.Value.U32
		target, err := &t.u32Target, error(nil)
		return nil, target, err
	case "U64":
		t.u64Target.Value = &t.Value.U64
		target, err := &t.u64Target, error(nil)
		return nil, target, err
	case "I16":
		t.i16Target.Value = &t.Value.I16
		target, err := &t.i16Target, error(nil)
		return nil, target, err
	case "I32":
		t.i32Target.Value = &t.Value.I32
		target, err := &t.i32Target, error(nil)
		return nil, target, err
	case "I64":
		t.i64Target.Value = &t.Value.I64
		target, err := &t.i64Target, error(nil)
		return nil, target, err
	case "F32":
		t.f32Target.Value = &t.Value.F32
		target, err := &t.f32Target, error(nil)
		return nil, target, err
	case "F64":
		t.f64Target.Value = &t.Value.F64
		target, err := &t.f64Target, error(nil)
		return nil, target, err
	case "S":
		t.sTarget.Value = &t.Value.S
		target, err := &t.sTarget, error(nil)
		return nil, target, err
	case "Ms":
		t.msTarget.Value = &t.Value.Ms
		target, err := &t.msTarget, error(nil)
		return nil, target, err
	case "T":
		t.tTarget.Value = &t.Value.T
		target, err := &t.tTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ManyMapsTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ManyMapsTarget) ZeroField(name string) error {
	switch name {
	case "B":
		t.Value.B = map[bool]string(nil)
		return nil
	case "By":
		t.Value.By = map[byte]string(nil)
		return nil
	case "U16":
		t.Value.U16 = map[uint16]string(nil)
		return nil
	case "U32":
		t.Value.U32 = map[uint32]string(nil)
		return nil
	case "U64":
		t.Value.U64 = map[uint64]string(nil)
		return nil
	case "I16":
		t.Value.I16 = map[int16]string(nil)
		return nil
	case "I32":
		t.Value.I32 = map[int32]string(nil)
		return nil
	case "I64":
		t.Value.I64 = map[int64]string(nil)
		return nil
	case "F32":
		t.Value.F32 = map[float32]string(nil)
		return nil
	case "F64":
		t.Value.F64 = map[float64]string(nil)
		return nil
	case "S":
		t.Value.S = map[string]string(nil)
		return nil
	case "Ms":
		t.Value.Ms = map[string]map[string]string(nil)
		return nil
	case "T":
		t.Value.T = map[time.Time]string(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ManyMapsTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[bool]string
type __VDLTarget8_map struct {
	Value      *map[bool]string
	currKey    bool
	currElem   string
	keyTarget  vdl.BoolTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget8_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[bool]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[bool]string)
	return t, nil
}
func (t *__VDLTarget8_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = false
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget8_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget8_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget8_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[byte]string
type __VDLTarget9_map struct {
	Value      *map[byte]string
	currKey    byte
	currElem   string
	keyTarget  vdl.ByteTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget9_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[byte]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[byte]string)
	return t, nil
}
func (t *__VDLTarget9_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = byte(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget9_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget9_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint16]string
type __VDLTarget10_map struct {
	Value      *map[uint16]string
	currKey    uint16
	currElem   string
	keyTarget  vdl.Uint16Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget10_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint16]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint16]string)
	return t, nil
}
func (t *__VDLTarget10_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget10_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget10_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget10_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint32]string
type __VDLTarget11_map struct {
	Value      *map[uint32]string
	currKey    uint32
	currElem   string
	keyTarget  vdl.Uint32Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget11_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint32]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint32]string)
	return t, nil
}
func (t *__VDLTarget11_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget11_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget11_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget11_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint64]string
type __VDLTarget12_map struct {
	Value      *map[uint64]string
	currKey    uint64
	currElem   string
	keyTarget  vdl.Uint64Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget12_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64]string)
	return t, nil
}
func (t *__VDLTarget12_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget12_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget12_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget12_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int16]string
type __VDLTarget13_map struct {
	Value      *map[int16]string
	currKey    int16
	currElem   string
	keyTarget  vdl.Int16Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget13_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int16]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int16]string)
	return t, nil
}
func (t *__VDLTarget13_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget13_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget13_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget13_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int32]string
type __VDLTarget14_map struct {
	Value      *map[int32]string
	currKey    int32
	currElem   string
	keyTarget  vdl.Int32Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget14_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int32]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int32]string)
	return t, nil
}
func (t *__VDLTarget14_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget14_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget14_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget14_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int64]string
type __VDLTarget15_map struct {
	Value      *map[int64]string
	currKey    int64
	currElem   string
	keyTarget  vdl.Int64Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget15_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[int64]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int64]string)
	return t, nil
}
func (t *__VDLTarget15_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget15_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget15_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget15_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[float32]string
type __VDLTarget16_map struct {
	Value      *map[float32]string
	currKey    float32
	currElem   string
	keyTarget  vdl.Float32Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget16_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[float32]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[float32]string)
	return t, nil
}
func (t *__VDLTarget16_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = float32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget16_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget16_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget16_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[float64]string
type __VDLTarget17_map struct {
	Value      *map[float64]string
	currKey    float64
	currElem   string
	keyTarget  vdl.Float64Target
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget17_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[float64]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[float64]string)
	return t, nil
}
func (t *__VDLTarget17_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget17_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget17_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget17_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[string]string
type __VDLTarget18_map struct {
	Value      *map[string]string
	currKey    string
	currElem   string
	keyTarget  vdl.StringTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget18_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]string)
	return t, nil
}
func (t *__VDLTarget18_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget18_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget18_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget18_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[string]map[string]string
type __VDLTarget19_map struct {
	Value      *map[string]map[string]string
	currKey    string
	currElem   map[string]string
	keyTarget  vdl.StringTarget
	elemTarget __VDLTarget18_map
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget19_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[string]map[string]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[string]map[string]string)
	return t, nil
}
func (t *__VDLTarget19_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget19_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = map[string]string(nil)
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget19_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget19_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[time.Time]string
type __VDLTarget20_map struct {
	Value      *map[time.Time]string
	currKey    time.Time
	currElem   string
	keyTarget  vdltime.TimeTarget
	elemTarget vdl.StringTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *__VDLTarget20_map) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*map[time.Time]string)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[time.Time]string)
	return t, nil
}
func (t *__VDLTarget20_map) StartKey() (key vdl.Target, _ error) {
	t.currKey = reflect.Zero(reflect.TypeOf(t.currKey)).Interface().(time.Time)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget20_map) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget20_map) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *__VDLTarget20_map) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x ManyMaps) VDLIsZero() bool {
	if len(x.B) != 0 {
		return false
	}
	if len(x.By) != 0 {
		return false
	}
	if len(x.U16) != 0 {
		return false
	}
	if len(x.U32) != 0 {
		return false
	}
	if len(x.U64) != 0 {
		return false
	}
	if len(x.I16) != 0 {
		return false
	}
	if len(x.I32) != 0 {
		return false
	}
	if len(x.I64) != 0 {
		return false
	}
	if len(x.F32) != 0 {
		return false
	}
	if len(x.F64) != 0 {
		return false
	}
	if len(x.S) != 0 {
		return false
	}
	if len(x.Ms) != 0 {
		return false
	}
	if len(x.T) != 0 {
		return false
	}
	return true
}

func (x ManyMaps) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ManyMaps)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.B) != 0 {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_8(enc, x.B); err != nil {
			return err
		}
	}
	if len(x.By) != 0 {
		if err := enc.NextField("By"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_9(enc, x.By); err != nil {
			return err
		}
	}
	if len(x.U16) != 0 {
		if err := enc.NextField("U16"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_10(enc, x.U16); err != nil {
			return err
		}
	}
	if len(x.U32) != 0 {
		if err := enc.NextField("U32"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_11(enc, x.U32); err != nil {
			return err
		}
	}
	if len(x.U64) != 0 {
		if err := enc.NextField("U64"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_12(enc, x.U64); err != nil {
			return err
		}
	}
	if len(x.I16) != 0 {
		if err := enc.NextField("I16"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_13(enc, x.I16); err != nil {
			return err
		}
	}
	if len(x.I32) != 0 {
		if err := enc.NextField("I32"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_14(enc, x.I32); err != nil {
			return err
		}
	}
	if len(x.I64) != 0 {
		if err := enc.NextField("I64"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_15(enc, x.I64); err != nil {
			return err
		}
	}
	if len(x.F32) != 0 {
		if err := enc.NextField("F32"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_16(enc, x.F32); err != nil {
			return err
		}
	}
	if len(x.F64) != 0 {
		if err := enc.NextField("F64"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_17(enc, x.F64); err != nil {
			return err
		}
	}
	if len(x.S) != 0 {
		if err := enc.NextField("S"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_18(enc, x.S); err != nil {
			return err
		}
	}
	if len(x.Ms) != 0 {
		if err := enc.NextField("Ms"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_19(enc, x.Ms); err != nil {
			return err
		}
	}
	if len(x.T) != 0 {
		if err := enc.NextField("T"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_20(enc, x.T); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_8(enc vdl.Encoder, x map[bool]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[bool]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_9(enc vdl.Encoder, x map[byte]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[byte]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_10(enc vdl.Encoder, x map[uint16]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[uint16]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint16Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_11(enc vdl.Encoder, x map[uint32]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[uint32]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_12(enc vdl.Encoder, x map[uint64]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[uint64]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_13(enc vdl.Encoder, x map[int16]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[int16]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_14(enc vdl.Encoder, x map[int32]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[int32]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int32Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_15(enc vdl.Encoder, x map[int64]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[int64]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_16(enc vdl.Encoder, x map[float32]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[float32]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float32Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(float64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_17(enc vdl.Encoder, x map[float64]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[float64]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_18(enc vdl.Encoder, x map[string]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_19(enc vdl.Encoder, x map[string]map[string]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[string]map[string]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
		if err := __VDLWriteAnon_map_18(enc, elem); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_map_20(enc vdl.Encoder, x map[time.Time]string) error {
	if err := enc.StartValue(vdl.TypeOf((*map[time.Time]string)(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key, elem := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, key); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(elem); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ManyMaps) VDLRead(dec vdl.Decoder) error {
	*x = ManyMaps{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "B":
			if err := __VDLReadAnon_map_8(dec, &x.B); err != nil {
				return err
			}
		case "By":
			if err := __VDLReadAnon_map_9(dec, &x.By); err != nil {
				return err
			}
		case "U16":
			if err := __VDLReadAnon_map_10(dec, &x.U16); err != nil {
				return err
			}
		case "U32":
			if err := __VDLReadAnon_map_11(dec, &x.U32); err != nil {
				return err
			}
		case "U64":
			if err := __VDLReadAnon_map_12(dec, &x.U64); err != nil {
				return err
			}
		case "I16":
			if err := __VDLReadAnon_map_13(dec, &x.I16); err != nil {
				return err
			}
		case "I32":
			if err := __VDLReadAnon_map_14(dec, &x.I32); err != nil {
				return err
			}
		case "I64":
			if err := __VDLReadAnon_map_15(dec, &x.I64); err != nil {
				return err
			}
		case "F32":
			if err := __VDLReadAnon_map_16(dec, &x.F32); err != nil {
				return err
			}
		case "F64":
			if err := __VDLReadAnon_map_17(dec, &x.F64); err != nil {
				return err
			}
		case "S":
			if err := __VDLReadAnon_map_18(dec, &x.S); err != nil {
				return err
			}
		case "Ms":
			if err := __VDLReadAnon_map_19(dec, &x.Ms); err != nil {
				return err
			}
		case "T":
			if err := __VDLReadAnon_map_20(dec, &x.T); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_map_8(dec vdl.Decoder, x *map[bool]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[bool]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[bool]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key bool
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[bool]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_9(dec vdl.Decoder, x *map[byte]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[byte]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[byte]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key byte
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			key = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[byte]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_10(dec vdl.Decoder, x *map[uint16]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[uint16]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint16]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint16
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			key = uint16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[uint16]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_11(dec vdl.Decoder, x *map[uint32]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[uint32]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint32]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			key = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[uint32]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_12(dec vdl.Decoder, x *map[uint64]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[uint64]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint64]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[uint64]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_13(dec vdl.Decoder, x *map[int16]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[int16]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int16]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int16
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			key = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[int16]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_14(dec vdl.Decoder, x *map[int32]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[int32]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int32]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			key = int32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[int32]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_15(dec vdl.Decoder, x *map[int64]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[int64]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int64]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[int64]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_16(dec vdl.Decoder, x *map[float32]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[float32]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float32]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key float32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			key = float32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[float32]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_17(dec vdl.Decoder, x *map[float64]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[float64]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float64]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key float64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[float64]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_18(dec vdl.Decoder, x *map[string]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_19(dec vdl.Decoder, x *map[string]map[string]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[string]map[string]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[string]map[string]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		var elem map[string]string
		{
			if err := __VDLReadAnon_map_18(dec, &elem); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[string]map[string]string)
		}
		tmpMap[key] = elem
	}
}

func __VDLReadAnon_map_20(dec vdl.Decoder, x *map[time.Time]string) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible map %T, from %v", *x, dec.Type())
	}
	var tmpMap map[time.Time]string
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[time.Time]string, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key time.Time
		{
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &key); err != nil {
				return err
			}
		}
		var elem string
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if elem, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[time.Time]string)
		}
		tmpMap[key] = elem
	}
}

type ManySets struct {
	B   map[bool]struct{}
	By  map[byte]struct{}
	U16 map[uint16]struct{}
	U32 map[uint32]struct{}
	U64 map[uint64]struct{}
	I16 map[int16]struct{}
	I32 map[int32]struct{}
	I64 map[int64]struct{}
	F32 map[float32]struct{}
	F64 map[float64]struct{}
	S   map[string]struct{}
	T   map[time.Time]struct{}
}

func (ManySets) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.ManySets"`
}) {
}

func (m *ManySets) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var var4 bool
	if len(m.B) == 0 {
		var4 = true
	}
	if var4 {
		if err := fieldsTarget1.ZeroField("B"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("B")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget5, err := fieldTarget3.StartSet(tt.NonOptional().Field(0).Type, len(m.B))
			if err != nil {
				return err
			}
			for key7 := range m.B {
				keyTarget6, err := setTarget5.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget6.FromBool(bool(key7), tt.NonOptional().Field(0).Type.Key()); err != nil {
					return err
				}
				if err := setTarget5.FinishKey(keyTarget6); err != nil {
					return err
				}
			}
			if err := fieldTarget3.FinishSet(setTarget5); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var var10 bool
	if len(m.By) == 0 {
		var10 = true
	}
	if var10 {
		if err := fieldsTarget1.ZeroField("By"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("By")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget11, err := fieldTarget9.StartSet(tt.NonOptional().Field(1).Type, len(m.By))
			if err != nil {
				return err
			}
			for key13 := range m.By {
				keyTarget12, err := setTarget11.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget12.FromUint(uint64(key13), tt.NonOptional().Field(1).Type.Key()); err != nil {
					return err
				}
				if err := setTarget11.FinishKey(keyTarget12); err != nil {
					return err
				}
			}
			if err := fieldTarget9.FinishSet(setTarget11); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var var16 bool
	if len(m.U16) == 0 {
		var16 = true
	}
	if var16 {
		if err := fieldsTarget1.ZeroField("U16"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("U16")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget17, err := fieldTarget15.StartSet(tt.NonOptional().Field(2).Type, len(m.U16))
			if err != nil {
				return err
			}
			for key19 := range m.U16 {
				keyTarget18, err := setTarget17.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget18.FromUint(uint64(key19), tt.NonOptional().Field(2).Type.Key()); err != nil {
					return err
				}
				if err := setTarget17.FinishKey(keyTarget18); err != nil {
					return err
				}
			}
			if err := fieldTarget15.FinishSet(setTarget17); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var var22 bool
	if len(m.U32) == 0 {
		var22 = true
	}
	if var22 {
		if err := fieldsTarget1.ZeroField("U32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("U32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget23, err := fieldTarget21.StartSet(tt.NonOptional().Field(3).Type, len(m.U32))
			if err != nil {
				return err
			}
			for key25 := range m.U32 {
				keyTarget24, err := setTarget23.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget24.FromUint(uint64(key25), tt.NonOptional().Field(3).Type.Key()); err != nil {
					return err
				}
				if err := setTarget23.FinishKey(keyTarget24); err != nil {
					return err
				}
			}
			if err := fieldTarget21.FinishSet(setTarget23); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
				return err
			}
		}
	}
	var var28 bool
	if len(m.U64) == 0 {
		var28 = true
	}
	if var28 {
		if err := fieldsTarget1.ZeroField("U64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("U64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget29, err := fieldTarget27.StartSet(tt.NonOptional().Field(4).Type, len(m.U64))
			if err != nil {
				return err
			}
			for key31 := range m.U64 {
				keyTarget30, err := setTarget29.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget30.FromUint(uint64(key31), tt.NonOptional().Field(4).Type.Key()); err != nil {
					return err
				}
				if err := setTarget29.FinishKey(keyTarget30); err != nil {
					return err
				}
			}
			if err := fieldTarget27.FinishSet(setTarget29); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
				return err
			}
		}
	}
	var var34 bool
	if len(m.I16) == 0 {
		var34 = true
	}
	if var34 {
		if err := fieldsTarget1.ZeroField("I16"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget32, fieldTarget33, err := fieldsTarget1.StartField("I16")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget35, err := fieldTarget33.StartSet(tt.NonOptional().Field(5).Type, len(m.I16))
			if err != nil {
				return err
			}
			for key37 := range m.I16 {
				keyTarget36, err := setTarget35.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget36.FromInt(int64(key37), tt.NonOptional().Field(5).Type.Key()); err != nil {
					return err
				}
				if err := setTarget35.FinishKey(keyTarget36); err != nil {
					return err
				}
			}
			if err := fieldTarget33.FinishSet(setTarget35); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget32, fieldTarget33); err != nil {
				return err
			}
		}
	}
	var var40 bool
	if len(m.I32) == 0 {
		var40 = true
	}
	if var40 {
		if err := fieldsTarget1.ZeroField("I32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget38, fieldTarget39, err := fieldsTarget1.StartField("I32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget41, err := fieldTarget39.StartSet(tt.NonOptional().Field(6).Type, len(m.I32))
			if err != nil {
				return err
			}
			for key43 := range m.I32 {
				keyTarget42, err := setTarget41.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget42.FromInt(int64(key43), tt.NonOptional().Field(6).Type.Key()); err != nil {
					return err
				}
				if err := setTarget41.FinishKey(keyTarget42); err != nil {
					return err
				}
			}
			if err := fieldTarget39.FinishSet(setTarget41); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget38, fieldTarget39); err != nil {
				return err
			}
		}
	}
	var var46 bool
	if len(m.I64) == 0 {
		var46 = true
	}
	if var46 {
		if err := fieldsTarget1.ZeroField("I64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget44, fieldTarget45, err := fieldsTarget1.StartField("I64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget47, err := fieldTarget45.StartSet(tt.NonOptional().Field(7).Type, len(m.I64))
			if err != nil {
				return err
			}
			for key49 := range m.I64 {
				keyTarget48, err := setTarget47.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget48.FromInt(int64(key49), tt.NonOptional().Field(7).Type.Key()); err != nil {
					return err
				}
				if err := setTarget47.FinishKey(keyTarget48); err != nil {
					return err
				}
			}
			if err := fieldTarget45.FinishSet(setTarget47); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget44, fieldTarget45); err != nil {
				return err
			}
		}
	}
	var var52 bool
	if len(m.F32) == 0 {
		var52 = true
	}
	if var52 {
		if err := fieldsTarget1.ZeroField("F32"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget50, fieldTarget51, err := fieldsTarget1.StartField("F32")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget53, err := fieldTarget51.StartSet(tt.NonOptional().Field(8).Type, len(m.F32))
			if err != nil {
				return err
			}
			for key55 := range m.F32 {
				keyTarget54, err := setTarget53.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget54.FromFloat(float64(key55), tt.NonOptional().Field(8).Type.Key()); err != nil {
					return err
				}
				if err := setTarget53.FinishKey(keyTarget54); err != nil {
					return err
				}
			}
			if err := fieldTarget51.FinishSet(setTarget53); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget50, fieldTarget51); err != nil {
				return err
			}
		}
	}
	var var58 bool
	if len(m.F64) == 0 {
		var58 = true
	}
	if var58 {
		if err := fieldsTarget1.ZeroField("F64"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget56, fieldTarget57, err := fieldsTarget1.StartField("F64")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget59, err := fieldTarget57.StartSet(tt.NonOptional().Field(9).Type, len(m.F64))
			if err != nil {
				return err
			}
			for key61 := range m.F64 {
				keyTarget60, err := setTarget59.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget60.FromFloat(float64(key61), tt.NonOptional().Field(9).Type.Key()); err != nil {
					return err
				}
				if err := setTarget59.FinishKey(keyTarget60); err != nil {
					return err
				}
			}
			if err := fieldTarget57.FinishSet(setTarget59); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget56, fieldTarget57); err != nil {
				return err
			}
		}
	}
	var var64 bool
	if len(m.S) == 0 {
		var64 = true
	}
	if var64 {
		if err := fieldsTarget1.ZeroField("S"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget62, fieldTarget63, err := fieldsTarget1.StartField("S")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget65, err := fieldTarget63.StartSet(tt.NonOptional().Field(10).Type, len(m.S))
			if err != nil {
				return err
			}
			for key67 := range m.S {
				keyTarget66, err := setTarget65.StartKey()
				if err != nil {
					return err
				}
				if err := keyTarget66.FromString(string(key67), tt.NonOptional().Field(10).Type.Key()); err != nil {
					return err
				}
				if err := setTarget65.FinishKey(keyTarget66); err != nil {
					return err
				}
			}
			if err := fieldTarget63.FinishSet(setTarget65); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget62, fieldTarget63); err != nil {
				return err
			}
		}
	}
	var var70 bool
	if len(m.T) == 0 {
		var70 = true
	}
	if var70 {
		if err := fieldsTarget1.ZeroField("T"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget68, fieldTarget69, err := fieldsTarget1.StartField("T")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			setTarget71, err := fieldTarget69.StartSet(tt.NonOptional().Field(11).Type, len(m.T))
			if err != nil {
				return err
			}
			for key73 := range m.T {
				keyTarget72, err := setTarget71.StartKey()
				if err != nil {
					return err
				}

				var wireValue74 vdltime.Time
				if err := vdltime.TimeFromNative(&wireValue74, key73); err != nil {
					return err
				}

				if err := wireValue74.FillVDLTarget(keyTarget72, tt.NonOptional().Field(11).Type.Key()); err != nil {
					return err
				}
				if err := setTarget71.FinishKey(keyTarget72); err != nil {
					return err
				}
			}
			if err := fieldTarget69.FinishSet(setTarget71); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget68, fieldTarget69); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *ManySets) MakeVDLTarget() vdl.Target {
	return &ManySetsTarget{Value: m}
}

type ManySetsTarget struct {
	Value     *ManySets
	bTarget   __VDLTarget21_set
	byTarget  __VDLTarget22_set
	u16Target __VDLTarget23_set
	u32Target __VDLTarget24_set
	u64Target __VDLTarget25_set
	i16Target __VDLTarget26_set
	i32Target __VDLTarget27_set
	i64Target __VDLTarget28_set
	f32Target __VDLTarget29_set
	f64Target __VDLTarget30_set
	sTarget   __VDLTarget7_set
	tTarget   __VDLTarget31_set
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ManySetsTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*ManySets)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ManySetsTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "B":
		t.bTarget.Value = &t.Value.B
		target, err := &t.bTarget, error(nil)
		return nil, target, err
	case "By":
		t.byTarget.Value = &t.Value.By
		target, err := &t.byTarget, error(nil)
		return nil, target, err
	case "U16":
		t.u16Target.Value = &t.Value.U16
		target, err := &t.u16Target, error(nil)
		return nil, target, err
	case "U32":
		t.u32Target.Value = &t.Value.U32
		target, err := &t.u32Target, error(nil)
		return nil, target, err
	case "U64":
		t.u64Target.Value = &t.Value.U64
		target, err := &t.u64Target, error(nil)
		return nil, target, err
	case "I16":
		t.i16Target.Value = &t.Value.I16
		target, err := &t.i16Target, error(nil)
		return nil, target, err
	case "I32":
		t.i32Target.Value = &t.Value.I32
		target, err := &t.i32Target, error(nil)
		return nil, target, err
	case "I64":
		t.i64Target.Value = &t.Value.I64
		target, err := &t.i64Target, error(nil)
		return nil, target, err
	case "F32":
		t.f32Target.Value = &t.Value.F32
		target, err := &t.f32Target, error(nil)
		return nil, target, err
	case "F64":
		t.f64Target.Value = &t.Value.F64
		target, err := &t.f64Target, error(nil)
		return nil, target, err
	case "S":
		t.sTarget.Value = &t.Value.S
		target, err := &t.sTarget, error(nil)
		return nil, target, err
	case "T":
		t.tTarget.Value = &t.Value.T
		target, err := &t.tTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *ManySetsTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ManySetsTarget) ZeroField(name string) error {
	switch name {
	case "B":
		t.Value.B = map[bool]struct{}(nil)
		return nil
	case "By":
		t.Value.By = map[byte]struct{}(nil)
		return nil
	case "U16":
		t.Value.U16 = map[uint16]struct{}(nil)
		return nil
	case "U32":
		t.Value.U32 = map[uint32]struct{}(nil)
		return nil
	case "U64":
		t.Value.U64 = map[uint64]struct{}(nil)
		return nil
	case "I16":
		t.Value.I16 = map[int16]struct{}(nil)
		return nil
	case "I32":
		t.Value.I32 = map[int32]struct{}(nil)
		return nil
	case "I64":
		t.Value.I64 = map[int64]struct{}(nil)
		return nil
	case "F32":
		t.Value.F32 = map[float32]struct{}(nil)
		return nil
	case "F64":
		t.Value.F64 = map[float64]struct{}(nil)
		return nil
	case "S":
		t.Value.S = map[string]struct{}(nil)
		return nil
	case "T":
		t.Value.T = map[time.Time]struct{}(nil)
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *ManySetsTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// map[bool]struct{}
type __VDLTarget21_set struct {
	Value     *map[bool]struct{}
	currKey   bool
	keyTarget vdl.BoolTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget21_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[bool]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[bool]struct{})
	return t, nil
}
func (t *__VDLTarget21_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = false
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget21_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget21_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[byte]struct{}
type __VDLTarget22_set struct {
	Value     *map[byte]struct{}
	currKey   byte
	keyTarget vdl.ByteTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget22_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[byte]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[byte]struct{})
	return t, nil
}
func (t *__VDLTarget22_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = byte(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget22_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget22_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint16]struct{}
type __VDLTarget23_set struct {
	Value     *map[uint16]struct{}
	currKey   uint16
	keyTarget vdl.Uint16Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget23_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint16]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint16]struct{})
	return t, nil
}
func (t *__VDLTarget23_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget23_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget23_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint32]struct{}
type __VDLTarget24_set struct {
	Value     *map[uint32]struct{}
	currKey   uint32
	keyTarget vdl.Uint32Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget24_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint32]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint32]struct{})
	return t, nil
}
func (t *__VDLTarget24_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget24_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget24_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[uint64]struct{}
type __VDLTarget25_set struct {
	Value     *map[uint64]struct{}
	currKey   uint64
	keyTarget vdl.Uint64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget25_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[uint64]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[uint64]struct{})
	return t, nil
}
func (t *__VDLTarget25_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = uint64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget25_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget25_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int16]struct{}
type __VDLTarget26_set struct {
	Value     *map[int16]struct{}
	currKey   int16
	keyTarget vdl.Int16Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget26_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[int16]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int16]struct{})
	return t, nil
}
func (t *__VDLTarget26_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = int16(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget26_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget26_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int32]struct{}
type __VDLTarget27_set struct {
	Value     *map[int32]struct{}
	currKey   int32
	keyTarget vdl.Int32Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget27_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[int32]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int32]struct{})
	return t, nil
}
func (t *__VDLTarget27_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = int32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget27_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget27_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[int64]struct{}
type __VDLTarget28_set struct {
	Value     *map[int64]struct{}
	currKey   int64
	keyTarget vdl.Int64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget28_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[int64]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[int64]struct{})
	return t, nil
}
func (t *__VDLTarget28_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = int64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget28_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget28_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[float32]struct{}
type __VDLTarget29_set struct {
	Value     *map[float32]struct{}
	currKey   float32
	keyTarget vdl.Float32Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget29_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[float32]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[float32]struct{})
	return t, nil
}
func (t *__VDLTarget29_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = float32(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget29_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget29_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[float64]struct{}
type __VDLTarget30_set struct {
	Value     *map[float64]struct{}
	currKey   float64
	keyTarget vdl.Float64Target
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget30_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[float64]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[float64]struct{})
	return t, nil
}
func (t *__VDLTarget30_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = float64(0)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget30_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget30_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// map[time.Time]struct{}
type __VDLTarget31_set struct {
	Value     *map[time.Time]struct{}
	currKey   time.Time
	keyTarget vdltime.TimeTarget
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *__VDLTarget31_set) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {

	if ttWant := vdl.TypeOf((*map[time.Time]struct{})(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(map[time.Time]struct{})
	return t, nil
}
func (t *__VDLTarget31_set) StartKey() (key vdl.Target, _ error) {
	t.currKey = reflect.Zero(reflect.TypeOf(t.currKey)).Interface().(time.Time)
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *__VDLTarget31_set) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *__VDLTarget31_set) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

func (x ManySets) VDLIsZero() bool {
	if len(x.B) != 0 {
		return false
	}
	if len(x.By) != 0 {
		return false
	}
	if len(x.U16) != 0 {
		return false
	}
	if len(x.U32) != 0 {
		return false
	}
	if len(x.U64) != 0 {
		return false
	}
	if len(x.I16) != 0 {
		return false
	}
	if len(x.I32) != 0 {
		return false
	}
	if len(x.I64) != 0 {
		return false
	}
	if len(x.F32) != 0 {
		return false
	}
	if len(x.F64) != 0 {
		return false
	}
	if len(x.S) != 0 {
		return false
	}
	if len(x.T) != 0 {
		return false
	}
	return true
}

func (x ManySets) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*ManySets)(nil)).Elem()); err != nil {
		return err
	}
	if len(x.B) != 0 {
		if err := enc.NextField("B"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_21(enc, x.B); err != nil {
			return err
		}
	}
	if len(x.By) != 0 {
		if err := enc.NextField("By"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_22(enc, x.By); err != nil {
			return err
		}
	}
	if len(x.U16) != 0 {
		if err := enc.NextField("U16"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_23(enc, x.U16); err != nil {
			return err
		}
	}
	if len(x.U32) != 0 {
		if err := enc.NextField("U32"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_24(enc, x.U32); err != nil {
			return err
		}
	}
	if len(x.U64) != 0 {
		if err := enc.NextField("U64"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_25(enc, x.U64); err != nil {
			return err
		}
	}
	if len(x.I16) != 0 {
		if err := enc.NextField("I16"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_26(enc, x.I16); err != nil {
			return err
		}
	}
	if len(x.I32) != 0 {
		if err := enc.NextField("I32"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_27(enc, x.I32); err != nil {
			return err
		}
	}
	if len(x.I64) != 0 {
		if err := enc.NextField("I64"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_28(enc, x.I64); err != nil {
			return err
		}
	}
	if len(x.F32) != 0 {
		if err := enc.NextField("F32"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_29(enc, x.F32); err != nil {
			return err
		}
	}
	if len(x.F64) != 0 {
		if err := enc.NextField("F64"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_30(enc, x.F64); err != nil {
			return err
		}
	}
	if len(x.S) != 0 {
		if err := enc.NextField("S"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_7(enc, x.S); err != nil {
			return err
		}
	}
	if len(x.T) != 0 {
		if err := enc.NextField("T"); err != nil {
			return err
		}
		if err := __VDLWriteAnon_set_31(enc, x.T); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_21(enc vdl.Encoder, x map[bool]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[bool]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.BoolType); err != nil {
			return err
		}
		if err := enc.EncodeBool(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_22(enc vdl.Encoder, x map[byte]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[byte]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.ByteType); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_23(enc vdl.Encoder, x map[uint16]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[uint16]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint16Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_24(enc vdl.Encoder, x map[uint32]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[uint32]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint32Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(uint64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_25(enc vdl.Encoder, x map[uint64]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[uint64]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Uint64Type); err != nil {
			return err
		}
		if err := enc.EncodeUint(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_26(enc vdl.Encoder, x map[int16]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[int16]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int16Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_27(enc vdl.Encoder, x map[int32]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[int32]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int32Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(int64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_28(enc vdl.Encoder, x map[int64]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[int64]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Int64Type); err != nil {
			return err
		}
		if err := enc.EncodeInt(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_29(enc vdl.Encoder, x map[float32]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[float32]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float32Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(float64(key)); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_30(enc vdl.Encoder, x map[float64]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[float64]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.Float64Type); err != nil {
			return err
		}
		if err := enc.EncodeFloat(key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func __VDLWriteAnon_set_31(enc vdl.Encoder, x map[time.Time]struct{}) error {
	if err := enc.StartValue(vdl.TypeOf((*map[time.Time]struct{})(nil))); err != nil {
		return err
	}
	if err := enc.SetLenHint(len(x)); err != nil {
		return err
	}
	for key := range x {
		if err := enc.NextEntry(false); err != nil {
			return err
		}
		var wire vdltime.Time
		if err := vdltime.TimeFromNative(&wire, key); err != nil {
			return err
		}
		if err := wire.VDLWrite(enc); err != nil {
			return err
		}
	}
	if err := enc.NextEntry(true); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *ManySets) VDLRead(dec vdl.Decoder) error {
	*x = ManySets{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "B":
			if err := __VDLReadAnon_set_21(dec, &x.B); err != nil {
				return err
			}
		case "By":
			if err := __VDLReadAnon_set_22(dec, &x.By); err != nil {
				return err
			}
		case "U16":
			if err := __VDLReadAnon_set_23(dec, &x.U16); err != nil {
				return err
			}
		case "U32":
			if err := __VDLReadAnon_set_24(dec, &x.U32); err != nil {
				return err
			}
		case "U64":
			if err := __VDLReadAnon_set_25(dec, &x.U64); err != nil {
				return err
			}
		case "I16":
			if err := __VDLReadAnon_set_26(dec, &x.I16); err != nil {
				return err
			}
		case "I32":
			if err := __VDLReadAnon_set_27(dec, &x.I32); err != nil {
				return err
			}
		case "I64":
			if err := __VDLReadAnon_set_28(dec, &x.I64); err != nil {
				return err
			}
		case "F32":
			if err := __VDLReadAnon_set_29(dec, &x.F32); err != nil {
				return err
			}
		case "F64":
			if err := __VDLReadAnon_set_30(dec, &x.F64); err != nil {
				return err
			}
		case "S":
			if err := __VDLReadAnon_set_7(dec, &x.S); err != nil {
				return err
			}
		case "T":
			if err := __VDLReadAnon_set_31(dec, &x.T); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLReadAnon_set_21(dec vdl.Decoder, x *map[bool]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[bool]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[bool]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key bool
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeBool(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[bool]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_set_22(dec vdl.Decoder, x *map[byte]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[byte]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[byte]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key byte
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(8)
			if err != nil {
				return err
			}
			key = byte(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[byte]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_set_23(dec vdl.Decoder, x *map[uint16]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[uint16]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint16]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint16
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(16)
			if err != nil {
				return err
			}
			key = uint16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[uint16]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_set_24(dec vdl.Decoder, x *map[uint32]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[uint32]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint32]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeUint(32)
			if err != nil {
				return err
			}
			key = uint32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[uint32]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_set_25(dec vdl.Decoder, x *map[uint64]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[uint64]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[uint64]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key uint64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeUint(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[uint64]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_set_26(dec vdl.Decoder, x *map[int16]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[int16]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int16]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int16
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(16)
			if err != nil {
				return err
			}
			key = int16(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[int16]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_set_27(dec vdl.Decoder, x *map[int32]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[int32]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int32]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeInt(32)
			if err != nil {
				return err
			}
			key = int32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[int32]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_set_28(dec vdl.Decoder, x *map[int64]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[int64]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[int64]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key int64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeInt(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[int64]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_set_29(dec vdl.Decoder, x *map[float32]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[float32]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float32]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key float32
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			tmp, err := dec.DecodeFloat(32)
			if err != nil {
				return err
			}
			key = float32(tmp)
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[float32]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_set_30(dec vdl.Decoder, x *map[float64]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[float64]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[float64]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key float64
		{
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if key, err = dec.DecodeFloat(64); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[float64]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

func __VDLReadAnon_set_31(dec vdl.Decoder, x *map[time.Time]struct{}) error {
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible set %T, from %v", *x, dec.Type())
	}
	var tmpMap map[time.Time]struct{}
	if len := dec.LenHint(); len > 0 {
		tmpMap = make(map[time.Time]struct{}, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			*x = tmpMap
			return dec.FinishValue()
		}
		var key time.Time
		{
			var wire vdltime.Time
			if err := wire.VDLRead(dec); err != nil {
				return err
			}
			if err := vdltime.TimeToNative(wire, &key); err != nil {
				return err
			}
		}
		if tmpMap == nil {
			tmpMap = make(map[time.Time]struct{})
		}
		tmpMap[key] = struct{}{}
	}
}

type BigData struct {
	Key string // A dup of the key stored in the value.
}

func (BigData) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/query/engine/internal/testdata.BigData"`
}) {
}

func (m *BigData) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Key == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Key"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Key")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Key), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *BigData) MakeVDLTarget() vdl.Target {
	return &BigDataTarget{Value: m}
}

type BigDataTarget struct {
	Value     *BigData
	keyTarget vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *BigDataTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*BigData)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *BigDataTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Key":
		t.keyTarget.Value = &t.Value.Key
		target, err := &t.keyTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, vdl.ErrFieldNoExist
	}
}
func (t *BigDataTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *BigDataTarget) ZeroField(name string) error {
	switch name {
	case "Key":
		t.Value.Key = ""
		return nil
	default:
		return vdl.ErrFieldNoExist
	}
}
func (t *BigDataTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x BigData) VDLIsZero() bool {
	return x == BigData{}
}

func (x BigData) VDLWrite(enc vdl.Encoder) error {
	if err := enc.StartValue(vdl.TypeOf((*BigData)(nil)).Elem()); err != nil {
		return err
	}
	if x.Key != "" {
		if err := enc.NextField("Key"); err != nil {
			return err
		}
		if err := enc.StartValue(vdl.StringType); err != nil {
			return err
		}
		if err := enc.EncodeString(x.Key); err != nil {
			return err
		}
		if err := enc.FinishValue(); err != nil {
			return err
		}
	}
	if err := enc.NextField(""); err != nil {
		return err
	}
	return enc.FinishValue()
}

func (x *BigData) VDLRead(dec vdl.Decoder) error {
	*x = BigData{}
	if err := dec.StartValue(); err != nil {
		return err
	}
	if (dec.StackDepth() == 1 || dec.IsAny()) && !vdl.Compatible(vdl.TypeOf(*x), dec.Type()) {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Key":
			if err := dec.StartValue(); err != nil {
				return err
			}
			var err error
			if x.Key, err = dec.DecodeString(); err != nil {
				return err
			}
			if err := dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err := dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*AddressInfo)(nil))
	vdl.Register((*CreditAgency)(nil))
	vdl.Register((*ExperianRating)(nil))
	vdl.Register((*RatingsArray)(nil))
	vdl.Register((*EquifaxCreditReport)(nil))
	vdl.Register((*Tdh)(nil))
	vdl.Register((*ExperianCreditReport)(nil))
	vdl.Register((*TransUnionCreditReport)(nil))
	vdl.Register((*AgencyReport)(nil))
	vdl.Register((*CreditReport)(nil))
	vdl.Register((*Customer)(nil))
	vdl.Register((*Invoice)(nil))
	vdl.Register((*Numbers)(nil))
	vdl.Register((*TitleOrValueType)(nil))
	vdl.Register((*BazType)(nil))
	vdl.Register((*BarType)(nil))
	vdl.Register((*FooType)(nil))
	vdl.Register((*K)(nil))
	vdl.Register((*V)(nil))
	vdl.Register((*FunWithMaps)(nil))
	vdl.Register((*FunWithTypes)(nil))
	vdl.Register((*ManyMaps)(nil))
	vdl.Register((*ManySets)(nil))
	vdl.Register((*BigData)(nil))

	return struct{}{}
}
