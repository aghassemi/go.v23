// Yacc grammar file for the Veyron Query Language.
//
// See https://go/vql for a detailed description of the language.
//
// To generate the grammar.go source file containing the parser, run the
// following command.  It'll also generate a grammar.debug file containing a
// list of all states produced for the parser, and some stats.
//   go tool yacc -o grammar.go -v grammar.debug grammar.y && go fmt grammar.go && cat debugheader.txt grammar.debug > /tmp/grammar.debug && mv /tmp/grammar.debug ./

////////////////////////////////////////////////////////////////////////
// Declarations section.
%{
// This grammar.go file was auto-generated by yacc from grammar.y.

package parse

import (
  "fmt"
  "math/big"
  "strings"

  "veyron2/naming"
)

type strPos struct {
  str string
  pos Pos
}

func (s strPos) String() string {
	return fmt.Sprintf("{str:%s pos:%s}", s.str, s.pos)
}

type intPos struct {
  int *big.Int
  pos Pos
}

func (i intPos) String() string {
	return fmt.Sprintf("{int:%s pos:%s}", i.int, i.pos)
}

type ratPos struct {
  rat *big.Rat
  pos Pos
}

func (r ratPos) String() string {
	return fmt.Sprintf("{rat:%s pos:%s}", r.rat, r.pos)
}

func (y yySymType) String() string {
	return fmt.Sprintf("{yys:%d pos:%s strpos:%s intpos:%s ratpos:%s pipeline:%s WildcardName:%s pred:%s expr:%s}",
                     y.yys, y.pos, y.strpos, y.intpos, y.ratpos, y.pipeline, y.wildcardname, y.pred, y.expr)
}

func newWildcardName(name strPos, yylex yyLexer) *WildcardName {
  if strings.Index(name.str, "/") == 0 {
    lexAbort(yylex, "Names must be relative.  Found leading '/'")
    return &WildcardName{}
  }
  parts := strings.Split(name.str, "/")
  if len(parts) == 0  || (len(parts) == 1 && parts[0] == "") {
    lexAbort(yylex, "Must provide a name, an expansion ('.', '*') or both")
    return &WildcardName{}
  }
  var clean []string
  for i, c := range parts {
    switch c {
    case "", ".":
      // Do nothing.
    case "*":
      if i != len(parts) - 1 {
        lexAbort(yylex, fmt.Sprintf("'%s' is supported only as the last component", c))
        return &WildcardName{}
      } else {
        clean = append(clean, c)
      }
    default:
      clean = append(clean, c)
    }
  }
  if len(clean) > 0 && clean[len(clean)-1] == "*" {
    return &WildcardName{joinPath(clean[:len(clean)-1]), Star, name.pos}
  }
  return &WildcardName{joinPath(clean), Self, name.pos}
}

// joinPath uses naming.Join to combine an array of path parts into one.
// We don't use path.Join because that version strips out ".." which does
// not have a special meaning in Veyron.
func joinPath(parts []string) string {
  path := ""
  for _, p := range parts {
    path = naming.Join(path, p)
  }
  return path
}

%}

// This union is turned into the struct type yySymType.  Most symbols include
// positional information; this is necessary since Go yacc doesn't support
// passing positional information, so we need to track it ourselves.
%union {
  pos          Pos
  strpos       strPos
  intpos       intPos
  ratpos       ratPos
  pipeline     Pipeline
  wildcardname *WildcardName
  pred         Predicate
  expr         Expr
  exprlist     []Expr
  alias        Alias
  aliaslist    []Alias
}

// Terminal tokens.  We leave single-char tokens as-is using their ascii code as
// their id, to make the grammar more readable; multi-char tokens get their own
// id.
//
// The value in <> specifies the field in %union to be used for the token or
// type.  For example:
//   %token <strpos> tIDENT
// Tokens of type tIDENT will be of type strPos and can be referenced with the
// $N variables.  For example:
//   vname:
//     tIDENT { fmt.Printf("Found identifier %s at %s\n", $1.str, $1.pos) }
//
// %type rules are similar to %token rules.  They are used for the LHS of
// productions.  The name in <> is substituted for $$ in all productions
// for that type.  For example:
//   %type <strpos> vname
//   vname:
//     tIDENT  // The default rule is { $$ = $1 }
//   | vname '/' tIDENT
//     { $$ = strPos{naming.Join($1.str, $3.str), $1.pos} }

%token <pos> '.' '{' '}' '$' '!' '(' ')' '=' '<' '>' '*' '/' ':' '?' '&' '|'
%token <pos> '-' '+'
%token <pos> tOROR tANDAND tLE tGE tNE tEQEQ
%token <pos> tTRUE tFALSE tTYPE tAS tHIDDEN
%token <strpos> tIDENT tSTRLIT
%token <intpos> tINTLIT
%token <ratpos> tRATLIT

%type <pipeline> pipeline
%type <wildcardname> wildcard_name
%type <strpos> type_filter
%type <pred> predicate
%type <expr> expr
%type <exprlist> expr_list
%type <strpos> vname
%type <alias> alias
%type <aliaslist> alias_list

%left tOROR
%left tANDAND
%right '!'

%start start

%%
////////////////////////////////////////////////////////////////////////
// Rules section.

start:
  pipeline
  { lexASTResult(yylex, $1) }  // Store the result in the lexer.

pipeline:
  wildcard_name
  { $$ = &PipelineName{$1, $1.Pos} }
| pipeline '|' type_filter
  { $$ = &PipelineType{$1, $3.str, $2} }
| type_filter
  {
    lexAbort(yylex, "'type' cannot start a pipeline")
  }
| pipeline '|' '?' predicate
  { $$ = &PipelineFilter{$1, $4, $2} }
| pipeline '|' '{' alias_list '}'
  { $$ = &PipelineSelection{$1, $4, $2} }
| pipeline '|' tIDENT '(' expr_list ')'
  { $$ = &PipelineFunc{$1, $3.str, $5, $2} }
| pipeline '|' tIDENT
  { $$ = &PipelineFunc{$1, $3.str, nil, $2} }
| pipeline '|' tIDENT '(' ')'
  { $$ = &PipelineFunc{$1, $3.str, nil, $2} }


wildcard_name:
  tSTRLIT
  { $$ = newWildcardName($1, yylex) }
| tIDENT '/' '*'
  { $$ = &WildcardName{$1.str, Star, $1.pos} }
| tIDENT '/' '.'
  { $$ = &WildcardName{$1.str, Self, $1.pos} }
| tIDENT
  { $$ = &WildcardName{$1.str, Self, $1.pos} }
| '.'
  { $$ = &WildcardName{"", Self, $1} }
| '*'
  { $$ = &WildcardName{"", Star, $1} }
| tIDENT '/' tIDENT
  {
    lexAbort(yylex, "Found '/'.  Multi-component names must be passed as string literals")
    $$ = &WildcardName{}  // Avoid nil pointer dereference in pipeline.
  }
| tIDENT '/' '.' '/'
  {
    lexAbort(yylex, "Found '/'.  Multi-component names must be passed as string literals")
    $$ = &WildcardName{}  // Avoid nil pointer dereference in pipeline.
  }
| tIDENT '/' '*' '/'
  {
    lexAbort(yylex, "'*' is supported only as the last component of a name")
    $$ = &WildcardName{}  // Avoid nil pointer dereference in pipeline.
  }
| tIDENT '/'
  {
    lexAbort(yylex, "Found spurious trailing '/'")
    $$ = &WildcardName{}  // Avoid nil pointer dereference in pipeline.
  }
| '.' '/'
  {
    lexAbort(yylex, "Found '/'.  Multi-component names must be passed as string literals")
    $$ = &WildcardName{}  // Avoid nil pointer dereference in pipeline.
  }
| '*' '/'
  {
    lexAbort(yylex, "'...' is supported only as the last component of a name")
    $$ = &WildcardName{}  // Avoid nil pointer dereference in pipeline.
  }
| '/'
  {
    lexAbort(yylex, "Names must be relative.  Found leading '/'")
    $$ = &WildcardName{}  // Avoid nil pointer dereference in pipeline.
  }

type_filter:
  tTYPE tIDENT
  { $$ = $2 }
| tTYPE tSTRLIT
  { $$ = $2 }

predicate:
  tTRUE
  { $$ = &PredicateBool{true, $1} }
| tFALSE
  { $$ = &PredicateBool{false, $1} }
| '(' predicate ')'
  { $$ = $2 }
| expr '=' expr
  { $$ = &PredicateCompare{$1, $3, CompEQ, $2} }
| expr tEQEQ expr
  { $$ = &PredicateCompare{$1, $3, CompEQ, $2} }
| expr tNE expr
  { $$ = &PredicateCompare{$1, $3, CompNE, $2} }
| expr '<' expr
  { $$ = &PredicateCompare{$1, $3, CompLT, $2} }
| expr tLE expr
  { $$ = &PredicateCompare{$1, $3, CompLE, $2} }
| expr '>' expr
  { $$ = &PredicateCompare{$1, $3, CompGT, $2} }
| expr tGE expr
  { $$ = &PredicateCompare{$1, $3, CompGE, $2} }
| predicate tANDAND predicate
  { $$ = &PredicateAnd{$1, $3, $2} }
| predicate tOROR predicate
  { $$ = &PredicateOr{$1, $3, $2} }
| '!' predicate
  { $$ = &PredicateNot{$2, $1} }
| tIDENT '(' expr_list ')'
  { $$ = &PredicateFunc{$1.str, $3, $1.pos} }

expr:
  tSTRLIT
  { $$ = &ExprString{$1.str, $1.pos} }
| tRATLIT
  { $$ = &ExprRat{$1.rat, $1.pos} }
| tINTLIT
  { $$ = &ExprInt{$1.int, $1.pos} }
| vname
  { $$ = &ExprName{$1.str, $1.pos} }
| '/' tSTRLIT
  { $$ = &ExprName{$2.str, $1} }
| tIDENT '(' expr_list ')'
  { $$ = &ExprFunc{$1.str, $3, $1.pos} }
| '-' expr
  { $$ = &ExprUnary{$2, OpNeg, $1} }
| '+' expr
  { $$ = &ExprUnary{$2, OpPos, $1} }

expr_list:
  expr
  { $$ = []Expr{$1} }
| expr_list ',' expr
  { $$ = append($1, $3) }

// TODO(kash): Expressions can have multi-component paths, but WildcardNames
// have to be quoted.  Resolve this.
vname:
  tIDENT
| vname '/' tIDENT
  { $$ = strPos{naming.Join($1.str, $3.str), $1.pos} }

alias_list:
  alias
  { $$ = []Alias{$1}}
| alias_list ',' alias
  {  $$ = append($1, $3) }

alias:
  pipeline
  { $$ = Alias{$1, "", false} }
| pipeline tAS tIDENT
  { $$ = Alias{$1, $3.str, false}}
| pipeline tAS tSTRLIT
  { $$ = Alias{$1, $3.str, false}}
| pipeline tAS tIDENT tHIDDEN
  { $$ = Alias{$1, $3.str, true}}
| pipeline tAS tSTRLIT tHIDDEN
  { $$ = Alias{$1, $3.str, true}}
