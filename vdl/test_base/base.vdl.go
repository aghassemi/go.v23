// This file was auto-generated by the veyron vdl tool.
// Source: base.vdl

// Package test_base is a simple single-file test of vdl functionality.
package test_base

import (
	// The non-user imports are prefixed with "_gen_" to prevent collisions.
	_gen_io "io"
	_gen_veyron2 "veyron.io/veyron/veyron2"
	_gen_context "veyron.io/veyron/veyron2/context"
	_gen_ipc "veyron.io/veyron/veyron2/ipc"
	_gen_naming "veyron.io/veyron/veyron2/naming"
	_gen_vdl "veyron.io/veyron/veyron2/vdl"
	_gen_vdlutil "veyron.io/veyron/veyron2/vdl/vdlutil"
	_gen_verror "veyron.io/veyron/veyron2/verror"
	_gen_wiretype "veyron.io/veyron/veyron2/wiretype"
)

type NamedBool bool

type NamedByte byte

type NamedUint16 uint16

type NamedUint32 uint32

type NamedUint64 uint64

type NamedInt16 int16

type NamedInt32 int32

type NamedInt64 int64

type NamedFloat32 float32

type NamedFloat64 float64

type NamedComplex64 complex64

type NamedComplex128 complex128

type NamedString string

//NamedEnum       enum{A;B;C}
type NamedArray [2]bool

type NamedList []uint32

type NamedSet map[string]struct{}

type NamedMap map[string]float32

type NamedStruct struct {
	A bool
	B string
	C int32
}

type Scalars struct {
	A0  bool
	A1  byte
	A2  uint16
	A3  uint32
	A4  uint64
	A5  int16
	A6  int32
	A7  int64
	A8  float32
	A9  float64
	A10 complex64
	A11 complex128
	A12 string
	A13 error
	A14 _gen_vdlutil.Any
	A15 *_gen_vdl.Type
	B0  NamedBool
	B1  NamedByte
	B2  NamedUint16
	B3  NamedUint32
	B4  NamedUint64
	B5  NamedInt16
	B6  NamedInt32
	B7  NamedInt64
	B8  NamedFloat32
	B9  NamedFloat64
	B10 NamedComplex64
	B11 NamedComplex128
	B12 NamedString
}

type Composites struct {
	A0 Scalars
	A1 [2]Scalars
	A2 []Scalars
	A3 map[Scalars]struct{}
	A4 map[string]Scalars
	A5 map[Scalars][]map[string]complex128
}

type CompComp struct {
	A0 Composites
	A1 [2]Composites
	A2 []Composites
	A3 map[string]Composites
	A4 map[Scalars][]map[string]Composites
}

// NestedArgs is defined before Args; that's allowed in regular Go, and also
// allowed in our vdl files.  The compiler will re-order dependent types to ease
// code generation in other languages.
type NestedArgs struct {
	Args Args
}

// Args will be reordered to show up before NestedArgs in the generated output.
type Args struct {
	A int32
	B int32
}

const Cbool = true

const Cbyte = byte(1)

const Cint32 = int32(2)

const Cint64 = int64(3)

const Cuint32 = uint32(4)

const Cuint64 = uint64(5)

const Cfloat32 = float32(6)

const Cfloat64 = float64(7)

const Ccomplex64 = complex64(8 + 9i)

const Ccomplex128 = complex128(10 + 11i)

const Cstring = "foo"

const True = true

const Foo = "foo"

const Five = int32(5)

const Six = uint64(6)

const SixSquared = uint64(36)

const FiveSquared = int32(25)

// TODO(bprosnitz) Remove this line once signatures are updated to use typevals.
// It corrects a bug where _gen_wiretype is unused in VDL pacakges where only bootstrap types are used on interfaces.
const _ = _gen_wiretype.TypeIDInvalid

const ErrIDFoo = _gen_verror.ID("veyron.io/veyron/veyron2/vdl/test_base.ErrIDFoo")

const ErrIDBar = _gen_verror.ID("some/path.ErrIdOther")

// ServiceA is the interface the client binds and uses.
// ServiceA_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type ServiceA_ExcludingUniversal interface {
	MethodA1(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (err error)
	MethodA2(ctx _gen_context.T, a int32, b string, opts ..._gen_ipc.CallOpt) (reply string, err error)
	MethodA3(ctx _gen_context.T, a int32, opts ..._gen_ipc.CallOpt) (reply ServiceAMethodA3Call, err error)
	MethodA4(ctx _gen_context.T, a int32, opts ..._gen_ipc.CallOpt) (reply ServiceAMethodA4Call, err error)
}
type ServiceA interface {
	_gen_ipc.UniversalServiceMethods
	ServiceA_ExcludingUniversal
}

// ServiceAService is the interface the server implements.
type ServiceAService interface {
	MethodA1(context _gen_ipc.ServerContext) (err error)
	MethodA2(context _gen_ipc.ServerContext, a int32, b string) (reply string, err error)
	MethodA3(context _gen_ipc.ServerContext, a int32, stream ServiceAServiceMethodA3Stream) (reply string, err error)
	MethodA4(context _gen_ipc.ServerContext, a int32, stream ServiceAServiceMethodA4Stream) (err error)
}

// ServiceAMethodA3Call is the interface for call object of the method
// MethodA3 in the service interface ServiceA.
type ServiceAMethodA3Call interface {
	// RecvStream returns the recv portion of the stream
	RecvStream() interface {
		// Advance stages an element so the client can retrieve it
		// with Value.  Advance returns true iff there is an
		// element to retrieve.  The client must call Advance before
		// calling Value. Advance may block if an element is not
		// immediately available.
		Advance() bool

		// Value returns the element that was staged by Advance.
		// Value may panic if Advance returned false or was not
		// called at all.  Value does not block.
		Value() Scalars

		// Err returns a non-nil error iff the stream encountered
		// any errors.  Err does not block.
		Err() error
	}

	// Finish blocks until the server is done and returns the positional
	// return values for call.
	//
	// If Cancel has been called, Finish will return immediately; the output of
	// Finish could either be an error signalling cancelation, or the correct
	// positional return values from the server depending on the timing of the
	// call.
	//
	// Calling Finish is mandatory for releasing stream resources, unless Cancel
	// has been called or any of the other methods return an error.
	// Finish should be called at most once.
	Finish() (reply string, err error)

	// Cancel cancels the RPC, notifying the server to stop processing.  It
	// is safe to call Cancel concurrently with any of the other stream methods.
	// Calling Cancel after Finish has returned is a no-op.
	Cancel()
}

type implServiceAMethodA3StreamIterator struct {
	clientCall _gen_ipc.Call
	val        Scalars
	err        error
}

func (c *implServiceAMethodA3StreamIterator) Advance() bool {
	c.val = Scalars{}
	c.err = c.clientCall.Recv(&c.val)
	return c.err == nil
}

func (c *implServiceAMethodA3StreamIterator) Value() Scalars {
	return c.val
}

func (c *implServiceAMethodA3StreamIterator) Err() error {
	if c.err == _gen_io.EOF {
		return nil
	}
	return c.err
}

// Implementation of the ServiceAMethodA3Call interface that is not exported.
type implServiceAMethodA3Call struct {
	clientCall _gen_ipc.Call
	readStream implServiceAMethodA3StreamIterator
}

func (c *implServiceAMethodA3Call) RecvStream() interface {
	Advance() bool
	Value() Scalars
	Err() error
} {
	return &c.readStream
}

func (c *implServiceAMethodA3Call) Finish() (reply string, err error) {
	if ierr := c.clientCall.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c *implServiceAMethodA3Call) Cancel() {
	c.clientCall.Cancel()
}

type implServiceAServiceMethodA3StreamSender struct {
	serverCall _gen_ipc.ServerCall
}

func (s *implServiceAServiceMethodA3StreamSender) Send(item Scalars) error {
	return s.serverCall.Send(item)
}

// ServiceAServiceMethodA3Stream is the interface for streaming responses of the method
// MethodA3 in the service interface ServiceA.
type ServiceAServiceMethodA3Stream interface {
	// SendStream returns the send portion of the stream.
	SendStream() interface {
		// Send places the item onto the output stream, blocking if there is no buffer
		// space available.  If the client has canceled, an error is returned.
		Send(item Scalars) error
	}
}

// Implementation of the ServiceAServiceMethodA3Stream interface that is not exported.
type implServiceAServiceMethodA3Stream struct {
	writer implServiceAServiceMethodA3StreamSender
}

func (s *implServiceAServiceMethodA3Stream) SendStream() interface {
	// Send places the item onto the output stream, blocking if there is no buffer
	// space available.  If the client has canceled, an error is returned.
	Send(item Scalars) error
} {
	return &s.writer
}

// ServiceAMethodA4Call is the interface for call object of the method
// MethodA4 in the service interface ServiceA.
type ServiceAMethodA4Call interface {
	// RecvStream returns the recv portion of the stream
	RecvStream() interface {
		// Advance stages an element so the client can retrieve it
		// with Value.  Advance returns true iff there is an
		// element to retrieve.  The client must call Advance before
		// calling Value. Advance may block if an element is not
		// immediately available.
		Advance() bool

		// Value returns the element that was staged by Advance.
		// Value may panic if Advance returned false or was not
		// called at all.  Value does not block.
		Value() string

		// Err returns a non-nil error iff the stream encountered
		// any errors.  Err does not block.
		Err() error
	}

	// SendStream returns the send portion of the stream
	SendStream() interface {
		// Send places the item onto the output stream, blocking if there is no
		// buffer space available.  Calls to Send after having called Close
		// or Cancel will fail.  Any blocked Send calls will be unblocked upon
		// calling Cancel.
		Send(item int32) error

		// Close indicates to the server that no more items will be sent;
		// server Recv calls will receive io.EOF after all sent items.  This is
		// an optional call - it's used by streaming clients that need the
		// server to receive the io.EOF terminator before the client calls
		// Finish (for example, if the client needs to continue receiving items
		// from the server after having finished sending).
		// Calls to Close after having called Cancel will fail.
		// Like Send, Close blocks when there's no buffer space available.
		Close() error
	}

	// Finish performs the equivalent of SendStream().Close, then blocks until the server
	// is done, and returns the positional return values for call.
	// If Cancel has been called, Finish will return immediately; the output of
	// Finish could either be an error signalling cancelation, or the correct
	// positional return values from the server depending on the timing of the
	// call.
	//
	// Calling Finish is mandatory for releasing stream resources, unless Cancel
	// has been called or any of the other methods return an error.
	// Finish should be called at most once.
	Finish() (err error)

	// Cancel cancels the RPC, notifying the server to stop processing.  It
	// is safe to call Cancel concurrently with any of the other stream methods.
	// Calling Cancel after Finish has returned is a no-op.
	Cancel()
}

type implServiceAMethodA4StreamSender struct {
	clientCall _gen_ipc.Call
}

func (c *implServiceAMethodA4StreamSender) Send(item int32) error {
	return c.clientCall.Send(item)
}

func (c *implServiceAMethodA4StreamSender) Close() error {
	return c.clientCall.CloseSend()
}

type implServiceAMethodA4StreamIterator struct {
	clientCall _gen_ipc.Call
	val        string
	err        error
}

func (c *implServiceAMethodA4StreamIterator) Advance() bool {
	c.err = c.clientCall.Recv(&c.val)
	return c.err == nil
}

func (c *implServiceAMethodA4StreamIterator) Value() string {
	return c.val
}

func (c *implServiceAMethodA4StreamIterator) Err() error {
	if c.err == _gen_io.EOF {
		return nil
	}
	return c.err
}

// Implementation of the ServiceAMethodA4Call interface that is not exported.
type implServiceAMethodA4Call struct {
	clientCall  _gen_ipc.Call
	writeStream implServiceAMethodA4StreamSender
	readStream  implServiceAMethodA4StreamIterator
}

func (c *implServiceAMethodA4Call) SendStream() interface {
	Send(item int32) error
	Close() error
} {
	return &c.writeStream
}

func (c *implServiceAMethodA4Call) RecvStream() interface {
	Advance() bool
	Value() string
	Err() error
} {
	return &c.readStream
}

func (c *implServiceAMethodA4Call) Finish() (err error) {
	if ierr := c.clientCall.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c *implServiceAMethodA4Call) Cancel() {
	c.clientCall.Cancel()
}

type implServiceAServiceMethodA4StreamSender struct {
	serverCall _gen_ipc.ServerCall
}

func (s *implServiceAServiceMethodA4StreamSender) Send(item string) error {
	return s.serverCall.Send(item)
}

type implServiceAServiceMethodA4StreamIterator struct {
	serverCall _gen_ipc.ServerCall
	val        int32
	err        error
}

func (s *implServiceAServiceMethodA4StreamIterator) Advance() bool {
	s.err = s.serverCall.Recv(&s.val)
	return s.err == nil
}

func (s *implServiceAServiceMethodA4StreamIterator) Value() int32 {
	return s.val
}

func (s *implServiceAServiceMethodA4StreamIterator) Err() error {
	if s.err == _gen_io.EOF {
		return nil
	}
	return s.err
}

// ServiceAServiceMethodA4Stream is the interface for streaming responses of the method
// MethodA4 in the service interface ServiceA.
type ServiceAServiceMethodA4Stream interface {
	// SendStream returns the send portion of the stream.
	SendStream() interface {
		// Send places the item onto the output stream, blocking if there is no buffer
		// space available.  If the client has canceled, an error is returned.
		Send(item string) error
	}
	// RecvStream returns the recv portion of the stream
	RecvStream() interface {
		// Advance stages an element so the client can retrieve it
		// with Value.  Advance returns true iff there is an
		// element to retrieve.  The client must call Advance before
		// calling Value.  Advance may block if an element is not
		// immediately available.
		Advance() bool

		// Value returns the element that was staged by Advance.
		// Value may panic if Advance returned false or was not
		// called at all.  Value does not block.
		Value() int32

		// Err returns a non-nil error iff the stream encountered
		// any errors.  Err does not block.
		Err() error
	}
}

// Implementation of the ServiceAServiceMethodA4Stream interface that is not exported.
type implServiceAServiceMethodA4Stream struct {
	writer implServiceAServiceMethodA4StreamSender
	reader implServiceAServiceMethodA4StreamIterator
}

func (s *implServiceAServiceMethodA4Stream) SendStream() interface {
	// Send places the item onto the output stream, blocking if there is no buffer
	// space available.  If the client has canceled, an error is returned.
	Send(item string) error
} {
	return &s.writer
}

func (s *implServiceAServiceMethodA4Stream) RecvStream() interface {
	// Advance stages an element so the client can retrieve it
	// with Value.  Advance returns true iff there is an
	// element to retrieve.  The client must call Advance before
	// calling Value.  The client must call Cancel if it does
	// not iterate through all elements (i.e. until Advance
	// returns false).  Advance may block if an element is not
	// immediately available.
	Advance() bool

	// Value returns the element that was staged by Advance.
	// Value may panic if Advance returned false or was not
	// called at all.  Value does not block.
	Value() int32

	// Err returns a non-nil error iff the stream encountered
	// any errors.  Err does not block.
	Err() error
} {
	return &s.reader
}

// BindServiceA returns the client stub implementing the ServiceA
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindServiceA(name string, opts ..._gen_ipc.BindOpt) (ServiceA, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubServiceA{defaultClient: client, name: name}

	return stub, nil
}

// NewServerServiceA creates a new server stub.
//
// It takes a regular server implementing the ServiceAService
// interface, and returns a new server stub.
func NewServerServiceA(server ServiceAService) interface{} {
	return &ServerStubServiceA{
		service: server,
	}
}

// clientStubServiceA implements ServiceA.
type clientStubServiceA struct {
	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubServiceA) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubServiceA) MethodA1(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "MethodA1", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubServiceA) MethodA2(ctx _gen_context.T, a int32, b string, opts ..._gen_ipc.CallOpt) (reply string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "MethodA2", []interface{}{a, b}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubServiceA) MethodA3(ctx _gen_context.T, a int32, opts ..._gen_ipc.CallOpt) (reply ServiceAMethodA3Call, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "MethodA3", []interface{}{a}, opts...); err != nil {
		return
	}
	reply = &implServiceAMethodA3Call{clientCall: call, readStream: implServiceAMethodA3StreamIterator{clientCall: call}}
	return
}

func (__gen_c *clientStubServiceA) MethodA4(ctx _gen_context.T, a int32, opts ..._gen_ipc.CallOpt) (reply ServiceAMethodA4Call, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "MethodA4", []interface{}{a}, opts...); err != nil {
		return
	}
	reply = &implServiceAMethodA4Call{clientCall: call, writeStream: implServiceAMethodA4StreamSender{clientCall: call}, readStream: implServiceAMethodA4StreamIterator{clientCall: call}}
	return
}

func (__gen_c *clientStubServiceA) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubServiceA) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubServiceA) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubServiceA wraps a server that implements
// ServiceAService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubServiceA struct {
	service ServiceAService
}

func (__gen_s *ServerStubServiceA) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	switch method {
	case "MethodA1":
		return []interface{}{}, nil
	case "MethodA2":
		return []interface{}{}, nil
	case "MethodA3":
		return []interface{}{"tag", uint64(6)}, nil
	case "MethodA4":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubServiceA) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["MethodA1"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["MethodA2"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "a", Type: 36},
			{Name: "b", Type: 3},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "s", Type: 3},
			{Name: "err", Type: 65},
		},
	}
	result.Methods["MethodA3"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "a", Type: 36},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "s", Type: 3},
			{Name: "err", Type: 65},
		},

		OutStream: 82,
	}
	result.Methods["MethodA4"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "a", Type: 36},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 65},
		},
		InStream:  36,
		OutStream: 3,
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x32, Name: "byte", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "anydata", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x7, Name: "TypeID", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x2, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedBool", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x32, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedByte", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x33, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedUint16", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x34, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedUint32", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x35, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedUint64", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x23, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedInt16", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x24, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedInt32", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x25, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedInt64", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x19, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedFloat32", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1a, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedFloat64", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x38, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedComplex64", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x39, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedComplex128", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x3, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedString", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x2, Name: "A0"},
				_gen_wiretype.FieldType{Type: 0x42, Name: "A1"},
				_gen_wiretype.FieldType{Type: 0x33, Name: "A2"},
				_gen_wiretype.FieldType{Type: 0x34, Name: "A3"},
				_gen_wiretype.FieldType{Type: 0x35, Name: "A4"},
				_gen_wiretype.FieldType{Type: 0x23, Name: "A5"},
				_gen_wiretype.FieldType{Type: 0x24, Name: "A6"},
				_gen_wiretype.FieldType{Type: 0x25, Name: "A7"},
				_gen_wiretype.FieldType{Type: 0x19, Name: "A8"},
				_gen_wiretype.FieldType{Type: 0x1a, Name: "A9"},
				_gen_wiretype.FieldType{Type: 0x38, Name: "A10"},
				_gen_wiretype.FieldType{Type: 0x39, Name: "A11"},
				_gen_wiretype.FieldType{Type: 0x3, Name: "A12"},
				_gen_wiretype.FieldType{Type: 0x41, Name: "A13"},
				_gen_wiretype.FieldType{Type: 0x43, Name: "A14"},
				_gen_wiretype.FieldType{Type: 0x44, Name: "A15"},
				_gen_wiretype.FieldType{Type: 0x45, Name: "B0"},
				_gen_wiretype.FieldType{Type: 0x46, Name: "B1"},
				_gen_wiretype.FieldType{Type: 0x47, Name: "B2"},
				_gen_wiretype.FieldType{Type: 0x48, Name: "B3"},
				_gen_wiretype.FieldType{Type: 0x49, Name: "B4"},
				_gen_wiretype.FieldType{Type: 0x4a, Name: "B5"},
				_gen_wiretype.FieldType{Type: 0x4b, Name: "B6"},
				_gen_wiretype.FieldType{Type: 0x4c, Name: "B7"},
				_gen_wiretype.FieldType{Type: 0x4d, Name: "B8"},
				_gen_wiretype.FieldType{Type: 0x4e, Name: "B9"},
				_gen_wiretype.FieldType{Type: 0x4f, Name: "B10"},
				_gen_wiretype.FieldType{Type: 0x50, Name: "B11"},
				_gen_wiretype.FieldType{Type: 0x51, Name: "B12"},
			},
			"veyron.io/veyron/veyron2/vdl/test_base.Scalars", []string(nil)},
	}

	return result, nil
}

func (__gen_s *ServerStubServiceA) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubServiceA) MethodA1(call _gen_ipc.ServerCall) (err error) {
	err = __gen_s.service.MethodA1(call)
	return
}

func (__gen_s *ServerStubServiceA) MethodA2(call _gen_ipc.ServerCall, a int32, b string) (reply string, err error) {
	reply, err = __gen_s.service.MethodA2(call, a, b)
	return
}

func (__gen_s *ServerStubServiceA) MethodA3(call _gen_ipc.ServerCall, a int32) (reply string, err error) {
	stream := &implServiceAServiceMethodA3Stream{writer: implServiceAServiceMethodA3StreamSender{serverCall: call}}
	reply, err = __gen_s.service.MethodA3(call, a, stream)
	return
}

func (__gen_s *ServerStubServiceA) MethodA4(call _gen_ipc.ServerCall, a int32) (err error) {
	stream := &implServiceAServiceMethodA4Stream{reader: implServiceAServiceMethodA4StreamIterator{serverCall: call}, writer: implServiceAServiceMethodA4StreamSender{serverCall: call}}
	err = __gen_s.service.MethodA4(call, a, stream)
	return
}

// ServiceB is the interface the client binds and uses.
// ServiceB_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type ServiceB_ExcludingUniversal interface {
	ServiceA_ExcludingUniversal
	MethodB1(ctx _gen_context.T, a Scalars, b Composites, opts ..._gen_ipc.CallOpt) (reply CompComp, err error)
}
type ServiceB interface {
	_gen_ipc.UniversalServiceMethods
	ServiceB_ExcludingUniversal
}

// ServiceBService is the interface the server implements.
type ServiceBService interface {
	ServiceAService
	MethodB1(context _gen_ipc.ServerContext, a Scalars, b Composites) (reply CompComp, err error)
}

// BindServiceB returns the client stub implementing the ServiceB
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindServiceB(name string, opts ..._gen_ipc.BindOpt) (ServiceB, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubServiceB{defaultClient: client, name: name}
	stub.ServiceA_ExcludingUniversal, _ = BindServiceA(name, client)

	return stub, nil
}

// NewServerServiceB creates a new server stub.
//
// It takes a regular server implementing the ServiceBService
// interface, and returns a new server stub.
func NewServerServiceB(server ServiceBService) interface{} {
	return &ServerStubServiceB{
		ServerStubServiceA: *NewServerServiceA(server).(*ServerStubServiceA),
		service:            server,
	}
}

// clientStubServiceB implements ServiceB.
type clientStubServiceB struct {
	ServiceA_ExcludingUniversal

	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubServiceB) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubServiceB) MethodB1(ctx _gen_context.T, a Scalars, b Composites, opts ..._gen_ipc.CallOpt) (reply CompComp, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "MethodB1", []interface{}{a, b}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubServiceB) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubServiceB) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubServiceB) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubServiceB wraps a server that implements
// ServiceBService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubServiceB struct {
	ServerStubServiceA

	service ServiceBService
}

func (__gen_s *ServerStubServiceB) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	if resp, err := __gen_s.ServerStubServiceA.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	switch method {
	case "MethodB1":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubServiceB) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["MethodB1"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "a", Type: 82},
			{Name: "b", Type: 90},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "c", Type: 96},
			{Name: "err", Type: 66},
		},
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x32, Name: "byte", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "anydata", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x7, Name: "TypeID", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x2, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedBool", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x32, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedByte", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x33, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedUint16", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x34, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedUint32", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x35, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedUint64", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x23, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedInt16", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x24, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedInt32", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x25, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedInt64", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x19, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedFloat32", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1a, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedFloat64", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x38, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedComplex64", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x39, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedComplex128", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x3, Name: "veyron.io/veyron/veyron2/vdl/test_base.NamedString", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x2, Name: "A0"},
				_gen_wiretype.FieldType{Type: 0x41, Name: "A1"},
				_gen_wiretype.FieldType{Type: 0x33, Name: "A2"},
				_gen_wiretype.FieldType{Type: 0x34, Name: "A3"},
				_gen_wiretype.FieldType{Type: 0x35, Name: "A4"},
				_gen_wiretype.FieldType{Type: 0x23, Name: "A5"},
				_gen_wiretype.FieldType{Type: 0x24, Name: "A6"},
				_gen_wiretype.FieldType{Type: 0x25, Name: "A7"},
				_gen_wiretype.FieldType{Type: 0x19, Name: "A8"},
				_gen_wiretype.FieldType{Type: 0x1a, Name: "A9"},
				_gen_wiretype.FieldType{Type: 0x38, Name: "A10"},
				_gen_wiretype.FieldType{Type: 0x39, Name: "A11"},
				_gen_wiretype.FieldType{Type: 0x3, Name: "A12"},
				_gen_wiretype.FieldType{Type: 0x42, Name: "A13"},
				_gen_wiretype.FieldType{Type: 0x43, Name: "A14"},
				_gen_wiretype.FieldType{Type: 0x44, Name: "A15"},
				_gen_wiretype.FieldType{Type: 0x45, Name: "B0"},
				_gen_wiretype.FieldType{Type: 0x46, Name: "B1"},
				_gen_wiretype.FieldType{Type: 0x47, Name: "B2"},
				_gen_wiretype.FieldType{Type: 0x48, Name: "B3"},
				_gen_wiretype.FieldType{Type: 0x49, Name: "B4"},
				_gen_wiretype.FieldType{Type: 0x4a, Name: "B5"},
				_gen_wiretype.FieldType{Type: 0x4b, Name: "B6"},
				_gen_wiretype.FieldType{Type: 0x4c, Name: "B7"},
				_gen_wiretype.FieldType{Type: 0x4d, Name: "B8"},
				_gen_wiretype.FieldType{Type: 0x4e, Name: "B9"},
				_gen_wiretype.FieldType{Type: 0x4f, Name: "B10"},
				_gen_wiretype.FieldType{Type: 0x50, Name: "B11"},
				_gen_wiretype.FieldType{Type: 0x51, Name: "B12"},
			},
			"veyron.io/veyron/veyron2/vdl/test_base.Scalars", []string(nil)},
		_gen_wiretype.ArrayType{Elem: 0x52, Len: 0x2, Name: "", Tags: []string(nil)}, _gen_wiretype.SliceType{Elem: 0x52, Name: "", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x52, Elem: 0x2, Name: "", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x3, Elem: 0x52, Name: "", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x3, Elem: 0x39, Name: "", Tags: []string(nil)}, _gen_wiretype.SliceType{Elem: 0x57, Name: "", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x52, Elem: 0x58, Name: "", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x52, Name: "A0"},
				_gen_wiretype.FieldType{Type: 0x53, Name: "A1"},
				_gen_wiretype.FieldType{Type: 0x54, Name: "A2"},
				_gen_wiretype.FieldType{Type: 0x55, Name: "A3"},
				_gen_wiretype.FieldType{Type: 0x56, Name: "A4"},
				_gen_wiretype.FieldType{Type: 0x59, Name: "A5"},
			},
			"veyron.io/veyron/veyron2/vdl/test_base.Composites", []string(nil)},
		_gen_wiretype.ArrayType{Elem: 0x5a, Len: 0x2, Name: "", Tags: []string(nil)}, _gen_wiretype.SliceType{Elem: 0x5a, Name: "", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x3, Elem: 0x5a, Name: "", Tags: []string(nil)}, _gen_wiretype.SliceType{Elem: 0x5d, Name: "", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x52, Elem: 0x5e, Name: "", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x5a, Name: "A0"},
				_gen_wiretype.FieldType{Type: 0x5b, Name: "A1"},
				_gen_wiretype.FieldType{Type: 0x5c, Name: "A2"},
				_gen_wiretype.FieldType{Type: 0x5d, Name: "A3"},
				_gen_wiretype.FieldType{Type: 0x5f, Name: "A4"},
			},
			"veyron.io/veyron/veyron2/vdl/test_base.CompComp", []string(nil)},
	}
	var ss _gen_ipc.ServiceSignature
	var firstAdded int
	ss, _ = __gen_s.ServerStubServiceA.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}

	return result, nil
}

func (__gen_s *ServerStubServiceB) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubServiceB) MethodB1(call _gen_ipc.ServerCall, a Scalars, b Composites) (reply CompComp, err error) {
	reply, err = __gen_s.service.MethodB1(call, a, b)
	return
}
