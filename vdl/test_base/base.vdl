// Package test_base is a simple single-file test of vdl functionality.
package test_base

// Error ids, that allow stable error checking across different error messages
// and different address spaces.
errorid (
	ErrIDFoo
	ErrIDBar = "some/path.ErrIdOther"
)

type (
	Bool       bool
	Byte       byte
	Uint16     uint16
	Uint32     uint32
	Uint64     uint64
	Int16      int16
	Int32      int32
	Int64      int64
	Float32    float32
	Float64    float64
	Complex64  complex64
	Complex128 complex128
	String     string
	//Enum       enum{A;B;C}
	Array      [2]bool
	List       []uint32
	//Set        set[string]
	Map        map[string]float32
	Struct     struct{A bool;B string;C int32}
	//OneOf      oneof{bool;string;int32}
)

type Scalars struct {
	A0  bool
	A1  byte
	A2  uint16
	A3  uint32
	A4  uint64
	A5  int16
	A6  int32
	A7  int64
	A8  float32
	A9  float64
	A10 complex64
	A11 complex128
	A12 string
	A13 error
	A14 any
	A15 typeval

	B0  Bool
	B1  Byte
	B2  Uint16
	B3  Uint32
	B4  Uint64
	B5  Int16
	B6  Int32
	B7  Int64
	B8  Float32
	B9  Float64
	B10 Complex64
	B11 Complex128
	B12 String
	//B13 Enum
	//B14 OneOf
}

type Composites struct {
	A0 Scalars
	A1 [2]Scalars
	A2 []Scalars
	//A3 set[Scalars]
	A4 map[string]Scalars
	A5 map[Scalars][]map[string]complex128
}

type CompComp struct {
	A0 Composites
	A1 [2]Composites
	A2 []Composites
	A3 map[string]Composites
	A4 map[Scalars][]map[string]Composites
}

// NestedArgs is defined before Args; that's allowed in regular Go, and also
// allowed in our vdl files.  The compiler will re-order dependent types to ease
// code generation in other languages.
type NestedArgs struct {
	Args Args
}

// Args will be reordered to show up before NestedArgs in the generated output.
type Args struct {
	A int32
	B int32
}

const (
	Cbool = true
	Cbyte = byte(1)
	Cint32 = int32(2)
	Cint64 = int64(3)
	Cuint32 = uint32(4)
	Cuint64 = uint64(5)
	Cfloat32 = float32(6)
	Cfloat64 = float64(7)
	Ccomplex64 = complex64(8+9i)
	Ccomplex128 = complex128(10+11i)
	Cstring = "foo"
	Cany = Cbool

	True = true
	Foo = "foo"
	Five = int32(5)
	SixSquared = Six*Six
	FiveSquared = Five*Five
	Six = uint64(6)
)

type ServiceA interface {
	MethodA1() error
	MethodA2(a int32, b string) (s string, err error)
	MethodA3(a int32) stream<_, Scalars> (s string, err error) {"tag", Six}
	MethodA4(a int32) stream<int32, string> error
}

type ServiceB interface {
	ServiceA
	MethodB1(a Scalars, b Composites) (c CompComp, err error)
}
