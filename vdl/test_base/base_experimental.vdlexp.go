// This file was auto-generated by the veyron vdl tool.
// Source: base_experimental.vdlexp

package test_base

type NamedEnum int

const (
	NamedEnumA NamedEnum = iota
	NamedEnumB
	NamedEnumC
)

// AllNamedEnum holds all labels for NamedEnum.
var AllNamedEnum = []NamedEnum{NamedEnumA, NamedEnumB, NamedEnumC}

// MakeNamedEnum creates a NamedEnum from a string label.
// Returns true iff the label is valid.
func MakeNamedEnum(label string) (x NamedEnum, ok bool) {
	ok = x.Assign(label)
	return
}

// Assign assigns label to x.
// Returns true iff the label is valid.
func (x *NamedEnum) Assign(label string) bool {
	switch label {
	case "A":
		*x = NamedEnumA
		return true
	case "B":
		*x = NamedEnumB
		return true
	case "C":
		*x = NamedEnumC
		return true
	}
	*x = -1
	return false
}

// String returns the string label of x.
func (x NamedEnum) String() string {
	switch x {
	case NamedEnumA:
		return "A"
	case NamedEnumB:
		return "B"
	case NamedEnumC:
		return "C"
	}
	return ""
}

// vdlEnumLabels identifies NamedEnum as an enum.
func (NamedEnum) vdlEnumLabels(struct{ A, B, C bool }) {}

type NamedOneOf struct{ oneof interface{} }

// MakeNamedOneOf creates a NamedOneOf.
// Returns true iff the oneof value has a valid type.
func MakeNamedOneOf(oneof interface{}) (x NamedOneOf, ok bool) {
	ok = x.Assign(oneof)
	return
}

// Assign assigns oneof to x.
// Returns true iff the oneof value has a valid type.
func (x *NamedOneOf) Assign(oneof interface{}) bool {
	switch oneof.(type) {
	case bool, string, int32:
		x.oneof = oneof
		return true
	}
	x.oneof = nil
	return false
}

// OneOf returns the underlying typed value of x.
func (x NamedOneOf) OneOf() interface{} {
	return x.oneof
}

// vdlOneOfTypes identifies NamedOneOf as a oneof.
func (NamedOneOf) vdlOneOfTypes(_ bool, _ string, _ int32) {}

type ScalarsExp struct {
	B13 NamedEnum
	B14 NamedOneOf
}

const Cenum = NamedEnumA

var Carray = [3]int32{1, 2, 3}

var Clist = []int32{1, 2, 3}

// TODO(toddw): test multiple items after ordering is fixed.
//Cset   = set[int32]{1, 2, 3}
var Cset = map[int32]struct{}{1: struct{}{}}

// TODO(toddw): test multiple items after ordering is fixed.
//cmap   = map[int32]string{1: "A", 2: "B", 3: "C"}
var cmap = map[int32]string{1: "A"}

var Cargs = Args{A: 1, B: 2}
