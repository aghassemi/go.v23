package gen

import (
	"bytes"
	"fmt"
	"log"
	"path"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"veyron2/val"
	"veyron2/vdl"
	"veyron2/vdl/compile"
)

// javaGenImplDir is the directory in which implementation details for the generated interfaces should be put.
const javaGenImplDir = "gen_impl"

// javaGenPkgPrefix is the path prefix to be added to generated VDL package paths.
var javaGenPkgPrefix string

// SetJavaGenPkgPrefix sets the prefix that will be added to generated VDL package paths.
func SetJavaGenPkgPrefix(prefix string) {
	javaGenPkgPrefix = prefix
}

// javaGenPkgPath returns the Java package path given the Go package path.
func javaGenPkgPath(goPkgPath string) string {
	return path.Join(javaGenPkgPrefix, goPkgPath)
}

// JavaFileInfo stores the name and contents of the generated Java file.
type JavaFileInfo struct {
	Dir  string
	Name string
	Data []byte
}

// GenJavaFiles generates Java files for all VDL files in the provided package,
// returning the list of generated Java files as a slice.  Since Java requires
// that each public class/interface gets defined in a separate file, this method
// will return one generated file per struct.  (Interfaces actually generate
// two files because we create separate interfaces for clients and services.)
// In addition, since Java doesn't support global variables (i.e., variables
// defined outside of a class), all constants are moved into a special "Consts"
// class and stored in a separate file.  All client bindings are stored in a
// separate Client.java file. Finally, package documentation (if any) is stored
// in a "package-info.java" file.
//
// The current generator doesn't yet support the full set of VDL features.  In
// particular, we don't yet support error ids and types Complex64 and Complex128.
//
// TODO(spetrovic): Run Java formatters on the generated files.
func GenJavaFiles(pkg *compile.Package, env *compile.Env) (ret []JavaFileInfo) {
	// One file for package documentation (if any).
	if g := genJavaPackageFile(pkg, env); g != nil {
		ret = append(ret, *g)
	}
	// Single file for all constants' definitions.
	if g := genJavaConstFile(pkg, env); g != nil {
		ret = append(ret, *g)
	}
	for _, file := range pkg.Files {
		// Separate file for all (struct) typedefs.
		for _, tdef := range file.TypeDefs {
			if tdef.Type.Kind() == val.Struct {
				ret = append(ret, genJavaClassFile(tdef, env))
			}
		}
		// Separate file for all interface definitions.
		for _, iface := range file.Interfaces {
			ret = append(ret, genJavaIfaceFile(iface, false, env)) // client interface
			ret = append(ret, genJavaIfaceFile(iface, true, env))  // service interface
			ret = append(ret, genJavaServiceWrapperFile(iface, env))
			ret = append(ret, genJavaClientStubFile(iface, env))
			ret = append(ret, genJavaClientFactoryFile(iface, env))
		}
	}
	return
}

// genPackageFileJava generates the Java package info file, iff any package
// comments were specified in the package's VDL files.
func genJavaPackageFile(pkg *compile.Package, env *compile.Env) *JavaFileInfo {
	for _, file := range pkg.Files {
		if file.PackageDef.Doc != "" {
			var buf bytes.Buffer
			err := javaPkgTmpl.Execute(&buf, file)
			if err != nil {
				log.Fatalf("vdl: couldn't execute package template: %v", err)
			}
			return &JavaFileInfo{
				Name: "package-info.java",
				Data: buf.Bytes(),
			}
		}
	}
	return nil
}

const javaPkgTmplStr = `
{{$file := .}}// This file was auto-generated by the veyron vdl tool.
// Source: {{$file.BaseName}}

{{javaDoc $file.PackageDef.Doc}}package {{javaPath (javaGenPkgPath $file.Package.Path)}};{{$file.PackageDef.DocSuffix}}
`

// genConstFileJava generates the (single) Java file that contains constant
// definitions from all the VDL files.
func genJavaConstFile(pkg *compile.Package, env *compile.Env) *JavaFileInfo {
	hasConsts := false
	for _, file := range pkg.Files {
		if javaHasConsts(file) {
			hasConsts = true
			break
		}
	}
	if !hasConsts {
		return nil
	}
	data := struct {
		Package *compile.Package
		Imports javaUserImports
		Env     *compile.Env
	}{
		Package: pkg,
		Imports: javaConstImports(pkg, env),
		Env:     env,
	}
	var buf bytes.Buffer
	err := javaConstTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatalf("vdl: couldn't execute const template: %v", err)
	}
	return &JavaFileInfo{
		Name: "VeyronConsts.java", // TODO(bprosnitz) Look into better ways to handle potential naming conflicts.
		Data: buf.Bytes(),
	}
}

const javaConstTmplStr = `{{$data := .}}{{$forceClass := true}}// This file was auto-generated by the veyron vdl tool.
// Source(s):{{range $file := $data.Package.Files}} {{$file.BaseName}}{{end}}
package {{javaPath (javaGenPkgPath $data.Package.Path)}};
{{range $imp := javaImports $data.Imports $data.Package.Path}}
import {{$imp}};{{end}}

public class VeyronConsts { {{range $file := $data.Package.Files}}{{if javaHasConsts $file}}
	/* The following constants originate in file: {{$file.BaseName}}. */{{range $const := $file.ConstDefs}}
	{{$const.Doc}}public static final {{javaType $const.Value.Type (not $forceClass) $data.Imports $data.Env}} {{toConstCase $const.Name}} = {{javaConstVal $const.Value $data.Imports $data.Env}};{{$const.DocSuffix}}{{end}}{{range $eid := $file.ErrorIDs}}
	{{$eid.Doc}}public static final {{javaName "java/lang/String" $data.Imports}} {{toConstCase $eid.Name}} = new {{javaName "java/lang/String" $data.Imports}}("{{$eid.ID}}");{{$eid.DocSuffix}}{{end}}{{end}}{{end}}
}
`

// genStructFile generates the Java class file for the provided struct.
func genJavaClassFile(tdef *compile.TypeDef, env *compile.Env) JavaFileInfo {
	data := struct {
		TypeDef *compile.TypeDef
		Imports javaUserImports
		Env     *compile.Env
	}{
		TypeDef: tdef,
		Imports: javaStructImports(tdef, env),
		Env:     env,
	}
	var buf bytes.Buffer
	err := javaClassTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatalf("vdl: couldn't execute struct template: %v", err)
	}
	return JavaFileInfo{
		Name: tdef.Name + ".java",
		Data: buf.Bytes(),
	}
}

const javaClassTmplStr = `
{{$data := .}}{{$typeDef := $data.TypeDef}}{{$forceClass := true}}// This file was auto-generated by the veyron vdl tool.
// Source: {{$typeDef.File.BaseName}}
package {{javaPath (javaGenPkgPath $typeDef.File.Package.Path)}};
{{range $imp := javaImports $data.Imports $typeDef.File.Package.Path}}
import {{$imp}};{{end}}

{{javaDoc $typeDef.Doc}}public class {{javaQualifiedName $typeDef.Name $typeDef.File $data.Imports}} { {{range $idx, $field := javaStructFields $typeDef.Type}}
	{{index $typeDef.FieldDoc $idx}}public {{javaType $field.Type (not $forceClass) $data.Imports $data.Env}} {{toCamelCase $field.Name}};{{index $typeDef.FieldDocSuffix $idx}}{{end}}
}
`

// genJavaIfaceFile generates the Java interface file for the provided
// interface.
func genJavaIfaceFile(iface *compile.Interface, isService bool, env *compile.Env) JavaFileInfo {
	data := struct {
		Interface *compile.Interface
		IsService bool
		Imports   javaUserImports
		Env       *compile.Env
	}{
		Interface: iface,
		IsService: isService,
		Imports:   javaIfaceImports(iface, isService, env),
		Env:       env,
	}
	var buf bytes.Buffer
	err := javaIfaceTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatalf("vdl: couldn't execute struct template: %v", err)
	}
	name := iface.Name
	if isService {
		name += "Service"
	}
	name += ".java"
	return JavaFileInfo{
		Name: name,
		Data: buf.Bytes(),
	}
}

const javaIfaceTmplStr = `{{$data := .}}{{$iface := $data.Interface}}{{$forceClass := true}}{{$camelCase := true}}{{$useOptions := true}}// This file was auto-generated by the veyron vdl tool.
// Source: {{$iface.File.BaseName}}
package {{javaPath (javaGenPkgPath $iface.File.Package.Path)}};
{{range $imp := javaImports $data.Imports $iface.File.Package.Path}}
import {{$imp}};{{end}}

{{javaDoc $iface.Doc}}{{if $data.IsService}}@VeyronService(serviceWrapper={{$iface.Name}}ServiceWrapper.class)
{{end}}public interface {{$iface.Name}}{{if $data.IsService}}Service{{end}}{{if gt (len $iface.Embeds) 0}} extends {{end}}{{range $idx, $eIface := $iface.Embeds}}{{if gt $idx 0}}, {{end}}{{javaIfaceName $eIface $data.IsService $data.Imports}}{{end}} { {{range $method := $iface.Methods}}{{if gt (len (javaNonErrorOutArgs $method)) 1}}
	// {{$method.Name}}Out packages output arguments for method {{$method.Name}}.
	public static class {{$method.Name}}Out { {{range $arg := javaNonErrorOutArgs $method}}
		{{$arg.Doc}}public {{javaType $arg.Type (not $forceClass) $data.Imports $data.Env}} {{toCamelCase $arg.Name}};{{$arg.DocSuffix}}{{end}}
	}{{end}}
	{{$method.Doc}}	public {{javaOutArgType $method $iface $data.IsService (not $forceClass) $data.Imports $data.Env}} {{toCamelCase $method.Name}}({{javaInArgs $method $iface $data.IsService (not $useOptions) $camelCase $data.Imports $data.Env}}) throws {{javaName "com/veyron2/ipc/VeyronException" $data.Imports}};{{$method.DocSuffix}}{{if not $data.IsService}}
	public {{javaOutArgType $method $iface $data.IsService (not $forceClass) $data.Imports $data.Env}} {{toCamelCase $method.Name}}({{javaInArgs $method $iface $data.IsService $useOptions $camelCase $data.Imports $data.Env}}) throws {{javaName "com/veyron2/ipc/VeyronException" $data.Imports}};{{end}}{{end}}
}
`

// genJavaClientFile generates the Java file containing client bindings for
// all interfaces in the provided package.
func genJavaClientFactoryFile(iface *compile.Interface, env *compile.Env) JavaFileInfo {
	data := struct {
		Interface *compile.Interface
		Imports   javaUserImports
		Env       *compile.Env
	}{
		Interface: iface,
		Imports:   javaClientFactoryImports(iface, env),
		Env:       env,
	}
	var buf bytes.Buffer
	err := javaClientFactoryTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatal("vdl: couldn't execute client template: %v", err)
	}
	return JavaFileInfo{
		Name: iface.Name + "Factory.java",
		Data: buf.Bytes(),
	}
}

const javaClientFactoryTmplStr = `{{$data := .}}{{$isService := false}}{{$iface := $data.Interface}}{{$ifaceClassName := javaIfaceName $iface (not $isService) $data.Imports}}{{$ifaceShortClassName := javaShortIfaceName $iface (not $isService)}}{{$forceClass := true}}{{$useOptions := true}}{{$optionVarName := "veyronOpts"}}{{$camelCase := true}}{{$clientClassName := javaName "com/veyron2/ipc/Client" $data.Imports}}{{$optsClassName := javaName "com/veyron2/Options" $data.Imports}}{{$optDefsClassName := javaName "com/veyron2/OptionDefs" $data.Imports}}{{$runtimeClassName := javaName "com/veyron2/Runtime" $data.Imports}}{{$stringClassName := javaName "java/lang/String" $data.Imports}}{{$objectClassName := javaName "java/lang/Object" $data.Imports}}{{$veyronExceptionClassName := javaName "com/veyron2/ipc/VeyronException" $data.Imports}}// This file was auto-generated by the veyron vdl tool.
// Source(s): {{range $file := $iface.File.Package.Files}} {{$file.BaseName}}{{end}}
package {{javaPath (javaGenPkgPath $iface.File.Package.Path)}};
{{range $imp := javaImports $data.Imports $iface.File.Package.Path}}
import {{$imp}};{{end}}

/* Factory for binding to {{$iface.Name}} interfaces. */
public class {{$iface.Name}}Factory {
	public static {{$iface.Name}} bind({{$stringClassName}} name) throws {{$veyronExceptionClassName}} {
		return bind(name, null);
	}
	public static {{$iface.Name}} bind({{$stringClassName}} name, {{$optsClassName}} {{$optionVarName}}) throws {{$veyronExceptionClassName}} {
		{{$clientClassName}} client = null;
		if ({{$optionVarName}} != null && {{$optionVarName}}.get({{$optDefsClassName}}.CLIENT) != null) {
			client = {{$optionVarName}}.get({{$optDefsClassName}}.CLIENT, {{$clientClassName}}.class);
		} else if ({{$optionVarName}} != null && {{$optionVarName}}.get({{$optDefsClassName}}.RUNTIME) != null) {
			client = {{$optionVarName}}.get({{$optDefsClassName}}.RUNTIME, {{$runtimeClassName}}.class).getClient();
		} else {
			client = {{javaName "com/veyron2/RuntimeFactory" $data.Imports}}.getRuntime().getClient();
		}
		return new {{$iface.Name}}Stub(client, name);
	}
}
`

// genJavaClientStubFile generates a client stub for the specified interface.
func genJavaClientStubFile(iface *compile.Interface, env *compile.Env) JavaFileInfo {
	data := struct {
		Interface  *compile.Interface
		Imports    javaUserImports
		Env        *compile.Env
		GenImplDir string
	}{
		Interface:  iface,
		Imports:    javaClientStubImports(iface, env),
		Env:        env,
		GenImplDir: javaGenImplDir,
	}
	var buf bytes.Buffer
	err := javaClientStubTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatal("vdl: couldn't execute client stub template: %v", err)
	}
	return JavaFileInfo{
		Dir:  javaGenImplDir,
		Name: iface.Name + "Stub.java",
		Data: buf.Bytes(),
	}
}

const javaClientStubTmplStr = `{{$data := .}}{{$iface := $data.Interface}}{{$pkgPath := (printf "%s/%s" $iface.File.Package.Path $data.GenImplDir)}}{{$forceClass := true}}{{$isService := true}}{{$useOptions := true}}{{$optionVarName := "veyronOpts"}}{{$camelCase := true}}{{$clientClassName := javaName "com/veyron2/ipc/Client" $data.Imports}}{{$optsClassName := javaName "com/veyron2/Options" $data.Imports}}{{$optDefsClassName := javaName "com/veyron2/OptionDefs" $data.Imports}}{{$runtimeClassName := javaName "com/veyron2/Runtime" $data.Imports}}{{$stringClassName := javaName "java/lang/String" $data.Imports}}{{$objectClassName := javaName "java/lang/Object" $data.Imports}}{{$veyronExceptionClassName := javaName "com/veyron2/ipc/VeyronException" $data.Imports}}// This file was auto-generated by the veyron vdl tool.
// Source(s): {{range $file := $iface.File.Package.Files}} {{$file.BaseName}}{{end}}
package {{javaPath (javaGenPkgPath $pkgPath)}};
{{range $imp := javaImports $data.Imports $pkgPath}}
import {{$imp}};{{end}}

/* Client stub for interface: {{$iface.Name}}. */{{$ifaceClassName := javaIfaceName $iface (not $isService) $data.Imports}}{{$ifaceShortClassName := javaShortIfaceName $iface (not $isService)}}
public final class {{$ifaceShortClassName}}Stub implements {{$ifaceClassName}} {
	private static final {{$stringClassName}} vdlIfacePathOpt = "{{javaPath (javaGenPkgPath $iface.File.Package.Path)}}.{{$ifaceShortClassName}}";
	private final {{$clientClassName}} client;
	private final {{$stringClassName}} name;{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface (not $isService) $data.Imports}}{{$eIfaceShortClassName := javaShortIfaceName $eIface (not $isService)}}
	private final {{$eIfaceClassName}} {{javaClassToVarName $eIfaceShortClassName}};{{end}}

	public {{$ifaceShortClassName}}Stub({{$clientClassName}} client, {{$stringClassName}} name) {
		this.client = client;
		this.name = name;{{range $eIface := $iface.Embeds}}{{$eIfaceShortClassName := javaShortIfaceName $eIface (not $isService)}}{{$varName := javaClassToVarName $eIfaceShortClassName}}
		this.{{$varName}} = new {{javaName (printf "%s/%s/%sStub" (javaGenPkgPath $eIface.File.Package.Path) $data.GenImplDir $eIface.Name) $data.Imports}}(client, name);{{end}}
	}{{if gt (len $iface.Methods) 0}}
	// Methods from interface {{$iface.Name}}.{{end}}{{range $method := $iface.Methods}}{{$outArgType := javaOutArgType $method $iface (not $isService) (not $forceClass) $data.Imports $data.Env}}
	@Override
	public {{$outArgType}} {{toCamelCase $method.Name}}({{javaInArgs $method $iface (not $isService) (not $useOptions) (not $camelCase) $data.Imports $data.Env}}) throws {{$veyronExceptionClassName}} {
		{{if ne $outArgType "void"}}return {{end}}{{toCamelCase $method.Name}}(context{{range $arg := $method.InArgs}}, {{$arg.Name}}{{end}}, null);
	}
	@Override
	public {{$outArgType}} {{toCamelCase $method.Name}}({{javaInArgs $method $iface (not $isService) $useOptions (not $camelCase) $data.Imports $data.Env}}) throws {{$veyronExceptionClassName}} {
		// Prepare input arguments.
		final {{$objectClassName}}[] inArgs = new {{$objectClassName}}[]{ {{range $idx, $arg := $method.InArgs}}{{if gt $idx 0}}, {{end}}{{javaCastToObject $arg $data.Imports}}{{end}} };

		// Add VDL path option.
		// NOTE(spetrovic): this option is temporary and will be removed soon after we switch
		// Java to encoding/decoding from vom.Value objects.
		if ({{$optionVarName}} == null) {{$optionVarName}} = new {{$optsClassName}}();
		if (!{{$optionVarName}}.has({{$optDefsClassName}}.VDL_INTERFACE_PATH)) {
			{{$optionVarName}}.set({{$optDefsClassName}}.VDL_INTERFACE_PATH, {{$ifaceShortClassName}}Stub.vdlIfacePathOpt);
		}

		// Start the call.
		final {{$clientClassName}}.Call call = this.client.startCall(context, this.name, "{{$method.Name}}", inArgs, {{$optionVarName}});
{{if javaIsStreamingMethod $method}}{{$typeTokenClassName := javaName "com/google/common/reflect/TypeToken" $data.Imports}}{{$streamClassName := javaName "com/veyron2/vdl/ClientStream" $data.Imports}}{{$streamSend := javaType $method.InStream $forceClass $data.Imports $data.Env}}{{$streamRecv := javaType $method.OutStream $forceClass $data.Imports $data.Env}}{{$streamFinish := javaNonStreamingOutArgType $method $iface (not $isService) $forceClass $data.Imports $data.Env}}
		return new {{$streamClassName}}<{{$streamSend}}, {{$streamRecv}}, {{$streamFinish}}>() {
			@Override
			public void send({{$streamSend}} item) throws {{$veyronExceptionClassName}} {
				call.send(item);
			}
			@Override
			public {{$streamRecv}} recv() throws {{javaName "java/io/EOFException" $data.Imports}}, {{$veyronExceptionClassName}} {
				final {{$typeTokenClassName}}<?> type = new {{$typeTokenClassName}}<{{$streamRecv}}>() {};
				final {{$objectClassName}} result = call.recv(type);
				try {
					return ({{$streamRecv}})result;
				} catch ({{javaName "java/lang/ClassCastException" $data.Imports}} e) {
					throw new {{$veyronExceptionClassName}}("Unexpected result type: " + result.getClass().getCanonicalName());
				}
			}
			@Override
			public {{$streamFinish}} finish() throws {{$veyronExceptionClassName}} {
				{{template "resultFetch" (javaClientResultFetchArgs $method $iface $forceClass "\t\t\t\t\t" $data.Imports $data.Env)}}
			}
		};{{else}}
		{{template "resultFetch" (javaClientResultFetchArgs $method $iface (not $forceClass) "\t\t\t" $data.Imports $data.Env)}}{{end}}
	}{{end}}{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface (not $isService) $data.Imports}}{{$eIfaceShortClassName := javaShortIfaceName $eIface (not $isService)}}{{$allMethods := javaAllMethods $eIface}}{{if gt (len $allMethods) 0}}
	// Methods from sub-interface {{$eIface.Name}}.{{end}}{{range $method := $allMethods}}{{$outArgType := javaOutArgType $method $eIface (not $isService) (not $forceClass) $data.Imports $data.Env}}
	@Override
	public {{$outArgType}} {{toCamelCase $method.Name}}({{javaInArgs $method $iface (not $isService) (not $useOptions) (not $camelCase) $data.Imports $data.Env}}) throws {{javaName "com/veyron2/ipc/VeyronException" $data.Imports}} {
		{{if ne $outArgType "void"}}return {{end}}{{toCamelCase $method.Name}}(context{{range $arg := $method.InArgs}}, {{$arg.Name}}{{end}}, null);
	}
	@Override
	public {{$outArgType}} {{toCamelCase $method.Name}}({{javaInArgs $method $iface (not $isService) $useOptions (not $camelCase) $data.Imports $data.Env}}) throws {{javaName "com/veyron2/ipc/VeyronException" $data.Imports}} {
		// Add VDL path option.
		// NOTE(spetrovic): this option is temporary and will be removed soon after we switch
	    // Java to encoding/decoding from vom.Value objects.
		if ({{$optionVarName}} == null) {{$optionVarName}} = new {{$optsClassName}}();
		if (!{{$optionVarName}}.has({{$optDefsClassName}}.VDL_INTERFACE_PATH)) {
			{{$optionVarName}}.set({{$optDefsClassName}}.VDL_INTERFACE_PATH, {{$ifaceShortClassName}}Stub.vdlIfacePathOpt);
		}
		{{if ne $outArgType "void"}}return {{end}}this.{{javaClassToVarName $eIfaceShortClassName}}.{{toCamelCase $method.Name}}(context{{range $arg := $method.InArgs}}, {{$arg.Name}}{{end}}, {{$optionVarName}});
	}{{end}}{{end}}
}
{{define "resultFetch"}}{{$data := .}}{{$forceClass := true}}{{$isService := true}}{{$typeTokenClassName := javaName "com/google/common/reflect/TypeToken" $data.Imports}}{{$objectClassName := javaName "java/lang/Object" $data.Imports}}// Prepare output argument and finish the call.{{$outArgs := javaNonErrorOutArgs $data.Method}}{{$finalOutArgType := javaNonStreamingOutArgType $data.Method $data.Interface (not $isService) $data.ForceClass $data.Imports $data.Env}}{{$objOutArgType := javaNonStreamingOutArgType $data.Method $data.Interface (not $isService) $forceClass $data.Imports $data.Env}}
{{$data.Indent}}final {{$typeTokenClassName}}<?>[] resultTypes = new {{$typeTokenClassName}}<?>[]{ {{range $idx, $arg := $outArgs}}{{if gt $idx 0}}, {{end}}new {{$typeTokenClassName}}<{{javaType $arg.Type $forceClass $data.Imports $data.Env}}>() {}{{end}} };{{if eq (len $outArgs) 0}}
{{$data.Indent}}call.finish(resultTypes);{{if eq $finalOutArgType "java.lang.Void"}}
{{$data.Indent}}return null;{{end}}{{else}}{{if eq (len $outArgs) 1}}
{{$data.Indent}}return ({{$objOutArgType}})call.finish(resultTypes)[0];{{else}}
{{$data.Indent}}final {{$objectClassName}}[] results = call.finish(resultTypes);
{{$data.Indent}}// Pack the results.
{{$data.Indent}}final {{$finalOutArgType}} ret = new {{$finalOutArgType}}();
{{$data.Indent}}int resultIdx = 0;{{range $arg := $outArgs}}
{{$data.Indent}}ret.{{toCamelCase $arg.Name}} = ({{javaType $arg.Type $forceClass $data.Imports $data.Env}})results[resultIdx++];{{end}}
{{$data.Indent}}return ret;{{end}}{{end}}
{{end}}`

// genJavaServiceWrapperFile generates a java file containing a service wrapper for the specified
// interface.
func genJavaServiceWrapperFile(iface *compile.Interface, env *compile.Env) JavaFileInfo {
	data := struct {
		Interface  *compile.Interface
		Imports    javaUserImports
		Env        *compile.Env
		GenImplDir string
	}{
		Interface:  iface,
		Imports:    javaServiceWrapperImports(iface, env),
		Env:        env,
		GenImplDir: javaGenImplDir,
	}
	var buf bytes.Buffer
	err := javaServiceWrapperTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatal("vdl: couldn't execute service wrapper template: %v", err)
	}
	return JavaFileInfo{
		Dir:  javaGenImplDir,
		Name: iface.Name + "ServiceWrapper.java",
		Data: buf.Bytes(),
	}
}

const javaServiceWrapperTmplStr = `{{$data := .}}{{$iface := $data.Interface}}{{$pkgPath := (printf "%s/%s" $iface.File.Package.Path $data.GenImplDir)}}{{$forceClass := true}}{{$isService := true}}{{$objectClassName := javaName "java/lang/Object" $data.Imports}}{{$serverCallClassName := javaName "com/veyron2/ipc/ServerCall" $data.Imports}}{{$veyronExceptionClassName := javaName "com/veyron2/ipc/VeyronException" $data.Imports}}// This file was auto-generated by the veyron vdl tool.
// Source(s): {{range $file := $iface.File.Package.Files}} {{$file.BaseName}}{{end}}
package {{javaPath (javaGenPkgPath $pkgPath)}};
{{range $imp := javaImports $data.Imports $pkgPath}}
import {{$imp}};{{end}}

public class {{$iface.Name}}ServiceWrapper {
{{$ifaceClassName := javaIfaceName $iface $isService $data.Imports}}{{$ifaceShortClassName := javaShortIfaceName $iface (not $isService)}}
	private final {{$ifaceClassName}} service;{{range $eIface := $iface.Embeds}}{{$eIfaceShortClassName := javaShortIfaceName $eIface (not $isService)}}
	private final {{$eIface.Name}}ServiceWrapper {{javaClassToVarName $eIfaceShortClassName}};{{end}}

	public {{$iface.Name}}ServiceWrapper({{$ifaceClassName}} service) {
		{{range $eIface := $iface.Embeds}}{{$eIfaceShortClassName := javaShortIfaceName $eIface (not $isService)}}this.{{javaClassToVarName $eIfaceShortClassName}} = new {{$eIface.Name}}ServiceWrapper(service);
		{{end}}this.service = service;{{range $eIface := $iface.Embeds}}{{$eIfaceShortClassName := javaShortIfaceName $eIface (not $isService)}}{{end}}
	}
	/**
	 * Returns all tags associated with the provided method or null if the method isn't implemented
	 * by this service.
	 */
	public {{$objectClassName}}[] getMethodTags({{$serverCallClassName}} call, String method) { {{range $eIface := $iface.Embeds}}{{$eIfaceShortClassName := javaShortIfaceName $eIface (not $isService)}}
		{
			final {{$objectClassName}}[] tags = this.{{javaClassToVarName $eIfaceShortClassName}}.getMethodTags(call, method);
			if (tags != null) return tags;
		}{{end}}{{range $method := $iface.Methods}}
		if (method == "{{$method.Name}}") {
			return new {{$objectClassName}}[]{ {{range $idx, $tag := $method.Tags}}{{if gt $idx 0}}, {{end}}{{javaConstVal $tag $data.Imports $data.Env}}{{end}} };
		}{{end}}
		return null;
	}
	// Methods from interface {{$iface.Name}}.{{range $method := $iface.Methods}}{{$outArgType := javaNonStreamingOutArgType $method $iface $isService (not $forceClass) $data.Imports $data.Env}}
	public {{$outArgType}} {{toCamelCase $method.Name}}({{$serverCallClassName}} call{{range $arg := $method.InArgs}}, {{javaType $arg.Type (not $forceClass) $data.Imports $data.Env}} {{$arg.Name}}{{end}}) throws {{$veyronExceptionClassName}} { {{if javaIsStreamingMethod $method}}{{$classCastExceptionClassName := javaName "java/lang/ClassCastException" $data.Imports}}{{$typeTokenClassName := javaName "com/google/common/reflect/TypeToken" $data.Imports}}{{$streamClassName := javaName "com/veyron2/vdl/Stream" $data.Imports}}{{$streamSend := javaType $method.OutStream $forceClass $data.Imports $data.Env}}{{$streamRecv := javaType $method.InStream $forceClass $data.Imports $data.Env}}
		final {{$serverCallClassName}} serverCall = call;
		final {{$streamClassName}}<{{$streamSend}},{{$streamRecv}}> stream = new {{$streamClassName}}<{{$streamSend}},{{$streamRecv}}>() {
			@Override
			public void send({{$streamSend}} item) throws {{$veyronExceptionClassName}} {
				serverCall.send(item);
			}
			@Override
			public {{$streamRecv}} recv() throws {{javaName "java/io/EOFException" $data.Imports}}, {{$veyronExceptionClassName}} {
				final {{$typeTokenClassName}}<?> type = new {{$typeTokenClassName}}<{{$streamRecv}}>() {};
				final {{$objectClassName}} result = serverCall.recv(type);
				try {
					return ({{$streamRecv}})result;
				} catch ({{$classCastExceptionClassName}} e) {
					throw new {{$veyronExceptionClassName}}("Unexpected result type: " + result.getClass().getCanonicalName());
				}
			}
		};{{end}}
		{{if ne $outArgType "void"}}return {{end}}this.service.{{toCamelCase $method.Name}}(call{{range $arg := $method.InArgs}}, {{$arg.Name}}{{end}}{{if javaIsStreamingMethod $method}}, stream{{end}});
	}{{end}}{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface $isService $data.Imports}}{{$eIfaceShortClassName := javaShortIfaceName $eIface (not $isService)}}{{$allMethods := javaAllMethods $eIface}}{{if gt (len $allMethods) 0}}
	// Methods from sub-interface {{$eIface.Name}}.{{end}}{{range $method := $allMethods}}{{$outArgType := javaNonStreamingOutArgType $method $eIface $isService (not $forceClass) $data.Imports $data.Env}}
	public {{$outArgType}} {{toCamelCase $method.Name}}({{$serverCallClassName}} call{{range $arg := $method.InArgs}}, {{javaType $arg.Type (not $forceClass) $data.Imports $data.Env}} {{$arg.Name}}{{end}}) throws {{$veyronExceptionClassName}} {
		{{if ne $outArgType "void"}}return {{end}}this.{{javaClassToVarName $eIfaceShortClassName}}.{{toCamelCase $method.Name}}(call{{range $arg := $method.InArgs}}, {{$arg.Name}}{{end}});
	}{{end}}{{end}}
}
`

// javaUserImports stores Java class imports found in user-specified code (i.e.,
// structs, interfaces, consts).  These imports are stores as a map of
// ClassName -> ClassPkgPath.
type javaUserImports map[string]string

// javaConstImports returns Java class imports originating in the constant
// definitions of all VDL files in the provided package.
func javaConstImports(pkg *compile.Package, env *compile.Env) javaUserImports {
	var classPaths []string
	for _, file := range pkg.Files {
		for _, cdef := range file.ConstDefs {
			classPaths = append(classPaths, javaClassPaths(cdef.Value.Type(), env)...)
		}
		if len(file.ErrorIDs) > 0 {
			classPaths = append(classPaths, "java/lang/String")
		}
	}
	classPaths = append(classPaths, javaPackageDefinedPaths(pkg)...)
	return genJavaUserImports(classPaths, pkg.Path)
}

// javaStructImports returns Java class imports originating in the provided
// struct definition.
func javaStructImports(tdef *compile.TypeDef, env *compile.Env) javaUserImports {
	classPaths := javaClassPaths(tdef.Type, env)
	for _, field := range javaStructFields(tdef.Type) {
		classPaths = append(classPaths, javaClassPaths(field.Type, env)...)
	}
	classPaths = append(classPaths, javaPackageDefinedPaths(tdef.File.Package)...)
	return genJavaUserImports(classPaths, tdef.File.Package.Path)
}

// javaIfaceImports returns Java class imports originating in the provided
// interface definition.
func javaIfaceImports(iface *compile.Interface, isService bool, env *compile.Env) javaUserImports {
	classPaths := javaIfaceClassPaths(iface, isService, env)
	if isService {
		classPaths = append(classPaths, "com/veyron2/ipc/ServerContext")
		classPaths = append(classPaths, javaGenPkgPath(filepath.Join(iface.File.Package.Path, javaGenImplDir, iface.Name+"ServiceWrapper")))
		classPaths = append(classPaths, "com/veyron2/vdl/VeyronService")
	}
	classPaths = append(classPaths, javaPackageDefinedPaths(iface.File.Package)...)
	return genJavaUserImports(classPaths, iface.File.Package.Path)
}

// javaClientsImports returns Java class imports for the Java client file, which
// provides client stub implementations for all the interfaces in the provided
// package.
func javaClientFactoryImports(iface *compile.Interface, env *compile.Env) javaUserImports {
	var classPaths []string
	hasStreaming := false
	classPaths = append(classPaths, javaIfaceClassPaths(iface, false, env)...)
	classPaths = append(classPaths, javaGenPkgPath(filepath.Join(iface.File.Package.Path, javaGenImplDir, iface.Name+"Stub")))
	for _, method := range iface.Methods {
		if javaIsStreamingMethod(method) {
			hasStreaming = true
		}
	}
	for _, eIface := range iface.Embeds {
		// Name of the embedded interface will be added twice, but that's fine.
		classPaths = append(classPaths, javaIfaceClassPaths(eIface, false, env)...)
	}
	// Add all the classes used in the client stub implementations.
	classPaths = append(classPaths, []string{
		"com/google/common/reflect/TypeToken",
		"com/veyron2/Options",
		"com/veyron2/OptionDefs",
		"com/veyron2/RuntimeFactory",
		"com/veyron2/ipc/Client",
	}...)
	if hasStreaming {
		classPaths = append(classPaths, []string{
			"java/lang/ClassCastException",
		}...)
	}
	pkg := iface.File.Package
	classPaths = append(classPaths, javaPackageDefinedPaths(pkg)...)
	return genJavaUserImports(classPaths, filepath.Join(pkg.Path, javaGenImplDir))
}

// javaServiceWrapperImports returns Java class imports for the Java service wrapper file
// that provides a server stub implementation for a service.
func javaServiceWrapperImports(iface *compile.Interface, env *compile.Env) javaUserImports {
	var classPaths []string
	var hasStreaming bool
	classPaths = append(classPaths, javaIfaceClassPaths(iface, true, env)...)
	classPaths = append(classPaths, javaGenPkgPath(filepath.Join(iface.File.Package.Path, javaGenImplDir, iface.Name+"ServiceWrapper")))
	for _, eIface := range iface.Embeds {
		// Name of the embedded interface will be added twice, but that's fine.
		classPaths = append(classPaths, javaIfaceClassPaths(eIface, true, env)...)
		classPaths = append(classPaths, javaGenPkgPath(filepath.Join(eIface.File.Package.Path, javaGenImplDir, eIface.Name+"ServiceWrapper")))
	}
	// Add all the classes used in the server stub implementations.
	pkg := iface.File.Package
	classPaths = append(classPaths, []string{
		path.Join(javaGenPkgPath(pkg.Path), iface.Name+"Service"),
		"java/lang/Object",
		"com/veyron2/ipc/ServerCall",
	}...)
	for _, method := range iface.Methods {
		if javaIsStreamingMethod(method) {
			hasStreaming = true
		}
	}
	if hasStreaming {
		classPaths = append(classPaths, []string{
			"com/veyron2/vdl/Stream",
			"com/google/common/reflect/TypeToken",
		}...)
	}
	classPaths = append(classPaths, javaPackageDefinedPaths(pkg)...)
	return genJavaUserImports(classPaths, filepath.Join(pkg.Path, javaGenImplDir))
}

// javaClientStubImports imports the files needed for the Java client stub file that provides
// and functionality to make RPCs.
func javaClientStubImports(iface *compile.Interface, env *compile.Env) javaUserImports {
	var classPaths []string

	classPaths = append(classPaths, javaPackageDefinedPaths(iface.File.Package)...)
	return genJavaUserImports(classPaths, filepath.Join(iface.File.Package.Path, javaGenImplDir))
}

// javaPackageDefinedPaths defines the set of type declared in the package and cause conflicts.
func javaPackageDefinedPaths(pkg *compile.Package) []string {
	pkgPath := javaGenPkgPath(pkg.Path)
	paths := []string{}
	for _, f := range pkg.Files {
		if len(f.ConstDefs) > 0 {
			paths = append(paths, path.Join(pkgPath, "VeyronConsts"))
		}
		for _, i := range f.Interfaces {
			paths = append(paths, path.Join(pkgPath, i.Name))
			paths = append(paths, path.Join(pkgPath, i.Name+"Service"))
			paths = append(paths, path.Join(pkgPath, i.Name+"Factory"))
		}
		for _, t := range f.TypeDefs {
			if t.Type.Kind() == val.Struct {
				paths = append(paths, path.Join(pkgPath, t.Name))
			}
		}
	}
	return paths
}

// genjavaUserImports generates the final list of Java class imports, given the
// list of class paths.
func genJavaUserImports(classPaths []string, pkgPath string) (ret javaUserImports) {
	// Sort all the class paths so that we get deterministic ordering;
	// it would be annoying for imported/non-imported class names to
	// change between runs.
	sort.StringSlice(classPaths).Sort()

	// Decide which class names to keep.  Here is the list of rules in order of
	// their preference:
	//   1) Prefer local classes.
	//   2) Prefer system classes (e.g., "java.lang.*").
	//   3) Prefer classes that are lexicographically smaller.
	ret = make(javaUserImports)
	for _, class := range classPaths {
		cur, ok := ret[path.Base(class)]
		switch {
		case !ok:
			ret[path.Base(class)] = path.Dir(class)
		case path.Dir(class) == javaGenPkgPath(pkgPath):
			ret[path.Base(class)] = path.Dir(class)
		case path.Dir(class) == "java/lang" && cur != javaGenPkgPath(pkgPath):
			ret[path.Base(class)] = path.Dir(class)
		}
	}
	return
}

// javaClassPaths returns pathnames of all Java classes originating in the
// provided type.
func javaClassPaths(t *val.Type, env *compile.Env) (ret []string) {
	if t == nil {
		typeStr, _ := javaPrimitiveType(nil, true)
		return []string{typeStr}
	}
	if def := env.FindTypeDef(t); def != nil {
		return javaNamedClassPaths(def, env)
	}
	switch t.Kind() {
	case val.Array:
		ret = javaClassPaths(t.Elem(), env)
	case val.List:
		ret = append(ret, "java/util/ArrayList")
		ret = append(ret, javaClassPaths(t.Elem(), env)...)
	case val.Set:
		ret = append(ret, "java/util/HashSet")
		ret = append(ret, javaClassPaths(t.Key(), env)...)
	case val.Map:
		ret = append(ret, "java/util/HashMap")
		ret = append(ret, javaClassPaths(t.Key(), env)...)
		ret = append(ret, javaClassPaths(t.Elem(), env)...)
	default:
		log.Fatalf("vdl: javaClassPaths unhandled type %#v", t)
	}
	return
}

func javaNamedClassPaths(def *compile.TypeDef, env *compile.Env) []string {
	if def.File == compile.BuiltInFile {
		t, _ := javaPrimitiveType(def.Type, true)
		return []string{t}
	}
	switch def.Type.Kind() {
	case val.Struct:
		return []string{path.Join(javaGenPkgPath(def.File.Package.Path), def.Name)}
	default:
		// Not a named struct/interface - recurse through the underlying type,
		// effectively getting rid of this (named) typedef.
		return javaClassPaths(def.BaseType, env)
	}
}

// javaIfaceClassPaths returns all class paths originating in the provided
// interface.
func javaIfaceClassPaths(iface *compile.Interface, isService bool, env *compile.Env) (ret []string) {
	ret = []string{javaIfacePathName(iface, isService)}
	for _, m := range iface.Methods {
		if javaIsStreamingMethod(m) {
			ret = append(ret, javaStreamClassPaths(m, iface, isService, env)...)
		}
		if !isService {
			ret = append(ret, "java/lang/String")
			ret = append(ret, "java/lang/Object")
			ret = append(ret, "com/veyron2/Options")
			ret = append(ret, "com/veyron2/ipc/Context")
		}
		for _, iarg := range m.InArgs {
			ret = append(ret, javaClassPaths(iarg.Type, env)...)
		}
		for _, oarg := range m.OutArgs {
			ret = append(ret, javaClassPaths(oarg.Type, env)...)
		}
		if isService && len(m.OutArgs) > 2 {
			ret = append(ret, path.Join(javaGenPkgPath(iface.File.Package.Path), iface.Name+"Service"))
		} else if !javaIsStreamingMethod(m) && len(m.OutArgs) > 2 {
			ret = append(ret, path.Join(javaGenPkgPath(iface.File.Package.Path), iface.Name))
		}
	}
	for _, eIface := range iface.Embeds {
		ret = append(ret, javaIfacePathName(eIface, isService))
	}
	return
}

// javaStreamClassPaths returns all class paths originating in the provided
// methods streaming argument.
func javaStreamClassPaths(method *compile.Method, iface *compile.Interface, isService bool, env *compile.Env) (ret []string) {
	if !javaIsStreamingMethod(method) {
		return
	}
	if isService {
		ret = append(ret, "com/veyron2/vdl/Stream")
	} else {
		ret = append(ret, "com/veyron2/vdl/ClientStream")
	}
	ret = append(ret, javaClassPaths(method.InStream, env)...)
	ret = append(ret, javaClassPaths(method.OutStream, env)...)
	if !isService {
		switch len(method.OutArgs) {
		case 0:
			log.Fatalf("vdl: method must have at least one output arg (i.e., error): %v", method)
		case 1:
			ret = append(ret, javaClassPaths(nil, env)...)
		case 2:
			ret = append(ret, javaClassPaths(method.OutArgs[0].Type, env)...)
		default:
			ret = append(ret, path.Join(javaGenPkgPath(iface.File.Package.Path), method.Name+"Out"))
		}
	}
	return
}

// javaType returns the Java type string given the provided VDL type.  It
// consults the provided imports map to see if the full pathnames or only
// base names can be used (e.g., "java.util.HashMap" or "HashMap").
func javaType(t *val.Type, forceClass bool, imports javaUserImports, env *compile.Env) string {
	if t == nil {
		name, class := javaPrimitiveType(nil, forceClass)
		if class {
			return javaName(name, imports)
		}
		return name
	}
	if def := env.FindTypeDef(t); def != nil {
		return javaNamedType(def, forceClass, imports, env)
	}
	switch t.Kind() {
	case val.Array:
		return fmt.Sprintf("%s[]", javaType(t.Elem(), false, imports, env))
	case val.List:
		return fmt.Sprintf("%s<%s>", javaName("java/util/ArrayList", imports), javaType(t.Elem(), true, imports, env))
	case val.Set:
		return fmt.Sprintf("%s<%s>", javaName("java/util/HashSet", imports), javaType(t.Key(), true, imports, env))
	case val.Map:
		return fmt.Sprintf("%s<%s, %s>", javaName("java/util/HashMap", imports), javaType(t.Key(), true, imports, env), javaType(t.Elem(), true, imports, env))
	default:
		log.Fatalf("vdl: javaType unhandled type %v %v", t.Kind(), t)
		return ""
	}
}

func javaNamedType(def *compile.TypeDef, forceClass bool, imports javaUserImports, env *compile.Env) string {
	if def.File == compile.BuiltInFile {
		name, class := javaPrimitiveType(def.Type, forceClass)
		if class {
			return javaName(name, imports)
		}
		return name
	}
	switch def.Type.Kind() {
	case val.Struct:
		return javaQualifiedName(def.Name, def.File, imports)
	default:
		// Not a named struct/interface - recurse through the underlying type,
		// effectively getting rid of this (named) typedef.
		return javaType(def.BaseType, forceClass, imports, env)
	}
}

// javaPrimitiveType returns the type name for the provided primitive type
// definition, forcing the use of a java class (e.g., java.lang.Integer) if so
// desired.  This method also returns a boolean value indicating whether the
// returned type is a class.
func javaPrimitiveType(typ *val.Type, forceClass bool) (string, bool) {
	if typ == nil {
		if forceClass {
			return "java/lang/Void", true
		} else {
			return "void", false
		}
	}
	if typ.Name() == "error" {
		return "com/veyron2/ipc/VeyronException", true
	}
	switch typ.Kind() {
	case val.Bool:
		if forceClass {
			return "java/lang/Boolean", true
		} else {
			return "boolean", false
		}
	case val.Byte:
		if forceClass {
			return "java/lang/Byte", true
		} else {
			return "byte", false
		}
	case val.Uint16, val.Int16:
		if forceClass {
			return "java/lang/Short", true
		} else {
			return "short", false
		}
	case val.Uint32, val.Int32:
		if forceClass {
			return "java/lang/Integer", true
		} else {
			return "int", false
		}
	case val.Uint64, val.Int64:
		if forceClass {
			return "java/lang/Long", true
		} else {
			return "long", false
		}
	case val.Float32:
		if forceClass {
			return "java/lang/Float", true
		} else {
			return "float", false
		}
	case val.Float64:
		if forceClass {
			return "java/lang/Double", true
		} else {
			return "double", false
		}
	case val.Complex64, val.Complex128:
		return "org/apache/commons/math3/complex/Complex", true
	case val.String:
		return "java/lang/String", true
	// TODO(spetrovic): handle typeval correctly.
	case val.Any, val.TypeVal:
		return "java/lang/Object", true
	default:
		return "", false
	}
}

// javaStreamType returns the stream type for the given (streaming) method.
func javaStreamType(method *compile.Method, iface *compile.Interface, isService bool, imports javaUserImports, env *compile.Env) (ret string) {
	if !javaIsStreamingMethod(method) {
		return ""
	}
	if isService {
		ret = javaName("com/veyron2/vdl/Stream", imports)
	} else {
		ret = javaName("com/veyron2/vdl/ClientStream", imports)
	}
	var sendType, recvType string
	if !isService {
		sendType = javaType(method.InStream, true, imports, env)
		recvType = javaType(method.OutStream, true, imports, env)
	} else {
		sendType = javaType(method.OutStream, true, imports, env)
		recvType = javaType(method.InStream, true, imports, env)
	}
	ret += "<" + sendType + "," + recvType
	if !isService {
		ret += "," + javaNonStreamingOutArgType(method, iface, isService, true, imports, env)
	}
	ret += ">"
	return
}

// javaConstVal returns the value string for the provided constant.
func javaConstVal(v *val.Value, imports javaUserImports, env *compile.Env) string {
	const longSuffix = "L"
	const floatSuffix = "f"

	switch v.Kind() {
	case val.Bool:
		if v.Bool() {
			return "true"
		} else {
			return "false"
		}
	case val.Byte:
		return strconv.FormatUint(uint64(v.Byte()), 10)
	case val.Uint16, val.Uint32, val.Uint64:
		c := strconv.FormatUint(v.Uint(), 10)
		if v.Kind() == val.Uint64 {
			return c + longSuffix
		}
		return c
	case val.Int16, val.Int32, val.Int64:
		c := strconv.FormatInt(v.Int(), 10)
		if v.Kind() == val.Int64 {
			return c + longSuffix
		}
		return c
	case val.Float32, val.Float64:
		c := strconv.FormatFloat(v.Float(), 'g', -1, bitlen(v.Kind()))
		if strings.Index(c, ".") == -1 {
			c += ".0"
		}
		if v.Kind() == val.Float32 {
			return c + floatSuffix
		}
		return c
	case val.Complex64, val.Complex128:
		r := strconv.FormatFloat(real(v.Complex()), 'g', -1, bitlen(v.Kind()))
		i := strconv.FormatFloat(imag(v.Complex()), 'g', -1, bitlen(v.Kind()))
		return fmt.Sprintf("new %s(%s, %s)", javaType(v.Type(), true, imports, env), r, i)
	case val.String:
		return strconv.Quote(v.RawString())
	}
	if v.Type().IsBytes() {
		return strconv.Quote(string(v.Bytes()))
	}
	// TODO(spetrovic): Handle Enum, List, Map, Struct, OneOf, Any
	panic(fmt.Errorf("vdl: javaConstVal unhandled type %v %v", v.Kind(), v.Type()))
}

// javaImports prunes the provided imports list, removing the unnecessary
// imports, and returns the pruned list in the Java format.
func javaImports(imports javaUserImports, pkgPath string) (ret []string) {
	for base, dir := range imports {
		if dir == javaGenPkgPath(pkgPath) || dir == "java/lang" {
			continue
		}
		ret = append(ret, javaPath(path.Join(dir, base)))
	}
	sort.StringSlice(ret).Sort()
	return
}

// javaOutArg returns the type for the (single) output argument for the provided
// method.
func javaOutArgType(method *compile.Method, iface *compile.Interface, isService, forceClass bool, imports javaUserImports, env *compile.Env) string {
	if javaIsStreamingMethod(method) && !isService {
		// Clients get a single output stream argument.
		return javaStreamType(method, iface, isService, imports, env)
	}
	return javaNonStreamingOutArgType(method, iface, isService, forceClass, imports, env)
}

// javaNonStreamingOutArgType returns the type for the non-streaming output arguments of the
// provided method.
func javaNonStreamingOutArgType(method *compile.Method, iface *compile.Interface, isService, forceClass bool, imports javaUserImports, env *compile.Env) string {
	switch len(method.OutArgs) {
	case 0:
		log.Fatalf("vdl: method must have at least one output arg (i.e., error): %v", method)
		return ""
	case 1:
		return javaType(nil, forceClass, imports, env)
	case 2:
		return javaType(method.OutArgs[0].Type, forceClass, imports, env)
	default:
		return javaIfaceName(iface, isService, imports) + "." + method.Name + "Out"
	}
}

// javaNonErrorOutArgs returns the list of non-error output arguments for the
// provided method.
func javaNonErrorOutArgs(method *compile.Method) []*compile.Arg {
	return method.OutArgs[:len(method.OutArgs)-1]
}

func javaIsStreamingMethod(method *compile.Method) bool {
	return method.InStream != nil || method.OutStream != nil
}

// javaInArgs returns the in-args string for the provided method.
func javaInArgs(method *compile.Method, iface *compile.Interface, isService, useOptions, camelCase bool, imports javaUserImports, env *compile.Env) (ret string) {
	if isService {
		ret += javaName("com/veyron2/ipc/ServerContext", imports) + " context"
	} else {
		ret += javaName("com/veyron2/ipc/Context", imports) + " context"
	}
	for _, arg := range method.InArgs {
		if ret != "" {
			ret += ", "
		}
		argName := arg.Name
		if camelCase {
			argName = vdl.ToCamelCase(argName)
		}
		ret += javaType(arg.Type, false, imports, env) + " " + argName
	}
	if !isService && useOptions {
		if ret != "" {
			ret += ", "
		}
		ret += fmt.Sprintf("%s veyronOpts", javaName("com/veyron2/Options", imports))
	}
	if javaIsStreamingMethod(method) && isService {
		// Services get the stream inlined with the input arguments; clients
		// treat the stream as an output argument so we ignore it here.
		if ret != "" {
			ret += ", "
		}
		ret += javaStreamType(method, iface, true, imports, env) + " stream"
	}
	return
}

// javaClientResultFetchImpl provides implementation for client's result fetch
// functionality.
func javaClientResultFetchArgs(method *compile.Method, iface *compile.Interface, forceClass bool, indent string, imports javaUserImports, env *compile.Env) (ret interface{}) {
	return struct {
		Method     *compile.Method
		Interface  *compile.Interface
		ForceClass bool
		Indent     string
		Imports    javaUserImports
		Env        *compile.Env
	}{
		Method:     method,
		Interface:  iface,
		ForceClass: forceClass,
		Indent:     indent,
		Imports:    imports,
		Env:        env,
	}
}

// javaAllMethods returns all methods implemented by this interface, including
// the methods from embedded interfaces.
func javaAllMethods(iface *compile.Interface) (ret []*compile.Method) {
	ret = iface.Methods
	for _, eIface := range javaAllEmbeddedIfaces(iface) {
		ret = append(ret, eIface.Methods...)
	}
	return
}

// javaAllEmbeddedIfaces returns all unique interfaces in the embed tree
// starting at the provided interface (not including that interface).
func javaAllEmbeddedIfaces(iface *compile.Interface) (ret []*compile.Interface) {
	added := make(map[string]bool)
	for _, eIface := range iface.Embeds {
		for _, eIface = range append(javaAllEmbeddedIfaces(eIface), eIface) {
			path := path.Join(eIface.File.Package.Path, eIface.Name)
			if _, ok := added[path]; ok { // already added iface
				continue
			}
			ret = append(ret, eIface)
			added[path] = true
		}
	}
	return
}

func javaHasConsts(file *compile.File) bool {
	return len(file.ConstDefs) > 0 || len(file.ErrorIDs) > 0
}

// javaStructFields returns the types of all the fields in the provided struct type.
func javaStructFields(t *val.Type) (ret []val.StructField) {
	for idx := 0; idx < t.NumField(); idx++ {
		ret = append(ret, t.Field(idx))
	}
	return
}

// javaDoc transforms the provided VDL comment into the JavaDoc format.
func javaDoc(goComment string) string {
	if goComment == "" {
		return ""
	}
	if strings.Index(goComment, "/*") != -1 {
		return goComment
	}
	return "/**\n" + strings.Replace(goComment, "//", " *", -1) + "**/\n"
}

// javaPath converts the provided Go path into the Java path.  It replaces all "/"
// with "." in the path.
func javaPath(goPath string) string {
	return strings.Replace(goPath, "/", ".", -1)
}

// javaShortName converts the provided Go pathname into a short Java name (just the base class name).
func javaShortName(goPathName string) string {
	return path.Base(goPathName)
}

// javaName converts the provided Go pathname into the Java pathname and returns a
// shorter version of it if possible, given the provided imports.
func javaName(goPathName string, imports javaUserImports) string {
	if dir, ok := imports[path.Base(goPathName)]; ok && dir == path.Dir(goPathName) {
		return javaShortName(goPathName)
	}
	return javaPath(goPathName)
}

// javaName returns the fully qualified Java name for the provided goName.
func javaQualifiedName(goName string, file *compile.File, imports javaUserImports) string {
	return javaName(path.Join(javaGenPkgPath(file.Package.Path), goName), imports)
}

// javaIfaceName returns the name for the provided interface.
func javaIfaceName(iface *compile.Interface, isService bool, imports javaUserImports) string {
	return javaName(javaIfacePathName(iface, isService), imports)
}

// javaShortIfaceName returns the short name for the provided interface.
func javaShortIfaceName(iface *compile.Interface, isService bool) string {
	return javaShortName(javaIfacePathName(iface, isService))
}

// javaIfacePathName returns the full pathname for the provided interface.
func javaIfacePathName(iface *compile.Interface, isService bool) string {
	name := iface.Name
	if isService {
		name += "Service"
	}
	return path.Join(javaGenPkgPath(iface.File.Package.Path), name)
}

// javaClassToVarName generates a Java variable name corresponding to the provided
// Java class name.
func javaClassToVarName(className string) string {
	dir := path.Dir(className)
	if dir == "." {
		return vdl.ToCamelCase(className)
	}
	return strings.Replace(path.Dir(className), "/", "_", -1) + "_" + vdl.ToCamelCase(path.Base(className))
}

// javaCastToObject generates a string that represents a value of type Object.
func javaCastToObject(arg *compile.Arg, imports javaUserImports) string {
	if tname, prim := javaPrimitiveType(arg.Type, true); prim {
		switch tname {
		case "java/lang/String", "java/lang/Object":
		default:
			return "new " + javaName(tname, imports) + "(" + arg.Name + ")"
		}
	}
	return arg.Name
}

// toConstCase converts ThisString to THIS_STRING.
func toConstCase(s string) string {
	// Extract all characters.
	chars := []rune{}
	idx := 0
	for idx < len(s) {
		r, size := utf8.DecodeRuneInString(s[idx:])
		if r == utf8.RuneError {
			log.Fatalf("Invalid UTF8 string: %s", s)
		}
		chars = append(chars, r)
		idx += size
	}
	// Case.
	var buf bytes.Buffer
	for i, r := range chars {
		if i > 0 && unicode.IsUpper(r) && i < len(chars)-1 && !unicode.IsUpper(chars[i+1]) {
			buf.WriteRune('_')
		}
		buf.WriteRune(unicode.ToUpper(r))
	}
	return buf.String()
}

var (
	javaPkgTmpl            *template.Template
	javaConstTmpl          *template.Template
	javaClassTmpl          *template.Template
	javaIfaceTmpl          *template.Template
	javaClientFactoryTmpl  *template.Template
	javaServiceWrapperTmpl *template.Template
	javaClientStubTmpl     *template.Template
)

// The template mechanism is great at high-level formatting and simple
// substitution, but is bad at more complicated logic (by design).  We define
// some functions that we can use in the template so that when things get
// complicated we back off to a regular function.
func init() {
	funcMap := template.FuncMap{
		"javaDoc":                    javaDoc,
		"javaGenPkgPath":             javaGenPkgPath,
		"javaPath":                   javaPath,
		"javaImports":                javaImports,
		"javaType":                   javaType,
		"javaConstVal":               javaConstVal,
		"javaInArgs":                 javaInArgs,
		"javaOutArgType":             javaOutArgType,
		"javaClientResultFetchArgs":  javaClientResultFetchArgs,
		"javaNonErrorOutArgs":        javaNonErrorOutArgs,
		"javaIsStreamingMethod":      javaIsStreamingMethod,
		"javaNonStreamingOutArgType": javaNonStreamingOutArgType,
		"javaHasConsts":              javaHasConsts,
		"javaStructFields":           javaStructFields,
		"javaAllMethods":             javaAllMethods,
		"javaName":                   javaName,
		"javaQualifiedName":          javaQualifiedName,
		"javaIfaceName":              javaIfaceName,
		"javaShortIfaceName":         javaShortIfaceName,
		"javaClassToVarName":         javaClassToVarName,
		"javaCastToObject":           javaCastToObject,
		"toCamelCase":                vdl.ToCamelCase,
		"toConstCase":                toConstCase,
	}
	javaPkgTmpl = template.Must(template.New("javaPkg").Funcs(funcMap).Parse(javaPkgTmplStr))
	javaConstTmpl = template.Must(template.New("javaConst").Funcs(funcMap).Parse(javaConstTmplStr))
	javaClassTmpl = template.Must(template.New("javaClass").Funcs(funcMap).Parse(javaClassTmplStr))
	javaIfaceTmpl = template.Must(template.New("javaIface").Funcs(funcMap).Parse(javaIfaceTmplStr))
	javaClientFactoryTmpl = template.Must(template.New("javaClient").Funcs(funcMap).Parse(javaClientFactoryTmplStr))
	javaServiceWrapperTmpl = template.Must(template.New("javaServiceWrapper").Funcs(funcMap).Parse(javaServiceWrapperTmplStr))
	javaClientStubTmpl = template.Must(template.New("javaClientStub").Funcs(funcMap).Parse(javaClientStubTmplStr))
}
