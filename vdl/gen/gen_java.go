package gen

import (
	"bytes"
	"fmt"
	"log"
	"path"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"

	"veyron2/val"
	"veyron2/vdl/compile"
)

// javaGenPkgPrefix is the path prefix to be added to generated VDL package paths.
var javaGenPkgPrefix string = "com"

// SetJavaGenPkgPrefix sets the prefix that will be added to generated VDL package paths.
func SetJavaGenPkgPrefix(prefix string) {
	javaGenPkgPrefix = prefix
}

// javaGenPkgPath returns the Java package path given the Go package path.
func javaGenPkgPath(goPkgPath string) string {
	return path.Join(javaGenPkgPrefix, goPkgPath)
}

// JavaFileInfo stores the name and contents of the generated Java file.
type JavaFileInfo struct {
	Name string
	Data []byte
}

// GenJavaFiles generates Java files for all VDL files in the provided package,
// returning the list of generated Java files as a slice.  Since Java requires
// that each public class/interface gets defined in a separate file, this method
// will return one generated file per struct.  (Interfaces actually generate
// two files because we create separate interfaces for clients and services.)
// In addition, since Java doesn't support global variables (i.e., variables
// defined outside of a class), all constants are moved into a special "Consts"
// class and stored in a separate file.  All client bindings are stored in a
// separate Client.java file. Finally, package documentation (if any) is stored
// in a "package-info.java" file.
//
// The current generator doesn't yet support the full set of VDL features.  In
// particular, we don't yet support error ids and types Complex64 and Complex128.
//
// TODO(spetrovic): Run Java formatters on the generated files.
func GenJavaFiles(pkg *compile.Package, env *compile.Env) (ret []JavaFileInfo) {
	// One file for package documentation (if any).
	if g := genJavaPackageFile(pkg, env); g != nil {
		ret = append(ret, *g)
	}
	// Single file for all constants' definitions.
	if g := genJavaConstFile(pkg, env); g != nil {
		ret = append(ret, *g)
	}
	for _, file := range pkg.Files {
		// Separate file for all (struct) typedefs.
		for _, tdef := range file.TypeDefs {
			if tdef.Type.Kind() == val.Struct {
				ret = append(ret, genJavaClassFile(tdef, env))
			}
		}
		// Separate file for all interface definitions.
		for _, iface := range file.Interfaces {
			ret = append(ret, genJavaIfaceFile(iface, false, env)) // client interface
			ret = append(ret, genJavaIfaceFile(iface, true, env))  // service interface
		}
	}
	// Single file for all client stub implementations.
	ret = append(ret, genJavaClientFile(pkg, env))
	// Single file for all server stub implementations.
	ret = append(ret, genJavaServerFile(pkg, env))
	return
}

// genPackageFileJava generates the Java package info file, iff any package
// comments were specified in the package's VDL files.
func genJavaPackageFile(pkg *compile.Package, env *compile.Env) *JavaFileInfo {
	for _, file := range pkg.Files {
		if file.PackageDef.Doc != "" {
			var buf bytes.Buffer
			err := javaPkgTmpl.Execute(&buf, file)
			if err != nil {
				log.Fatalf("vdl: couldn't execute package template: %v", err)
			}
			return &JavaFileInfo{
				Name: "package-info.java",
				Data: buf.Bytes(),
			}
		}
	}
	return nil
}

const javaPkgTmplStr = `
{{$file := .}}// This file was auto-generated by the veyron vdl tool.
// Source: {{$file.BaseName}}

{{javaDoc $file.PackageDef.Doc}}package {{javaPath (javaGenPkgPath $file.Package.Path)}};{{$file.PackageDef.DocSuffix}}
`

// genConstFileJava generates the (single) Java file that contains constant
// definitions from all the VDL files.
func genJavaConstFile(pkg *compile.Package, env *compile.Env) *JavaFileInfo {
	hasConsts := false
	for _, file := range pkg.Files {
		if javaHasConsts(file) {
			hasConsts = true
			break
		}
	}
	if !hasConsts {
		return nil
	}
	data := struct {
		Package *compile.Package
		Imports javaUserImports
		Env     *compile.Env
	}{
		Package: pkg,
		Imports: javaConstImports(pkg, env),
		Env:     env,
	}
	var buf bytes.Buffer
	err := javaConstTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatalf("vdl: couldn't execute const template: %v", err)
	}
	return &JavaFileInfo{
		Name: "Consts.java",
		Data: buf.Bytes(),
	}
}

const javaConstTmplStr = `{{$data := .}}{{$forceClass := true}}// This file was auto-generated by the veyron vdl tool.
// Source(s):{{range $file := $data.Package.Files}} {{$file.BaseName}}{{end}}
package {{javaPath (javaGenPkgPath $data.Package.Path)}};
{{range $imp := javaImports $data.Imports $data.Package}}
import {{$imp}};{{end}}

public class Consts { {{range $file := $data.Package.Files}}{{if javaHasConsts $file}}
	/* The following constants originate in file: {{$file.BaseName}}. */{{range $const := $file.ConstDefs}}
	{{$const.Doc}}public static final {{javaType $const.Value.Type (not $forceClass) $data.Imports $data.Env}} {{toConstCase $const.Name}} = {{javaConstVal $const.Value $data.Imports $data.Env}};{{$const.DocSuffix}}{{end}}{{range $eid := $file.ErrorIDs}}
	{{$eid.Doc}}public static final {{javaName "java/lang/String" $data.Imports}} {{toConstCase $eid.Name}} = new {{javaName "java/lang/String" $data.Imports}}("{{$eid.ID}}");{{$eid.DocSuffix}}{{end}}{{end}}{{end}}
}
`

// genStructFile generates the Java class file for the provided struct.
func genJavaClassFile(tdef *compile.TypeDef, env *compile.Env) JavaFileInfo {
	data := struct {
		TypeDef *compile.TypeDef
		Imports javaUserImports
		Env     *compile.Env
	}{
		TypeDef: tdef,
		Imports: javaStructImports(tdef, env),
		Env:     env,
	}
	var buf bytes.Buffer
	err := javaClassTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatalf("vdl: couldn't execute struct template: %v", err)
	}
	return JavaFileInfo{
		Name: tdef.Name + ".java",
		Data: buf.Bytes(),
	}
}

const javaClassTmplStr = `
{{$data := .}}{{$typeDef := $data.TypeDef}}{{$forceClass := true}}// This file was auto-generated by the veyron vdl tool.
// Source: {{$typeDef.File.BaseName}}
package {{javaPath (javaGenPkgPath $typeDef.File.Package.Path)}};
{{range $imp := javaImports $data.Imports $typeDef.File.Package}}
import {{$imp}};{{end}}

{{javaDoc $typeDef.Doc}}public class {{javaQualifiedName $typeDef.Name $typeDef.File $data.Imports}} { {{range $idx, $field := javaStructFields $typeDef.Type}}
	{{index $typeDef.FieldDoc $idx}}public {{javaType $field.Type (not $forceClass) $data.Imports $data.Env}} {{toCamelCase $field.Name}};{{index $typeDef.FieldDocSuffix $idx}}{{end}}
}
`

// genJavaIfaceFile generates the Java interface file for the provided
// interface.
func genJavaIfaceFile(iface *compile.Interface, isService bool, env *compile.Env) JavaFileInfo {
	data := struct {
		Interface *compile.Interface
		IsService bool
		Imports   javaUserImports
		Env       *compile.Env
	}{
		Interface: iface,
		IsService: isService,
		Imports:   javaIfaceImports(iface, isService, env),
		Env:       env,
	}
	var buf bytes.Buffer
	err := javaIfaceTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatalf("vdl: couldn't execute struct template: %v", err)
	}
	name := iface.Name
	if isService {
		name += "Service"
	}
	name += ".java"
	return JavaFileInfo{
		Name: name,
		Data: buf.Bytes(),
	}
}

const javaIfaceTmplStr = `{{$data := .}}{{$iface := $data.Interface}}{{$forceClass := true}}{{$camelCase := true}}// This file was auto-generated by the veyron vdl tool.
// Source: {{$iface.File.BaseName}}
package {{javaPath (javaGenPkgPath $iface.File.Package.Path)}};
{{range $imp := javaImports $data.Imports $iface.File.Package}}
import {{$imp}};{{end}}

{{javaDoc $iface.Doc}}public interface {{$iface.Name}}{{if $data.IsService}}Service{{end}}{{if gt (len $iface.Embeds) 0}} extends {{end}}{{range $idx, $eIface := $iface.Embeds}}{{if gt $idx 0}}, {{end}}{{javaIfaceName $eIface $data.IsService $data.Imports}}{{end}} { {{range $method := $iface.Methods}}{{if gt (len (javaNonErrorOutArgs $method)) 1}}
	// {{$method.Name}}Out packages output arguments for method {{$method.Name}}.
	public class {{javaQualifiedName (printf "%sOut" $method.Name) $iface.File $data.Imports}} { {{range $arg := javaNonErrorOutArgs $method}}
		{{$arg.Doc}}public {{javaType $arg.Type (not $forceClass) $data.Imports $data.Env}} {{toCamelCase $arg.Name}};{{$arg.DocSuffix}}{{end}}
	}{{end}}
	{{$method.Doc}}	public {{javaOutArgType $method $iface $data.IsService (not $forceClass) $data.Imports $data.Env}} {{toCamelCase $method.Name}}({{javaInArgs $method $iface $data.IsService $camelCase $data.Imports $data.Env}}) throws {{javaName "com/veyron2/ipc/VeyronException" $data.Imports}};{{$method.DocSuffix}}{{end}}
}
`

// genJavaClientFile generates the Java file containing client bindings for
// all interfaces in the provided package.
func genJavaClientFile(pkg *compile.Package, env *compile.Env) JavaFileInfo {
	data := struct {
		Package *compile.Package
		Imports javaUserImports
		Env     *compile.Env
	}{
		Package: pkg,
		Imports: javaClientImports(pkg, env),
		Env:     env,
	}
	var buf bytes.Buffer
	err := javaClientTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatal("vdl: couldn't execute client template: %v", err)
	}
	return JavaFileInfo{
		Name: "Client.java",
		Data: buf.Bytes(),
	}
}

const javaClientTmplStr = `{{$data := .}}{{$forceClass := true}}{{$isService := true}}{{$camelCase := true}}{{$clientClassName := javaName "com/veyron2/ipc/Client" $data.Imports}}{{$stringClassName := javaName "java/lang/String" $data.Imports}}{{$veyronExceptionClassName := javaName "com/veyron2/ipc/VeyronException" $data.Imports}}// This file was auto-generated by the veyron vdl tool.
// Source(s): {{range $file := $data.Package.Files}} {{$file.BaseName}}{{end}}
package {{javaPath (javaGenPkgPath $data.Package.Path)}};
{{range $imp := javaImports $data.Imports $data.Package}}
import {{$imp}};{{end}}

public class Client { {{range $file := $data.Package.Files}}
	/* Bind methods for interfaces in file: {{$file.BaseName}}. */{{range $iface := $file.Interfaces}}{{$ifaceClassName := javaIfaceName $iface (not $isService) $data.Imports}}
	@SuppressWarnings("unused")
	public static {{$ifaceClassName}} bind{{$ifaceClassName}}({{$stringClassName}} name, {{$clientClassName}}.BindOption... opts) {
		// TODO(spetrovic): check bind options.{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface (not $isService) $data.Imports}}
		final {{$eIfaceClassName}} {{javaClassToVarName $eIfaceClassName}} = {{javaName (printf "%s/Client" (javaGenPkgPath $eIface.File.Package.Path)) $data.Imports}}.bind{{$eIface.Name}}(name, opts);{{end}}
		final {{$clientClassName}} client = {{javaName "com/veyron2/runtime/RuntimeFactory" $data.Imports}}.getRuntime().getClient();
		return new {{$ifaceClassName}}Stub(client, name{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface (not $isService) $data.Imports}}, {{javaClassToVarName $eIfaceClassName}}{{end}});
	}{{end}}{{end}}
	{{range $file := $data.Package.Files}}
	/* Client stubs for interfaces in file: {{$file.BaseName}}. */{{range $iface := $file.Interfaces}}{{$ifaceClassName := javaIfaceName $iface (not $isService) $data.Imports}}
	private static class {{$ifaceClassName}}Stub implements {{$ifaceClassName}} {
		private final {{$clientClassName}} client;
		private final {{$stringClassName}} name;{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface (not $isService) $data.Imports}}
		private final {{$eIfaceClassName}} {{javaClassToVarName $eIfaceClassName}};{{end}}

		{{$ifaceClassName}}Stub({{$clientClassName}} client, {{$stringClassName}} name{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface (not $isService) $data.Imports}}, {{$eIfaceClassName}} {{javaClassToVarName $eIfaceClassName}}{{end}}) {
			this.client = client;
			this.name = name;{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface (not $isService) $data.Imports}}{{$varName := javaClassToVarName $eIfaceClassName}}
			this.{{$varName}} = {{$varName}};{{end}}
		}{{if gt (len $iface.Methods) 0}}
		// Methods from interface {{$iface.Name}}.{{end}}{{range $method := $iface.Methods}}
		@Override
		public {{javaOutArgType $method $iface (not $isService) (not $forceClass) $data.Imports $data.Env}} {{toCamelCase $method.Name}}({{javaInArgs $method $iface (not $isService) (not $camelCase) $data.Imports $data.Env}}) throws {{$veyronExceptionClassName}} {
			// Prepare input arguments.{{$objectClassName := javaName "java/lang/Object" $data.Imports}}
			final {{$objectClassName}}[] inArgs = new {{$objectClassName}}[]{ {{range $idx, $arg := $method.InArgs}}{{if gt $idx 0}}, {{end}}{{$arg.Name}}{{end}} };

			// Start the call.
			final {{$clientClassName}}.Call call = this.client.startCall(context, this.name, "{{$method.Name}}", inArgs, opts);
			{{if javaIsStreamingMethod $method}}{{$typeTokenClassName := javaName "com/google/common/reflect/TypeToken" $data.Imports}}{{$streamClassName := javaName "com/veyron2/vdl/ClientStream" $data.Imports}}{{$streamSend := javaType $method.InStream $forceClass $data.Imports $data.Env}}{{$streamRecv := javaType $method.OutStream $forceClass $data.Imports $data.Env}}{{$streamFinish := javaNonStreamingOutArgType $method $iface (not $isService) $forceClass $data.Imports $data.Env}}
			return new {{$streamClassName}}<{{$streamSend}}, {{$streamRecv}}, {{$streamFinish}}>() {
				@Override
				public void send({{$streamSend}} item) throws {{$veyronExceptionClassName}} {
					call.send(item);
				}
				@Override
				public {{$streamRecv}} recv() throws {{javaName "java/io/EOFException" $data.Imports}}, {{$veyronExceptionClassName}} {
					final {{$typeTokenClassName}}<?> type = new {{$typeTokenClassName}}<{{$streamRecv}}>() {};
					final {{$objectClassName}} result = call.recv(type);
					try {
						return ({{$streamRecv}})result;
					} catch ({{javaName "java/lang/ClassCastException" $data.Imports}} e) {
						throw new {{$veyronExceptionClassName}}("Unexpected result type: " + result.getClass().getCanonicalName());
					}
				}
				@Override
				public {{$streamFinish}} finish() throws {{$veyronExceptionClassName}} {
					{{template "resultFetch" (javaClientResultFetchArgs $method $iface $forceClass "\t\t\t\t\t" $data.Imports $data.Env)}}
				}
			};{{else}}
			{{template "resultFetch" (javaClientResultFetchArgs $method $iface (not $forceClass) "\t\t\t" $data.Imports $data.Env)}}{{end}}
		}{{end}}{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface (not $isService) $data.Imports}}{{$allMethods := javaAllMethods $eIface}}{{if gt (len $allMethods) 0}}
		// Methods from sub-interface {{$eIface.Name}}.{{end}}{{range $method := $allMethods}}{{$outArgType := javaOutArgType $method $eIface (not $isService) (not $forceClass) $data.Imports $data.Env}}
		@Override
		public {{$outArgType}} {{toCamelCase $method.Name}}({{javaInArgs $method $iface (not $isService) (not $camelCase) $data.Imports $data.Env}}) throws {{javaName "com/veyron2/ipc/VeyronException" $data.Imports}} {
			{{if ne $outArgType "void"}}return {{end}}this.{{javaClassToVarName $eIfaceClassName}}.{{toCamelCase $method.Name}}(context{{range $idx, $arg := $method.InArgs}}, {{$arg.Name}}{{end}}, opts);
		}{{end}}{{end}}
	}{{end}}{{end}}
}{{define "resultFetch"}}{{$data := .}}{{$forceClass := true}}{{$isService := true}}{{$typeTokenClassName := javaName "com/google/common/reflect/TypeToken" $data.Imports}}{{$objectClassName := javaName "java/lang/Object" $data.Imports}}// Prepare output argument and finish the call.{{$outArgs := javaNonErrorOutArgs $data.Method}}{{$outArgType := javaNonStreamingOutArgType $data.Method $data.Interface (not $isService) $data.ForceClass $data.Imports $data.Env}}
{{$data.Indent}}final {{$typeTokenClassName}}<?>[] resultTypes = new {{$typeTokenClassName}}<?>[]{ {{range $idx, $arg := $outArgs}}{{if gt $idx 0}}, {{end}}new {{$typeTokenClassName}}<{{javaType $arg.Type $forceClass $data.Imports $data.Env}}>() {}{{end}} };{{if eq (len $outArgs) 0}}
{{$data.Indent}}call.finish(resultTypes);{{if ne $outArgType "void"}}
{{$data.Indent}}return null;{{end}}{{else}}{{if eq (len $outArgs) 1}}
{{$data.Indent}}return ({{$outArgType}})call.finish(resultTypes)[0];{{else}}
{{$data.Indent}}final {{$objectClassName}}[] results = call.finish(resultTypes);
{{$data.Indent}}// Pack the results.
{{$data.Indent}}final {{$outArgType}} ret = new {{$outArgType}}();
{{$data.Indent}}int resultIdx = 0;{{range $arg := $outArgs}}
{{$data.Indent}}ret.{{toCamelCase $arg.Name}} = ({{javaType $arg.Type $forceClass $data.Imports $data.Env}})results[resultIdx++];{{end}}
{{$data.Indent}}return ret;{{end}}{{end}}
{{end}}
`

// genJavaServerFile generates the Java file containing server stubs for all
// interfaces in the provided package.
func genJavaServerFile(pkg *compile.Package, env *compile.Env) JavaFileInfo {
	data := struct {
		Package *compile.Package
		Imports javaUserImports
		Env     *compile.Env
	}{
		Package: pkg,
		Imports: javaServerImports(pkg, env),
		Env:     env,
	}
	var buf bytes.Buffer
	err := javaServerTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatal("vdl: couldn't execute server template: %v", err)
	}
	return JavaFileInfo{
		Name: "Server.java",
		Data: buf.Bytes(),
	}
}

const javaServerTmplStr = `{{$data := .}}{{$forceClass := true}}{{$isService := true}}{{$objectClassName := javaName "java/lang/Object" $data.Imports}}{{$serverCallClassName := javaName "com/veyron2/ipc/ServerCall" $data.Imports}}{{$veyronExceptionClassName := javaName "com/veyron2/ipc/VeyronException" $data.Imports}}// This file was auto-generated by the veyron vdl tool.
// Source(s): {{range $file := $data.Package.Files}} {{$file.BaseName}}{{end}}
package {{javaPath (javaGenPkgPath $data.Package.Path)}};
{{range $imp := javaImports $data.Imports $data.Package}}
import {{$imp}};{{end}}

public class Server { {{range $file := $data.Package.Files}}
	/* Server stub creation methods for interfaces in file: {{$file.BaseName}}. */{{range $iface := $file.Interfaces}}{{$ifaceClassName := javaIfaceName $iface $isService $data.Imports}}
	public static {{$objectClassName}} new{{$iface.Name}}({{$ifaceClassName}} service) { {{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface $isService $data.Imports}}{{$eIfaceServerClassName := javaQualifiedName "Server" $eIface.File $data.Imports}}{{$eIfaceStubClassName := printf "%s.%sStub" $eIfaceServerClassName $eIface.Name}}
		final {{$eIfaceStubClassName}} {{javaClassToVarName $eIfaceClassName}} = ({{$eIfaceStubClassName}}){{$eIfaceServerClassName}}.new{{$eIface.Name}}(service);{{end}}
		return new {{$iface.Name}}Stub(service{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface $isService $data.Imports}}, {{javaClassToVarName $eIfaceClassName}}{{end}});
	}{{end}}{{end}}
	{{range $file := $data.Package.Files}}
	/* Server stubs for interfaces in file: {{$file.BaseName}}. */{{range $iface := $file.Interfaces}}{{$ifaceClassName := javaIfaceName $iface $isService $data.Imports}}
	public static class {{$iface.Name}}Stub {
		private final {{$ifaceClassName}} service;{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface $isService $data.Imports}}{{$eIfaceServerClassName := javaQualifiedName "Server" $eIface.File $data.Imports}}{{$eIfaceStubClassName := printf "%s.%sStub" $eIfaceServerClassName $eIface.Name}}
		private final {{$eIfaceStubClassName}} {{javaClassToVarName $eIfaceClassName}};{{end}}

		{{$iface.Name}}Stub({{$ifaceClassName}} service{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface $isService $data.Imports}}{{$eIfaceServerClassName := javaQualifiedName "Server" $eIface.File $data.Imports}}{{$eIfaceStubClassName := printf "%s.%sStub" $eIfaceServerClassName $eIface.Name}}, {{$eIfaceStubClassName}} {{javaClassToVarName $eIfaceClassName}}{{end}}) {
			this.service = service;{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface $isService $data.Imports}}
			this.{{javaClassToVarName $eIfaceClassName}} = {{javaClassToVarName $eIfaceClassName}};{{end}}
		}
		/**
		 * Returns all tags associated with the provided method or null if the method isn't implemented
		 * by this service.
		 */
		@SuppressWarnings("unused")
		public {{$objectClassName}}[] getMethodTags({{$serverCallClassName}} call, String method) { {{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface $isService $data.Imports}}
			{
				final {{$objectClassName}}[] tags = this.{{javaClassToVarName $eIfaceClassName}}.getMethodTags(call, method);
				if (tags != null) return tags;
			}{{end}}{{range $method := $iface.Methods}}
			if (method == "{{$method.Name}}") {
				return new Object[]{ {{range $idx, $tag := $method.Tags}}{{if gt $idx 0}}, {{end}}{{javaConstVal $tag $data.Imports $data.Env}}{{end}} };
			}{{end}}
			return null;
		}
		// Methods from interface {{$iface.Name}}.{{range $method := $iface.Methods}}{{$outArgType := javaNonStreamingOutArgType $method $iface $isService (not $forceClass) $data.Imports $data.Env}}
		public {{$outArgType}} {{toCamelCase $method.Name}}({{$serverCallClassName}} call{{range $arg := $method.InArgs}}, {{javaType $arg.Type (not $forceClass) $data.Imports $data.Env}} {{$arg.Name}}{{end}}) throws {{$veyronExceptionClassName}} { {{if javaIsStreamingMethod $method}}{{$classCastExceptionClassName := javaName "java/lang/ClassCastException" $data.Imports}}{{$typeTokenClassName := javaName "com/google/common/reflect/TypeToken" $data.Imports}}{{$streamClassName := javaName "com/veyron2/vdl/Stream" $data.Imports}}{{$streamSend := javaType $method.OutStream $forceClass $data.Imports $data.Env}}{{$streamRecv := javaType $method.InStream $forceClass $data.Imports $data.Env}}
			final {{$serverCallClassName}} serverCall = call;
			final {{$streamClassName}}<{{$streamSend}},{{$streamRecv}}> stream = new {{$streamClassName}}<{{$streamSend}},{{$streamRecv}}>() {
				@Override
				public void send({{$streamSend}} item) throws {{$veyronExceptionClassName}} {
					serverCall.send(item);
				}
				@Override
				public {{$streamRecv}} recv() throws {{javaName "java/io/EOFException" $data.Imports}}, {{$veyronExceptionClassName}} {
					final {{$typeTokenClassName}}<?> type = new {{$typeTokenClassName}}<{{$streamRecv}}>() {};
					final {{$objectClassName}} result = serverCall.recv(type);
					try {
						return ({{$streamRecv}})result;
					} catch ({{$classCastExceptionClassName}} e) {
						throw new {{$veyronExceptionClassName}}("Unexpected result type: " + result.getClass().getCanonicalName());
					}
				}
			};{{end}}
			{{if ne $outArgType "void"}}return {{end}}this.service.{{toCamelCase $method.Name}}(call{{range $arg := $method.InArgs}}, {{$arg.Name}}{{end}}{{if javaIsStreamingMethod $method}}, stream{{end}});
		}{{end}}{{range $eIface := $iface.Embeds}}{{$eIfaceClassName := javaIfaceName $eIface $isService $data.Imports}}{{$allMethods := javaAllMethods $eIface}}{{if gt (len $allMethods) 0}}
		// Methods from sub-interface {{$eIface.Name}}.{{end}}{{range $method := $allMethods}}{{$outArgType := javaNonStreamingOutArgType $method $eIface $isService (not $forceClass) $data.Imports $data.Env}}
		public {{$outArgType}} {{toCamelCase $method.Name}}({{$serverCallClassName}} call{{range $arg := $method.InArgs}}, {{javaType $arg.Type (not $forceClass) $data.Imports $data.Env}} {{$arg.Name}}{{end}}) throws {{$veyronExceptionClassName}} {
			{{if ne $outArgType "void"}}return {{end}}this.{{javaClassToVarName $eIfaceClassName}}.{{toCamelCase $method.Name}}(call{{range $arg := $method.InArgs}}, {{$arg.Name}}{{end}});
		}{{end}}{{end}}
	}{{end}}{{end}}
}
`

// javaUserImports stores Java class imports found in user-specified code (i.e.,
// structs, interfaces, consts).  These imports are stores as a map of
// ClassName -> ClassPkgPath.
type javaUserImports map[string]string

// javaConstImports returns Java class imports originating in the constant
// definitions of all VDL files in the provided package.
func javaConstImports(pkg *compile.Package, env *compile.Env) javaUserImports {
	var classPaths []string
	for _, file := range pkg.Files {
		for _, cdef := range file.ConstDefs {
			classPaths = append(classPaths, javaClassPaths(cdef.Value.Type(), env)...)
		}
		if len(file.ErrorIDs) > 0 {
			classPaths = append(classPaths, "java/lang/String")
		}
	}
	return genJavaUserImports(classPaths, pkg)
}

// javaStructImports returns Java class imports originating in the provided
// struct definition.
func javaStructImports(tdef *compile.TypeDef, env *compile.Env) javaUserImports {
	classPaths := javaClassPaths(tdef.Type, env)
	for _, field := range javaStructFields(tdef.Type) {
		classPaths = append(classPaths, javaClassPaths(field.Type, env)...)
	}
	return genJavaUserImports(classPaths, tdef.File.Package)
}

// javaIfaceImports returns Java class imports originating in the provided
// interface definition.
func javaIfaceImports(iface *compile.Interface, isService bool, env *compile.Env) javaUserImports {
	classPaths := javaIfaceClassPaths(iface, isService, env)
	if isService {
		classPaths = append(classPaths, "com/veyron2/ipc/ServerContext")
	}
	return genJavaUserImports(classPaths, iface.File.Package)
}

// javaClientsImports returns Java class imports for the Java client file, which
// provides client stub implementations for all the interfaces in the provided
// package.
func javaClientImports(pkg *compile.Package, env *compile.Env) javaUserImports {
	var classPaths []string
	hasStreaming := false
	for _, file := range pkg.Files {
		for _, iface := range file.Interfaces {
			classPaths = append(classPaths, javaIfaceClassPaths(iface, false, env)...)
			for _, method := range iface.Methods {
				if javaIsStreamingMethod(method) {
					hasStreaming = true
				}
			}
			for _, eIface := range iface.Embeds {
				// Name of the embedded interface will be added twice, but that's fine.
				classPaths = append(classPaths, javaIfaceClassPaths(eIface, false, env)...)
			}
		}
	}
	// Add all the classes used in the client stub implementations.
	classPaths = append(classPaths, []string{
		path.Join(javaGenPkgPath(pkg.Path), "Client"),
		"com/veyron2/ipc/Client",
		"com/veyron2/runtime/RuntimeFactory",
		"java/lang/String",
		"java/lang/Object",
		"com/google/common/reflect/TypeToken",
	}...)
	if hasStreaming {
		classPaths = append(classPaths, []string{
			"java/lang/ClassCastException",
		}...)
	}
	return genJavaUserImports(classPaths, pkg)
}

// javaServerImports returns Java class imports for the Java server file, which
// provides server stub implementations for all the interfaces in the provided
// package.
func javaServerImports(pkg *compile.Package, env *compile.Env) javaUserImports {
	var classPaths []string
	hasStreaming := false
	for _, file := range pkg.Files {
		for _, iface := range file.Interfaces {
			classPaths = append(classPaths, javaIfaceClassPaths(iface, true, env)...)
			for _, method := range iface.Methods {
				if javaIsStreamingMethod(method) {
					hasStreaming = true
				}
			}
			for _, eIface := range iface.Embeds {
				// Name of the embedded interface will be added twice, but that's fine.
				classPaths = append(classPaths, javaIfaceClassPaths(eIface, true, env)...)
				classPaths = append(classPaths, path.Join(javaGenPkgPath(eIface.File.Package.Path), "Server"))
			}
		}
	}
	// Add all the classes used in the server stub implementations.
	classPaths = append(classPaths, []string{
		path.Join(javaGenPkgPath(pkg.Path), "Server"),
		"java/lang/Object",
		"com/veyron2/ipc/ServerCall",
	}...)
	if hasStreaming {
		classPaths = append(classPaths, []string{
			"com/veyron2/vdl/Stream",
			"com/google/common/reflect/TypeToken",
		}...)
	}
	return genJavaUserImports(classPaths, pkg)
}

// genjavaUserImports generates the final list of Java class imports, given the
// list of class paths.
func genJavaUserImports(classPaths []string, pkg *compile.Package) (ret javaUserImports) {
	// Sort all the class paths so that we get deterministic ordering;
	// it would be annoying for imported/non-imported class names to
	// change between runs.
	sort.StringSlice(classPaths).Sort()

	// Decide which class names to keep.  Here is the list of rules in order of
	// their preference:
	//   1) Prefer local classes.
	//   2) Prefer system classes (e.g., "java.lang.*").
	//   3) Prefer classes that are lexicographically smaller.
	ret = make(javaUserImports)
	for _, class := range classPaths {
		cur, ok := ret[path.Base(class)]
		switch {
		case !ok:
			ret[path.Base(class)] = path.Dir(class)
		case path.Dir(class) == javaGenPkgPath(pkg.Path):
			ret[path.Base(class)] = path.Dir(class)
		case path.Dir(class) == "java/lang" && path.Dir(cur) != pkg.Path:
			ret[path.Base(class)] = path.Dir(class)
		}
	}
	return
}

// javaClassPaths returns pathnames of all Java classes originating in the
// provided type.
func javaClassPaths(t *val.Type, env *compile.Env) (ret []string) {
	if t == nil {
		typeStr, _ := javaPrimitiveType(nil, true)
		return []string{typeStr}
	}
	if def := env.FindTypeDef(t); def != nil {
		return javaNamedClassPaths(def, env)
	}
	switch t.Kind() {
	case val.Array:
		ret = javaClassPaths(t.Elem(), env)
	case val.List:
		ret = append(ret, "java/util/ArrayList")
		ret = append(ret, javaClassPaths(t.Elem(), env)...)
	case val.Set:
		ret = append(ret, "java/util/HashSet")
		ret = append(ret, javaClassPaths(t.Key(), env)...)
	case val.Map:
		ret = append(ret, "java/util/HashMap")
		ret = append(ret, javaClassPaths(t.Key(), env)...)
		ret = append(ret, javaClassPaths(t.Elem(), env)...)
	default:
		log.Fatalf("vdl: javaClassPaths unhandled type %#v", t)
	}
	return
}

func javaNamedClassPaths(def *compile.TypeDef, env *compile.Env) []string {
	if def.File == compile.BuiltInFile {
		t, _ := javaPrimitiveType(def, true)
		return []string{t}
	}
	switch def.Type.Kind() {
	case val.Struct:
		return []string{path.Join(javaGenPkgPath(def.File.Package.Path), def.Name)}
	default:
		// Not a named struct/interface - recurse through the underlying type,
		// effectively getting rid of this (named) typedef.
		return javaClassPaths(def.BaseType, env)
	}
}

// javaIfaceClassPaths returns all class paths originating in the provided
// interface.
func javaIfaceClassPaths(iface *compile.Interface, isService bool, env *compile.Env) (ret []string) {
	ret = []string{javaIfacePathName(iface, isService)}
	for _, m := range iface.Methods {
		if javaIsStreamingMethod(m) {
			ret = append(ret, javaStreamClassPaths(m, iface, isService, env)...)
		}
		if !isService {
			ret = append(ret, "com/veyron2/ipc/Client")
			ret = append(ret, "com/veyron2/ipc/Context")
		}
		for _, iarg := range m.InArgs {
			ret = append(ret, javaClassPaths(iarg.Type, env)...)
		}
		for _, oarg := range m.OutArgs {
			ret = append(ret, javaClassPaths(oarg.Type, env)...)
		}
		if (!javaIsStreamingMethod(m) || isService) && len(m.OutArgs) > 2 {
			ret = append(ret, path.Join(javaGenPkgPath(iface.File.Package.Path), m.Name+"Out"))
		}
	}
	for _, eIface := range iface.Embeds {
		ret = append(ret, javaIfacePathName(eIface, isService))
	}
	return
}

// javaStreamClassPaths returns all class paths originating in the provided
// methods streaming argument.
func javaStreamClassPaths(method *compile.Method, iface *compile.Interface, isService bool, env *compile.Env) (ret []string) {
	if !javaIsStreamingMethod(method) {
		return
	}
	if isService {
		ret = append(ret, "com/veyron2/vdl/Stream")
	} else {
		ret = append(ret, "com/veyron2/vdl/ClientStream")
	}
	ret = append(ret, javaClassPaths(method.InStream, env)...)
	ret = append(ret, javaClassPaths(method.OutStream, env)...)
	if !isService {
		switch len(method.OutArgs) {
		case 0:
			log.Fatalf("vdl: method must have at least one output arg (i.e., error): %v", method)
		case 1:
			ret = append(ret, javaClassPaths(nil, env)...)
		case 2:
			ret = append(ret, javaClassPaths(method.OutArgs[0].Type, env)...)
		default:
			ret = append(ret, path.Join(javaGenPkgPath(iface.File.Package.Path), method.Name+"Out"))
		}
	}
	return
}

// javaType returns the Java type string given the provided VDL type.  It
// consults the provided imports map to see if the full pathnames or only
// base names can be used (e.g., "java.util.HashMap" or "HashMap").
func javaType(t *val.Type, forceClass bool, imports javaUserImports, env *compile.Env) string {
	if t == nil {
		name, class := javaPrimitiveType(nil, forceClass)
		if class {
			return javaName(name, imports)
		}
		return name
	}
	if def := env.FindTypeDef(t); def != nil {
		return javaNamedType(def, forceClass, imports, env)
	}
	switch t.Kind() {
	case val.Array:
		return fmt.Sprintf("%s[]", javaType(t.Elem(), false, imports, env))
	case val.List:
		return fmt.Sprintf("%s<%s>", javaName("java/util/ArrayList", imports), javaType(t.Elem(), true, imports, env))
	case val.Set:
		return fmt.Sprintf("%s<%s>", javaName("java/util/HashSet", imports), javaType(t.Key(), true, imports, env))
	case val.Map:
		return fmt.Sprintf("%s<%s, %s>", javaName("java/util/HashMap", imports), javaType(t.Key(), true, imports, env), javaType(t.Elem(), true, imports, env))
	default:
		log.Fatalf("vdl: javaType unhandled type %v %v", t.Kind(), t)
		return ""
	}
}

func javaNamedType(def *compile.TypeDef, forceClass bool, imports javaUserImports, env *compile.Env) string {
	if def.File == compile.BuiltInFile {
		name, class := javaPrimitiveType(def, forceClass)
		if class {
			return javaName(name, imports)
		}
		return name
	}
	switch def.Type.Kind() {
	case val.Struct:
		return javaQualifiedName(def.Name, def.File, imports)
	default:
		// Not a named struct/interface - recurse through the underlying type,
		// effectively getting rid of this (named) typedef.
		return javaType(def.BaseType, forceClass, imports, env)
	}
}

// javaPrimitiveType returns the type name for the provided primitive type
// definition, forcing the use of a java class (e.g., java.lang.Integer) if so
// desired.  This method also returns a boolean value indicating whether the
// returned type is a class.
func javaPrimitiveType(def *compile.TypeDef, forceClass bool) (string, bool) {
	if def == nil {
		if forceClass {
			return "java/lang/Void", true
		} else {
			return "void", false
		}
	}
	if def.Name == "error" {
		return "com/veyron2/ipc/VeyronException", true
	}
	switch def.Type.Kind() {
	case val.Bool:
		if forceClass {
			return "java/lang/Boolean", true
		} else {
			return "boolean", false
		}
	case val.Byte:
		if forceClass {
			return "java/lang/Byte", true
		} else {
			return "byte", false
		}
	case val.Uint16, val.Int16:
		if forceClass {
			return "java/lang/Short", true
		} else {
			return "short", false
		}
	case val.Uint32, val.Int32:
		if forceClass {
			return "java/lang/Integer", true
		} else {
			return "int", false
		}
	case val.Uint64, val.Int64:
		if forceClass {
			return "java/lang/Long", true
		} else {
			return "long", false
		}
	case val.Float32:
		if forceClass {
			return "java/lang/Float", true
		} else {
			return "float", false
		}
	case val.Float64:
		if forceClass {
			return "java/lang/Double", true
		} else {
			return "double", false
		}
	case val.Complex64, val.Complex128:
		return "org/apache/commons/math3/complex/Complex", true
	case val.String:
		return "java/lang/String", true
	// TODO(spetrovic): handle typeval correctly.
	case val.Any, val.TypeVal:
		return "java/lang/Object", true
	default:
		log.Fatalf("unexpected primitive type %q", def)
		return "", false
	}
}

// javaStreamType returns the stream type for the given (streaming) method.
func javaStreamType(method *compile.Method, iface *compile.Interface, isService bool, imports javaUserImports, env *compile.Env) (ret string) {
	if !javaIsStreamingMethod(method) {
		return ""
	}
	if isService {
		ret = javaName("com/veyron2/vdl/Stream", imports)
	} else {
		ret = javaName("com/veyron2/vdl/ClientStream", imports)
	}
	var sendType, recvType string
	if !isService {
		sendType = javaType(method.InStream, true, imports, env)
		recvType = javaType(method.OutStream, true, imports, env)
	} else {
		sendType = javaType(method.OutStream, true, imports, env)
		recvType = javaType(method.InStream, true, imports, env)
	}
	ret += "<" + sendType + "," + recvType
	if !isService {
		ret += "," + javaNonStreamingOutArgType(method, iface, isService, true, imports, env)
	}
	ret += ">"
	return
}

// javaConstVal returns the value string for the provided constant.
func javaConstVal(v *val.Value, imports javaUserImports, env *compile.Env) string {
	switch v.Kind() {
	case val.Bool:
		if v.Bool() {
			return "true"
		} else {
			return "false"
		}
	case val.Byte:
		return strconv.FormatUint(uint64(v.Byte()), 10)
	case val.Uint16, val.Uint32, val.Uint64:
		return strconv.FormatUint(v.Uint(), 10)
	case val.Int16, val.Int32, val.Int64:
		return strconv.FormatInt(v.Int(), 10)
	case val.Float32, val.Float64:
		return strconv.FormatFloat(v.Float(), 'g', -1, bitlen(v.Kind()))
	case val.Complex64, val.Complex128:
		r := strconv.FormatFloat(real(v.Complex()), 'g', -1, bitlen(v.Kind()))
		i := strconv.FormatFloat(imag(v.Complex()), 'g', -1, bitlen(v.Kind()))
		return fmt.Sprintf("new %s(%s, %s)", javaType(v.Type(), true, imports, env), r, i)
	case val.String:
		return strconv.Quote(v.RawString())
	}
	if v.Type().IsBytes() {
		return strconv.Quote(string(v.Bytes()))
	}
	// TODO(spetrovic): Handle Enum, List, Map, Struct, OneOf, Any
	panic(fmt.Errorf("vdl: javaConstVal unhandled type %v %v", v.Kind(), v.Type()))
}

// javaImports prunes the provided imports list, removing the unnecessary
// imports, and returns the pruned list in the Java format.
func javaImports(imports javaUserImports, pkg *compile.Package) (ret []string) {
	for base, dir := range imports {
		if dir == javaGenPkgPath(pkg.Path) || dir == "java/lang" {
			continue
		}
		ret = append(ret, javaPath(path.Join(dir, base)))
	}
	sort.StringSlice(ret).Sort()
	return
}

// javaOutArg returns the type for the (single) output argument for the provided
// method.
func javaOutArgType(method *compile.Method, iface *compile.Interface, isService, forceClass bool, imports javaUserImports, env *compile.Env) string {
	if javaIsStreamingMethod(method) && !isService {
		// Clients get a single output stream argument.
		return javaStreamType(method, iface, isService, imports, env)
	}
	return javaNonStreamingOutArgType(method, iface, isService, forceClass, imports, env)
}

// javaNonStreamingOutArgType returns the type for the non-streaming output arguments of the
// provided method.
func javaNonStreamingOutArgType(method *compile.Method, iface *compile.Interface, isService, forceClass bool, imports javaUserImports, env *compile.Env) string {
	switch len(method.OutArgs) {
	case 0:
		log.Fatalf("vdl: method must have at least one output arg (i.e., error): %v", method)
		return ""
	case 1:
		return javaType(nil, forceClass, imports, env)
	case 2:
		return javaType(method.OutArgs[0].Type, forceClass, imports, env)
	default:
		return javaIfaceName(iface, isService, imports) + "." + method.Name + "Out"
	}
}

// javaNonErrorOutArgs returns the list of non-error output arguments for the
// provided method.
func javaNonErrorOutArgs(method *compile.Method) []*compile.Arg {
	return method.OutArgs[:len(method.OutArgs)-1]
}

func javaIsStreamingMethod(method *compile.Method) bool {
	return method.InStream != nil || method.OutStream != nil
}

// javaInArgs returns the in-args string for the provided method.
func javaInArgs(method *compile.Method, iface *compile.Interface, isService, camelCase bool, imports javaUserImports, env *compile.Env) (ret string) {
	if isService {
		ret += javaName("com/veyron2/ipc/ServerContext", imports) + " context"
	} else {
		ret += javaName("com/veyron2/ipc/Context", imports) + " context"
	}
	for _, arg := range method.InArgs {
		if ret != "" {
			ret += ", "
		}
		argName := arg.Name
		if camelCase {
			argName = toCamelCase(argName)
		}
		ret += javaType(arg.Type, false, imports, env) + " " + argName
	}
	if !isService {
		if ret != "" {
			ret += ", "
		}
		ret += javaName("com/veyron2/ipc/Client", imports) + ".CallOption... opts"
	}
	if javaIsStreamingMethod(method) && isService {
		// Services get the stream inlined with the input arguments; clients
		// treat the stream as an output argument so we ignore it here.
		if ret != "" {
			ret += ", "
		}
		ret += javaStreamType(method, iface, true, imports, env) + " stream"
	}
	return
}

// javaClientResultFetchImpl provides implementation for client's result fetch
// functionality.
func javaClientResultFetchArgs(method *compile.Method, iface *compile.Interface, forceClass bool, indent string, imports javaUserImports, env *compile.Env) (ret interface{}) {
	return struct {
		Method     *compile.Method
		Interface  *compile.Interface
		ForceClass bool
		Indent     string
		Imports    javaUserImports
		Env        *compile.Env
	}{
		Method:     method,
		Interface:  iface,
		ForceClass: forceClass,
		Indent:     indent,
		Imports:    imports,
		Env:        env,
	}
}

// javaAllMethods returns all methods implemented by this interface, including
// the methods from embedded interfaces.
func javaAllMethods(iface *compile.Interface) (ret []*compile.Method) {
	ret = iface.Methods
	for _, eIface := range javaAllEmbeddedIfaces(iface) {
		ret = append(ret, eIface.Methods...)
	}
	return
}

// javaAllEmbeddedIfaces returns all unique interfaces in the embed tree
// starting at the provided interface (not including that interface).
func javaAllEmbeddedIfaces(iface *compile.Interface) (ret []*compile.Interface) {
	added := make(map[string]bool)
	for _, eIface := range iface.Embeds {
		for _, eIface = range append(javaAllEmbeddedIfaces(eIface), eIface) {
			path := path.Join(eIface.File.Package.Path, eIface.Name)
			if _, ok := added[path]; ok { // already added iface
				continue
			}
			ret = append(ret, eIface)
			added[path] = true
		}
	}
	return
}

func javaHasConsts(file *compile.File) bool {
	return len(file.ConstDefs) > 0 || len(file.ErrorIDs) > 0
}

// javaStructFields returns the types of all the fields in the provided struct type.
func javaStructFields(t *val.Type) (ret []val.StructField) {
	for idx := 0; idx < t.NumField(); idx++ {
		ret = append(ret, t.Field(idx))
	}
	return
}

// javaDoc transforms the provided VDL comment into the JavaDoc format.
func javaDoc(goComment string) string {
	if goComment == "" {
		return ""
	}
	return "/**\n" + strings.Replace(goComment, "//", " *", -1) + "**/\n"
}

// javaPath converts the provided Go path into the Java path.  It replaces all "/"
// with "." in the path.
func javaPath(goPath string) string {
	return strings.Replace(goPath, "/", ".", -1)
}

// javaName converts the provided Go pathname into the Java pathname and returns a
// shorter version of it if possible, given the provided imports.
func javaName(goPathName string, imports javaUserImports) string {
	if dir, ok := imports[path.Base(goPathName)]; ok && dir == path.Dir(goPathName) {
		return path.Base(goPathName)
	}
	return javaPath(goPathName)
}

// javaName returns the fully qualified Java name for the provided goName.
func javaQualifiedName(goName string, file *compile.File, imports javaUserImports) string {
	return javaName(path.Join(javaGenPkgPath(file.Package.Path), goName), imports)
}

// javaIfaceName returns the name for the provided interface.
func javaIfaceName(iface *compile.Interface, isService bool, imports javaUserImports) string {
	return javaName(javaIfacePathName(iface, isService), imports)
}

// javaIfacePathName returns the full pathname for the provided interface.
func javaIfacePathName(iface *compile.Interface, isService bool) string {
	name := iface.Name
	if isService {
		name += "Service"
	}
	return path.Join(javaGenPkgPath(iface.File.Package.Path), name)
}

// javaClassToVarName generates a Java variable name corresponding to the provided
// Java class name.
func javaClassToVarName(className string) string {
	dir := path.Dir(className)
	if dir == "." {
		return toCamelCase(className)
	}
	return strings.Replace(path.Dir(className), "/", "_", -1) + "_" + toCamelCase(path.Base(className))
}

// toCamelCase converts ThisString to thisString.
func toCamelCase(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}

// toConstCase converts ThisString to THIS_STRING.
func toConstCase(s string) string {
	// Extract all characters.
	chars := []rune{}
	idx := 0
	for idx < len(s) {
		r, size := utf8.DecodeRuneInString(s[idx:])
		if r == utf8.RuneError {
			log.Fatalf("Invalid UTF8 string: %s", s)
		}
		chars = append(chars, r)
		idx += size
	}
	// Case.
	var buf bytes.Buffer
	for i, r := range chars {
		if i > 0 && unicode.IsUpper(r) && i < len(chars)-1 && !unicode.IsUpper(chars[i+1]) {
			buf.WriteRune('_')
		}
		buf.WriteRune(unicode.ToUpper(r))
	}
	return buf.String()
}

var (
	javaPkgTmpl    *template.Template
	javaConstTmpl  *template.Template
	javaClassTmpl  *template.Template
	javaIfaceTmpl  *template.Template
	javaClientTmpl *template.Template
	javaServerTmpl *template.Template
)

// The template mechanism is great at high-level formatting and simple
// substitution, but is bad at more complicated logic (by design).  We define
// some functions that we can use in the template so that when things get
// complicated we back off to a regular function.
func init() {
	funcMap := template.FuncMap{
		"javaDoc":                    javaDoc,
		"javaGenPkgPath":             javaGenPkgPath,
		"javaPath":                   javaPath,
		"javaImports":                javaImports,
		"javaType":                   javaType,
		"javaConstVal":               javaConstVal,
		"javaInArgs":                 javaInArgs,
		"javaOutArgType":             javaOutArgType,
		"javaClientResultFetchArgs":  javaClientResultFetchArgs,
		"javaNonErrorOutArgs":        javaNonErrorOutArgs,
		"javaIsStreamingMethod":      javaIsStreamingMethod,
		"javaNonStreamingOutArgType": javaNonStreamingOutArgType,
		"javaHasConsts":              javaHasConsts,
		"javaStructFields":           javaStructFields,
		"javaAllMethods":             javaAllMethods,
		"javaName":                   javaName,
		"javaQualifiedName":          javaQualifiedName,
		"javaIfaceName":              javaIfaceName,
		"javaClassToVarName":         javaClassToVarName,
		"toCamelCase":                toCamelCase,
		"toConstCase":                toConstCase,
	}
	javaPkgTmpl = template.Must(template.New("javaPkg").Funcs(funcMap).Parse(javaPkgTmplStr))
	javaConstTmpl = template.Must(template.New("javaConst").Funcs(funcMap).Parse(javaConstTmplStr))
	javaClassTmpl = template.Must(template.New("javaClass").Funcs(funcMap).Parse(javaClassTmplStr))
	javaIfaceTmpl = template.Must(template.New("javaIface").Funcs(funcMap).Parse(javaIfaceTmplStr))
	javaClientTmpl = template.Must(template.New("javaClient").Funcs(funcMap).Parse(javaClientTmplStr))
	javaServerTmpl = template.Must(template.New("javaServer").Funcs(funcMap).Parse(javaServerTmplStr))
}
