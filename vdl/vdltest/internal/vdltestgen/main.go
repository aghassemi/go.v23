// Copyright 2016 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// The following enables go generate to generate the doc.go file.
//go:generate go run $JIRI_ROOT/release/go/src/v.io/x/lib/cmdline/testdata/gendoc.go . -help

package main

import (
	"fmt"
	"io"
	"os"
	"strings"

	"v.io/v23/vdl"
	"v.io/v23/vdl/vdltest"
	"v.io/x/lib/cmdline"
	"v.io/x/lib/textutil"
	"v.io/x/ref/lib/vdl/codegen/vdlgen"
)

var cmdGen = &cmdline.Command{
	Runner: cmdline.RunnerFunc(runGen),
	Name:   "vdltestgen",
	Short:  "generates test data for the vdltest package",
	Long: `
Command vdltestgen generates types and values for the vdltest package.  The
following files are generated:

   vtype_gen.vdl       - A variety of types useful for testing.
   ventry_pass_gen.vdl - Entries that pass conversion from source to target.
   ventry_fail_gen.vdl - Entries that fail conversion from source to target.

This tool does not run the vdl tool on the generated *.vdl files; you must do
that yourself, typically via "jiri go install".

Instead of running this tool manually, it is typically invoked via:

   $ jiri run go generate v.io/v23/vdl/vdltest
`,
}

func main() {
	cmdGen.Flags.StringVar(&flagVType, "vtype", "vtype_gen.vdl", "Name of the generated vtype file, containing VDL types.")
	cmdGen.Flags.StringVar(&flagVEntryPass, "ventry-pass", "ventry_pass_gen.vdl", "Name of the generated ventry pass file, containing VDL values that pass conversion tests.")
	cmdGen.Flags.StringVar(&flagVEntryFail, "ventry-fail", "ventry_fail_gen.vdl", "Name of the generated ventry fail file, containing VDL values that fail conversion tests.")
	cmdline.Main(cmdGen)
}

var (
	flagVType      string
	flagVEntryPass string
	flagVEntryFail string
)

func runGen(_ *cmdline.Env, _ []string) error {
	typeGen := vdltest.NewTypeGenerator()
	typeGen.RandSeed(1)
	types := typeGen.Gen(3)
	entryGen := vdltest.NewEntryGenerator(types)
	entryGen.RandSeed(1)
	writeFileVType(flagVType, types)
	writeFileVEntry(flagVEntryPass, "vAllPass", entryGen.GenAllPass())
	writeFileVEntry(flagVEntryFail, "vAllFail", entryGen.GenAllFail())
	return nil
}

// This tool is only used to generate test cases for the vdltest package, so the
// strategy is to panic on any error, to make the code simpler.
func panicOnError(err error) {
	if err != nil {
		panic(err)
	}
}

func createFile(name string) (*os.File, func()) {
	file, err := os.Create(name)
	panicOnError(err)
	return file, func() { panicOnError(file.Close()) }
}

func writef(w io.Writer, format string, args ...interface{}) {
	_, err := fmt.Fprintf(w, format, args...)
	panicOnError(err)
}

func writeHeader(w io.Writer) {
	writef(w, `// Copyright 2016 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by v.io/v23/vdl/vdltest/internal/vdltestgen
// Run the following to re-generate:
//   $ jiri run go generate v.io/v23/vdl/vdltest

package vdltest

`)
}

func writeFileVType(fileName string, types []*vdl.Type) {
	fmt.Printf("Writing %[1]s:\t%[2]d types\n", fileName, len(types))
	file, cleanup := createFile(fileName)
	defer cleanup()
	writeHeader(file)
	comment := textutil.PrefixLineWriter(file, "// ")
	panicOnError(vdltest.PrintTypeStats(comment, types...))
	writef(comment, "\nOnly named types appear below, by definition.\n")
	panicOnError(comment.Flush())
	writef(file, "\ntype (\n")
	for _, tt := range types {
		if tt.Name() != "" {
			base := vdlgen.BaseType(tt, "", nil)
			base = strings.Replace(base, "\n", "\n\t", -1)
			writef(file, "\t%[1]s %[2]s\n", tt.Name(), base)
		}
	}
	writef(file, ")\n")
}

func writeFileVEntry(fileName, constName string, entries []vdltest.EntryValue) {
	fmt.Printf("Writing %[1]s:\t%[2]d entries\n", fileName, len(entries))
	file, cleanup := createFile(fileName)
	defer cleanup()
	writeHeader(file)
	comment := textutil.PrefixLineWriter(file, "// ")
	panicOnError(vdltest.PrintEntryStats(comment, entries...))
	panicOnError(comment.Flush())
	writef(file, "\nconst %[1]s = []Entry{\n", constName)
	for _, e := range entries {
		if e.IsCanonical() {
			writef(file, "\t// Canonical\n")
		}
		target := vdlgen.TypedConst(e.Target, "", nil)
		source := vdlgen.TypedConst(e.Source, "", nil)
		writef(file, "\t{ %[1]v, %#[2]q, %#[3]q, %[3]s, %#[4]q, %[4]s },\n", e.IsCanonical(), e.Label, target, source)
	}
	writef(file, "}\n")
}
