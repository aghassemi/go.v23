// Copyright 2016 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// The following enables go generate to generate the doc.go file.
//go:generate go run $JIRI_ROOT/release/go/src/v.io/x/lib/cmdline/testdata/gendoc.go . -help

package main

import (
	"fmt"
	"io"
	"os"
	"strings"

	"v.io/v23/vdl"
	"v.io/v23/vdl/vdltest"
	"v.io/x/lib/cmdline"
	"v.io/x/lib/textutil"
	"v.io/x/ref/lib/vdl/codegen/vdlgen"
)

var cmdGenerate = &cmdline.Command{
	Runner: cmdline.RunnerFunc(runGenerate),
	Name:   "vdltestgen",
	Short:  "generates test data for the vdltest package",
	Long: `
Command vdltestgen generates the following files:

   vtype_gen.vdl       - A variety of types useful for testing.
   ventry_pass_gen.vdl - Entries that pass conversion from source to target.
   ventry_fail_gen.vdl - Entries that fail conversion from source to target.

This tool does not run the vdl tool on the generated *.vdl files; you must do
that yourself, typically via "jiri go install".
`,
}

func main() {
	cmdline.Main(cmdGenerate)
}

var (
	flagVType      string
	flagVEntryPass string
	flagVEntryFail string
)

func init() {
	cmdGenerate.Flags.StringVar(&flagVType, "vtype", "vtype_gen.vdl", "Name of the generated vtype file, containing VDL types.")
	cmdGenerate.Flags.StringVar(&flagVEntryPass, "ventry-pass", "ventry_pass_gen.vdl", "Name of the generated ventry pass file, containing VDL values that pass conversion tests.")
	cmdGenerate.Flags.StringVar(&flagVEntryFail, "ventry-fail", "ventry_fail_gen.vdl", "Name of the generated ventry fail file, containing VDL values that fail conversion tests.")
}

func runGenerate(_ *cmdline.Env, _ []string) error {
	typeGen := vdltest.NewTypeGenerator()
	typeGen.RandSeed(1)
	typeGen.MaxPerKind = 20
	types := typeGen.Gen(2)
	entryGen := vdltest.NewEntryGenerator(types)
	entryGen.RandSeed(1)
	writeFileVType(flagVType, types)
	writeFileVEntry(flagVEntryPass, "vAllPass", entryGen.GenAllPass())
	writeFileVEntry(flagVEntryFail, "vAllFail", entryGen.GenAllFail())
	return nil
}

// This tool is only used to generate test cases for the vdltest package, so the
// strategy is to panic on any error, to make the code simpler.
func panicOnError(err error) {
	if err != nil {
		panic(err)
	}
}

func createFile(name string) (*os.File, func()) {
	file, err := os.Create(name)
	panicOnError(err)
	return file, func() { panicOnError(file.Close()) }
}

func writef(w io.Writer, format string, args ...interface{}) {
	_, err := fmt.Fprintf(w, format, args...)
	panicOnError(err)
}

func writeHeader(w io.Writer) {
	writef(w, `// Copyright 2016 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by v.io/v23/vdl/vdltest/internal/vdltestgen

package vdltest
`)
}

func writeFileVType(fileName string, types []*vdl.Type) {
	fmt.Printf("Writing %[1]s:\t%[2]d types\n", fileName, len(types))
	file, cleanup := createFile(fileName)
	defer cleanup()
	writeHeader(file)
	comment := textutil.ByteReplaceWriter(file, '\n', "\n// ")
	writef(comment, "\n")
	panicOnError(vdltest.PrintTypeStats(comment, types...))
	// The byte replacement above causes the final line to start with "// ".
	writef(file, "Only named types appear below, by definition.\n")
	writef(file, "\ntype (\n")
	for _, tt := range types {
		if tt.Name() != "" {
			base := vdlgen.BaseType(tt, "", nil)
			base = strings.Replace(base, "\n", "\n\t", -1)
			writef(file, "\t%[1]s %[2]s\n", tt.Name(), base)
		}
	}
	writef(file, ")\n")
}

func writeFileVEntry(fileName, constName string, entries []vdltest.EntryValue) {
	fmt.Printf("Writing %[1]s:\t%[2]d entries\n", fileName, len(entries))
	file, cleanup := createFile(fileName)
	defer cleanup()
	writeHeader(file)
	comment := textutil.ByteReplaceWriter(file, '\n', "\n// ")
	writef(comment, "\n")
	panicOnError(vdltest.PrintEntryStats(comment, entries...))
	// The byte replacement above causes the final line to start with "// ".
	writef(file, `Each column has a pair of entry counts (canonical,non-canonical).
// An entry is canonical if Target == Source.
//   Full:         Target is entirely non-zero, except for cyclic types.
//   Neg{Max,Min}: Target tests max and min negative values.
//   Pos{Max,Min}: Target test max and min positive values.
//   NilAny:       Target is optional(nil), source is any(nil).
//   Random:       Target is random value.
//   Zero:         Target is zero value.
`)
	writef(file, "\nconst %[1]s = []Entry{\n", constName)
	for _, e := range entries {
		target := vdlgen.TypedConst(e.Target, "", nil)
		source := vdlgen.TypedConst(e.Source, "", nil)
		writef(file, "\t{ %[1]v, %#[2]q, %#[3]q, %[3]s, %#[4]q, %[4]s },\n", e.IsCanonical(), e.Label, target, source)
	}
	writef(file, "}\n")
}
