// This file was auto-generated by the veyron vdl tool.
// Source: base_experimental.vdlexp

package base

import (
	// The non-user imports are prefixed with "_gen_" to prevent collisions.
	_gen_vdl "veyron.io/veyron/veyron2/vdl"
)

type NamedEnum int

const (
	NamedEnumA NamedEnum = iota
	NamedEnumB
	NamedEnumC
)

// AllNamedEnum holds all labels for NamedEnum.
var AllNamedEnum = []NamedEnum{NamedEnumA, NamedEnumB, NamedEnumC}

// MakeNamedEnum creates a NamedEnum from a string label.
// Returns true iff the label is valid.
func MakeNamedEnum(label string) (x NamedEnum, ok bool) {
	ok = x.Assign(label)
	return
}

// Assign assigns label to x.
// Returns true iff the label is valid.
func (x *NamedEnum) Assign(label string) bool {
	switch label {
	case "A":
		*x = NamedEnumA
		return true
	case "B":
		*x = NamedEnumB
		return true
	case "C":
		*x = NamedEnumC
		return true
	}
	*x = -1
	return false
}

// String returns the string label of x.
func (x NamedEnum) String() string {
	switch x {
	case NamedEnumA:
		return "A"
	case NamedEnumB:
		return "B"
	case NamedEnumC:
		return "C"
	}
	return ""
}

// vdlEnumLabels identifies NamedEnum as an enum.
func (NamedEnum) vdlEnumLabels(struct{ A, B, C bool }) {}

type NamedOneOf struct{ oneof interface{} }

// MakeNamedOneOf creates a NamedOneOf.
// Returns true iff the oneof value has a valid type.
func MakeNamedOneOf(oneof interface{}) (x NamedOneOf, ok bool) {
	ok = x.Assign(oneof)
	return
}

// Assign assigns oneof to x.
// Returns true iff the oneof value has a valid type.
func (x *NamedOneOf) Assign(oneof interface{}) bool {
	switch oneof.(type) {
	case bool, string, int32:
		x.oneof = oneof
		return true
	}
	x.oneof = nil
	return false
}

// OneOf returns the underlying typed value of x.
func (x NamedOneOf) OneOf() interface{} {
	return x.oneof
}

// vdlOneOfTypes identifies NamedOneOf as a oneof.
func (NamedOneOf) vdlOneOfTypes(_ bool, _ string, _ int32) {}

type ScalarsExp struct {
	B13 NamedEnum
	B14 NamedOneOf
}

const Cenum = NamedEnumA

var Carray = [3]int32{
	1,
	2,
	3,
}

var Clist = []int32{
	1,
	2,
	3,
}

// TODO(toddw): test multiple items after ordering is fixed.
//Cset   = set[int32]{1, 2, 3}
var Cset = map[int32]struct{}{
	1: struct{}{},
}

// TODO(toddw): test multiple items after ordering is fixed.
//cmap   = map[int32]string{1: "A", 2: "B", 3: "C"}
var Cmap = map[int32]string{
	1: "A",
}

var Cargs = Args{
	A: 1,
	B: 2,
}

var CTVbool = _gen_vdl.TypeOf(false)

var CTVstring = _gen_vdl.TypeOf("")

var CTVbytes = _gen_vdl.TypeOf([]byte(""))

var CTVbyte = _gen_vdl.TypeOf(byte(0))

var CTVuint16 = _gen_vdl.TypeOf(uint16(0))

var CTVint16 = _gen_vdl.TypeOf(int16(0))

var CTVfloat32 = _gen_vdl.TypeOf(float32(0))

var CTVcomplex64 = _gen_vdl.TypeOf(complex64(0))

var CTVenum = _gen_vdl.TypeOf(NamedEnumA)

var CTVArray = _gen_vdl.TypeOf([3]string{})

var CTVList = _gen_vdl.TypeOf([]string{})

var CTVSet = _gen_vdl.TypeOf(map[string]struct{}{})

var CTVMap = _gen_vdl.TypeOf(map[string]int64{})

var CTVStruct = _gen_vdl.TypeOf(ScalarsExp{})

var CTVOneOf = _gen_vdl.TypeOf(NamedOneOf{false})

var CTVAny = _gen_vdl.AnyType
