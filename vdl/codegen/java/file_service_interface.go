package java

import (
	"bytes"
	"fmt"
	"log"
	"path"

	"veyron2/vdl/compile"
	"veyron2/vdl/vdlutil"
)

const serverInterfaceTmpl = `// This file was auto-generated by the veyron vdl tool.
// Source: {{ .Source }}
package {{ .PackagePath }};

{{ .ServiceDoc }}
@com.veyron2.vdl.VeyronService(
	serviceWrapper = {{ .ServiceWrapperPath }}.class,
	vdlPathName = "{{ .ServiceVDLPath }}"
)
public interface {{ .ServiceName }} {{ .Extends }} {
{{ range $method := .Methods }}
    {{/* Generate the method signature. */}}
    {{ $method.Doc }}
    public {{ $method.RetType }} {{ $method.Name }}(final com.veyron2.ipc.ServerContext context{{ $method.Args }}) throws com.veyron2.ipc.VeyronException;
{{ end }}
}
`

func serviceInterfaceOutArg(method *compile.Method, iface *compile.Interface, env *compile.Env) string {
	switch len(method.OutArgs) {
	case 0:
		panic("Unexpected to have 0 out args in an interface method")
	case 1:
		return "void"
	case 2:
		return javaType(method.OutArgs[0].Type, false, env)
	default:
		return javaPath(path.Join(interfaceFullyQualifiedName(iface), method.Name+"Out"))
	}
}

type serviceInterfaceMethod struct {
	Args    string
	Doc     string
	Name    string
	RetType string
}

func processServiceInterfaceMethod(method *compile.Method, iface *compile.Interface, env *compile.Env) serviceInterfaceMethod {
	args := javaDeclarationArgStr(method.InArgs, env, true)
	if isStreamingMethod(method) {
		args += fmt.Sprintf(", com.veyron2.vdl.Stream<%s, %s> stream", javaType(method.InStream, true, env), javaType(method.OutStream, true, env))
	}
	return serviceInterfaceMethod{
		Name:    vdlutil.ToCamelCase(method.Name),
		Doc:     method.Doc,
		RetType: serviceInterfaceOutArg(method, iface, env),
		Args:    args,
	}
}

// genJavaServiceInterfaceFile generates the Java interface file for the provided
// interface.
func genJavaServiceInterfaceFile(iface *compile.Interface, env *compile.Env) JavaFileInfo {
	methods := make([]serviceInterfaceMethod, len(iface.Methods))
	for i, method := range iface.Methods {
		methods[i] = processServiceInterfaceMethod(method, iface, env)
	}
	data := struct {
		Extends            string
		Methods            []serviceInterfaceMethod
		PackagePath        string
		ServiceDoc         string
		ServiceVDLPath     string
		ServiceName        string
		ServiceWrapperPath string
		Source             string
	}{
		Extends:            javaExtendsStr(iface.Embeds, "Service"),
		Methods:            methods,
		PackagePath:        javaPath(javaGenPkgPath(iface.File.Package.Path)),
		ServiceDoc:         javaDoc(iface.Doc),
		ServiceName:        iface.Name + "Service",
		ServiceVDLPath:     path.Join(iface.File.Package.Path, iface.Name+"Service"),
		ServiceWrapperPath: javaPath(javaGenPkgPath(path.Join(iface.File.Package.Path, javaGenImplDir, iface.Name+"ServiceWrapper"))),
		Source:             iface.File.BaseName,
	}
	var buf bytes.Buffer
	err := parseTmpl("server interface", serverInterfaceTmpl).Execute(&buf, data)
	if err != nil {
		log.Fatalf("vdl: couldn't execute struct template: %v", err)
	}
	return JavaFileInfo{
		Name: iface.Name + "Service.java",
		Data: buf.Bytes(),
	}
}
