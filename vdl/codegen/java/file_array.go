package java

import (
	"bytes"
	"fmt"
	"log"
	"strings"

	"v.io/v23/vdl/compile"
)

const arrayTmpl = `// This file was auto-generated by the veyron vdl tool.
// Source: {{.SourceFile}}

package {{.Package}};

/**
 * type {{.Name}} {{.VdlTypeString}} {{.Doc}}
 **/
@io.v.v23.vdl.GeneratedFromVdl(name = "{{.VdlTypeName}}")
{{ .AccessModifier }} final class {{.Name}} extends io.v.v23.vdl.VdlArray<{{.ElemType}}> {
    public static final int LENGTH = {{.Length}};

    public static final io.v.v23.vdl.VdlType VDL_TYPE =
            io.v.v23.vdl.Types.getVdlTypeFromReflect({{.Name}}.class);

    public {{.Name}}({{.ElemType}}[] arr) {
        super(VDL_TYPE, arr);
    }

    public {{.Name}}() {
        this({{.ZeroValue}});
    }

    {{ if .ElemIsPrimitive }}
    public {{.Name}}({{ .ElemPrimitiveType }}[] arr) {
        super(VDL_TYPE, convert(arr));
    }

    private static {{ .ElemType }}[] convert({{ .ElemPrimitiveType }}[] arr) {
        final {{ .ElemType }}[] ret = new {{ .ElemType }}[arr.length];
        for (int i = 0; i < arr.length; ++i) {
            ret[i] = arr[i];
        }
        return ret;
    }
    {{ end }}

    @Override
    public void writeToParcel(android.os.Parcel out, int flags) {
        java.lang.reflect.Type elemType =
                new com.google.common.reflect.TypeToken<{{.ElemType}}>(){}.getType();
        io.v.v23.vdl.ParcelUtil.writeList(out, this, elemType);
    }

    @SuppressWarnings("hiding")
    public static final android.os.Parcelable.Creator<{{.Name}}> CREATOR =
            new android.os.Parcelable.Creator<{{.Name}}>() {
        @SuppressWarnings("unchecked")
        @Override
        public {{.Name}} createFromParcel(android.os.Parcel in) {
            java.lang.reflect.Type elemType =
                    new com.google.common.reflect.TypeToken<{{.ElemType}}>(){}.getType();
            final {{.ElemType}}[] array = io.v.v23.vdl.ParcelUtil.readList(
                    in, {{.Name}}.class.getClassLoader(), elemType).toArray(new {{.ElemType}}[0]);
            return new {{.Name}}(array);
        }

        @Override
        public {{.Name}}[] newArray(int size) {
            return new {{.Name}}[size];
        }
    };
}
`

// genJavaArrayFile generates the Java class file for the provided named array type.
func genJavaArrayFile(tdef *compile.TypeDef, env *compile.Env) JavaFileInfo {
	javaTypeName := toUpperCamelCase(tdef.Name)
	elemType := javaType(tdef.Type.Elem(), true, env)
	elems := strings.TrimSuffix(strings.Repeat(javaZeroValue(tdef.Type.Elem(), env)+", ", tdef.Type.Len()), ", ")
	zeroValue := fmt.Sprintf("new %s[] {%s}", elemType, elems)
	data := struct {
		AccessModifier    string
		Doc               string
		ElemType          string
		ElemIsPrimitive   bool
		ElemPrimitiveType string
		Length            int
		Name              string
		Package           string
		SourceFile        string
		VdlTypeName       string
		VdlTypeString     string
		ZeroValue         string
	}{
		AccessModifier:    accessModifierForName(tdef.Name),
		Doc:               javaDocInComment(tdef.Doc),
		ElemType:          elemType,
		ElemIsPrimitive:   !isClass(tdef.Type.Elem(), env),
		ElemPrimitiveType: javaType(tdef.Type.Elem(), false, env),
		Length:            tdef.Type.Len(),
		Name:              javaTypeName,
		Package:           javaPath(javaGenPkgPath(tdef.File.Package.GenPath)),
		SourceFile:        tdef.File.BaseName,
		VdlTypeName:       tdef.Type.Name(),
		VdlTypeString:     tdef.Type.String(),
		ZeroValue:         zeroValue,
	}
	var buf bytes.Buffer
	err := parseTmpl("array", arrayTmpl).Execute(&buf, data)
	if err != nil {
		log.Fatalf("vdl: couldn't execute array template: %v", err)
	}
	return JavaFileInfo{
		Name: javaTypeName + ".java",
		Data: buf.Bytes(),
	}
}
