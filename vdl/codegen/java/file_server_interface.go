package java

import (
	"bytes"
	"fmt"
	"log"
	"path"

	"veyron.io/veyron/veyron2/vdl/compile"
	"veyron.io/veyron/veyron2/vdl/vdlutil"
)

const serverInterfaceTmpl = `// This file was auto-generated by the veyron vdl tool.
// Source: {{ .Source }}
package {{ .PackagePath }};

{{ .ServerDoc }}
@io.veyron.veyron.veyron2.vdl.VeyronServer(
	serverWrapper = {{ .ServerWrapperPath }}.class,
	vdlPathName = "{{ .ServerVDLPath }}"
)
public interface {{ .ServiceName }}Server {{ .Extends }} {
{{ range $method := .Methods }}
    {{/* Generate the method signature. */}}
    {{ $method.Doc }}
    public {{ $method.RetType }} {{ $method.Name }}(final io.veyron.veyron.veyron2.ipc.ServerContext context{{ $method.Args }}) throws io.veyron.veyron.veyron2.VeyronException;
{{ end }}
}
`

func serverInterfaceOutArg(method *compile.Method, iface *compile.Interface, env *compile.Env) string {
	switch len(method.OutArgs) {
	case 0:
		panic("Unexpected to have 0 out args in an interface method")
	case 1:
		return "void"
	case 2:
		return javaType(method.OutArgs[0].Type, false, env)
	default:
		return javaPath(path.Join(interfaceFullyQualifiedName(iface), method.Name+"Out"))
	}
}

type serverInterfaceMethod struct {
	Args    string
	Doc     string
	Name    string
	RetType string
}

func processServerInterfaceMethod(method *compile.Method, iface *compile.Interface, env *compile.Env) serverInterfaceMethod {
	args := javaDeclarationArgStr(method.InArgs, env, true)
	if isStreamingMethod(method) {
		args += fmt.Sprintf(", io.veyron.veyron.veyron2.vdl.Stream<%s, %s> stream", javaType(method.InStream, true, env), javaType(method.OutStream, true, env))
	}
	return serverInterfaceMethod{
		Name:    vdlutil.ToCamelCase(method.Name),
		Doc:     method.Doc,
		RetType: serverInterfaceOutArg(method, iface, env),
		Args:    args,
	}
}

// genJavaServerInterfaceFile generates the Java interface file for the provided
// interface.
func genJavaServerInterfaceFile(iface *compile.Interface, env *compile.Env) JavaFileInfo {
	methods := make([]serverInterfaceMethod, len(iface.Methods))
	for i, method := range iface.Methods {
		methods[i] = processServerInterfaceMethod(method, iface, env)
	}
	data := struct {
		Extends           string
		Methods           []serverInterfaceMethod
		PackagePath       string
		ServerDoc         string
		ServerVDLPath     string
		ServiceName       string
		ServerWrapperPath string
		Source            string
	}{
		Extends:           javaServerExtendsStr(iface.Embeds),
		Methods:           methods,
		PackagePath:       javaPath(javaGenPkgPath(iface.File.Package.Path)),
		ServerDoc:         javaDoc(iface.Doc),
		ServiceName:       iface.Name,
		ServerVDLPath:     path.Join(iface.File.Package.Path, iface.Name+"ServerMethods"),
		ServerWrapperPath: javaPath(javaGenPkgPath(path.Join(iface.File.Package.Path, javaGenImplDir, iface.Name+"ServerWrapper"))),
		Source:            iface.File.BaseName,
	}
	var buf bytes.Buffer
	err := parseTmpl("server interface", serverInterfaceTmpl).Execute(&buf, data)
	if err != nil {
		log.Fatalf("vdl: couldn't execute struct template: %v", err)
	}
	return JavaFileInfo{
		Name: iface.Name + "Server.java",
		Data: buf.Bytes(),
	}
}
