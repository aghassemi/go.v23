// Copyright 2016 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package vdl

import "fmt"

// This file contains the code generated by the experimental vdl codegen for
// vdl.Decoder.  Normally this would appear in vdl.vdl.go, but we manually
// include the code here, since the new vdl codegen logic isn't submitted.
//
// TODO(toddw): Remove this file when the new vdl codegen is submitted.

func (x *WireRetryCode) VDLRead(dec Decoder) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	enum, err := dec.DecodeString()
	if err != nil {
		return err
	}
	if err = x.Set(enum); err != nil {
		return err
	}
	return dec.FinishValue()
}

func (x *WireError) VDLRead(dec Decoder) error {
	*x = WireError{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if dec.Type().Kind() != Struct {
		return fmt.Errorf("incompatible types, got %v, want %T", dec.Type(), *x)
	}
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			return dec.FinishValue()
		case "Id":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Id, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "RetryCode":
			if err = x.RetryCode.VDLRead(dec); err != nil {
				return err
			}
		case "Msg":
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Msg, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "ParamList":
			if err = __VDLRead1_list(dec, &x.ParamList); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead1_list(dec Decoder, x *[]*Value) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if k := dec.Type().Kind(); k != Array && k != List {
		return fmt.Errorf("incompatible types, got %v, want %T", dec.Type(), *x)
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
	case len > 0:
		*x = make([]*Value, 0, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem *Value
		// TODO(toddw): any
		*x = append(*x, elem)
	}
}
