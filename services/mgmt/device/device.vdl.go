// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Source: device.vdl

// Package device supports managing a device and applications running on
// the device.
package device

import (
	// VDL system imports
	"fmt"
	"io"
	"v.io/v23"
	"v.io/v23/context"
	"v.io/v23/rpc"
	"v.io/v23/vdl"

	// VDL user imports
	"v.io/v23/security"
	"v.io/v23/security/access"
	"v.io/v23/services/mgmt/application"
	"v.io/v23/services/mgmt/binary"
	"v.io/v23/services/security/object"
)

// Config specifies app configuration that overrides what's in the envelope.
type Config map[string]string

func (Config) __VDLReflect(struct {
	Name string "v.io/v23/services/mgmt/device.Config"
}) {
}

// InstallationState describes the states that an installation can be in at any
// time.
type InstallationState int

const (
	InstallationStateActive InstallationState = iota
	InstallationStateUninstalled
)

// InstallationStateAll holds all labels for InstallationState.
var InstallationStateAll = [...]InstallationState{InstallationStateActive, InstallationStateUninstalled}

// InstallationStateFromString creates a InstallationState from a string label.
func InstallationStateFromString(label string) (x InstallationState, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *InstallationState) Set(label string) error {
	switch label {
	case "Active", "active":
		*x = InstallationStateActive
		return nil
	case "Uninstalled", "uninstalled":
		*x = InstallationStateUninstalled
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in device.InstallationState", label)
}

// String returns the string label of x.
func (x InstallationState) String() string {
	switch x {
	case InstallationStateActive:
		return "Active"
	case InstallationStateUninstalled:
		return "Uninstalled"
	}
	return ""
}

func (InstallationState) __VDLReflect(struct {
	Name string "v.io/v23/services/mgmt/device.InstallationState"
	Enum struct{ Active, Uninstalled string }
}) {
}

// InstanceState describes the states that an instance can be in at any
// time.
type InstanceState int

const (
	InstanceStateStarting InstanceState = iota
	InstanceStateStarted
	InstanceStateSuspending
	InstanceStateSuspended
	InstanceStateStopping
	InstanceStateStopped
	InstanceStateUpdating
)

// InstanceStateAll holds all labels for InstanceState.
var InstanceStateAll = [...]InstanceState{InstanceStateStarting, InstanceStateStarted, InstanceStateSuspending, InstanceStateSuspended, InstanceStateStopping, InstanceStateStopped, InstanceStateUpdating}

// InstanceStateFromString creates a InstanceState from a string label.
func InstanceStateFromString(label string) (x InstanceState, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *InstanceState) Set(label string) error {
	switch label {
	case "Starting", "starting":
		*x = InstanceStateStarting
		return nil
	case "Started", "started":
		*x = InstanceStateStarted
		return nil
	case "Suspending", "suspending":
		*x = InstanceStateSuspending
		return nil
	case "Suspended", "suspended":
		*x = InstanceStateSuspended
		return nil
	case "Stopping", "stopping":
		*x = InstanceStateStopping
		return nil
	case "Stopped", "stopped":
		*x = InstanceStateStopped
		return nil
	case "Updating", "updating":
		*x = InstanceStateUpdating
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in device.InstanceState", label)
}

// String returns the string label of x.
func (x InstanceState) String() string {
	switch x {
	case InstanceStateStarting:
		return "Starting"
	case InstanceStateStarted:
		return "Started"
	case InstanceStateSuspending:
		return "Suspending"
	case InstanceStateSuspended:
		return "Suspended"
	case InstanceStateStopping:
		return "Stopping"
	case InstanceStateStopped:
		return "Stopped"
	case InstanceStateUpdating:
		return "Updating"
	}
	return ""
}

func (InstanceState) __VDLReflect(struct {
	Name string "v.io/v23/services/mgmt/device.InstanceState"
	Enum struct{ Starting, Started, Suspending, Suspended, Stopping, Stopped, Updating string }
}) {
}

type (
	// Status represents any single field of the Status union type.
	//
	// Status is returned by the Application Status method.
	Status interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the Status union type.
		__VDLReflect(__StatusReflect)
	}
	// StatusInstance represents field Instance of the Status union type.
	StatusInstance struct{ Value InstanceStatus }
	// StatusInstallation represents field Installation of the Status union type.
	StatusInstallation struct{ Value InstallationStatus }
	// __StatusReflect describes the Status union type.
	__StatusReflect struct {
		Name  string "v.io/v23/services/mgmt/device.Status"
		Type  Status
		Union struct {
			Instance     StatusInstance
			Installation StatusInstallation
		}
	}
)

func (x StatusInstance) Index() int                   { return 0 }
func (x StatusInstance) Interface() interface{}       { return x.Value }
func (x StatusInstance) Name() string                 { return "Instance" }
func (x StatusInstance) __VDLReflect(__StatusReflect) {}

func (x StatusInstallation) Index() int                   { return 1 }
func (x StatusInstallation) Interface() interface{}       { return x.Value }
func (x StatusInstallation) Name() string                 { return "Installation" }
func (x StatusInstallation) __VDLReflect(__StatusReflect) {}

// InstallationStatus specifies the Status returned by the Application Status
// method for installation objects.
type InstallationStatus struct {
	State   InstallationState
	Version string
}

func (InstallationStatus) __VDLReflect(struct {
	Name string "v.io/v23/services/mgmt/device.InstallationStatus"
}) {
}

// InstanceStatus specifies the Status returned by the Application Status method
// for instance objects.
type InstanceStatus struct {
	State   InstanceState
	Version string
}

func (InstanceStatus) __VDLReflect(struct {
	Name string "v.io/v23/services/mgmt/device.InstanceStatus"
}) {
}

type (
	// StartServerMessage represents any single field of the StartServerMessage union type.
	//
	// StartServerMessage is the data type that is streamed from the server to the
	// client during a Start method call.
	StartServerMessage interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the StartServerMessage union type.
		__VDLReflect(__StartServerMessageReflect)
	}
	// StartServerMessageInstanceName represents field InstanceName of the StartServerMessage union type.
	//
	// The object name of the instance being started.
	StartServerMessageInstanceName struct{ Value string }
	// StartServerMessageInstancePublicKey represents field InstancePublicKey of the StartServerMessage union type.
	//
	// The public key of the instance being started. The client must return
	// blessings for this key.
	StartServerMessageInstancePublicKey struct{ Value []byte }
	// __StartServerMessageReflect describes the StartServerMessage union type.
	__StartServerMessageReflect struct {
		Name  string "v.io/v23/services/mgmt/device.StartServerMessage"
		Type  StartServerMessage
		Union struct {
			InstanceName      StartServerMessageInstanceName
			InstancePublicKey StartServerMessageInstancePublicKey
		}
	}
)

func (x StartServerMessageInstanceName) Index() int                               { return 0 }
func (x StartServerMessageInstanceName) Interface() interface{}                   { return x.Value }
func (x StartServerMessageInstanceName) Name() string                             { return "InstanceName" }
func (x StartServerMessageInstanceName) __VDLReflect(__StartServerMessageReflect) {}

func (x StartServerMessageInstancePublicKey) Index() int                               { return 1 }
func (x StartServerMessageInstancePublicKey) Interface() interface{}                   { return x.Value }
func (x StartServerMessageInstancePublicKey) Name() string                             { return "InstancePublicKey" }
func (x StartServerMessageInstancePublicKey) __VDLReflect(__StartServerMessageReflect) {}

type (
	// StartClientMessage represents any single field of the StartClientMessage union type.
	//
	// StartClientMessage is the data type that is streamed from the client to the
	// server during a Start method call.
	StartClientMessage interface {
		// Index returns the field index.
		Index() int
		// Interface returns the field value as an interface.
		Interface() interface{}
		// Name returns the field name.
		Name() string
		// __VDLReflect describes the StartClientMessage union type.
		__VDLReflect(__StartClientMessageReflect)
	}
	// StartClientMessageAppBlessings represents field AppBlessings of the StartClientMessage union type.
	//
	// Blessings for the application instance.
	StartClientMessageAppBlessings struct{ Value security.Blessings }
	// __StartClientMessageReflect describes the StartClientMessage union type.
	__StartClientMessageReflect struct {
		Name  string "v.io/v23/services/mgmt/device.StartClientMessage"
		Type  StartClientMessage
		Union struct {
			AppBlessings StartClientMessageAppBlessings
		}
	}
)

func (x StartClientMessageAppBlessings) Index() int                               { return 0 }
func (x StartClientMessageAppBlessings) Interface() interface{}                   { return x.Value }
func (x StartClientMessageAppBlessings) Name() string                             { return "AppBlessings" }
func (x StartClientMessageAppBlessings) __VDLReflect(__StartClientMessageReflect) {}

// Description enumerates the profiles that a Device supports.
type Description struct {
	// Profiles is a set of names of supported profiles.	Each name can
	// either be an object name that resolves to a Profile, or can be the
	// profile's label, e.g.:
	//   "profiles/google/cluster/diskfull"
	//   "linux-media"
	//
	// Profiles for devices can be provided by hand, but they can also be
	// automatically derived by examining the device.
	Profiles map[string]struct{}
}

func (Description) __VDLReflect(struct {
	Name string "v.io/v23/services/mgmt/device.Description"
}) {
}

// Association is a tuple containing an association between a Vanadium
// identity and a system account name.
type Association struct {
	IdentityName string
	AccountName  string
}

func (Association) __VDLReflect(struct {
	Name string "v.io/v23/services/mgmt/device.Association"
}) {
}

func init() {
	vdl.Register((*Config)(nil))
	vdl.Register((*InstallationState)(nil))
	vdl.Register((*InstanceState)(nil))
	vdl.Register((*Status)(nil))
	vdl.Register((*InstallationStatus)(nil))
	vdl.Register((*InstanceStatus)(nil))
	vdl.Register((*StartServerMessage)(nil))
	vdl.Register((*StartClientMessage)(nil))
	vdl.Register((*Description)(nil))
	vdl.Register((*Association)(nil))
}

// ApplicationClientMethods is the client interface
// containing Application methods.
//
// Application can be used to manage applications on a device. The
// idea is that this interace will be invoked using an object name that
// identifies the application and its installations and instances
// where applicable.
//
// In particular, the interface methods can be divided into three
// groups based on their intended receiver:
//
// 1) Method receiver is an application:
// -- Install()
//
// 2) Method receiver is an application installation:
// -- Start()
// -- Uninstall()
// -- Update()
//
// 3) Method receiver is application installation instance:
// -- Refresh()
// -- Restart()
// -- Resume()
// -- Stop()
// -- Suspend()
//
// For groups 2) and 3), the suffix that specifies the receiver can
// optionally omit the installation and/or instance, in which case the
// operation applies to all installations and/or instances in the
// scope of the suffix.
//
// Examples:
// # Install Google Maps on the device.
// device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/0"
//
// # Start an instance of the previously installed maps application installation.
// device/apps/google maps/0.Start() --> { "0" }
//
// # Start a second instance of the previously installed maps application installation.
// device/apps/google maps/0.Start() --> { "1" }
//
// # Stop the first instance previously started.
// device/apps/google maps/0/0.Stop()
//
// # Install a second Google Maps installation.
// device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/1"
//
// # Start an instance for all maps application installations.
// device/apps/google maps.Start() --> {"0/2", "1/0"}
//
// # Refresh the state of all instances of all maps application installations.
// device/apps/google maps.Refresh()
//
// # Refresh the state of all instances of the maps application installation
// identified by the given suffix.
// device/apps/google maps/0.Refresh()
//
// # Refresh the state of the maps application installation instance identified by
// the given suffix.
// device/apps/google maps/0/2.Refresh()
//
// # Update the second maps installation to the latest version available.
// device/apps/google maps/1.Update()
//
// # Update the first maps installation to a specific version.
// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
//
// Further, the following methods complement one another:
// -- Install() and Uninstall()
// -- Start() and Stop()
// -- Suspend() and Resume()
//
// Finally, an application installation instance can be in one of
// three abstract states: 1) "does not exist", 2) "running", or 3)
// "suspended". The interface methods transition between these
// abstract states using the following state machine:
//
// apply(Start(), "does not exists") = "running"
// apply(Refresh(), "running") = "running"
// apply(Refresh(), "suspended") = "suspended"
// apply(Restart(), "running") = "running"
// apply(Restart(), "suspended") = "running"
// apply(Resume(), "suspended") = "running"
// apply(Resume(), "running") = "running"
// apply(Stop(), "running") = "does not exist"
// apply(Stop(), "suspended") = "does not exist"
// apply(Suspend(), "running") = "suspended"
// apply(Suspend(), "suspended") = "suspended"
//
// In other words, invoking any method using an existing application
// installation instance as a receiver is well-defined.
type ApplicationClientMethods interface {
	// Object provides access control for Vanadium objects.
	//
	// Vanadium services implementing dynamic access control would typically embed
	// this interface and tag additional methods defined by the service with one of
	// Admin, Read, Write, Resolve etc. For example, the VDL definition of the
	// object would be:
	//
	//   package mypackage
	//
	//   import "v.io/v23/security/access"
	//   import "v.io/v23/services/security/object"
	//
	//   type MyObject interface {
	//     object.Object
	//     MyRead() (string, error) {access.Read}
	//     MyWrite(string) error    {access.Write}
	//   }
	//
	// If the set of pre-defined tags is insufficient, services may define their
	// own tag type and annotate all methods with this new type.
	//
	// Instead of embedding this Object interface, define SetPermissions and
	// GetPermissions in their own interface. Authorization policies will typically
	// respect annotations of a single type. For example, the VDL definition of an
	// object would be:
	//
	//  package mypackage
	//
	//  import "v.io/v23/security/access"
	//
	//  type MyTag string
	//
	//  const (
	//    Blue = MyTag("Blue")
	//    Red  = MyTag("Red")
	//  )
	//
	//  type MyObject interface {
	//    MyMethod() (string, error) {Blue}
	//
	//    // Allow clients to change access via the access.Object interface:
	//    SetPermissions(acl access.Permissions, etag string) error         {Red}
	//    GetPermissions() (acl access.Permissions, etag string, err error) {Blue}
	//  }
	object.ObjectClientMethods
	// Install installs the application identified by the first argument and
	// returns an object name suffix that identifies the new installation.
	//
	// The name argument should be an object name for an application
	// envelope.  The service it identifies must implement
	// repository.Application, and is expected to return either the
	// requested version (if the object name encodes a specific version), or
	// otherwise the latest available version, as appropriate.  This object
	// name will be used by default by the Update method, as a source for
	// updated application envelopes (can be overriden by setting
	// AppOriginConfigKey in the config).
	//
	// The config argument specifies config settings that will take
	// precedence over those present in the application envelope.
	//
	// The packages argument specifies packages to be installed in addition
	// to those specified in the envelope.  If a package in the envelope has
	// the same key, the package in the packages argument takes precedence.
	//
	// The returned suffix, when appended to the name used to reach the
	// receiver for Install, can be used to control the installation object.
	// The suffix will contain the title of the application as a prefix,
	// which can then be used to control all the installations of the given
	// application.
	// TODO(rjkroege): Use customized labels.
	Install(ctx *context.T, name string, config Config, packages application.Packages, opts ...rpc.CallOpt) (string, error)
	// Refresh refreshes the state of application installation(s)
	// instance(s).
	Refresh(*context.T, ...rpc.CallOpt) error
	// Restart restarts execution of application installation(s)
	// instance(s).
	Restart(*context.T, ...rpc.CallOpt) error
	// Resume resumes execution of application installation(s)
	// instance(s).
	Resume(*context.T, ...rpc.CallOpt) error
	// Revert reverts application installation(s) to the most recent
	// previous installation.
	Revert(*context.T, ...rpc.CallOpt) error
	// Start starts an instance of application installation(s). The
	// server sends the application instance's Public Key on the stream.
	// When the client receives the Public Key it must send Blessings back
	// to the server. When the instance is ready to start, the server sends
	// the instance name to the client.
	// Client                 Server
	//  "object".Start() -->
	//                   <--  InstancePublicKey
	//  AppBlessings     -->
	//                   <--  InstanceName
	Start(*context.T, ...rpc.CallOpt) (ApplicationStartClientCall, error)
	// Stop attempts a clean shutdown of application installation(s)
	// instance(s). If the deadline (in seconds) is non-zero and the
	// instance(s) in questions are still running after the given deadline,
	// shutdown of the instance(s) is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Stop(ctx *context.T, deadline uint32, opts ...rpc.CallOpt) error
	// Suspend suspends execution of application installation(s)
	// instance(s).
	Suspend(*context.T, ...rpc.CallOpt) error
	// Uninstall uninstalls application installation(s).
	Uninstall(*context.T, ...rpc.CallOpt) error
	// Update updates the application installation(s) from the object name
	// provided during Install.  If the new application envelope contains a
	// different application title, the update does not occur, and an error
	// is returned.
	Update(*context.T, ...rpc.CallOpt) error
	// UpdateTo updates the application installation(s) to the application
	// specified by the object name argument.  If the new application
	// envelope contains a different application title, the update does not
	// occur, and an error is returned.
	UpdateTo(ctx *context.T, name string, opts ...rpc.CallOpt) error
	// Debug returns debug information about the application installation or
	// instance.  This is generally highly implementation-specific, and
	// presented in an unstructured form.  No guarantees are given about the
	// stability of the format, and parsing it programmatically is
	// specifically discouraged.
	Debug(*context.T, ...rpc.CallOpt) (string, error)
	// Status return structured information about the application
	// installation or instance.
	Status(*context.T, ...rpc.CallOpt) (Status, error)
}

// ApplicationClientStub adds universal methods to ApplicationClientMethods.
type ApplicationClientStub interface {
	ApplicationClientMethods
	rpc.UniversalServiceMethods
}

// ApplicationClient returns a client stub for Application.
func ApplicationClient(name string, opts ...rpc.BindOpt) ApplicationClientStub {
	var client rpc.Client
	for _, opt := range opts {
		if clientOpt, ok := opt.(rpc.Client); ok {
			client = clientOpt
		}
	}
	return implApplicationClientStub{name, client, object.ObjectClient(name, client)}
}

type implApplicationClientStub struct {
	name   string
	client rpc.Client

	object.ObjectClientStub
}

func (c implApplicationClientStub) c(ctx *context.T) rpc.Client {
	if c.client != nil {
		return c.client
	}
	return v23.GetClient(ctx)
}

func (c implApplicationClientStub) Install(ctx *context.T, i0 string, i1 Config, i2 application.Packages, opts ...rpc.CallOpt) (o0 string, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Install", []interface{}{i0, i1, i2}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implApplicationClientStub) Refresh(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Refresh", nil, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implApplicationClientStub) Restart(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Restart", nil, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implApplicationClientStub) Resume(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Resume", nil, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implApplicationClientStub) Revert(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Revert", nil, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implApplicationClientStub) Start(ctx *context.T, opts ...rpc.CallOpt) (ocall ApplicationStartClientCall, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Start", nil, opts...); err != nil {
		return
	}
	ocall = &implApplicationStartClientCall{ClientCall: call}
	return
}

func (c implApplicationClientStub) Stop(ctx *context.T, i0 uint32, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Stop", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implApplicationClientStub) Suspend(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Suspend", nil, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implApplicationClientStub) Uninstall(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Uninstall", nil, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implApplicationClientStub) Update(ctx *context.T, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Update", nil, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implApplicationClientStub) UpdateTo(ctx *context.T, i0 string, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "UpdateTo", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implApplicationClientStub) Debug(ctx *context.T, opts ...rpc.CallOpt) (o0 string, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Debug", nil, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implApplicationClientStub) Status(ctx *context.T, opts ...rpc.CallOpt) (o0 Status, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Status", nil, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

// ApplicationStartClientStream is the client stream for Application.Start.
type ApplicationStartClientStream interface {
	// RecvStream returns the receiver side of the Application.Start client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() StartServerMessage
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the Application.Start client stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors
		// encountered while sending, or if Send is called after Close or
		// the stream has been canceled.  Blocks if there is no buffer
		// space; will unblock when buffer space is available or after
		// the stream has been canceled.
		Send(item StartClientMessage) error
		// Close indicates to the server that no more items will be sent;
		// server Recv calls will receive io.EOF after all sent items.
		// This is an optional call - e.g. a client might call Close if it
		// needs to continue receiving items from the server after it's
		// done sending.  Returns errors encountered while closing, or if
		// Close is called after the stream has been canceled.  Like Send,
		// blocks if there is no buffer space available.
		Close() error
	}
}

// ApplicationStartClientCall represents the call returned from Application.Start.
type ApplicationStartClientCall interface {
	ApplicationStartClientStream
	// Finish performs the equivalent of SendStream().Close, then blocks until
	// the server is done, and returns the positional return values for the call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implApplicationStartClientCall struct {
	rpc.ClientCall
	valRecv StartServerMessage
	errRecv error
}

func (c *implApplicationStartClientCall) RecvStream() interface {
	Advance() bool
	Value() StartServerMessage
	Err() error
} {
	return implApplicationStartClientCallRecv{c}
}

type implApplicationStartClientCallRecv struct {
	c *implApplicationStartClientCall
}

func (c implApplicationStartClientCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implApplicationStartClientCallRecv) Value() StartServerMessage {
	return c.c.valRecv
}
func (c implApplicationStartClientCallRecv) Err() error {
	if c.c.errRecv == io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implApplicationStartClientCall) SendStream() interface {
	Send(item StartClientMessage) error
	Close() error
} {
	return implApplicationStartClientCallSend{c}
}

type implApplicationStartClientCallSend struct {
	c *implApplicationStartClientCall
}

func (c implApplicationStartClientCallSend) Send(item StartClientMessage) error {
	return c.c.Send(item)
}
func (c implApplicationStartClientCallSend) Close() error {
	return c.c.CloseSend()
}
func (c *implApplicationStartClientCall) Finish() (err error) {
	err = c.ClientCall.Finish()
	return
}

// ApplicationServerMethods is the interface a server writer
// implements for Application.
//
// Application can be used to manage applications on a device. The
// idea is that this interace will be invoked using an object name that
// identifies the application and its installations and instances
// where applicable.
//
// In particular, the interface methods can be divided into three
// groups based on their intended receiver:
//
// 1) Method receiver is an application:
// -- Install()
//
// 2) Method receiver is an application installation:
// -- Start()
// -- Uninstall()
// -- Update()
//
// 3) Method receiver is application installation instance:
// -- Refresh()
// -- Restart()
// -- Resume()
// -- Stop()
// -- Suspend()
//
// For groups 2) and 3), the suffix that specifies the receiver can
// optionally omit the installation and/or instance, in which case the
// operation applies to all installations and/or instances in the
// scope of the suffix.
//
// Examples:
// # Install Google Maps on the device.
// device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/0"
//
// # Start an instance of the previously installed maps application installation.
// device/apps/google maps/0.Start() --> { "0" }
//
// # Start a second instance of the previously installed maps application installation.
// device/apps/google maps/0.Start() --> { "1" }
//
// # Stop the first instance previously started.
// device/apps/google maps/0/0.Stop()
//
// # Install a second Google Maps installation.
// device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/1"
//
// # Start an instance for all maps application installations.
// device/apps/google maps.Start() --> {"0/2", "1/0"}
//
// # Refresh the state of all instances of all maps application installations.
// device/apps/google maps.Refresh()
//
// # Refresh the state of all instances of the maps application installation
// identified by the given suffix.
// device/apps/google maps/0.Refresh()
//
// # Refresh the state of the maps application installation instance identified by
// the given suffix.
// device/apps/google maps/0/2.Refresh()
//
// # Update the second maps installation to the latest version available.
// device/apps/google maps/1.Update()
//
// # Update the first maps installation to a specific version.
// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
//
// Further, the following methods complement one another:
// -- Install() and Uninstall()
// -- Start() and Stop()
// -- Suspend() and Resume()
//
// Finally, an application installation instance can be in one of
// three abstract states: 1) "does not exist", 2) "running", or 3)
// "suspended". The interface methods transition between these
// abstract states using the following state machine:
//
// apply(Start(), "does not exists") = "running"
// apply(Refresh(), "running") = "running"
// apply(Refresh(), "suspended") = "suspended"
// apply(Restart(), "running") = "running"
// apply(Restart(), "suspended") = "running"
// apply(Resume(), "suspended") = "running"
// apply(Resume(), "running") = "running"
// apply(Stop(), "running") = "does not exist"
// apply(Stop(), "suspended") = "does not exist"
// apply(Suspend(), "running") = "suspended"
// apply(Suspend(), "suspended") = "suspended"
//
// In other words, invoking any method using an existing application
// installation instance as a receiver is well-defined.
type ApplicationServerMethods interface {
	// Object provides access control for Vanadium objects.
	//
	// Vanadium services implementing dynamic access control would typically embed
	// this interface and tag additional methods defined by the service with one of
	// Admin, Read, Write, Resolve etc. For example, the VDL definition of the
	// object would be:
	//
	//   package mypackage
	//
	//   import "v.io/v23/security/access"
	//   import "v.io/v23/services/security/object"
	//
	//   type MyObject interface {
	//     object.Object
	//     MyRead() (string, error) {access.Read}
	//     MyWrite(string) error    {access.Write}
	//   }
	//
	// If the set of pre-defined tags is insufficient, services may define their
	// own tag type and annotate all methods with this new type.
	//
	// Instead of embedding this Object interface, define SetPermissions and
	// GetPermissions in their own interface. Authorization policies will typically
	// respect annotations of a single type. For example, the VDL definition of an
	// object would be:
	//
	//  package mypackage
	//
	//  import "v.io/v23/security/access"
	//
	//  type MyTag string
	//
	//  const (
	//    Blue = MyTag("Blue")
	//    Red  = MyTag("Red")
	//  )
	//
	//  type MyObject interface {
	//    MyMethod() (string, error) {Blue}
	//
	//    // Allow clients to change access via the access.Object interface:
	//    SetPermissions(acl access.Permissions, etag string) error         {Red}
	//    GetPermissions() (acl access.Permissions, etag string, err error) {Blue}
	//  }
	object.ObjectServerMethods
	// Install installs the application identified by the first argument and
	// returns an object name suffix that identifies the new installation.
	//
	// The name argument should be an object name for an application
	// envelope.  The service it identifies must implement
	// repository.Application, and is expected to return either the
	// requested version (if the object name encodes a specific version), or
	// otherwise the latest available version, as appropriate.  This object
	// name will be used by default by the Update method, as a source for
	// updated application envelopes (can be overriden by setting
	// AppOriginConfigKey in the config).
	//
	// The config argument specifies config settings that will take
	// precedence over those present in the application envelope.
	//
	// The packages argument specifies packages to be installed in addition
	// to those specified in the envelope.  If a package in the envelope has
	// the same key, the package in the packages argument takes precedence.
	//
	// The returned suffix, when appended to the name used to reach the
	// receiver for Install, can be used to control the installation object.
	// The suffix will contain the title of the application as a prefix,
	// which can then be used to control all the installations of the given
	// application.
	// TODO(rjkroege): Use customized labels.
	Install(call rpc.ServerCall, name string, config Config, packages application.Packages) (string, error)
	// Refresh refreshes the state of application installation(s)
	// instance(s).
	Refresh(rpc.ServerCall) error
	// Restart restarts execution of application installation(s)
	// instance(s).
	Restart(rpc.ServerCall) error
	// Resume resumes execution of application installation(s)
	// instance(s).
	Resume(rpc.ServerCall) error
	// Revert reverts application installation(s) to the most recent
	// previous installation.
	Revert(rpc.ServerCall) error
	// Start starts an instance of application installation(s). The
	// server sends the application instance's Public Key on the stream.
	// When the client receives the Public Key it must send Blessings back
	// to the server. When the instance is ready to start, the server sends
	// the instance name to the client.
	// Client                 Server
	//  "object".Start() -->
	//                   <--  InstancePublicKey
	//  AppBlessings     -->
	//                   <--  InstanceName
	Start(ApplicationStartServerCall) error
	// Stop attempts a clean shutdown of application installation(s)
	// instance(s). If the deadline (in seconds) is non-zero and the
	// instance(s) in questions are still running after the given deadline,
	// shutdown of the instance(s) is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Stop(call rpc.ServerCall, deadline uint32) error
	// Suspend suspends execution of application installation(s)
	// instance(s).
	Suspend(rpc.ServerCall) error
	// Uninstall uninstalls application installation(s).
	Uninstall(rpc.ServerCall) error
	// Update updates the application installation(s) from the object name
	// provided during Install.  If the new application envelope contains a
	// different application title, the update does not occur, and an error
	// is returned.
	Update(rpc.ServerCall) error
	// UpdateTo updates the application installation(s) to the application
	// specified by the object name argument.  If the new application
	// envelope contains a different application title, the update does not
	// occur, and an error is returned.
	UpdateTo(call rpc.ServerCall, name string) error
	// Debug returns debug information about the application installation or
	// instance.  This is generally highly implementation-specific, and
	// presented in an unstructured form.  No guarantees are given about the
	// stability of the format, and parsing it programmatically is
	// specifically discouraged.
	Debug(rpc.ServerCall) (string, error)
	// Status return structured information about the application
	// installation or instance.
	Status(rpc.ServerCall) (Status, error)
}

// ApplicationServerStubMethods is the server interface containing
// Application methods, as expected by rpc.Server.
// The only difference between this interface and ApplicationServerMethods
// is the streaming methods.
type ApplicationServerStubMethods interface {
	// Object provides access control for Vanadium objects.
	//
	// Vanadium services implementing dynamic access control would typically embed
	// this interface and tag additional methods defined by the service with one of
	// Admin, Read, Write, Resolve etc. For example, the VDL definition of the
	// object would be:
	//
	//   package mypackage
	//
	//   import "v.io/v23/security/access"
	//   import "v.io/v23/services/security/object"
	//
	//   type MyObject interface {
	//     object.Object
	//     MyRead() (string, error) {access.Read}
	//     MyWrite(string) error    {access.Write}
	//   }
	//
	// If the set of pre-defined tags is insufficient, services may define their
	// own tag type and annotate all methods with this new type.
	//
	// Instead of embedding this Object interface, define SetPermissions and
	// GetPermissions in their own interface. Authorization policies will typically
	// respect annotations of a single type. For example, the VDL definition of an
	// object would be:
	//
	//  package mypackage
	//
	//  import "v.io/v23/security/access"
	//
	//  type MyTag string
	//
	//  const (
	//    Blue = MyTag("Blue")
	//    Red  = MyTag("Red")
	//  )
	//
	//  type MyObject interface {
	//    MyMethod() (string, error) {Blue}
	//
	//    // Allow clients to change access via the access.Object interface:
	//    SetPermissions(acl access.Permissions, etag string) error         {Red}
	//    GetPermissions() (acl access.Permissions, etag string, err error) {Blue}
	//  }
	object.ObjectServerStubMethods
	// Install installs the application identified by the first argument and
	// returns an object name suffix that identifies the new installation.
	//
	// The name argument should be an object name for an application
	// envelope.  The service it identifies must implement
	// repository.Application, and is expected to return either the
	// requested version (if the object name encodes a specific version), or
	// otherwise the latest available version, as appropriate.  This object
	// name will be used by default by the Update method, as a source for
	// updated application envelopes (can be overriden by setting
	// AppOriginConfigKey in the config).
	//
	// The config argument specifies config settings that will take
	// precedence over those present in the application envelope.
	//
	// The packages argument specifies packages to be installed in addition
	// to those specified in the envelope.  If a package in the envelope has
	// the same key, the package in the packages argument takes precedence.
	//
	// The returned suffix, when appended to the name used to reach the
	// receiver for Install, can be used to control the installation object.
	// The suffix will contain the title of the application as a prefix,
	// which can then be used to control all the installations of the given
	// application.
	// TODO(rjkroege): Use customized labels.
	Install(call rpc.ServerCall, name string, config Config, packages application.Packages) (string, error)
	// Refresh refreshes the state of application installation(s)
	// instance(s).
	Refresh(rpc.ServerCall) error
	// Restart restarts execution of application installation(s)
	// instance(s).
	Restart(rpc.ServerCall) error
	// Resume resumes execution of application installation(s)
	// instance(s).
	Resume(rpc.ServerCall) error
	// Revert reverts application installation(s) to the most recent
	// previous installation.
	Revert(rpc.ServerCall) error
	// Start starts an instance of application installation(s). The
	// server sends the application instance's Public Key on the stream.
	// When the client receives the Public Key it must send Blessings back
	// to the server. When the instance is ready to start, the server sends
	// the instance name to the client.
	// Client                 Server
	//  "object".Start() -->
	//                   <--  InstancePublicKey
	//  AppBlessings     -->
	//                   <--  InstanceName
	Start(*ApplicationStartServerCallStub) error
	// Stop attempts a clean shutdown of application installation(s)
	// instance(s). If the deadline (in seconds) is non-zero and the
	// instance(s) in questions are still running after the given deadline,
	// shutdown of the instance(s) is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Stop(call rpc.ServerCall, deadline uint32) error
	// Suspend suspends execution of application installation(s)
	// instance(s).
	Suspend(rpc.ServerCall) error
	// Uninstall uninstalls application installation(s).
	Uninstall(rpc.ServerCall) error
	// Update updates the application installation(s) from the object name
	// provided during Install.  If the new application envelope contains a
	// different application title, the update does not occur, and an error
	// is returned.
	Update(rpc.ServerCall) error
	// UpdateTo updates the application installation(s) to the application
	// specified by the object name argument.  If the new application
	// envelope contains a different application title, the update does not
	// occur, and an error is returned.
	UpdateTo(call rpc.ServerCall, name string) error
	// Debug returns debug information about the application installation or
	// instance.  This is generally highly implementation-specific, and
	// presented in an unstructured form.  No guarantees are given about the
	// stability of the format, and parsing it programmatically is
	// specifically discouraged.
	Debug(rpc.ServerCall) (string, error)
	// Status return structured information about the application
	// installation or instance.
	Status(rpc.ServerCall) (Status, error)
}

// ApplicationServerStub adds universal methods to ApplicationServerStubMethods.
type ApplicationServerStub interface {
	ApplicationServerStubMethods
	// Describe the Application interfaces.
	Describe__() []rpc.InterfaceDesc
}

// ApplicationServer returns a server stub for Application.
// It converts an implementation of ApplicationServerMethods into
// an object that may be used by rpc.Server.
func ApplicationServer(impl ApplicationServerMethods) ApplicationServerStub {
	stub := implApplicationServerStub{
		impl:             impl,
		ObjectServerStub: object.ObjectServer(impl),
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implApplicationServerStub struct {
	impl ApplicationServerMethods
	object.ObjectServerStub
	gs *rpc.GlobState
}

func (s implApplicationServerStub) Install(call rpc.ServerCall, i0 string, i1 Config, i2 application.Packages) (string, error) {
	return s.impl.Install(call, i0, i1, i2)
}

func (s implApplicationServerStub) Refresh(call rpc.ServerCall) error {
	return s.impl.Refresh(call)
}

func (s implApplicationServerStub) Restart(call rpc.ServerCall) error {
	return s.impl.Restart(call)
}

func (s implApplicationServerStub) Resume(call rpc.ServerCall) error {
	return s.impl.Resume(call)
}

func (s implApplicationServerStub) Revert(call rpc.ServerCall) error {
	return s.impl.Revert(call)
}

func (s implApplicationServerStub) Start(call *ApplicationStartServerCallStub) error {
	return s.impl.Start(call)
}

func (s implApplicationServerStub) Stop(call rpc.ServerCall, i0 uint32) error {
	return s.impl.Stop(call, i0)
}

func (s implApplicationServerStub) Suspend(call rpc.ServerCall) error {
	return s.impl.Suspend(call)
}

func (s implApplicationServerStub) Uninstall(call rpc.ServerCall) error {
	return s.impl.Uninstall(call)
}

func (s implApplicationServerStub) Update(call rpc.ServerCall) error {
	return s.impl.Update(call)
}

func (s implApplicationServerStub) UpdateTo(call rpc.ServerCall, i0 string) error {
	return s.impl.UpdateTo(call, i0)
}

func (s implApplicationServerStub) Debug(call rpc.ServerCall) (string, error) {
	return s.impl.Debug(call)
}

func (s implApplicationServerStub) Status(call rpc.ServerCall) (Status, error) {
	return s.impl.Status(call)
}

func (s implApplicationServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implApplicationServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{ApplicationDesc, object.ObjectDesc}
}

// ApplicationDesc describes the Application interface.
var ApplicationDesc rpc.InterfaceDesc = descApplication

// descApplication hides the desc to keep godoc clean.
var descApplication = rpc.InterfaceDesc{
	Name:    "Application",
	PkgPath: "v.io/v23/services/mgmt/device",
	Doc:     "// Application can be used to manage applications on a device. The\n// idea is that this interace will be invoked using an object name that\n// identifies the application and its installations and instances\n// where applicable.\n//\n// In particular, the interface methods can be divided into three\n// groups based on their intended receiver:\n//\n// 1) Method receiver is an application:\n// -- Install()\n//\n// 2) Method receiver is an application installation:\n// -- Start()\n// -- Uninstall()\n// -- Update()\n//\n// 3) Method receiver is application installation instance:\n// -- Refresh()\n// -- Restart()\n// -- Resume()\n// -- Stop()\n// -- Suspend()\n//\n// For groups 2) and 3), the suffix that specifies the receiver can\n// optionally omit the installation and/or instance, in which case the\n// operation applies to all installations and/or instances in the\n// scope of the suffix.\n//\n// Examples:\n// # Install Google Maps on the device.\n// device/apps.Install(\"/google.com/appstore/maps\", nil, nil) --> \"google maps/0\"\n//\n// # Start an instance of the previously installed maps application installation.\n// device/apps/google maps/0.Start() --> { \"0\" }\n//\n// # Start a second instance of the previously installed maps application installation.\n// device/apps/google maps/0.Start() --> { \"1\" }\n//\n// # Stop the first instance previously started.\n// device/apps/google maps/0/0.Stop()\n//\n// # Install a second Google Maps installation.\n// device/apps.Install(\"/google.com/appstore/maps\", nil, nil) --> \"google maps/1\"\n//\n// # Start an instance for all maps application installations.\n// device/apps/google maps.Start() --> {\"0/2\", \"1/0\"}\n//\n// # Refresh the state of all instances of all maps application installations.\n// device/apps/google maps.Refresh()\n//\n// # Refresh the state of all instances of the maps application installation\n// identified by the given suffix.\n// device/apps/google maps/0.Refresh()\n//\n// # Refresh the state of the maps application installation instance identified by\n// the given suffix.\n// device/apps/google maps/0/2.Refresh()\n//\n// # Update the second maps installation to the latest version available.\n// device/apps/google maps/1.Update()\n//\n// # Update the first maps installation to a specific version.\n// device/apps/google maps/0.UpdateTo(\"/google.com/appstore/beta/maps\")\n//\n// Further, the following methods complement one another:\n// -- Install() and Uninstall()\n// -- Start() and Stop()\n// -- Suspend() and Resume()\n//\n// Finally, an application installation instance can be in one of\n// three abstract states: 1) \"does not exist\", 2) \"running\", or 3)\n// \"suspended\". The interface methods transition between these\n// abstract states using the following state machine:\n//\n// apply(Start(), \"does not exists\") = \"running\"\n// apply(Refresh(), \"running\") = \"running\"\n// apply(Refresh(), \"suspended\") = \"suspended\"\n// apply(Restart(), \"running\") = \"running\"\n// apply(Restart(), \"suspended\") = \"running\"\n// apply(Resume(), \"suspended\") = \"running\"\n// apply(Resume(), \"running\") = \"running\"\n// apply(Stop(), \"running\") = \"does not exist\"\n// apply(Stop(), \"suspended\") = \"does not exist\"\n// apply(Suspend(), \"running\") = \"suspended\"\n// apply(Suspend(), \"suspended\") = \"suspended\"\n//\n// In other words, invoking any method using an existing application\n// installation instance as a receiver is well-defined.",
	Embeds: []rpc.EmbedDesc{
		{"Object", "v.io/v23/services/security/object", "// Object provides access control for Vanadium objects.\n//\n// Vanadium services implementing dynamic access control would typically embed\n// this interface and tag additional methods defined by the service with one of\n// Admin, Read, Write, Resolve etc. For example, the VDL definition of the\n// object would be:\n//\n//   package mypackage\n//\n//   import \"v.io/v23/security/access\"\n//   import \"v.io/v23/services/security/object\"\n//\n//   type MyObject interface {\n//     object.Object\n//     MyRead() (string, error) {access.Read}\n//     MyWrite(string) error    {access.Write}\n//   }\n//\n// If the set of pre-defined tags is insufficient, services may define their\n// own tag type and annotate all methods with this new type.\n//\n// Instead of embedding this Object interface, define SetPermissions and\n// GetPermissions in their own interface. Authorization policies will typically\n// respect annotations of a single type. For example, the VDL definition of an\n// object would be:\n//\n//  package mypackage\n//\n//  import \"v.io/v23/security/access\"\n//\n//  type MyTag string\n//\n//  const (\n//    Blue = MyTag(\"Blue\")\n//    Red  = MyTag(\"Red\")\n//  )\n//\n//  type MyObject interface {\n//    MyMethod() (string, error) {Blue}\n//\n//    // Allow clients to change access via the access.Object interface:\n//    SetPermissions(acl access.Permissions, etag string) error         {Red}\n//    GetPermissions() (acl access.Permissions, etag string, err error) {Blue}\n//  }"},
	},
	Methods: []rpc.MethodDesc{
		{
			Name: "Install",
			Doc:  "// Install installs the application identified by the first argument and\n// returns an object name suffix that identifies the new installation.\n//\n// The name argument should be an object name for an application\n// envelope.  The service it identifies must implement\n// repository.Application, and is expected to return either the\n// requested version (if the object name encodes a specific version), or\n// otherwise the latest available version, as appropriate.  This object\n// name will be used by default by the Update method, as a source for\n// updated application envelopes (can be overriden by setting\n// AppOriginConfigKey in the config).\n//\n// The config argument specifies config settings that will take\n// precedence over those present in the application envelope.\n//\n// The packages argument specifies packages to be installed in addition\n// to those specified in the envelope.  If a package in the envelope has\n// the same key, the package in the packages argument takes precedence.\n//\n// The returned suffix, when appended to the name used to reach the\n// receiver for Install, can be used to control the installation object.\n// The suffix will contain the title of the application as a prefix,\n// which can then be used to control all the installations of the given\n// application.\n// TODO(rjkroege): Use customized labels.",
			InArgs: []rpc.ArgDesc{
				{"name", ``},     // string
				{"config", ``},   // Config
				{"packages", ``}, // application.Packages
			},
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Write"))},
		},
		{
			Name: "Refresh",
			Doc:  "// Refresh refreshes the state of application installation(s)\n// instance(s).",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Restart",
			Doc:  "// Restart restarts execution of application installation(s)\n// instance(s).",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Write"))},
		},
		{
			Name: "Resume",
			Doc:  "// Resume resumes execution of application installation(s)\n// instance(s).",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Write"))},
		},
		{
			Name: "Revert",
			Doc:  "// Revert reverts application installation(s) to the most recent\n// previous installation.",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Start",
			Doc:  "// Start starts an instance of application installation(s). The\n// server sends the application instance's Public Key on the stream.\n// When the client receives the Public Key it must send Blessings back\n// to the server. When the instance is ready to start, the server sends\n// the instance name to the client.\n// Client                 Server\n//  \"object\".Start() -->\n//                   <--  InstancePublicKey\n//  AppBlessings     -->\n//                   <--  InstanceName",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Read"))},
		},
		{
			Name: "Stop",
			Doc:  "// Stop attempts a clean shutdown of application installation(s)\n// instance(s). If the deadline (in seconds) is non-zero and the\n// instance(s) in questions are still running after the given deadline,\n// shutdown of the instance(s) is enforced.\n//\n// TODO(jsimsa): Switch deadline to time.Duration when built-in types\n// are implemented.",
			InArgs: []rpc.ArgDesc{
				{"deadline", ``}, // uint32
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Suspend",
			Doc:  "// Suspend suspends execution of application installation(s)\n// instance(s).",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Write"))},
		},
		{
			Name: "Uninstall",
			Doc:  "// Uninstall uninstalls application installation(s).",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Update",
			Doc:  "// Update updates the application installation(s) from the object name\n// provided during Install.  If the new application envelope contains a\n// different application title, the update does not occur, and an error\n// is returned.",
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "UpdateTo",
			Doc:  "// UpdateTo updates the application installation(s) to the application\n// specified by the object name argument.  If the new application\n// envelope contains a different application title, the update does not\n// occur, and an error is returned.",
			InArgs: []rpc.ArgDesc{
				{"name", ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Debug",
			Doc:  "// Debug returns debug information about the application installation or\n// instance.  This is generally highly implementation-specific, and\n// presented in an unstructured form.  No guarantees are given about the\n// stability of the format, and parsing it programmatically is\n// specifically discouraged.",
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Debug"))},
		},
		{
			Name: "Status",
			Doc:  "// Status return structured information about the application\n// installation or instance.",
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // Status
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Read"))},
		},
	},
}

// ApplicationStartServerStream is the server stream for Application.Start.
type ApplicationStartServerStream interface {
	// RecvStream returns the receiver side of the Application.Start server stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() StartClientMessage
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
	// SendStream returns the send side of the Application.Start server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item StartServerMessage) error
	}
}

// ApplicationStartServerCall represents the context passed to Application.Start.
type ApplicationStartServerCall interface {
	rpc.ServerCall
	ApplicationStartServerStream
}

// ApplicationStartServerCallStub is a wrapper that converts rpc.StreamServerCall into
// a typesafe stub that implements ApplicationStartServerCall.
type ApplicationStartServerCallStub struct {
	rpc.StreamServerCall
	valRecv StartClientMessage
	errRecv error
}

// Init initializes ApplicationStartServerCallStub from rpc.StreamServerCall.
func (s *ApplicationStartServerCallStub) Init(call rpc.StreamServerCall) {
	s.StreamServerCall = call
}

// RecvStream returns the receiver side of the Application.Start server stream.
func (s *ApplicationStartServerCallStub) RecvStream() interface {
	Advance() bool
	Value() StartClientMessage
	Err() error
} {
	return implApplicationStartServerCallRecv{s}
}

type implApplicationStartServerCallRecv struct {
	s *ApplicationStartServerCallStub
}

func (s implApplicationStartServerCallRecv) Advance() bool {
	s.s.errRecv = s.s.Recv(&s.s.valRecv)
	return s.s.errRecv == nil
}
func (s implApplicationStartServerCallRecv) Value() StartClientMessage {
	return s.s.valRecv
}
func (s implApplicationStartServerCallRecv) Err() error {
	if s.s.errRecv == io.EOF {
		return nil
	}
	return s.s.errRecv
}

// SendStream returns the send side of the Application.Start server stream.
func (s *ApplicationStartServerCallStub) SendStream() interface {
	Send(item StartServerMessage) error
} {
	return implApplicationStartServerCallSend{s}
}

type implApplicationStartServerCallSend struct {
	s *ApplicationStartServerCallStub
}

func (s implApplicationStartServerCallSend) Send(item StartServerMessage) error {
	return s.s.Send(item)
}

// ClaimableClientMethods is the client interface
// containing Claimable methods.
//
// Claimable represents an uninitialized device with no owner
// (i.e., a device that has no blessings).
//
// Claim is used to claim ownership by blessing the device's private key.
// Devices that have provided a pairing token to the claimer through an
// out-of-band communication channel (eg: display/email) would expect this
// pairing token to be replayed by the claimer.
//
// Once claimed, the device will export the "Device" interface and all methods
// will be restricted to the claimer.
//
// The blessings that the device is to be claimed with is provided
// via the ipc.Granter option in Go.
type ClaimableClientMethods interface {
	Claim(ctx *context.T, pairingToken string, opts ...rpc.CallOpt) error
}

// ClaimableClientStub adds universal methods to ClaimableClientMethods.
type ClaimableClientStub interface {
	ClaimableClientMethods
	rpc.UniversalServiceMethods
}

// ClaimableClient returns a client stub for Claimable.
func ClaimableClient(name string, opts ...rpc.BindOpt) ClaimableClientStub {
	var client rpc.Client
	for _, opt := range opts {
		if clientOpt, ok := opt.(rpc.Client); ok {
			client = clientOpt
		}
	}
	return implClaimableClientStub{name, client}
}

type implClaimableClientStub struct {
	name   string
	client rpc.Client
}

func (c implClaimableClientStub) c(ctx *context.T) rpc.Client {
	if c.client != nil {
		return c.client
	}
	return v23.GetClient(ctx)
}

func (c implClaimableClientStub) Claim(ctx *context.T, i0 string, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Claim", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

// ClaimableServerMethods is the interface a server writer
// implements for Claimable.
//
// Claimable represents an uninitialized device with no owner
// (i.e., a device that has no blessings).
//
// Claim is used to claim ownership by blessing the device's private key.
// Devices that have provided a pairing token to the claimer through an
// out-of-band communication channel (eg: display/email) would expect this
// pairing token to be replayed by the claimer.
//
// Once claimed, the device will export the "Device" interface and all methods
// will be restricted to the claimer.
//
// The blessings that the device is to be claimed with is provided
// via the ipc.Granter option in Go.
type ClaimableServerMethods interface {
	Claim(call rpc.ServerCall, pairingToken string) error
}

// ClaimableServerStubMethods is the server interface containing
// Claimable methods, as expected by rpc.Server.
// There is no difference between this interface and ClaimableServerMethods
// since there are no streaming methods.
type ClaimableServerStubMethods ClaimableServerMethods

// ClaimableServerStub adds universal methods to ClaimableServerStubMethods.
type ClaimableServerStub interface {
	ClaimableServerStubMethods
	// Describe the Claimable interfaces.
	Describe__() []rpc.InterfaceDesc
}

// ClaimableServer returns a server stub for Claimable.
// It converts an implementation of ClaimableServerMethods into
// an object that may be used by rpc.Server.
func ClaimableServer(impl ClaimableServerMethods) ClaimableServerStub {
	stub := implClaimableServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implClaimableServerStub struct {
	impl ClaimableServerMethods
	gs   *rpc.GlobState
}

func (s implClaimableServerStub) Claim(call rpc.ServerCall, i0 string) error {
	return s.impl.Claim(call, i0)
}

func (s implClaimableServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implClaimableServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{ClaimableDesc}
}

// ClaimableDesc describes the Claimable interface.
var ClaimableDesc rpc.InterfaceDesc = descClaimable

// descClaimable hides the desc to keep godoc clean.
var descClaimable = rpc.InterfaceDesc{
	Name:    "Claimable",
	PkgPath: "v.io/v23/services/mgmt/device",
	Doc:     "// Claimable represents an uninitialized device with no owner\n// (i.e., a device that has no blessings).\n//\n// Claim is used to claim ownership by blessing the device's private key.\n// Devices that have provided a pairing token to the claimer through an\n// out-of-band communication channel (eg: display/email) would expect this\n// pairing token to be replayed by the claimer.\n//\n// Once claimed, the device will export the \"Device\" interface and all methods\n// will be restricted to the claimer.\n//\n// The blessings that the device is to be claimed with is provided\n// via the ipc.Granter option in Go.",
	Methods: []rpc.MethodDesc{
		{
			Name: "Claim",
			InArgs: []rpc.ArgDesc{
				{"pairingToken", ``}, // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
	},
}

// DeviceClientMethods is the client interface
// containing Device methods.
//
// Device can be used to manage a device remotely using an object name that
// identifies it.
type DeviceClientMethods interface {
	// Application can be used to manage applications on a device. The
	// idea is that this interace will be invoked using an object name that
	// identifies the application and its installations and instances
	// where applicable.
	//
	// In particular, the interface methods can be divided into three
	// groups based on their intended receiver:
	//
	// 1) Method receiver is an application:
	// -- Install()
	//
	// 2) Method receiver is an application installation:
	// -- Start()
	// -- Uninstall()
	// -- Update()
	//
	// 3) Method receiver is application installation instance:
	// -- Refresh()
	// -- Restart()
	// -- Resume()
	// -- Stop()
	// -- Suspend()
	//
	// For groups 2) and 3), the suffix that specifies the receiver can
	// optionally omit the installation and/or instance, in which case the
	// operation applies to all installations and/or instances in the
	// scope of the suffix.
	//
	// Examples:
	// # Install Google Maps on the device.
	// device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/0"
	//
	// # Start an instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "0" }
	//
	// # Start a second instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "1" }
	//
	// # Stop the first instance previously started.
	// device/apps/google maps/0/0.Stop()
	//
	// # Install a second Google Maps installation.
	// device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/1"
	//
	// # Start an instance for all maps application installations.
	// device/apps/google maps.Start() --> {"0/2", "1/0"}
	//
	// # Refresh the state of all instances of all maps application installations.
	// device/apps/google maps.Refresh()
	//
	// # Refresh the state of all instances of the maps application installation
	// identified by the given suffix.
	// device/apps/google maps/0.Refresh()
	//
	// # Refresh the state of the maps application installation instance identified by
	// the given suffix.
	// device/apps/google maps/0/2.Refresh()
	//
	// # Update the second maps installation to the latest version available.
	// device/apps/google maps/1.Update()
	//
	// # Update the first maps installation to a specific version.
	// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
	//
	// Further, the following methods complement one another:
	// -- Install() and Uninstall()
	// -- Start() and Stop()
	// -- Suspend() and Resume()
	//
	// Finally, an application installation instance can be in one of
	// three abstract states: 1) "does not exist", 2) "running", or 3)
	// "suspended". The interface methods transition between these
	// abstract states using the following state machine:
	//
	// apply(Start(), "does not exists") = "running"
	// apply(Refresh(), "running") = "running"
	// apply(Refresh(), "suspended") = "suspended"
	// apply(Restart(), "running") = "running"
	// apply(Restart(), "suspended") = "running"
	// apply(Resume(), "suspended") = "running"
	// apply(Resume(), "running") = "running"
	// apply(Stop(), "running") = "does not exist"
	// apply(Stop(), "suspended") = "does not exist"
	// apply(Suspend(), "running") = "suspended"
	// apply(Suspend(), "suspended") = "suspended"
	//
	// In other words, invoking any method using an existing application
	// installation instance as a receiver is well-defined.
	ApplicationClientMethods
	// Describe generates a description of the device.
	Describe(*context.T, ...rpc.CallOpt) (Description, error)
	// IsRunnable checks if the device can execute the given binary.
	IsRunnable(ctx *context.T, description binary.Description, opts ...rpc.CallOpt) (bool, error)
	// Reset resets the device. If the deadline is non-zero and the device
	// in question is still running after the given deadline expired,
	// reset of the device is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Reset(ctx *context.T, deadline uint64, opts ...rpc.CallOpt) error
	// AssociateAccount associates a local  system account name with the provided
	// Vanadium identities. It replaces the existing association if one already exists for that
	// identity. Setting an AccountName to "" removes the association for each
	// listed identity.
	AssociateAccount(ctx *context.T, identityNames []string, accountName string, opts ...rpc.CallOpt) error
	// ListAssociations returns all of the associations between Vanadium identities
	// and system names.
	ListAssociations(*context.T, ...rpc.CallOpt) ([]Association, error)
}

// DeviceClientStub adds universal methods to DeviceClientMethods.
type DeviceClientStub interface {
	DeviceClientMethods
	rpc.UniversalServiceMethods
}

// DeviceClient returns a client stub for Device.
func DeviceClient(name string, opts ...rpc.BindOpt) DeviceClientStub {
	var client rpc.Client
	for _, opt := range opts {
		if clientOpt, ok := opt.(rpc.Client); ok {
			client = clientOpt
		}
	}
	return implDeviceClientStub{name, client, ApplicationClient(name, client)}
}

type implDeviceClientStub struct {
	name   string
	client rpc.Client

	ApplicationClientStub
}

func (c implDeviceClientStub) c(ctx *context.T) rpc.Client {
	if c.client != nil {
		return c.client
	}
	return v23.GetClient(ctx)
}

func (c implDeviceClientStub) Describe(ctx *context.T, opts ...rpc.CallOpt) (o0 Description, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Describe", nil, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implDeviceClientStub) IsRunnable(ctx *context.T, i0 binary.Description, opts ...rpc.CallOpt) (o0 bool, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "IsRunnable", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

func (c implDeviceClientStub) Reset(ctx *context.T, i0 uint64, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Reset", []interface{}{i0}, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implDeviceClientStub) AssociateAccount(ctx *context.T, i0 []string, i1 string, opts ...rpc.CallOpt) (err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "AssociateAccount", []interface{}{i0, i1}, opts...); err != nil {
		return
	}
	err = call.Finish()
	return
}

func (c implDeviceClientStub) ListAssociations(ctx *context.T, opts ...rpc.CallOpt) (o0 []Association, err error) {
	var call rpc.ClientCall
	if call, err = c.c(ctx).StartCall(ctx, c.name, "ListAssociations", nil, opts...); err != nil {
		return
	}
	err = call.Finish(&o0)
	return
}

// DeviceServerMethods is the interface a server writer
// implements for Device.
//
// Device can be used to manage a device remotely using an object name that
// identifies it.
type DeviceServerMethods interface {
	// Application can be used to manage applications on a device. The
	// idea is that this interace will be invoked using an object name that
	// identifies the application and its installations and instances
	// where applicable.
	//
	// In particular, the interface methods can be divided into three
	// groups based on their intended receiver:
	//
	// 1) Method receiver is an application:
	// -- Install()
	//
	// 2) Method receiver is an application installation:
	// -- Start()
	// -- Uninstall()
	// -- Update()
	//
	// 3) Method receiver is application installation instance:
	// -- Refresh()
	// -- Restart()
	// -- Resume()
	// -- Stop()
	// -- Suspend()
	//
	// For groups 2) and 3), the suffix that specifies the receiver can
	// optionally omit the installation and/or instance, in which case the
	// operation applies to all installations and/or instances in the
	// scope of the suffix.
	//
	// Examples:
	// # Install Google Maps on the device.
	// device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/0"
	//
	// # Start an instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "0" }
	//
	// # Start a second instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "1" }
	//
	// # Stop the first instance previously started.
	// device/apps/google maps/0/0.Stop()
	//
	// # Install a second Google Maps installation.
	// device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/1"
	//
	// # Start an instance for all maps application installations.
	// device/apps/google maps.Start() --> {"0/2", "1/0"}
	//
	// # Refresh the state of all instances of all maps application installations.
	// device/apps/google maps.Refresh()
	//
	// # Refresh the state of all instances of the maps application installation
	// identified by the given suffix.
	// device/apps/google maps/0.Refresh()
	//
	// # Refresh the state of the maps application installation instance identified by
	// the given suffix.
	// device/apps/google maps/0/2.Refresh()
	//
	// # Update the second maps installation to the latest version available.
	// device/apps/google maps/1.Update()
	//
	// # Update the first maps installation to a specific version.
	// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
	//
	// Further, the following methods complement one another:
	// -- Install() and Uninstall()
	// -- Start() and Stop()
	// -- Suspend() and Resume()
	//
	// Finally, an application installation instance can be in one of
	// three abstract states: 1) "does not exist", 2) "running", or 3)
	// "suspended". The interface methods transition between these
	// abstract states using the following state machine:
	//
	// apply(Start(), "does not exists") = "running"
	// apply(Refresh(), "running") = "running"
	// apply(Refresh(), "suspended") = "suspended"
	// apply(Restart(), "running") = "running"
	// apply(Restart(), "suspended") = "running"
	// apply(Resume(), "suspended") = "running"
	// apply(Resume(), "running") = "running"
	// apply(Stop(), "running") = "does not exist"
	// apply(Stop(), "suspended") = "does not exist"
	// apply(Suspend(), "running") = "suspended"
	// apply(Suspend(), "suspended") = "suspended"
	//
	// In other words, invoking any method using an existing application
	// installation instance as a receiver is well-defined.
	ApplicationServerMethods
	// Describe generates a description of the device.
	Describe(rpc.ServerCall) (Description, error)
	// IsRunnable checks if the device can execute the given binary.
	IsRunnable(call rpc.ServerCall, description binary.Description) (bool, error)
	// Reset resets the device. If the deadline is non-zero and the device
	// in question is still running after the given deadline expired,
	// reset of the device is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Reset(call rpc.ServerCall, deadline uint64) error
	// AssociateAccount associates a local  system account name with the provided
	// Vanadium identities. It replaces the existing association if one already exists for that
	// identity. Setting an AccountName to "" removes the association for each
	// listed identity.
	AssociateAccount(call rpc.ServerCall, identityNames []string, accountName string) error
	// ListAssociations returns all of the associations between Vanadium identities
	// and system names.
	ListAssociations(rpc.ServerCall) ([]Association, error)
}

// DeviceServerStubMethods is the server interface containing
// Device methods, as expected by rpc.Server.
// The only difference between this interface and DeviceServerMethods
// is the streaming methods.
type DeviceServerStubMethods interface {
	// Application can be used to manage applications on a device. The
	// idea is that this interace will be invoked using an object name that
	// identifies the application and its installations and instances
	// where applicable.
	//
	// In particular, the interface methods can be divided into three
	// groups based on their intended receiver:
	//
	// 1) Method receiver is an application:
	// -- Install()
	//
	// 2) Method receiver is an application installation:
	// -- Start()
	// -- Uninstall()
	// -- Update()
	//
	// 3) Method receiver is application installation instance:
	// -- Refresh()
	// -- Restart()
	// -- Resume()
	// -- Stop()
	// -- Suspend()
	//
	// For groups 2) and 3), the suffix that specifies the receiver can
	// optionally omit the installation and/or instance, in which case the
	// operation applies to all installations and/or instances in the
	// scope of the suffix.
	//
	// Examples:
	// # Install Google Maps on the device.
	// device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/0"
	//
	// # Start an instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "0" }
	//
	// # Start a second instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "1" }
	//
	// # Stop the first instance previously started.
	// device/apps/google maps/0/0.Stop()
	//
	// # Install a second Google Maps installation.
	// device/apps.Install("/google.com/appstore/maps", nil, nil) --> "google maps/1"
	//
	// # Start an instance for all maps application installations.
	// device/apps/google maps.Start() --> {"0/2", "1/0"}
	//
	// # Refresh the state of all instances of all maps application installations.
	// device/apps/google maps.Refresh()
	//
	// # Refresh the state of all instances of the maps application installation
	// identified by the given suffix.
	// device/apps/google maps/0.Refresh()
	//
	// # Refresh the state of the maps application installation instance identified by
	// the given suffix.
	// device/apps/google maps/0/2.Refresh()
	//
	// # Update the second maps installation to the latest version available.
	// device/apps/google maps/1.Update()
	//
	// # Update the first maps installation to a specific version.
	// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
	//
	// Further, the following methods complement one another:
	// -- Install() and Uninstall()
	// -- Start() and Stop()
	// -- Suspend() and Resume()
	//
	// Finally, an application installation instance can be in one of
	// three abstract states: 1) "does not exist", 2) "running", or 3)
	// "suspended". The interface methods transition between these
	// abstract states using the following state machine:
	//
	// apply(Start(), "does not exists") = "running"
	// apply(Refresh(), "running") = "running"
	// apply(Refresh(), "suspended") = "suspended"
	// apply(Restart(), "running") = "running"
	// apply(Restart(), "suspended") = "running"
	// apply(Resume(), "suspended") = "running"
	// apply(Resume(), "running") = "running"
	// apply(Stop(), "running") = "does not exist"
	// apply(Stop(), "suspended") = "does not exist"
	// apply(Suspend(), "running") = "suspended"
	// apply(Suspend(), "suspended") = "suspended"
	//
	// In other words, invoking any method using an existing application
	// installation instance as a receiver is well-defined.
	ApplicationServerStubMethods
	// Describe generates a description of the device.
	Describe(rpc.ServerCall) (Description, error)
	// IsRunnable checks if the device can execute the given binary.
	IsRunnable(call rpc.ServerCall, description binary.Description) (bool, error)
	// Reset resets the device. If the deadline is non-zero and the device
	// in question is still running after the given deadline expired,
	// reset of the device is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Reset(call rpc.ServerCall, deadline uint64) error
	// AssociateAccount associates a local  system account name with the provided
	// Vanadium identities. It replaces the existing association if one already exists for that
	// identity. Setting an AccountName to "" removes the association for each
	// listed identity.
	AssociateAccount(call rpc.ServerCall, identityNames []string, accountName string) error
	// ListAssociations returns all of the associations between Vanadium identities
	// and system names.
	ListAssociations(rpc.ServerCall) ([]Association, error)
}

// DeviceServerStub adds universal methods to DeviceServerStubMethods.
type DeviceServerStub interface {
	DeviceServerStubMethods
	// Describe the Device interfaces.
	Describe__() []rpc.InterfaceDesc
}

// DeviceServer returns a server stub for Device.
// It converts an implementation of DeviceServerMethods into
// an object that may be used by rpc.Server.
func DeviceServer(impl DeviceServerMethods) DeviceServerStub {
	stub := implDeviceServerStub{
		impl: impl,
		ApplicationServerStub: ApplicationServer(impl),
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := rpc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := rpc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implDeviceServerStub struct {
	impl DeviceServerMethods
	ApplicationServerStub
	gs *rpc.GlobState
}

func (s implDeviceServerStub) Describe(call rpc.ServerCall) (Description, error) {
	return s.impl.Describe(call)
}

func (s implDeviceServerStub) IsRunnable(call rpc.ServerCall, i0 binary.Description) (bool, error) {
	return s.impl.IsRunnable(call, i0)
}

func (s implDeviceServerStub) Reset(call rpc.ServerCall, i0 uint64) error {
	return s.impl.Reset(call, i0)
}

func (s implDeviceServerStub) AssociateAccount(call rpc.ServerCall, i0 []string, i1 string) error {
	return s.impl.AssociateAccount(call, i0, i1)
}

func (s implDeviceServerStub) ListAssociations(call rpc.ServerCall) ([]Association, error) {
	return s.impl.ListAssociations(call)
}

func (s implDeviceServerStub) Globber() *rpc.GlobState {
	return s.gs
}

func (s implDeviceServerStub) Describe__() []rpc.InterfaceDesc {
	return []rpc.InterfaceDesc{DeviceDesc, ApplicationDesc, object.ObjectDesc}
}

// DeviceDesc describes the Device interface.
var DeviceDesc rpc.InterfaceDesc = descDevice

// descDevice hides the desc to keep godoc clean.
var descDevice = rpc.InterfaceDesc{
	Name:    "Device",
	PkgPath: "v.io/v23/services/mgmt/device",
	Doc:     "// Device can be used to manage a device remotely using an object name that\n// identifies it.",
	Embeds: []rpc.EmbedDesc{
		{"Application", "v.io/v23/services/mgmt/device", "// Application can be used to manage applications on a device. The\n// idea is that this interace will be invoked using an object name that\n// identifies the application and its installations and instances\n// where applicable.\n//\n// In particular, the interface methods can be divided into three\n// groups based on their intended receiver:\n//\n// 1) Method receiver is an application:\n// -- Install()\n//\n// 2) Method receiver is an application installation:\n// -- Start()\n// -- Uninstall()\n// -- Update()\n//\n// 3) Method receiver is application installation instance:\n// -- Refresh()\n// -- Restart()\n// -- Resume()\n// -- Stop()\n// -- Suspend()\n//\n// For groups 2) and 3), the suffix that specifies the receiver can\n// optionally omit the installation and/or instance, in which case the\n// operation applies to all installations and/or instances in the\n// scope of the suffix.\n//\n// Examples:\n// # Install Google Maps on the device.\n// device/apps.Install(\"/google.com/appstore/maps\", nil, nil) --> \"google maps/0\"\n//\n// # Start an instance of the previously installed maps application installation.\n// device/apps/google maps/0.Start() --> { \"0\" }\n//\n// # Start a second instance of the previously installed maps application installation.\n// device/apps/google maps/0.Start() --> { \"1\" }\n//\n// # Stop the first instance previously started.\n// device/apps/google maps/0/0.Stop()\n//\n// # Install a second Google Maps installation.\n// device/apps.Install(\"/google.com/appstore/maps\", nil, nil) --> \"google maps/1\"\n//\n// # Start an instance for all maps application installations.\n// device/apps/google maps.Start() --> {\"0/2\", \"1/0\"}\n//\n// # Refresh the state of all instances of all maps application installations.\n// device/apps/google maps.Refresh()\n//\n// # Refresh the state of all instances of the maps application installation\n// identified by the given suffix.\n// device/apps/google maps/0.Refresh()\n//\n// # Refresh the state of the maps application installation instance identified by\n// the given suffix.\n// device/apps/google maps/0/2.Refresh()\n//\n// # Update the second maps installation to the latest version available.\n// device/apps/google maps/1.Update()\n//\n// # Update the first maps installation to a specific version.\n// device/apps/google maps/0.UpdateTo(\"/google.com/appstore/beta/maps\")\n//\n// Further, the following methods complement one another:\n// -- Install() and Uninstall()\n// -- Start() and Stop()\n// -- Suspend() and Resume()\n//\n// Finally, an application installation instance can be in one of\n// three abstract states: 1) \"does not exist\", 2) \"running\", or 3)\n// \"suspended\". The interface methods transition between these\n// abstract states using the following state machine:\n//\n// apply(Start(), \"does not exists\") = \"running\"\n// apply(Refresh(), \"running\") = \"running\"\n// apply(Refresh(), \"suspended\") = \"suspended\"\n// apply(Restart(), \"running\") = \"running\"\n// apply(Restart(), \"suspended\") = \"running\"\n// apply(Resume(), \"suspended\") = \"running\"\n// apply(Resume(), \"running\") = \"running\"\n// apply(Stop(), \"running\") = \"does not exist\"\n// apply(Stop(), \"suspended\") = \"does not exist\"\n// apply(Suspend(), \"running\") = \"suspended\"\n// apply(Suspend(), \"suspended\") = \"suspended\"\n//\n// In other words, invoking any method using an existing application\n// installation instance as a receiver is well-defined."},
	},
	Methods: []rpc.MethodDesc{
		{
			Name: "Describe",
			Doc:  "// Describe generates a description of the device.",
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // Description
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "IsRunnable",
			Doc:  "// IsRunnable checks if the device can execute the given binary.",
			InArgs: []rpc.ArgDesc{
				{"description", ``}, // binary.Description
			},
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // bool
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "Reset",
			Doc:  "// Reset resets the device. If the deadline is non-zero and the device\n// in question is still running after the given deadline expired,\n// reset of the device is enforced.\n//\n// TODO(jsimsa): Switch deadline to time.Duration when built-in types\n// are implemented.",
			InArgs: []rpc.ArgDesc{
				{"deadline", ``}, // uint64
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "AssociateAccount",
			Doc:  "// AssociateAccount associates a local  system account name with the provided\n// Vanadium identities. It replaces the existing association if one already exists for that\n// identity. Setting an AccountName to \"\" removes the association for each\n// listed identity.",
			InArgs: []rpc.ArgDesc{
				{"identityNames", ``}, // []string
				{"accountName", ``},   // string
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
		{
			Name: "ListAssociations",
			Doc:  "// ListAssociations returns all of the associations between Vanadium identities\n// and system names.",
			OutArgs: []rpc.ArgDesc{
				{"", ``}, // []Association
			},
			Tags: []*vdl.Value{vdl.ValueOf(access.Tag("Admin"))},
		},
	},
}
