// Package node supports managing a node and applications running on
// the node.
package node

import (
  "veyron2/services/mgmt/build"
)

// Description enumerates the profiles that a Node supports.
type Description struct {
  // Profiles is a set of names of supported profiles.  Each name can
  // either be a veyron name that resolves to a Profile, or can be the
  // profile's label, e.g.:
  //   "profiles/google/cluster/diskfull"
  //   "linux-media"
  //
  // Profiles for nodes can be provided by hand, but they can also be
  // automatically derived by examining the node.
  Profiles map[string]struct{}
}

// Application can be used to manage applications. The idea is that
// this interace will be invoked using a veyron name that identifies
// the application and its installations and instances where
// applicable.
//
// In particular, the interface methods can be divided into three
// groups based on their intended receiver:
//
// 1) Method receiver is an application:
// -- Install()
//
// 2) Method receiver is an application installation:
// -- Start()
// -- Uninstall()
// -- Update()
//
// 3) Method receiver is application installation instance:
// -- Refresh()
// -- Restart()
// -- Resume()
// -- Shutdown()
// -- Suspend()
//
// For groups 2) and 3), the suffix that specifies the receiver can
// optionally omit the installation and/or instance, in which case the
// operation applies to all installations and/or instances in the
// scope of the suffix.
//
// Examples:
//
// device/apps/maps.Start() starts an instance of all maps application
// installations.
//
// device/apps/maps/installation.Start() starts an instance of the
// maps application installation identified by the given suffix.
//
// device/apps/maps.Refresh() refreshes the state of all instances of
// all maps application installations.
//
// device/apps/maps/installation.Refresh() refreshes the state of all
// instances of the maps application installation identified by the
// given suffix.
//
// device/apps/maps/installation/instance.Refresh() refreshes the
// state of the maps application installation instance identified by
// the given suffix.
//
// Further, the following methods complement one another:
// -- Install() and Uninstall()
// -- Start() and Shutdown()
// -- Suspend() and Resume()
//
// Finally, an application installation instance can be in one of
// three abstract states: 1) "does not exist", 2) "running", or 3)
// "suspended". The interface methods transition between these
// abstract states using the following state machine:
//
// apply(Start(), "does not exists") = "running"
// apply(Refresh(), "running") = "running"
// apply(Refresh(), "suspended") = "suspended"
// apply(Restart(), "running") = "running"
// apply(Restart(), "suspended") = "running"
// apply(Resume(), "suspended") = "running"
// apply(Resume(), "running") = "running"
// apply(Shutdown(), "running") = "does not exist"
// apply(Shutdown(), "suspended") = "does not exist"
// apply(Suspend(), "running") = "suspended"
// apply(Suspend(), "suspended") = "suspended"
//
// In other words, invoking any method using an existing application
// installation instance as a receiver is well-defined.
type Application interface {
  // Install installs the latest version of the application and
  // returns a veyron name that identifies the new
  // installation. Optionally, veyron name suffix can be used to
  // specify the application version to be installed. If no version is
  // specified, the latest version is installed.
  Install() (string, error)
  // Start starts an instance of application installation(s) and
  // returns the veyron name(s) that identifies/identify the new
  // instance(s).
  Start() ([]string, error)
  // Uninstall uninstalls application installation(s).
  Uninstall() error
  // Update updates application installation(s) version. Optionally,
  // veyron name suffix can be used to specify the application version
  // to which the installation(s) should be updated. If no version is
  // specified, the installation(s) are updated to the latest version.
  Update() error
  // Refresh refreshes the state of application installation(s)
  // instance(s).
  Refresh() error
  // Restart restarts execution of application installation(s)
  // instance(s).
  Restart() error
  // Resume resumes execution of application installation(s)
  // instance(s).
  Resume() error
  // Shutdown attempts a clean shutdown of application installation(s)
  // instance(s). If the deadline is non-zero and the instance(s) in
  // questions is/are still running after the given deadline, shutdown
  // of the instance(s) is enforced.
  //
  // TODO(jsimsa): Switch deadline to time.Duration when built-in types
  // are implemented.
  Shutdown(Deadline uint64) error
  // Suspend suspends execution of application installation(s)
  // instance(s).
  Suspend() error
}

// Node can be used to manage a node. The idea is that this interace
// will be invoked using a veyron name that identifies the node.
type Node interface {
  // Each method of the Application interface invoked at the node
  // level applies to all applications installed on the node (and
  // their installations and instances where applicable).
  Application
  // Describe generates a description of the node.
  Describe() (Description, error)
  // IsRunnable checks if the node can execute the given binary.
  IsRunnable(Binary build.BinaryDescription) (bool, error)
  // Reset resets the node. If the deadline is non-zero and the node
  // in question is still running after the given deadline expired,
  // reset of the node is enforced.
  //
  // TODO(jsimsa): Switch deadline to time.Duration when built-in types
  // are implemented.
  Reset(Deadline uint64) error
}

