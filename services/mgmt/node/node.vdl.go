// This file was auto-generated by the veyron vdl tool.
// Source: node.vdl

// Package node supports managing a node and applications running on
// the node.
package node

import (
	"veyron.io/veyron/veyron2/security"

	"veyron.io/veyron/veyron2/services/mgmt/binary"

	"veyron.io/veyron/veyron2/services/security/access"

	// The non-user imports are prefixed with "__" to prevent collisions.
	__veyron2 "veyron.io/veyron/veyron2"
	__context "veyron.io/veyron/veyron2/context"
	__ipc "veyron.io/veyron/veyron2/ipc"
	__vdlutil "veyron.io/veyron/veyron2/vdl/vdlutil"
	__wiretype "veyron.io/veyron/veyron2/wiretype"
)

// TODO(toddw): Remove this line once the new signature support is done.
// It corrects a bug where __wiretype is unused in VDL pacakges where only
// bootstrap types are used on interfaces.
const _ = __wiretype.TypeIDInvalid

// Description enumerates the profiles that a Node supports.
type Description struct {
	// Profiles is a set of names of supported profiles.	Each name can
	// either be an object name that resolves to a Profile, or can be the
	// profile's label, e.g.:
	//   "profiles/google/cluster/diskfull"
	//   "linux-media"
	//
	// Profiles for nodes can be provided by hand, but they can also be
	// automatically derived by examining the node.
	Profiles map[string]struct{}
}

// Association is a tuple containing an association between a Veyron
// identity and a system account name.
type Association struct {
	IdentityName string
	AccountName  string
}

// ApplicationClientMethods is the client interface
// containing Application methods.
//
// Application can be used to manage applications on a device. The
// idea is that this interace will be invoked using an object name that
// identifies the application and its installations and instances
// where applicable.
//
// In particular, the interface methods can be divided into three
// groups based on their intended receiver:
//
// 1) Method receiver is an application:
// -- Install()
//
// 2) Method receiver is an application installation:
// -- Start()
// -- Uninstall()
// -- Update()
//
// 3) Method receiver is application installation instance:
// -- Refresh()
// -- Restart()
// -- Resume()
// -- Stop()
// -- Suspend()
//
// For groups 2) and 3), the suffix that specifies the receiver can
// optionally omit the installation and/or instance, in which case the
// operation applies to all installations and/or instances in the
// scope of the suffix.
//
// Examples:
// # Install Google Maps on the node.
// device/apps.Install("/google.com/appstore/maps") --> "google maps/0"
//
// # Start an instance of the previously installed maps application installation.
// device/apps/google maps/0.Start() --> { "0" }
//
// # Start a second instance of the previously installed maps application installation.
// device/apps/google maps/0.Start() --> { "1" }
//
// # Stop the first instance previously started.
// device/apps/google maps/0/0.Stop()
//
// # Install a second Google Maps installation.
// device/apps.Install("/google.com/appstore/maps") --> "google maps/1"
//
// # Start an instance for all maps application installations.
// device/apps/google maps.Start() --> {"0/2", "1/0"}
//
// # Refresh the state of all instances of all maps application installations.
// device/apps/google maps.Refresh()
//
// # Refresh the state of all instances of the maps application installation
// identified by the given suffix.
// device/apps/google maps/0.Refresh()
//
// # Refresh the state of the maps application installation instance identified by
// the given suffix.
// device/apps/google maps/0/2.Refresh()
//
// # Update the second maps installation to the latest version available.
// device/apps/google maps/1.Update()
//
// # Update the first maps installation to a specific version.
// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
//
// Further, the following methods complement one another:
// -- Install() and Uninstall()
// -- Start() and Stop()
// -- Suspend() and Resume()
//
// Finally, an application installation instance can be in one of
// three abstract states: 1) "does not exist", 2) "running", or 3)
// "suspended". The interface methods transition between these
// abstract states using the following state machine:
//
// apply(Start(), "does not exists") = "running"
// apply(Refresh(), "running") = "running"
// apply(Refresh(), "suspended") = "suspended"
// apply(Restart(), "running") = "running"
// apply(Restart(), "suspended") = "running"
// apply(Resume(), "suspended") = "running"
// apply(Resume(), "running") = "running"
// apply(Stop(), "running") = "does not exist"
// apply(Stop(), "suspended") = "does not exist"
// apply(Suspend(), "running") = "suspended"
// apply(Suspend(), "suspended") = "suspended"
//
// In other words, invoking any method using an existing application
// installation instance as a receiver is well-defined.
type ApplicationClientMethods interface {
	// Object provides access control for Veyron objects.
	access.ObjectClientMethods
	// Install installs the application identified by the argument and
	// returns an object name suffix that identifies the new installation.
	//
	// The argument should be an object name for an application envelope.
	// The service it identifies must implement repository.Application, and
	// is expected to return either the requested version (if the object name
	// encodes a specific version), or otherwise the latest available version,
	// as appropriate.
	//
	// The returned suffix, when appended to the name used to reach the
	// receiver for Install, can be used to control the installation object.
	// The suffix will contain the title of the application as a prefix,
	// which can then be used to control all the installations of the given
	// application.
	// TODO(rjkroege): Use customized labels.
	Install(ctx __context.T, Name string, opts ...__ipc.CallOpt) (string, error)
	// Refresh refreshes the state of application installation(s)
	// instance(s).
	Refresh(__context.T, ...__ipc.CallOpt) error
	// Restart restarts execution of application installation(s)
	// instance(s).
	Restart(__context.T, ...__ipc.CallOpt) error
	// Resume resumes execution of application installation(s)
	// instance(s).
	Resume(__context.T, ...__ipc.CallOpt) error
	// Revert reverts application installation(s) to the most recent
	// previous installation.
	Revert(__context.T, ...__ipc.CallOpt) error
	// Start starts an instance of application installation(s) and
	// returns the object name(s) that identifies/identify the new
	// instance(s).
	Start(__context.T, ...__ipc.CallOpt) ([]string, error)
	// Stop attempts a clean shutdown of application installation(s)
	// instance(s). If the deadline (in seconds) is non-zero and the
	// instance(s) in questions are still running after the given deadline,
	// shutdown of the instance(s) is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Stop(ctx __context.T, Deadline uint32, opts ...__ipc.CallOpt) error
	// Suspend suspends execution of application installation(s)
	// instance(s).
	Suspend(__context.T, ...__ipc.CallOpt) error
	// Uninstall uninstalls application installation(s).
	Uninstall(__context.T, ...__ipc.CallOpt) error
	// Update updates the application installation(s) from the object name
	// provided during Install.  If the new application envelope contains a
	// different application title, the update does not occur, and an error
	// is returned.
	Update(__context.T, ...__ipc.CallOpt) error
	// UpdateTo updates the application installation(s) to the application
	// specified by the object name argument.  If the new application
	// envelope contains a different application title, the update does not
	// occur, and an error is returned.
	UpdateTo(ctx __context.T, Name string, opts ...__ipc.CallOpt) error
}

// ApplicationClientStub adds universal methods to ApplicationClientMethods.
type ApplicationClientStub interface {
	ApplicationClientMethods
	__ipc.UniversalServiceMethods
}

// ApplicationClient returns a client stub for Application.
func ApplicationClient(name string, opts ...__ipc.BindOpt) ApplicationClientStub {
	var client __ipc.Client
	for _, opt := range opts {
		if clientOpt, ok := opt.(__ipc.Client); ok {
			client = clientOpt
		}
	}
	return implApplicationClientStub{name, client, access.ObjectClient(name, client)}
}

type implApplicationClientStub struct {
	name   string
	client __ipc.Client

	access.ObjectClientStub
}

func (c implApplicationClientStub) c(ctx __context.T) __ipc.Client {
	if c.client != nil {
		return c.client
	}
	return __veyron2.RuntimeFromContext(ctx).Client()
}

func (c implApplicationClientStub) Install(ctx __context.T, i0 string, opts ...__ipc.CallOpt) (o0 string, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Install", []interface{}{i0}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Refresh(ctx __context.T, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Refresh", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Restart(ctx __context.T, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Restart", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Resume(ctx __context.T, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Resume", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Revert(ctx __context.T, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Revert", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Start(ctx __context.T, opts ...__ipc.CallOpt) (o0 []string, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Start", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Stop(ctx __context.T, i0 uint32, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Stop", []interface{}{i0}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Suspend(ctx __context.T, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Suspend", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Uninstall(ctx __context.T, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Uninstall", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Update(ctx __context.T, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Update", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) UpdateTo(ctx __context.T, i0 string, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "UpdateTo", []interface{}{i0}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Signature(ctx __context.T, opts ...__ipc.CallOpt) (o0 __ipc.ServiceSignature, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) GetMethodTags(ctx __context.T, method string, opts ...__ipc.CallOpt) (o0 []interface{}, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

// ApplicationServerMethods is the interface a server writer
// implements for Application.
//
// Application can be used to manage applications on a device. The
// idea is that this interace will be invoked using an object name that
// identifies the application and its installations and instances
// where applicable.
//
// In particular, the interface methods can be divided into three
// groups based on their intended receiver:
//
// 1) Method receiver is an application:
// -- Install()
//
// 2) Method receiver is an application installation:
// -- Start()
// -- Uninstall()
// -- Update()
//
// 3) Method receiver is application installation instance:
// -- Refresh()
// -- Restart()
// -- Resume()
// -- Stop()
// -- Suspend()
//
// For groups 2) and 3), the suffix that specifies the receiver can
// optionally omit the installation and/or instance, in which case the
// operation applies to all installations and/or instances in the
// scope of the suffix.
//
// Examples:
// # Install Google Maps on the node.
// device/apps.Install("/google.com/appstore/maps") --> "google maps/0"
//
// # Start an instance of the previously installed maps application installation.
// device/apps/google maps/0.Start() --> { "0" }
//
// # Start a second instance of the previously installed maps application installation.
// device/apps/google maps/0.Start() --> { "1" }
//
// # Stop the first instance previously started.
// device/apps/google maps/0/0.Stop()
//
// # Install a second Google Maps installation.
// device/apps.Install("/google.com/appstore/maps") --> "google maps/1"
//
// # Start an instance for all maps application installations.
// device/apps/google maps.Start() --> {"0/2", "1/0"}
//
// # Refresh the state of all instances of all maps application installations.
// device/apps/google maps.Refresh()
//
// # Refresh the state of all instances of the maps application installation
// identified by the given suffix.
// device/apps/google maps/0.Refresh()
//
// # Refresh the state of the maps application installation instance identified by
// the given suffix.
// device/apps/google maps/0/2.Refresh()
//
// # Update the second maps installation to the latest version available.
// device/apps/google maps/1.Update()
//
// # Update the first maps installation to a specific version.
// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
//
// Further, the following methods complement one another:
// -- Install() and Uninstall()
// -- Start() and Stop()
// -- Suspend() and Resume()
//
// Finally, an application installation instance can be in one of
// three abstract states: 1) "does not exist", 2) "running", or 3)
// "suspended". The interface methods transition between these
// abstract states using the following state machine:
//
// apply(Start(), "does not exists") = "running"
// apply(Refresh(), "running") = "running"
// apply(Refresh(), "suspended") = "suspended"
// apply(Restart(), "running") = "running"
// apply(Restart(), "suspended") = "running"
// apply(Resume(), "suspended") = "running"
// apply(Resume(), "running") = "running"
// apply(Stop(), "running") = "does not exist"
// apply(Stop(), "suspended") = "does not exist"
// apply(Suspend(), "running") = "suspended"
// apply(Suspend(), "suspended") = "suspended"
//
// In other words, invoking any method using an existing application
// installation instance as a receiver is well-defined.
type ApplicationServerMethods interface {
	// Object provides access control for Veyron objects.
	access.ObjectServerMethods
	// Install installs the application identified by the argument and
	// returns an object name suffix that identifies the new installation.
	//
	// The argument should be an object name for an application envelope.
	// The service it identifies must implement repository.Application, and
	// is expected to return either the requested version (if the object name
	// encodes a specific version), or otherwise the latest available version,
	// as appropriate.
	//
	// The returned suffix, when appended to the name used to reach the
	// receiver for Install, can be used to control the installation object.
	// The suffix will contain the title of the application as a prefix,
	// which can then be used to control all the installations of the given
	// application.
	// TODO(rjkroege): Use customized labels.
	Install(ctx __ipc.ServerContext, Name string) (string, error)
	// Refresh refreshes the state of application installation(s)
	// instance(s).
	Refresh(__ipc.ServerContext) error
	// Restart restarts execution of application installation(s)
	// instance(s).
	Restart(__ipc.ServerContext) error
	// Resume resumes execution of application installation(s)
	// instance(s).
	Resume(__ipc.ServerContext) error
	// Revert reverts application installation(s) to the most recent
	// previous installation.
	Revert(__ipc.ServerContext) error
	// Start starts an instance of application installation(s) and
	// returns the object name(s) that identifies/identify the new
	// instance(s).
	Start(__ipc.ServerContext) ([]string, error)
	// Stop attempts a clean shutdown of application installation(s)
	// instance(s). If the deadline (in seconds) is non-zero and the
	// instance(s) in questions are still running after the given deadline,
	// shutdown of the instance(s) is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Stop(ctx __ipc.ServerContext, Deadline uint32) error
	// Suspend suspends execution of application installation(s)
	// instance(s).
	Suspend(__ipc.ServerContext) error
	// Uninstall uninstalls application installation(s).
	Uninstall(__ipc.ServerContext) error
	// Update updates the application installation(s) from the object name
	// provided during Install.  If the new application envelope contains a
	// different application title, the update does not occur, and an error
	// is returned.
	Update(__ipc.ServerContext) error
	// UpdateTo updates the application installation(s) to the application
	// specified by the object name argument.  If the new application
	// envelope contains a different application title, the update does not
	// occur, and an error is returned.
	UpdateTo(ctx __ipc.ServerContext, Name string) error
}

// ApplicationServerStubMethods is the server interface containing
// Application methods, as expected by ipc.Server.  The difference between
// this interface and ApplicationServerMethods is that the first context
// argument for each method is always ipc.ServerCall here, while it is either
// ipc.ServerContext or a typed streaming context there.
type ApplicationServerStubMethods interface {
	// Object provides access control for Veyron objects.
	access.ObjectServerStubMethods
	// Install installs the application identified by the argument and
	// returns an object name suffix that identifies the new installation.
	//
	// The argument should be an object name for an application envelope.
	// The service it identifies must implement repository.Application, and
	// is expected to return either the requested version (if the object name
	// encodes a specific version), or otherwise the latest available version,
	// as appropriate.
	//
	// The returned suffix, when appended to the name used to reach the
	// receiver for Install, can be used to control the installation object.
	// The suffix will contain the title of the application as a prefix,
	// which can then be used to control all the installations of the given
	// application.
	// TODO(rjkroege): Use customized labels.
	Install(call __ipc.ServerCall, Name string) (string, error)
	// Refresh refreshes the state of application installation(s)
	// instance(s).
	Refresh(__ipc.ServerCall) error
	// Restart restarts execution of application installation(s)
	// instance(s).
	Restart(__ipc.ServerCall) error
	// Resume resumes execution of application installation(s)
	// instance(s).
	Resume(__ipc.ServerCall) error
	// Revert reverts application installation(s) to the most recent
	// previous installation.
	Revert(__ipc.ServerCall) error
	// Start starts an instance of application installation(s) and
	// returns the object name(s) that identifies/identify the new
	// instance(s).
	Start(__ipc.ServerCall) ([]string, error)
	// Stop attempts a clean shutdown of application installation(s)
	// instance(s). If the deadline (in seconds) is non-zero and the
	// instance(s) in questions are still running after the given deadline,
	// shutdown of the instance(s) is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Stop(call __ipc.ServerCall, Deadline uint32) error
	// Suspend suspends execution of application installation(s)
	// instance(s).
	Suspend(__ipc.ServerCall) error
	// Uninstall uninstalls application installation(s).
	Uninstall(__ipc.ServerCall) error
	// Update updates the application installation(s) from the object name
	// provided during Install.  If the new application envelope contains a
	// different application title, the update does not occur, and an error
	// is returned.
	Update(__ipc.ServerCall) error
	// UpdateTo updates the application installation(s) to the application
	// specified by the object name argument.  If the new application
	// envelope contains a different application title, the update does not
	// occur, and an error is returned.
	UpdateTo(call __ipc.ServerCall, Name string) error
}

// ApplicationServerStub adds universal methods to ApplicationServerStubMethods.
type ApplicationServerStub interface {
	ApplicationServerStubMethods
	// GetMethodTags will be replaced with DescribeInterfaces.
	GetMethodTags(call __ipc.ServerCall, method string) ([]interface{}, error)
	// Signature will be replaced with DescribeInterfaces.
	Signature(call __ipc.ServerCall) (__ipc.ServiceSignature, error)
}

// ApplicationServer returns a server stub for Application.
// It converts an implementation of ApplicationServerMethods into
// an object that may be used by ipc.Server.
func ApplicationServer(impl ApplicationServerMethods) ApplicationServerStub {
	stub := implApplicationServerStub{
		impl:             impl,
		ObjectServerStub: access.ObjectServer(impl),
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := __ipc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := __ipc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implApplicationServerStub struct {
	impl ApplicationServerMethods
	gs   *__ipc.GlobState

	access.ObjectServerStub
}

func (s implApplicationServerStub) Install(call __ipc.ServerCall, i0 string) (string, error) {
	return s.impl.Install(call, i0)
}

func (s implApplicationServerStub) Refresh(call __ipc.ServerCall) error {
	return s.impl.Refresh(call)
}

func (s implApplicationServerStub) Restart(call __ipc.ServerCall) error {
	return s.impl.Restart(call)
}

func (s implApplicationServerStub) Resume(call __ipc.ServerCall) error {
	return s.impl.Resume(call)
}

func (s implApplicationServerStub) Revert(call __ipc.ServerCall) error {
	return s.impl.Revert(call)
}

func (s implApplicationServerStub) Start(call __ipc.ServerCall) ([]string, error) {
	return s.impl.Start(call)
}

func (s implApplicationServerStub) Stop(call __ipc.ServerCall, i0 uint32) error {
	return s.impl.Stop(call, i0)
}

func (s implApplicationServerStub) Suspend(call __ipc.ServerCall) error {
	return s.impl.Suspend(call)
}

func (s implApplicationServerStub) Uninstall(call __ipc.ServerCall) error {
	return s.impl.Uninstall(call)
}

func (s implApplicationServerStub) Update(call __ipc.ServerCall) error {
	return s.impl.Update(call)
}

func (s implApplicationServerStub) UpdateTo(call __ipc.ServerCall, i0 string) error {
	return s.impl.UpdateTo(call, i0)
}

func (s implApplicationServerStub) VGlob() *__ipc.GlobState {
	return s.gs
}

func (s implApplicationServerStub) GetMethodTags(call __ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(toddw): Replace with new DescribeInterfaces implementation.
	if resp, err := s.ObjectServerStub.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	switch method {
	case "Install":
		return []interface{}{security.Label(4)}, nil
	case "Refresh":
		return []interface{}{security.Label(8)}, nil
	case "Restart":
		return []interface{}{security.Label(4)}, nil
	case "Resume":
		return []interface{}{security.Label(4)}, nil
	case "Revert":
		return []interface{}{security.Label(8)}, nil
	case "Start":
		return []interface{}{security.Label(2)}, nil
	case "Stop":
		return []interface{}{security.Label(8)}, nil
	case "Suspend":
		return []interface{}{security.Label(4)}, nil
	case "Uninstall":
		return []interface{}{security.Label(8)}, nil
	case "Update":
		return []interface{}{security.Label(8)}, nil
	case "UpdateTo":
		return []interface{}{security.Label(8)}, nil
	default:
		return nil, nil
	}
}

func (s implApplicationServerStub) Signature(call __ipc.ServerCall) (__ipc.ServiceSignature, error) {
	// TODO(toddw) Replace with new DescribeInterfaces implementation.
	result := __ipc.ServiceSignature{Methods: make(map[string]__ipc.MethodSignature)}
	result.Methods["Install"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{
			{Name: "Name", Type: 3},
		},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 3},
			{Name: "", Type: 65},
		},
	}
	result.Methods["Refresh"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["Restart"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["Resume"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["Revert"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["Start"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 61},
			{Name: "", Type: 65},
		},
	}
	result.Methods["Stop"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{
			{Name: "Deadline", Type: 52},
		},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["Suspend"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["Uninstall"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["Update"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["UpdateTo"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{
			{Name: "Name", Type: 3},
		},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}

	result.TypeDefs = []__vdlutil.Any{
		__wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}}
	var ss __ipc.ServiceSignature
	var firstAdded int
	ss, _ = s.ObjectServerStub.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= __wiretype.TypeIDFirst {
				v.InArgs[i].Type += __wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= __wiretype.TypeIDFirst {
				v.OutArgs[i].Type += __wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= __wiretype.TypeIDFirst {
			v.InStream += __wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= __wiretype.TypeIDFirst {
			v.OutStream += __wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case __wiretype.SliceType:
			if wt.Elem >= __wiretype.TypeIDFirst {
				wt.Elem += __wiretype.TypeID(firstAdded)
			}
			d = wt
		case __wiretype.ArrayType:
			if wt.Elem >= __wiretype.TypeIDFirst {
				wt.Elem += __wiretype.TypeID(firstAdded)
			}
			d = wt
		case __wiretype.MapType:
			if wt.Key >= __wiretype.TypeIDFirst {
				wt.Key += __wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= __wiretype.TypeIDFirst {
				wt.Elem += __wiretype.TypeID(firstAdded)
			}
			d = wt
		case __wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= __wiretype.TypeIDFirst {
					wt.Fields[i].Type += __wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}

	return result, nil
}

// NodeClientMethods is the client interface
// containing Node methods.
//
// Node can be used to manage a node. The idea is that this interface
// will be invoked using an object name that identifies the node.
type NodeClientMethods interface {
	// Application can be used to manage applications on a device. The
	// idea is that this interace will be invoked using an object name that
	// identifies the application and its installations and instances
	// where applicable.
	//
	// In particular, the interface methods can be divided into three
	// groups based on their intended receiver:
	//
	// 1) Method receiver is an application:
	// -- Install()
	//
	// 2) Method receiver is an application installation:
	// -- Start()
	// -- Uninstall()
	// -- Update()
	//
	// 3) Method receiver is application installation instance:
	// -- Refresh()
	// -- Restart()
	// -- Resume()
	// -- Stop()
	// -- Suspend()
	//
	// For groups 2) and 3), the suffix that specifies the receiver can
	// optionally omit the installation and/or instance, in which case the
	// operation applies to all installations and/or instances in the
	// scope of the suffix.
	//
	// Examples:
	// # Install Google Maps on the node.
	// device/apps.Install("/google.com/appstore/maps") --> "google maps/0"
	//
	// # Start an instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "0" }
	//
	// # Start a second instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "1" }
	//
	// # Stop the first instance previously started.
	// device/apps/google maps/0/0.Stop()
	//
	// # Install a second Google Maps installation.
	// device/apps.Install("/google.com/appstore/maps") --> "google maps/1"
	//
	// # Start an instance for all maps application installations.
	// device/apps/google maps.Start() --> {"0/2", "1/0"}
	//
	// # Refresh the state of all instances of all maps application installations.
	// device/apps/google maps.Refresh()
	//
	// # Refresh the state of all instances of the maps application installation
	// identified by the given suffix.
	// device/apps/google maps/0.Refresh()
	//
	// # Refresh the state of the maps application installation instance identified by
	// the given suffix.
	// device/apps/google maps/0/2.Refresh()
	//
	// # Update the second maps installation to the latest version available.
	// device/apps/google maps/1.Update()
	//
	// # Update the first maps installation to a specific version.
	// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
	//
	// Further, the following methods complement one another:
	// -- Install() and Uninstall()
	// -- Start() and Stop()
	// -- Suspend() and Resume()
	//
	// Finally, an application installation instance can be in one of
	// three abstract states: 1) "does not exist", 2) "running", or 3)
	// "suspended". The interface methods transition between these
	// abstract states using the following state machine:
	//
	// apply(Start(), "does not exists") = "running"
	// apply(Refresh(), "running") = "running"
	// apply(Refresh(), "suspended") = "suspended"
	// apply(Restart(), "running") = "running"
	// apply(Restart(), "suspended") = "running"
	// apply(Resume(), "suspended") = "running"
	// apply(Resume(), "running") = "running"
	// apply(Stop(), "running") = "does not exist"
	// apply(Stop(), "suspended") = "does not exist"
	// apply(Suspend(), "running") = "suspended"
	// apply(Suspend(), "suspended") = "suspended"
	//
	// In other words, invoking any method using an existing application
	// installation instance as a receiver is well-defined.
	ApplicationClientMethods
	// Claim is used to claim ownership of a Node running on a device
	// by blessing its identity. By default, after this call all node
	// methods will be access protected to the identity of the claimer.
	Claim(__context.T, ...__ipc.CallOpt) error
	// Describe generates a description of the node.
	Describe(__context.T, ...__ipc.CallOpt) (Description, error)
	// IsRunnable checks if the node can execute the given binary.
	IsRunnable(ctx __context.T, Description binary.Description, opts ...__ipc.CallOpt) (bool, error)
	// Reset resets the node. If the deadline is non-zero and the node
	// in question is still running after the given deadline expired,
	// reset of the node is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Reset(ctx __context.T, Deadline uint64, opts ...__ipc.CallOpt) error
	// AssociateAccount associates a local  system account name with the provided
	// Veyron identities. It replaces the existing association if one already exists for that
	// identity. Setting an AccountName to "" removes the association for each
	// listed identity.
	AssociateAccount(ctx __context.T, identityNames []string, accountName string, opts ...__ipc.CallOpt) error
	// ListAssociations returns all of the associations between Veyron identities
	// and system names.
	ListAssociations(__context.T, ...__ipc.CallOpt) (associations []Association, err error)
}

// NodeClientStub adds universal methods to NodeClientMethods.
type NodeClientStub interface {
	NodeClientMethods
	__ipc.UniversalServiceMethods
}

// NodeClient returns a client stub for Node.
func NodeClient(name string, opts ...__ipc.BindOpt) NodeClientStub {
	var client __ipc.Client
	for _, opt := range opts {
		if clientOpt, ok := opt.(__ipc.Client); ok {
			client = clientOpt
		}
	}
	return implNodeClientStub{name, client, ApplicationClient(name, client)}
}

type implNodeClientStub struct {
	name   string
	client __ipc.Client

	ApplicationClientStub
}

func (c implNodeClientStub) c(ctx __context.T) __ipc.Client {
	if c.client != nil {
		return c.client
	}
	return __veyron2.RuntimeFromContext(ctx).Client()
}

func (c implNodeClientStub) Claim(ctx __context.T, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Claim", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implNodeClientStub) Describe(ctx __context.T, opts ...__ipc.CallOpt) (o0 Description, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Describe", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implNodeClientStub) IsRunnable(ctx __context.T, i0 binary.Description, opts ...__ipc.CallOpt) (o0 bool, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "IsRunnable", []interface{}{i0}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implNodeClientStub) Reset(ctx __context.T, i0 uint64, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Reset", []interface{}{i0}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implNodeClientStub) AssociateAccount(ctx __context.T, i0 []string, i1 string, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "AssociateAccount", []interface{}{i0, i1}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implNodeClientStub) ListAssociations(ctx __context.T, opts ...__ipc.CallOpt) (o0 []Association, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "ListAssociations", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implNodeClientStub) Signature(ctx __context.T, opts ...__ipc.CallOpt) (o0 __ipc.ServiceSignature, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implNodeClientStub) GetMethodTags(ctx __context.T, method string, opts ...__ipc.CallOpt) (o0 []interface{}, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

// NodeServerMethods is the interface a server writer
// implements for Node.
//
// Node can be used to manage a node. The idea is that this interface
// will be invoked using an object name that identifies the node.
type NodeServerMethods interface {
	// Application can be used to manage applications on a device. The
	// idea is that this interace will be invoked using an object name that
	// identifies the application and its installations and instances
	// where applicable.
	//
	// In particular, the interface methods can be divided into three
	// groups based on their intended receiver:
	//
	// 1) Method receiver is an application:
	// -- Install()
	//
	// 2) Method receiver is an application installation:
	// -- Start()
	// -- Uninstall()
	// -- Update()
	//
	// 3) Method receiver is application installation instance:
	// -- Refresh()
	// -- Restart()
	// -- Resume()
	// -- Stop()
	// -- Suspend()
	//
	// For groups 2) and 3), the suffix that specifies the receiver can
	// optionally omit the installation and/or instance, in which case the
	// operation applies to all installations and/or instances in the
	// scope of the suffix.
	//
	// Examples:
	// # Install Google Maps on the node.
	// device/apps.Install("/google.com/appstore/maps") --> "google maps/0"
	//
	// # Start an instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "0" }
	//
	// # Start a second instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "1" }
	//
	// # Stop the first instance previously started.
	// device/apps/google maps/0/0.Stop()
	//
	// # Install a second Google Maps installation.
	// device/apps.Install("/google.com/appstore/maps") --> "google maps/1"
	//
	// # Start an instance for all maps application installations.
	// device/apps/google maps.Start() --> {"0/2", "1/0"}
	//
	// # Refresh the state of all instances of all maps application installations.
	// device/apps/google maps.Refresh()
	//
	// # Refresh the state of all instances of the maps application installation
	// identified by the given suffix.
	// device/apps/google maps/0.Refresh()
	//
	// # Refresh the state of the maps application installation instance identified by
	// the given suffix.
	// device/apps/google maps/0/2.Refresh()
	//
	// # Update the second maps installation to the latest version available.
	// device/apps/google maps/1.Update()
	//
	// # Update the first maps installation to a specific version.
	// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
	//
	// Further, the following methods complement one another:
	// -- Install() and Uninstall()
	// -- Start() and Stop()
	// -- Suspend() and Resume()
	//
	// Finally, an application installation instance can be in one of
	// three abstract states: 1) "does not exist", 2) "running", or 3)
	// "suspended". The interface methods transition between these
	// abstract states using the following state machine:
	//
	// apply(Start(), "does not exists") = "running"
	// apply(Refresh(), "running") = "running"
	// apply(Refresh(), "suspended") = "suspended"
	// apply(Restart(), "running") = "running"
	// apply(Restart(), "suspended") = "running"
	// apply(Resume(), "suspended") = "running"
	// apply(Resume(), "running") = "running"
	// apply(Stop(), "running") = "does not exist"
	// apply(Stop(), "suspended") = "does not exist"
	// apply(Suspend(), "running") = "suspended"
	// apply(Suspend(), "suspended") = "suspended"
	//
	// In other words, invoking any method using an existing application
	// installation instance as a receiver is well-defined.
	ApplicationServerMethods
	// Claim is used to claim ownership of a Node running on a device
	// by blessing its identity. By default, after this call all node
	// methods will be access protected to the identity of the claimer.
	Claim(__ipc.ServerContext) error
	// Describe generates a description of the node.
	Describe(__ipc.ServerContext) (Description, error)
	// IsRunnable checks if the node can execute the given binary.
	IsRunnable(ctx __ipc.ServerContext, Description binary.Description) (bool, error)
	// Reset resets the node. If the deadline is non-zero and the node
	// in question is still running after the given deadline expired,
	// reset of the node is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Reset(ctx __ipc.ServerContext, Deadline uint64) error
	// AssociateAccount associates a local  system account name with the provided
	// Veyron identities. It replaces the existing association if one already exists for that
	// identity. Setting an AccountName to "" removes the association for each
	// listed identity.
	AssociateAccount(ctx __ipc.ServerContext, identityNames []string, accountName string) error
	// ListAssociations returns all of the associations between Veyron identities
	// and system names.
	ListAssociations(__ipc.ServerContext) (associations []Association, err error)
}

// NodeServerStubMethods is the server interface containing
// Node methods, as expected by ipc.Server.  The difference between
// this interface and NodeServerMethods is that the first context
// argument for each method is always ipc.ServerCall here, while it is either
// ipc.ServerContext or a typed streaming context there.
type NodeServerStubMethods interface {
	// Application can be used to manage applications on a device. The
	// idea is that this interace will be invoked using an object name that
	// identifies the application and its installations and instances
	// where applicable.
	//
	// In particular, the interface methods can be divided into three
	// groups based on their intended receiver:
	//
	// 1) Method receiver is an application:
	// -- Install()
	//
	// 2) Method receiver is an application installation:
	// -- Start()
	// -- Uninstall()
	// -- Update()
	//
	// 3) Method receiver is application installation instance:
	// -- Refresh()
	// -- Restart()
	// -- Resume()
	// -- Stop()
	// -- Suspend()
	//
	// For groups 2) and 3), the suffix that specifies the receiver can
	// optionally omit the installation and/or instance, in which case the
	// operation applies to all installations and/or instances in the
	// scope of the suffix.
	//
	// Examples:
	// # Install Google Maps on the node.
	// device/apps.Install("/google.com/appstore/maps") --> "google maps/0"
	//
	// # Start an instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "0" }
	//
	// # Start a second instance of the previously installed maps application installation.
	// device/apps/google maps/0.Start() --> { "1" }
	//
	// # Stop the first instance previously started.
	// device/apps/google maps/0/0.Stop()
	//
	// # Install a second Google Maps installation.
	// device/apps.Install("/google.com/appstore/maps") --> "google maps/1"
	//
	// # Start an instance for all maps application installations.
	// device/apps/google maps.Start() --> {"0/2", "1/0"}
	//
	// # Refresh the state of all instances of all maps application installations.
	// device/apps/google maps.Refresh()
	//
	// # Refresh the state of all instances of the maps application installation
	// identified by the given suffix.
	// device/apps/google maps/0.Refresh()
	//
	// # Refresh the state of the maps application installation instance identified by
	// the given suffix.
	// device/apps/google maps/0/2.Refresh()
	//
	// # Update the second maps installation to the latest version available.
	// device/apps/google maps/1.Update()
	//
	// # Update the first maps installation to a specific version.
	// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
	//
	// Further, the following methods complement one another:
	// -- Install() and Uninstall()
	// -- Start() and Stop()
	// -- Suspend() and Resume()
	//
	// Finally, an application installation instance can be in one of
	// three abstract states: 1) "does not exist", 2) "running", or 3)
	// "suspended". The interface methods transition between these
	// abstract states using the following state machine:
	//
	// apply(Start(), "does not exists") = "running"
	// apply(Refresh(), "running") = "running"
	// apply(Refresh(), "suspended") = "suspended"
	// apply(Restart(), "running") = "running"
	// apply(Restart(), "suspended") = "running"
	// apply(Resume(), "suspended") = "running"
	// apply(Resume(), "running") = "running"
	// apply(Stop(), "running") = "does not exist"
	// apply(Stop(), "suspended") = "does not exist"
	// apply(Suspend(), "running") = "suspended"
	// apply(Suspend(), "suspended") = "suspended"
	//
	// In other words, invoking any method using an existing application
	// installation instance as a receiver is well-defined.
	ApplicationServerStubMethods
	// Claim is used to claim ownership of a Node running on a device
	// by blessing its identity. By default, after this call all node
	// methods will be access protected to the identity of the claimer.
	Claim(__ipc.ServerCall) error
	// Describe generates a description of the node.
	Describe(__ipc.ServerCall) (Description, error)
	// IsRunnable checks if the node can execute the given binary.
	IsRunnable(call __ipc.ServerCall, Description binary.Description) (bool, error)
	// Reset resets the node. If the deadline is non-zero and the node
	// in question is still running after the given deadline expired,
	// reset of the node is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Reset(call __ipc.ServerCall, Deadline uint64) error
	// AssociateAccount associates a local  system account name with the provided
	// Veyron identities. It replaces the existing association if one already exists for that
	// identity. Setting an AccountName to "" removes the association for each
	// listed identity.
	AssociateAccount(call __ipc.ServerCall, identityNames []string, accountName string) error
	// ListAssociations returns all of the associations between Veyron identities
	// and system names.
	ListAssociations(__ipc.ServerCall) (associations []Association, err error)
}

// NodeServerStub adds universal methods to NodeServerStubMethods.
type NodeServerStub interface {
	NodeServerStubMethods
	// GetMethodTags will be replaced with DescribeInterfaces.
	GetMethodTags(call __ipc.ServerCall, method string) ([]interface{}, error)
	// Signature will be replaced with DescribeInterfaces.
	Signature(call __ipc.ServerCall) (__ipc.ServiceSignature, error)
}

// NodeServer returns a server stub for Node.
// It converts an implementation of NodeServerMethods into
// an object that may be used by ipc.Server.
func NodeServer(impl NodeServerMethods) NodeServerStub {
	stub := implNodeServerStub{
		impl: impl,
		ApplicationServerStub: ApplicationServer(impl),
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := __ipc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := __ipc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implNodeServerStub struct {
	impl NodeServerMethods
	gs   *__ipc.GlobState

	ApplicationServerStub
}

func (s implNodeServerStub) Claim(call __ipc.ServerCall) error {
	return s.impl.Claim(call)
}

func (s implNodeServerStub) Describe(call __ipc.ServerCall) (Description, error) {
	return s.impl.Describe(call)
}

func (s implNodeServerStub) IsRunnable(call __ipc.ServerCall, i0 binary.Description) (bool, error) {
	return s.impl.IsRunnable(call, i0)
}

func (s implNodeServerStub) Reset(call __ipc.ServerCall, i0 uint64) error {
	return s.impl.Reset(call, i0)
}

func (s implNodeServerStub) AssociateAccount(call __ipc.ServerCall, i0 []string, i1 string) error {
	return s.impl.AssociateAccount(call, i0, i1)
}

func (s implNodeServerStub) ListAssociations(call __ipc.ServerCall) ([]Association, error) {
	return s.impl.ListAssociations(call)
}

func (s implNodeServerStub) VGlob() *__ipc.GlobState {
	return s.gs
}

func (s implNodeServerStub) GetMethodTags(call __ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(toddw): Replace with new DescribeInterfaces implementation.
	if resp, err := s.ApplicationServerStub.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	switch method {
	case "Claim":
		return []interface{}{}, nil
	case "Describe":
		return []interface{}{}, nil
	case "IsRunnable":
		return []interface{}{}, nil
	case "Reset":
		return []interface{}{}, nil
	case "AssociateAccount":
		return []interface{}{}, nil
	case "ListAssociations":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (s implNodeServerStub) Signature(call __ipc.ServerCall) (__ipc.ServiceSignature, error) {
	// TODO(toddw) Replace with new DescribeInterfaces implementation.
	result := __ipc.ServiceSignature{Methods: make(map[string]__ipc.MethodSignature)}
	result.Methods["AssociateAccount"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{
			{Name: "identityNames", Type: 61},
			{Name: "accountName", Type: 3},
		},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["Claim"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["Describe"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 67},
			{Name: "", Type: 65},
		},
	}
	result.Methods["IsRunnable"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{
			{Name: "Description", Type: 68},
		},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 2},
			{Name: "", Type: 65},
		},
	}
	result.Methods["ListAssociations"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "associations", Type: 70},
			{Name: "err", Type: 65},
		},
	}
	result.Methods["Reset"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{
			{Name: "Deadline", Type: 53},
		},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}

	result.TypeDefs = []__vdlutil.Any{
		__wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}, __wiretype.MapType{Key: 0x3, Elem: 0x2, Name: "", Tags: []string(nil)}, __wiretype.StructType{
			[]__wiretype.FieldType{
				__wiretype.FieldType{Type: 0x42, Name: "Profiles"},
			},
			"veyron.io/veyron/veyron2/services/mgmt/node.Description", []string(nil)},
		__wiretype.StructType{
			[]__wiretype.FieldType{
				__wiretype.FieldType{Type: 0x3, Name: "Name"},
				__wiretype.FieldType{Type: 0x42, Name: "Profiles"},
			},
			"veyron.io/veyron/veyron2/services/mgmt/binary.Description", []string(nil)},
		__wiretype.StructType{
			[]__wiretype.FieldType{
				__wiretype.FieldType{Type: 0x3, Name: "IdentityName"},
				__wiretype.FieldType{Type: 0x3, Name: "AccountName"},
			},
			"veyron.io/veyron/veyron2/services/mgmt/node.Association", []string(nil)},
		__wiretype.SliceType{Elem: 0x45, Name: "", Tags: []string(nil)}}
	var ss __ipc.ServiceSignature
	var firstAdded int
	ss, _ = s.ApplicationServerStub.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= __wiretype.TypeIDFirst {
				v.InArgs[i].Type += __wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= __wiretype.TypeIDFirst {
				v.OutArgs[i].Type += __wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= __wiretype.TypeIDFirst {
			v.InStream += __wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= __wiretype.TypeIDFirst {
			v.OutStream += __wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case __wiretype.SliceType:
			if wt.Elem >= __wiretype.TypeIDFirst {
				wt.Elem += __wiretype.TypeID(firstAdded)
			}
			d = wt
		case __wiretype.ArrayType:
			if wt.Elem >= __wiretype.TypeIDFirst {
				wt.Elem += __wiretype.TypeID(firstAdded)
			}
			d = wt
		case __wiretype.MapType:
			if wt.Key >= __wiretype.TypeIDFirst {
				wt.Key += __wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= __wiretype.TypeIDFirst {
				wt.Elem += __wiretype.TypeID(firstAdded)
			}
			d = wt
		case __wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= __wiretype.TypeIDFirst {
					wt.Fields[i].Type += __wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}

	return result, nil
}
