// Package node supports managing a node and applications running on
// the node.
package node

import (
	"veyron2/services/mgmt/binary"
	"veyron2/services/security/access"
)

// Application can be used to manage applications on a device. The
// idea is that this interace will be invoked using an object name that
// identifies the application and its installations and instances
// where applicable.
//
// In particular, the interface methods can be divided into three
// groups based on their intended receiver:
//
// 1) Method receiver is an application:
// -- Install()
//
// 2) Method receiver is an application installation:
// -- Start()
// -- Uninstall()
// -- Update()
//
// 3) Method receiver is application installation instance:
// -- Refresh()
// -- Restart()
// -- Resume()
// -- Stop()
// -- Suspend()
//
// For groups 2) and 3), the suffix that specifies the receiver can
// optionally omit the installation and/or instance, in which case the
// operation applies to all installations and/or instances in the
// scope of the suffix.
//
// Examples:
// # Install Google Maps on the node.
// device/apps.Install("/google.com/appstore/maps") --> "google maps/0"
//
// # Start an instance of the previously installed maps application installation.
// device/apps/google maps/0.Start() --> { "0" }
//
// # Start a second instance of the previously installed maps application installation.
// device/apps/google maps/0.Start() --> { "1" }
//
// # Stop the first instance previously started.
// device/apps/google maps/0/0.Stop()
//
// # Install a second Google Maps installation.
// device/apps.Install("/google.com/appstore/maps") --> "google maps/1"
//
// # Start an instance for all maps application installations.
// device/apps/google maps.Start() --> {"0/2", "1/0"}
//
// # Refresh the state of all instances of all maps application installations.
// device/apps/google maps.Refresh()
//
// # Refresh the state of all instances of the maps application installation
// identified by the given suffix.
// device/apps/google maps/0.Refresh()
//
// # Refresh the state of the maps application installation instance identified by
// the given suffix.
// device/apps/google maps/0/2.Refresh()
//
// # Update the second maps installation to the latest version available.
// device/apps/google maps/1.Update()
//
// # Update the first maps installation to a specific version.
// device/apps/google maps/0.UpdateTo("/google.com/appstore/beta/maps")
//
// Further, the following methods complement one another:
// -- Install() and Uninstall()
// -- Start() and Stop()
// -- Suspend() and Resume()
//
// Finally, an application installation instance can be in one of
// three abstract states: 1) "does not exist", 2) "running", or 3)
// "suspended". The interface methods transition between these
// abstract states using the following state machine:
//
// apply(Start(), "does not exists") = "running"
// apply(Refresh(), "running") = "running"
// apply(Refresh(), "suspended") = "suspended"
// apply(Restart(), "running") = "running"
// apply(Restart(), "suspended") = "running"
// apply(Resume(), "suspended") = "running"
// apply(Resume(), "running") = "running"
// apply(Stop(), "running") = "does not exist"
// apply(Stop(), "suspended") = "does not exist"
// apply(Suspend(), "running") = "suspended"
// apply(Suspend(), "suspended") = "suspended"
//
// In other words, invoking any method using an existing application
// installation instance as a receiver is well-defined.
type Application interface {
	// Install installs the application identified by the argument and
	// returns an object name suffix that identifies the new installation.
	//
	// The argument should be an object name for an application envelope.
	// The service it identifies must implement repository.Application, and
	// is expected to return either the requested version (if the object name
	// encodes a specific version), or otherwise the latest available version,
	// as appropriate.
	//
	// The returned suffix, when appended to the name used to reach the
	// receiver for Install, can be used to control the installation object.
	// The suffix will contain the title of the application as a prefix,
	// which can then be used to control all the installations of the given
	// application.
	Install(Name string) (string, error)
	// Refresh refreshes the state of application installation(s)
	// instance(s).
	Refresh() error
	// Restart restarts execution of application installation(s)
	// instance(s).
	Restart() error
	// Resume resumes execution of application installation(s)
	// instance(s).
	Resume() error
	// Revert reverts application installation(s) to the most recent
	// previous installation.
	Revert() error
	// Start starts an instance of application installation(s) and
	// returns the object name(s) that identifies/identify the new
	// instance(s).
	Start() ([]string, error)
	// Stop attempts a clean shutdown of application installation(s)
	// instance(s). If the deadline (in seconds) is non-zero and the
	// instance(s) in questions are still running after the given deadline,
	// shutdown of the instance(s) is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Stop(Deadline uint32) error
	// Suspend suspends execution of application installation(s)
	// instance(s).
	Suspend() error
	// Uninstall uninstalls application installation(s).
	Uninstall() error
	// Update updates the application installation(s) from the object name
	// provided during Install.  If the new application envelope contains a
	// different application title, the update does not occur, and an error
	// is returned.
	Update() error
	// UpdateTo updates the application installation(s) to the application
	// specified by the object name argument.  If the new application
	// envelope contains a different application title, the update does not
	// occur, and an error is returned.
	UpdateTo(Name string) error
}

// Description enumerates the profiles that a Node supports.
type Description struct {
	// Profiles is a set of names of supported profiles.	Each name can
	// either be an object name that resolves to a Profile, or can be the
	// profile's label, e.g.:
	//   "profiles/google/cluster/diskfull"
	//   "linux-media"
	//
	// Profiles for nodes can be provided by hand, but they can also be
	// automatically derived by examining the node.
	Profiles set[string]
}

// Node can be used to manage a node. The idea is that this interface
// will be invoked using an object name that identifies the node.
type Node interface {
	// Object provides GetACL/SetACL methods to read/modify ACLs for the
	// node methods. After a device has been claimed only the claimer will
	// be able to modify the ACLs for the node.
	access.Object
	// Each method of the Application interface invoked at the node
	// level applies to all applications installed on the node (and
	// their installations and instances where applicable).
	Application
	// Claim is used to claim ownership of a Node running on a device
	// by blessing its identity. By default, after this call all node
	// methods will be access protected to the identity of the claimer.
	Claim() error
	// Describe generates a description of the node.
	Describe() (Description, error)
	// IsRunnable checks if the node can execute the given binary.
	IsRunnable(Description binary.Description) (bool, error)
	// Reset resets the node. If the deadline is non-zero and the node
	// in question is still running after the given deadline expired,
	// reset of the node is enforced.
	//
	// TODO(jsimsa): Switch deadline to time.Duration when built-in types
	// are implemented.
	Reset(Deadline uint64) error
}
