// This file was auto-generated by the veyron vdl tool.
// Source: repository.vdl

// Package repository can be used for storing and serving various
// veyron management objects.
package repository

import (
	"v.io/veyron/veyron2/services/mgmt/application"

	"v.io/veyron/veyron2/services/mgmt/binary"

	"v.io/veyron/veyron2/services/security/access"

	// The non-user imports are prefixed with "__" to prevent collisions.
	__io "io"
	__veyron2 "v.io/veyron/veyron2"
	__context "v.io/veyron/veyron2/context"
	__ipc "v.io/veyron/veyron2/ipc"
	__vdl "v.io/veyron/veyron2/vdl"
	__vdlutil "v.io/veyron/veyron2/vdl/vdlutil"
	__wiretype "v.io/veyron/veyron2/wiretype"
)

// TODO(toddw): Remove this line once the new signature support is done.
// It corrects a bug where __wiretype is unused in VDL pacakges where only
// bootstrap types are used on interfaces.
const _ = __wiretype.TypeIDInvalid

// MediaInfo contains the metadata information for a binary.
type MediaInfo struct {
	Type     string // The media-type (RFC 2046)
	Encoding string // The file encoding is optional and can be either "gzip" or "bzip2".
}

func (MediaInfo) __VDLReflect(struct {
	Name string "v.io/veyron/veyron2/services/mgmt/repository.MediaInfo"
}) {
}

func init() {
	__vdl.Register(MediaInfo{})
}

// ApplicationClientMethods is the client interface
// containing Application methods.
//
// Application provides access to application envelopes. An
// application envelope is identified by an application name and an
// application version, which are specified through the object name,
// and a profile name, which is specified using a method argument.
//
// Example:
// /apps/search/v1.Match([]string{"base", "media"})
//   returns an application envelope that can be used for downloading
//   and executing the "search" application, version "v1", runnable
//   on either the "base" or "media" profile.
type ApplicationClientMethods interface {
	// Match checks if any of the given profiles contains an application
	// envelope for the given application version (specified through the
	// object name suffix) and if so, returns this envelope. If multiple
	// profile matches are possible, the method returns the first
	// matching profile, respecting the order of the input argument.
	Match(ctx __context.T, profiles []string, opts ...__ipc.CallOpt) (application.Envelope, error)
}

// ApplicationClientStub adds universal methods to ApplicationClientMethods.
type ApplicationClientStub interface {
	ApplicationClientMethods
	__ipc.UniversalServiceMethods
}

// ApplicationClient returns a client stub for Application.
func ApplicationClient(name string, opts ...__ipc.BindOpt) ApplicationClientStub {
	var client __ipc.Client
	for _, opt := range opts {
		if clientOpt, ok := opt.(__ipc.Client); ok {
			client = clientOpt
		}
	}
	return implApplicationClientStub{name, client}
}

type implApplicationClientStub struct {
	name   string
	client __ipc.Client
}

func (c implApplicationClientStub) c(ctx __context.T) __ipc.Client {
	if c.client != nil {
		return c.client
	}
	return __veyron2.RuntimeFromContext(ctx).Client()
}

func (c implApplicationClientStub) Match(ctx __context.T, i0 []string, opts ...__ipc.CallOpt) (o0 application.Envelope, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Match", []interface{}{i0}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implApplicationClientStub) Signature(ctx __context.T, opts ...__ipc.CallOpt) (o0 __ipc.ServiceSignature, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

// ApplicationServerMethods is the interface a server writer
// implements for Application.
//
// Application provides access to application envelopes. An
// application envelope is identified by an application name and an
// application version, which are specified through the object name,
// and a profile name, which is specified using a method argument.
//
// Example:
// /apps/search/v1.Match([]string{"base", "media"})
//   returns an application envelope that can be used for downloading
//   and executing the "search" application, version "v1", runnable
//   on either the "base" or "media" profile.
type ApplicationServerMethods interface {
	// Match checks if any of the given profiles contains an application
	// envelope for the given application version (specified through the
	// object name suffix) and if so, returns this envelope. If multiple
	// profile matches are possible, the method returns the first
	// matching profile, respecting the order of the input argument.
	Match(ctx __ipc.ServerContext, profiles []string) (application.Envelope, error)
}

// ApplicationServerStubMethods is the server interface containing
// Application methods, as expected by ipc.Server.
// There is no difference between this interface and ApplicationServerMethods
// since there are no streaming methods.
type ApplicationServerStubMethods ApplicationServerMethods

// ApplicationServerStub adds universal methods to ApplicationServerStubMethods.
type ApplicationServerStub interface {
	ApplicationServerStubMethods
	// Describe the Application interfaces.
	Describe__() []__ipc.InterfaceDesc
	// Signature will be replaced with Describe__.
	Signature(ctx __ipc.ServerContext) (__ipc.ServiceSignature, error)
}

// ApplicationServer returns a server stub for Application.
// It converts an implementation of ApplicationServerMethods into
// an object that may be used by ipc.Server.
func ApplicationServer(impl ApplicationServerMethods) ApplicationServerStub {
	stub := implApplicationServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := __ipc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := __ipc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implApplicationServerStub struct {
	impl ApplicationServerMethods
	gs   *__ipc.GlobState
}

func (s implApplicationServerStub) Match(ctx __ipc.ServerContext, i0 []string) (application.Envelope, error) {
	return s.impl.Match(ctx, i0)
}

func (s implApplicationServerStub) Globber() *__ipc.GlobState {
	return s.gs
}

func (s implApplicationServerStub) Describe__() []__ipc.InterfaceDesc {
	return []__ipc.InterfaceDesc{ApplicationDesc}
}

// ApplicationDesc describes the Application interface.
var ApplicationDesc __ipc.InterfaceDesc = descApplication

// descApplication hides the desc to keep godoc clean.
var descApplication = __ipc.InterfaceDesc{
	Name:    "Application",
	PkgPath: "v.io/veyron/veyron2/services/mgmt/repository",
	Doc:     "// Application provides access to application envelopes. An\n// application envelope is identified by an application name and an\n// application version, which are specified through the object name,\n// and a profile name, which is specified using a method argument.\n//\n// Example:\n// /apps/search/v1.Match([]string{\"base\", \"media\"})\n//   returns an application envelope that can be used for downloading\n//   and executing the \"search\" application, version \"v1\", runnable\n//   on either the \"base\" or \"media\" profile.",
	Methods: []__ipc.MethodDesc{
		{
			Name: "Match",
			Doc:  "// Match checks if any of the given profiles contains an application\n// envelope for the given application version (specified through the\n// object name suffix) and if so, returns this envelope. If multiple\n// profile matches are possible, the method returns the first\n// matching profile, respecting the order of the input argument.",
			InArgs: []__ipc.ArgDesc{
				{"profiles", ``}, // []string
			},
			OutArgs: []__ipc.ArgDesc{
				{"", ``}, // application.Envelope
				{"", ``}, // error
			},
			Tags: []__vdlutil.Any{access.Tag("Read")},
		},
	},
}

func (s implApplicationServerStub) Signature(ctx __ipc.ServerContext) (__ipc.ServiceSignature, error) {
	// TODO(toddw): Replace with new Describe__ implementation.
	result := __ipc.ServiceSignature{Methods: make(map[string]__ipc.MethodSignature)}
	result.Methods["Match"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{
			{Name: "profiles", Type: 61},
		},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 66},
			{Name: "", Type: 67},
		},
	}

	result.TypeDefs = []__vdlutil.Any{
		__wiretype.MapType{Key: 0x3, Elem: 0x3, Name: "", Tags: []string(nil)}, __wiretype.StructType{
			[]__wiretype.FieldType{
				__wiretype.FieldType{Type: 0x3, Name: "Title"},
				__wiretype.FieldType{Type: 0x3d, Name: "Args"},
				__wiretype.FieldType{Type: 0x3, Name: "Binary"},
				__wiretype.FieldType{Type: 0x3d, Name: "Env"},
				__wiretype.FieldType{Type: 0x41, Name: "Packages"},
			},
			"v.io/veyron/veyron2/services/mgmt/application.Envelope", []string(nil)},
		__wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}}

	return result, nil
}

// BinaryClientMethods is the client interface
// containing Binary methods.
//
// Binary can be used to store and retrieve veyron application
// binaries.
//
// To create a binary, clients first invoke the Create() method that
// specifies the number of parts the binary consists of. Clients then
// uploads the individual parts through the Upload() method, which
// identifies the part being uploaded. To resume an upload after a
// failure, clients invoke the UploadStatus() method, which returns a
// slice that identifies which parts are missing.
//
// To download a binary, clients first invoke Stat(), which returns
// information describing the binary, including the number of parts
// the binary consists of. Clients then download the individual parts
// through the Download() method, which identifies the part being
// downloaded. Alternatively, clients can download the binary through
// HTTP using a transient URL available through the DownloadURL()
// method.
//
// To delete the binary, clients invoke the Delete() method.
type BinaryClientMethods interface {
	// Create expresses the intent to create a binary identified by the
	// object name suffix consisting of the given number of parts. The
	// mediaInfo argument contains metadata for the binary. If the suffix
	// identifies a binary that has already been created, the method
	// returns an error.
	Create(ctx __context.T, nparts int32, mediaInfo MediaInfo, opts ...__ipc.CallOpt) error
	// Delete deletes the binary identified by the object name
	// suffix. If the binary that has not been created, the method
	// returns an error.
	Delete(__context.T, ...__ipc.CallOpt) error
	// Download opens a stream that can used for downloading the given
	// part of the binary identified by the object name suffix. If the
	// binary part has not been uploaded, the method returns an
	// error. If the Delete() method is invoked when the Download()
	// method is in progress, the outcome the Download() method is
	// undefined.
	Download(ctx __context.T, part int32, opts ...__ipc.CallOpt) (BinaryDownloadCall, error)
	// DownloadURL returns a transient URL from which the binary
	// identified by the object name suffix can be downloaded using the
	// HTTP protocol. If not all parts of the binary have been uploaded,
	// the method returns an error.
	DownloadURL(__context.T, ...__ipc.CallOpt) (URL string, TTL int64, err error)
	// Stat returns information describing the parts of the binary
	// identified by the object name suffix, and its RFC 2046 media type.
	// If the binary has not been created, the method returns an error.
	Stat(__context.T, ...__ipc.CallOpt) (Parts []binary.PartInfo, MediaInfo MediaInfo, err error)
	// Upload opens a stream that can be used for uploading the given
	// part of the binary identified by the object name suffix. If the
	// binary has not been created, the method returns an error. If the
	// binary part has been uploaded, the method returns an error. If
	// the same binary part is being uploaded by another caller, the
	// method returns an error.
	Upload(ctx __context.T, part int32, opts ...__ipc.CallOpt) (BinaryUploadCall, error)
}

// BinaryClientStub adds universal methods to BinaryClientMethods.
type BinaryClientStub interface {
	BinaryClientMethods
	__ipc.UniversalServiceMethods
}

// BinaryClient returns a client stub for Binary.
func BinaryClient(name string, opts ...__ipc.BindOpt) BinaryClientStub {
	var client __ipc.Client
	for _, opt := range opts {
		if clientOpt, ok := opt.(__ipc.Client); ok {
			client = clientOpt
		}
	}
	return implBinaryClientStub{name, client}
}

type implBinaryClientStub struct {
	name   string
	client __ipc.Client
}

func (c implBinaryClientStub) c(ctx __context.T) __ipc.Client {
	if c.client != nil {
		return c.client
	}
	return __veyron2.RuntimeFromContext(ctx).Client()
}

func (c implBinaryClientStub) Create(ctx __context.T, i0 int32, i1 MediaInfo, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Create", []interface{}{i0, i1}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implBinaryClientStub) Delete(ctx __context.T, opts ...__ipc.CallOpt) (err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Delete", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c implBinaryClientStub) Download(ctx __context.T, i0 int32, opts ...__ipc.CallOpt) (ocall BinaryDownloadCall, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Download", []interface{}{i0}, opts...); err != nil {
		return
	}
	ocall = &implBinaryDownloadCall{Call: call}
	return
}

func (c implBinaryClientStub) DownloadURL(ctx __context.T, opts ...__ipc.CallOpt) (o0 string, o1 int64, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "DownloadURL", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &o1, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implBinaryClientStub) Stat(ctx __context.T, opts ...__ipc.CallOpt) (o0 []binary.PartInfo, o1 MediaInfo, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Stat", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &o1, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implBinaryClientStub) Upload(ctx __context.T, i0 int32, opts ...__ipc.CallOpt) (ocall BinaryUploadCall, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Upload", []interface{}{i0}, opts...); err != nil {
		return
	}
	ocall = &implBinaryUploadCall{Call: call}
	return
}

func (c implBinaryClientStub) Signature(ctx __context.T, opts ...__ipc.CallOpt) (o0 __ipc.ServiceSignature, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

// BinaryDownloadClientStream is the client stream for Binary.Download.
type BinaryDownloadClientStream interface {
	// RecvStream returns the receiver side of the Binary.Download client stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() []byte
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// BinaryDownloadCall represents the call returned from Binary.Download.
type BinaryDownloadCall interface {
	BinaryDownloadClientStream
	// Finish blocks until the server is done, and returns the positional return
	// values for call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implBinaryDownloadCall struct {
	__ipc.Call
	valRecv []byte
	errRecv error
}

func (c *implBinaryDownloadCall) RecvStream() interface {
	Advance() bool
	Value() []byte
	Err() error
} {
	return implBinaryDownloadCallRecv{c}
}

type implBinaryDownloadCallRecv struct {
	c *implBinaryDownloadCall
}

func (c implBinaryDownloadCallRecv) Advance() bool {
	c.c.errRecv = c.c.Recv(&c.c.valRecv)
	return c.c.errRecv == nil
}
func (c implBinaryDownloadCallRecv) Value() []byte {
	return c.c.valRecv
}
func (c implBinaryDownloadCallRecv) Err() error {
	if c.c.errRecv == __io.EOF {
		return nil
	}
	return c.c.errRecv
}
func (c *implBinaryDownloadCall) Finish() (err error) {
	if ierr := c.Call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

// BinaryUploadClientStream is the client stream for Binary.Upload.
type BinaryUploadClientStream interface {
	// SendStream returns the send side of the Binary.Upload client stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors
		// encountered while sending, or if Send is called after Close or
		// the stream has been canceled.  Blocks if there is no buffer
		// space; will unblock when buffer space is available or after
		// the stream has been canceled.
		Send(item []byte) error
		// Close indicates to the server that no more items will be sent;
		// server Recv calls will receive io.EOF after all sent items.
		// This is an optional call - e.g. a client might call Close if it
		// needs to continue receiving items from the server after it's
		// done sending.  Returns errors encountered while closing, or if
		// Close is called after the stream has been canceled.  Like Send,
		// blocks if there is no buffer space available.
		Close() error
	}
}

// BinaryUploadCall represents the call returned from Binary.Upload.
type BinaryUploadCall interface {
	BinaryUploadClientStream
	// Finish performs the equivalent of SendStream().Close, then blocks until
	// the server is done, and returns the positional return values for the call.
	//
	// Finish returns immediately if the call has been canceled; depending on the
	// timing the output could either be an error signaling cancelation, or the
	// valid positional return values from the server.
	//
	// Calling Finish is mandatory for releasing stream resources, unless the call
	// has been canceled or any of the other methods return an error.  Finish should
	// be called at most once.
	Finish() error
}

type implBinaryUploadCall struct {
	__ipc.Call
}

func (c *implBinaryUploadCall) SendStream() interface {
	Send(item []byte) error
	Close() error
} {
	return implBinaryUploadCallSend{c}
}

type implBinaryUploadCallSend struct {
	c *implBinaryUploadCall
}

func (c implBinaryUploadCallSend) Send(item []byte) error {
	return c.c.Send(item)
}
func (c implBinaryUploadCallSend) Close() error {
	return c.c.CloseSend()
}
func (c *implBinaryUploadCall) Finish() (err error) {
	if ierr := c.Call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

// BinaryServerMethods is the interface a server writer
// implements for Binary.
//
// Binary can be used to store and retrieve veyron application
// binaries.
//
// To create a binary, clients first invoke the Create() method that
// specifies the number of parts the binary consists of. Clients then
// uploads the individual parts through the Upload() method, which
// identifies the part being uploaded. To resume an upload after a
// failure, clients invoke the UploadStatus() method, which returns a
// slice that identifies which parts are missing.
//
// To download a binary, clients first invoke Stat(), which returns
// information describing the binary, including the number of parts
// the binary consists of. Clients then download the individual parts
// through the Download() method, which identifies the part being
// downloaded. Alternatively, clients can download the binary through
// HTTP using a transient URL available through the DownloadURL()
// method.
//
// To delete the binary, clients invoke the Delete() method.
type BinaryServerMethods interface {
	// Create expresses the intent to create a binary identified by the
	// object name suffix consisting of the given number of parts. The
	// mediaInfo argument contains metadata for the binary. If the suffix
	// identifies a binary that has already been created, the method
	// returns an error.
	Create(ctx __ipc.ServerContext, nparts int32, mediaInfo MediaInfo) error
	// Delete deletes the binary identified by the object name
	// suffix. If the binary that has not been created, the method
	// returns an error.
	Delete(__ipc.ServerContext) error
	// Download opens a stream that can used for downloading the given
	// part of the binary identified by the object name suffix. If the
	// binary part has not been uploaded, the method returns an
	// error. If the Delete() method is invoked when the Download()
	// method is in progress, the outcome the Download() method is
	// undefined.
	Download(ctx BinaryDownloadContext, part int32) error
	// DownloadURL returns a transient URL from which the binary
	// identified by the object name suffix can be downloaded using the
	// HTTP protocol. If not all parts of the binary have been uploaded,
	// the method returns an error.
	DownloadURL(__ipc.ServerContext) (URL string, TTL int64, err error)
	// Stat returns information describing the parts of the binary
	// identified by the object name suffix, and its RFC 2046 media type.
	// If the binary has not been created, the method returns an error.
	Stat(__ipc.ServerContext) (Parts []binary.PartInfo, MediaInfo MediaInfo, err error)
	// Upload opens a stream that can be used for uploading the given
	// part of the binary identified by the object name suffix. If the
	// binary has not been created, the method returns an error. If the
	// binary part has been uploaded, the method returns an error. If
	// the same binary part is being uploaded by another caller, the
	// method returns an error.
	Upload(ctx BinaryUploadContext, part int32) error
}

// BinaryServerStubMethods is the server interface containing
// Binary methods, as expected by ipc.Server.
// The only difference between this interface and BinaryServerMethods
// is the streaming methods.
type BinaryServerStubMethods interface {
	// Create expresses the intent to create a binary identified by the
	// object name suffix consisting of the given number of parts. The
	// mediaInfo argument contains metadata for the binary. If the suffix
	// identifies a binary that has already been created, the method
	// returns an error.
	Create(ctx __ipc.ServerContext, nparts int32, mediaInfo MediaInfo) error
	// Delete deletes the binary identified by the object name
	// suffix. If the binary that has not been created, the method
	// returns an error.
	Delete(__ipc.ServerContext) error
	// Download opens a stream that can used for downloading the given
	// part of the binary identified by the object name suffix. If the
	// binary part has not been uploaded, the method returns an
	// error. If the Delete() method is invoked when the Download()
	// method is in progress, the outcome the Download() method is
	// undefined.
	Download(ctx *BinaryDownloadContextStub, part int32) error
	// DownloadURL returns a transient URL from which the binary
	// identified by the object name suffix can be downloaded using the
	// HTTP protocol. If not all parts of the binary have been uploaded,
	// the method returns an error.
	DownloadURL(__ipc.ServerContext) (URL string, TTL int64, err error)
	// Stat returns information describing the parts of the binary
	// identified by the object name suffix, and its RFC 2046 media type.
	// If the binary has not been created, the method returns an error.
	Stat(__ipc.ServerContext) (Parts []binary.PartInfo, MediaInfo MediaInfo, err error)
	// Upload opens a stream that can be used for uploading the given
	// part of the binary identified by the object name suffix. If the
	// binary has not been created, the method returns an error. If the
	// binary part has been uploaded, the method returns an error. If
	// the same binary part is being uploaded by another caller, the
	// method returns an error.
	Upload(ctx *BinaryUploadContextStub, part int32) error
}

// BinaryServerStub adds universal methods to BinaryServerStubMethods.
type BinaryServerStub interface {
	BinaryServerStubMethods
	// Describe the Binary interfaces.
	Describe__() []__ipc.InterfaceDesc
	// Signature will be replaced with Describe__.
	Signature(ctx __ipc.ServerContext) (__ipc.ServiceSignature, error)
}

// BinaryServer returns a server stub for Binary.
// It converts an implementation of BinaryServerMethods into
// an object that may be used by ipc.Server.
func BinaryServer(impl BinaryServerMethods) BinaryServerStub {
	stub := implBinaryServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := __ipc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := __ipc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implBinaryServerStub struct {
	impl BinaryServerMethods
	gs   *__ipc.GlobState
}

func (s implBinaryServerStub) Create(ctx __ipc.ServerContext, i0 int32, i1 MediaInfo) error {
	return s.impl.Create(ctx, i0, i1)
}

func (s implBinaryServerStub) Delete(ctx __ipc.ServerContext) error {
	return s.impl.Delete(ctx)
}

func (s implBinaryServerStub) Download(ctx *BinaryDownloadContextStub, i0 int32) error {
	return s.impl.Download(ctx, i0)
}

func (s implBinaryServerStub) DownloadURL(ctx __ipc.ServerContext) (string, int64, error) {
	return s.impl.DownloadURL(ctx)
}

func (s implBinaryServerStub) Stat(ctx __ipc.ServerContext) ([]binary.PartInfo, MediaInfo, error) {
	return s.impl.Stat(ctx)
}

func (s implBinaryServerStub) Upload(ctx *BinaryUploadContextStub, i0 int32) error {
	return s.impl.Upload(ctx, i0)
}

func (s implBinaryServerStub) Globber() *__ipc.GlobState {
	return s.gs
}

func (s implBinaryServerStub) Describe__() []__ipc.InterfaceDesc {
	return []__ipc.InterfaceDesc{BinaryDesc}
}

// BinaryDesc describes the Binary interface.
var BinaryDesc __ipc.InterfaceDesc = descBinary

// descBinary hides the desc to keep godoc clean.
var descBinary = __ipc.InterfaceDesc{
	Name:    "Binary",
	PkgPath: "v.io/veyron/veyron2/services/mgmt/repository",
	Doc:     "// Binary can be used to store and retrieve veyron application\n// binaries.\n//\n// To create a binary, clients first invoke the Create() method that\n// specifies the number of parts the binary consists of. Clients then\n// uploads the individual parts through the Upload() method, which\n// identifies the part being uploaded. To resume an upload after a\n// failure, clients invoke the UploadStatus() method, which returns a\n// slice that identifies which parts are missing.\n//\n// To download a binary, clients first invoke Stat(), which returns\n// information describing the binary, including the number of parts\n// the binary consists of. Clients then download the individual parts\n// through the Download() method, which identifies the part being\n// downloaded. Alternatively, clients can download the binary through\n// HTTP using a transient URL available through the DownloadURL()\n// method.\n//\n// To delete the binary, clients invoke the Delete() method.",
	Methods: []__ipc.MethodDesc{
		{
			Name: "Create",
			Doc:  "// Create expresses the intent to create a binary identified by the\n// object name suffix consisting of the given number of parts. The\n// mediaInfo argument contains metadata for the binary. If the suffix\n// identifies a binary that has already been created, the method\n// returns an error.",
			InArgs: []__ipc.ArgDesc{
				{"nparts", ``},    // int32
				{"mediaInfo", ``}, // MediaInfo
			},
			OutArgs: []__ipc.ArgDesc{
				{"", ``}, // error
			},
			Tags: []__vdlutil.Any{access.Tag("Write")},
		},
		{
			Name: "Delete",
			Doc:  "// Delete deletes the binary identified by the object name\n// suffix. If the binary that has not been created, the method\n// returns an error.",
			OutArgs: []__ipc.ArgDesc{
				{"", ``}, // error
			},
			Tags: []__vdlutil.Any{access.Tag("Write")},
		},
		{
			Name: "Download",
			Doc:  "// Download opens a stream that can used for downloading the given\n// part of the binary identified by the object name suffix. If the\n// binary part has not been uploaded, the method returns an\n// error. If the Delete() method is invoked when the Download()\n// method is in progress, the outcome the Download() method is\n// undefined.",
			InArgs: []__ipc.ArgDesc{
				{"part", ``}, // int32
			},
			OutArgs: []__ipc.ArgDesc{
				{"", ``}, // error
			},
			Tags: []__vdlutil.Any{access.Tag("Read")},
		},
		{
			Name: "DownloadURL",
			Doc:  "// DownloadURL returns a transient URL from which the binary\n// identified by the object name suffix can be downloaded using the\n// HTTP protocol. If not all parts of the binary have been uploaded,\n// the method returns an error.",
			OutArgs: []__ipc.ArgDesc{
				{"URL", ``}, // string
				{"TTL", ``}, // int64
				{"err", ``}, // error
			},
			Tags: []__vdlutil.Any{access.Tag("Read")},
		},
		{
			Name: "Stat",
			Doc:  "// Stat returns information describing the parts of the binary\n// identified by the object name suffix, and its RFC 2046 media type.\n// If the binary has not been created, the method returns an error.",
			OutArgs: []__ipc.ArgDesc{
				{"Parts", ``},     // []binary.PartInfo
				{"MediaInfo", ``}, // MediaInfo
				{"err", ``},       // error
			},
			Tags: []__vdlutil.Any{access.Tag("Read")},
		},
		{
			Name: "Upload",
			Doc:  "// Upload opens a stream that can be used for uploading the given\n// part of the binary identified by the object name suffix. If the\n// binary has not been created, the method returns an error. If the\n// binary part has been uploaded, the method returns an error. If\n// the same binary part is being uploaded by another caller, the\n// method returns an error.",
			InArgs: []__ipc.ArgDesc{
				{"part", ``}, // int32
			},
			OutArgs: []__ipc.ArgDesc{
				{"", ``}, // error
			},
			Tags: []__vdlutil.Any{access.Tag("Write")},
		},
	},
}

func (s implBinaryServerStub) Signature(ctx __ipc.ServerContext) (__ipc.ServiceSignature, error) {
	// TODO(toddw): Replace with new Describe__ implementation.
	result := __ipc.ServiceSignature{Methods: make(map[string]__ipc.MethodSignature)}
	result.Methods["Create"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{
			{Name: "nparts", Type: 36},
			{Name: "mediaInfo", Type: 65},
		},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 66},
		},
	}
	result.Methods["Delete"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 66},
		},
	}
	result.Methods["Download"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{
			{Name: "part", Type: 36},
		},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 66},
		},

		OutStream: 68,
	}
	result.Methods["DownloadURL"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "URL", Type: 3},
			{Name: "TTL", Type: 37},
			{Name: "err", Type: 66},
		},
	}
	result.Methods["Stat"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "Parts", Type: 70},
			{Name: "MediaInfo", Type: 65},
			{Name: "err", Type: 66},
		},
	}
	result.Methods["Upload"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{
			{Name: "part", Type: 36},
		},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 66},
		},
		InStream: 68,
	}

	result.TypeDefs = []__vdlutil.Any{
		__wiretype.StructType{
			[]__wiretype.FieldType{
				__wiretype.FieldType{Type: 0x3, Name: "Type"},
				__wiretype.FieldType{Type: 0x3, Name: "Encoding"},
			},
			"v.io/veyron/veyron2/services/mgmt/repository.MediaInfo", []string(nil)},
		__wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}, __wiretype.NamedPrimitiveType{Type: 0x32, Name: "byte", Tags: []string(nil)}, __wiretype.SliceType{Elem: 0x43, Name: "", Tags: []string(nil)}, __wiretype.StructType{
			[]__wiretype.FieldType{
				__wiretype.FieldType{Type: 0x3, Name: "Checksum"},
				__wiretype.FieldType{Type: 0x25, Name: "Size"},
			},
			"v.io/veyron/veyron2/services/mgmt/binary.PartInfo", []string(nil)},
		__wiretype.SliceType{Elem: 0x45, Name: "", Tags: []string(nil)}}

	return result, nil
}

// BinaryDownloadServerStream is the server stream for Binary.Download.
type BinaryDownloadServerStream interface {
	// SendStream returns the send side of the Binary.Download server stream.
	SendStream() interface {
		// Send places the item onto the output stream.  Returns errors encountered
		// while sending.  Blocks if there is no buffer space; will unblock when
		// buffer space is available.
		Send(item []byte) error
	}
}

// BinaryDownloadContext represents the context passed to Binary.Download.
type BinaryDownloadContext interface {
	__ipc.ServerContext
	BinaryDownloadServerStream
}

// BinaryDownloadContextStub is a wrapper that converts ipc.ServerCall into
// a typesafe stub that implements BinaryDownloadContext.
type BinaryDownloadContextStub struct {
	__ipc.ServerCall
}

// Init initializes BinaryDownloadContextStub from ipc.ServerCall.
func (s *BinaryDownloadContextStub) Init(call __ipc.ServerCall) {
	s.ServerCall = call
}

// SendStream returns the send side of the Binary.Download server stream.
func (s *BinaryDownloadContextStub) SendStream() interface {
	Send(item []byte) error
} {
	return implBinaryDownloadContextSend{s}
}

type implBinaryDownloadContextSend struct {
	s *BinaryDownloadContextStub
}

func (s implBinaryDownloadContextSend) Send(item []byte) error {
	return s.s.Send(item)
}

// BinaryUploadServerStream is the server stream for Binary.Upload.
type BinaryUploadServerStream interface {
	// RecvStream returns the receiver side of the Binary.Upload server stream.
	RecvStream() interface {
		// Advance stages an item so that it may be retrieved via Value.  Returns
		// true iff there is an item to retrieve.  Advance must be called before
		// Value is called.  May block if an item is not available.
		Advance() bool
		// Value returns the item that was staged by Advance.  May panic if Advance
		// returned false or was not called.  Never blocks.
		Value() []byte
		// Err returns any error encountered by Advance.  Never blocks.
		Err() error
	}
}

// BinaryUploadContext represents the context passed to Binary.Upload.
type BinaryUploadContext interface {
	__ipc.ServerContext
	BinaryUploadServerStream
}

// BinaryUploadContextStub is a wrapper that converts ipc.ServerCall into
// a typesafe stub that implements BinaryUploadContext.
type BinaryUploadContextStub struct {
	__ipc.ServerCall
	valRecv []byte
	errRecv error
}

// Init initializes BinaryUploadContextStub from ipc.ServerCall.
func (s *BinaryUploadContextStub) Init(call __ipc.ServerCall) {
	s.ServerCall = call
}

// RecvStream returns the receiver side of the Binary.Upload server stream.
func (s *BinaryUploadContextStub) RecvStream() interface {
	Advance() bool
	Value() []byte
	Err() error
} {
	return implBinaryUploadContextRecv{s}
}

type implBinaryUploadContextRecv struct {
	s *BinaryUploadContextStub
}

func (s implBinaryUploadContextRecv) Advance() bool {
	s.s.errRecv = s.s.Recv(&s.s.valRecv)
	return s.s.errRecv == nil
}
func (s implBinaryUploadContextRecv) Value() []byte {
	return s.s.valRecv
}
func (s implBinaryUploadContextRecv) Err() error {
	if s.s.errRecv == __io.EOF {
		return nil
	}
	return s.s.errRecv
}

// ProfileClientMethods is the client interface
// containing Profile methods.
//
// Profile abstracts a device's ability to run binaries, and hides
// specifics such as the operating system, hardware architecture, and
// the set of installed libraries. Profiles describe binaries and
// devices, and are used to match them.
type ProfileClientMethods interface {
	// Label is the human-readable profile key for the profile,
	// e.g. "linux-media". The label can be used to uniquely identify
	// the profile (for the purpose of matching application binaries and
	// devices).
	Label(__context.T, ...__ipc.CallOpt) (string, error)
	// Description is a free-text description of the profile, meant for
	// human consumption.
	Description(__context.T, ...__ipc.CallOpt) (string, error)
}

// ProfileClientStub adds universal methods to ProfileClientMethods.
type ProfileClientStub interface {
	ProfileClientMethods
	__ipc.UniversalServiceMethods
}

// ProfileClient returns a client stub for Profile.
func ProfileClient(name string, opts ...__ipc.BindOpt) ProfileClientStub {
	var client __ipc.Client
	for _, opt := range opts {
		if clientOpt, ok := opt.(__ipc.Client); ok {
			client = clientOpt
		}
	}
	return implProfileClientStub{name, client}
}

type implProfileClientStub struct {
	name   string
	client __ipc.Client
}

func (c implProfileClientStub) c(ctx __context.T) __ipc.Client {
	if c.client != nil {
		return c.client
	}
	return __veyron2.RuntimeFromContext(ctx).Client()
}

func (c implProfileClientStub) Label(ctx __context.T, opts ...__ipc.CallOpt) (o0 string, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Label", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implProfileClientStub) Description(ctx __context.T, opts ...__ipc.CallOpt) (o0 string, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Description", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

func (c implProfileClientStub) Signature(ctx __context.T, opts ...__ipc.CallOpt) (o0 __ipc.ServiceSignature, err error) {
	var call __ipc.Call
	if call, err = c.c(ctx).StartCall(ctx, c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&o0, &err); ierr != nil {
		err = ierr
	}
	return
}

// ProfileServerMethods is the interface a server writer
// implements for Profile.
//
// Profile abstracts a device's ability to run binaries, and hides
// specifics such as the operating system, hardware architecture, and
// the set of installed libraries. Profiles describe binaries and
// devices, and are used to match them.
type ProfileServerMethods interface {
	// Label is the human-readable profile key for the profile,
	// e.g. "linux-media". The label can be used to uniquely identify
	// the profile (for the purpose of matching application binaries and
	// devices).
	Label(__ipc.ServerContext) (string, error)
	// Description is a free-text description of the profile, meant for
	// human consumption.
	Description(__ipc.ServerContext) (string, error)
}

// ProfileServerStubMethods is the server interface containing
// Profile methods, as expected by ipc.Server.
// There is no difference between this interface and ProfileServerMethods
// since there are no streaming methods.
type ProfileServerStubMethods ProfileServerMethods

// ProfileServerStub adds universal methods to ProfileServerStubMethods.
type ProfileServerStub interface {
	ProfileServerStubMethods
	// Describe the Profile interfaces.
	Describe__() []__ipc.InterfaceDesc
	// Signature will be replaced with Describe__.
	Signature(ctx __ipc.ServerContext) (__ipc.ServiceSignature, error)
}

// ProfileServer returns a server stub for Profile.
// It converts an implementation of ProfileServerMethods into
// an object that may be used by ipc.Server.
func ProfileServer(impl ProfileServerMethods) ProfileServerStub {
	stub := implProfileServerStub{
		impl: impl,
	}
	// Initialize GlobState; always check the stub itself first, to handle the
	// case where the user has the Glob method defined in their VDL source.
	if gs := __ipc.NewGlobState(stub); gs != nil {
		stub.gs = gs
	} else if gs := __ipc.NewGlobState(impl); gs != nil {
		stub.gs = gs
	}
	return stub
}

type implProfileServerStub struct {
	impl ProfileServerMethods
	gs   *__ipc.GlobState
}

func (s implProfileServerStub) Label(ctx __ipc.ServerContext) (string, error) {
	return s.impl.Label(ctx)
}

func (s implProfileServerStub) Description(ctx __ipc.ServerContext) (string, error) {
	return s.impl.Description(ctx)
}

func (s implProfileServerStub) Globber() *__ipc.GlobState {
	return s.gs
}

func (s implProfileServerStub) Describe__() []__ipc.InterfaceDesc {
	return []__ipc.InterfaceDesc{ProfileDesc}
}

// ProfileDesc describes the Profile interface.
var ProfileDesc __ipc.InterfaceDesc = descProfile

// descProfile hides the desc to keep godoc clean.
var descProfile = __ipc.InterfaceDesc{
	Name:    "Profile",
	PkgPath: "v.io/veyron/veyron2/services/mgmt/repository",
	Doc:     "// Profile abstracts a device's ability to run binaries, and hides\n// specifics such as the operating system, hardware architecture, and\n// the set of installed libraries. Profiles describe binaries and\n// devices, and are used to match them.",
	Methods: []__ipc.MethodDesc{
		{
			Name: "Label",
			Doc:  "// Label is the human-readable profile key for the profile,\n// e.g. \"linux-media\". The label can be used to uniquely identify\n// the profile (for the purpose of matching application binaries and\n// devices).",
			OutArgs: []__ipc.ArgDesc{
				{"", ``}, // string
				{"", ``}, // error
			},
			Tags: []__vdlutil.Any{access.Tag("Read")},
		},
		{
			Name: "Description",
			Doc:  "// Description is a free-text description of the profile, meant for\n// human consumption.",
			OutArgs: []__ipc.ArgDesc{
				{"", ``}, // string
				{"", ``}, // error
			},
			Tags: []__vdlutil.Any{access.Tag("Read")},
		},
	},
}

func (s implProfileServerStub) Signature(ctx __ipc.ServerContext) (__ipc.ServiceSignature, error) {
	// TODO(toddw): Replace with new Describe__ implementation.
	result := __ipc.ServiceSignature{Methods: make(map[string]__ipc.MethodSignature)}
	result.Methods["Description"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 3},
			{Name: "", Type: 65},
		},
	}
	result.Methods["Label"] = __ipc.MethodSignature{
		InArgs: []__ipc.MethodArgument{},
		OutArgs: []__ipc.MethodArgument{
			{Name: "", Type: 3},
			{Name: "", Type: 65},
		},
	}

	result.TypeDefs = []__vdlutil.Any{
		__wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}}

	return result, nil
}
