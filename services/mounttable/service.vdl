// Package mounttable defines a set of mount points and how to traverse them.
package mounttable

import (
	"veyron2/security"
	"veyron2/services/mounttable/types"
)

type Globbable interface {
	// Glob returns all matching entries at the given server.
	Glob(pattern string) stream<_, types.MountEntry> error {security.ReadLabel}
}

// MountTable defines the interface to talk to a mounttable.
type MountTable interface {
	// In all methods of MountTable, the receiver is the name bound to.

	// Mount Server (a global name) onto the receiver.
	// Subsequent mounts add to the servers mounted there.  The multiple
	// servers are considered equivalent and are meant solely for
	// availability, i.e., no load balancing is guaranteed.
	//
	// TTL is the number of seconds the mount is to last unless refreshed by
	// another mount of the same server.  A TTL of 0 represents an infinite
	// duration.  A server with an expired TTL should never appear in the
	// results nor affect the operation of any MountTable method, and should
	// act as if it was never present as far as the interface is concerned.
	Mount(Server string, TTL uint32) error {security.WriteLabel}

	// Unmount removes Server from the mount point.  If Server is empty, remove
	// all servers mounted there.
	// Returns a non-nil error iff Server remains mounted at the mount point.
	Unmount(Server string) error {security.WriteLabel}

	// TODO(caprita): We can simplify this to just return []string where
	// each string already has the suffix baked in, and no ttl.

	// ResolveStep takes the next step in resolving a name.  Returns the next
	// servers to query and the suffix at those servers.
	ResolveStep() (Servers []types.MountedServer, Suffix string, Error error) {security.ReadLabel}

	Globbable
}
