// Package mounttable defines a set of mount points and how to traverse them.
package mounttable

import (
	"v.io/v23/naming"
	"v.io/v23/security"
	"v.io/v23/services/security/access/object"
)

// A mount table is a tree of names.  Each name may have something mounted on it,
// either a terminal server or another mount table server.  If multiple servers are
// mounted onto the same name, they are considered equivalent, i.e., it is semantically
// irrelevant which is chosen to pass an RPC to.
//
// Access is determined by ACLs at each node in the tree.  When resolving a
// name like a/b/c/d, one must check the client blessings against the ACLs of each
// node traversed ("", a, a/b, a/b/c, and a/b/c/d).

type Tag string

const (
	// Admin allow the client to SetACL or Delete the receiver.  It also subsumes
	// all the other tags.
	Admin   = Tag("Admin")
	// Mount allows the client to Mount or Unmount at the named receiver.
	// For example, to Mount onto a/b/c requires Mount or Admin access
	// to a/b/c (and Read, Admin, or Resolve to a and a/b).
	Mount   = Tag("Mount")
	// Read allows the client to Glob any children of the node.  Thus to
	// perform a Glob of a/* one must have Read access to a AND any other
	// access to each child of a.  It also allows Resolution through the node.
	Read    = Tag("Read")
	// Create allows the client to create nodes below the receiver.
	Create   = Tag("Create")
	// Resolve allows one to resolve through the receiver.  Thus to Resolve
	// a/b/c, one needs Admin, Resolve, or Read permission on a, a/b,
	// and a/b/c.
	Resolve = Tag("Resolve")
)

// MountTable defines the interface to talk to a mounttable.
//
// In all methods of MountTable, the receiver is the name bound to.
type MountTable interface {
	// DEPRECATED: TODO(ashankar): Rename MountX to Mount and remove
        // MountX before the release.
	Mount(Server string, TTL uint32, Flags naming.MountFlag) error

	// Mount Server (a global name) onto the receiver.
	//
	// Subsequent mounts add to the servers mounted there.  The multiple
	// servers are considered equivalent and are meant solely for
	// availability, i.e., no load balancing is guaranteed.
	//
	// BlessingPatterns is a set of patterns that match the blessings
	// presented by Server to clients that initiate connections with it.
	// If empty, the mounttable makes the conservative assumption that the
	// blessings presented by the client invoking Mount will be the
	// blessings presented by Server.
	//
	// TTL is the number of seconds the mount is to last unless refreshed by
	// another mount of the same server.  A TTL of 0 represents an infinite
	// duration.  A server with an expired TTL should never appear in the
	// results nor affect the operation of any MountTable method, and should
	// act as if it was never present as far as the interface is concerned.
	//
	// Opts represents a bit mask of options.
	MountX(Server string, BlessingPatterns []security.BlessingPattern, TTL uint32, Flags naming.MountFlag) error

	// Unmount removes Server from the receiver.  If Server is empty, remove
	// all servers mounted there.
	// Returns a non-nil error iff Server remains mounted at the mount point.
	Unmount(Server string) error

	// Delete removes the receiver.  If the receiver has children, it will not
	// be removed unless DeleteSubtree is true in which case the whole subtree is
	// removed.
	Delete(DeleteSubtree bool) error

	// ResolveStep takes the next step in resolving a name.  Returns the next
	// servers to query and the suffix at those servers.
	ResolveStep() (Entry naming.VDLMountEntry | error)

	// Obsolete, left for backward compatability until all uses are killed.
	ResolveStepX() (Entry naming.VDLMountEntry | error)

	object.Object
}
