package object

import (
	"v.io/core/veyron2/services/security/access"
)

// Object provides access control for Veyron objects.
//
// Veyron services implementing dynamic access control would typically
// embed this interface and tag additional methods defined by the service
// with one of Admin, Read, Write, Resolve etc. For example,
// the VDL definition of the object would be:
//
//   package mypackage
//
//   import "v.io/core/veyron2/security/access"
//   import "v.io/core/veyron2/security/access/object"
//
//   type MyObject interface {
//     object.Object
//     MyRead() (string, error) {access.Read}
//     MyWrite(string) error    {access.Write}
//   }
//
// If the set of pre-defined tags is insufficient, services may define their
// own tag type and annotate all methods with this new type.
// Instead of embedding this Object interface, define SetACL and GetACL in
// their own interface. Authorization policies will typically respect
// annotations of a single type. For example, the VDL definition of an object
// would be:
//
//  package mypackage
//
//  import "v.io/core/veyron2/security/access"
//
//  type MyTag string
//
//  const (
//    Blue = MyTag("Blue")
//    Red  = MyTag("Red")
//  )
//
//  type MyObject interface {
//    MyMethod() (string, error) {Blue}
//
//    // Allow clients to change access via the access.Object interface:
//    SetACL(acl access.TaggedACLMap, etag string) error         {Red}
//    GetACL() (acl access.TaggedACLMap, etag string, err error) {Blue}
//  }
type Object interface {
  // SetACL replaces the current ACL for an object.  etag allows for optional,
  // optimistic concurrency control.  If non-empty, etag's value must come from
  // GetACL.  If any client has successfully called SetACL in the meantime, the
  // etag will be stale and SetACL will fail.  If empty, SetACL performs an
  // unconditional update.
  //
  // ACL objects are expected to be small.  It is up to the implementation to
  // define the exact limit, though it should probably be around 100KB.  Large
  // lists of principals should use the Group API or blessings.
  //
  // There is some ambiguity when calling SetACL on a mount point.  Does it
  // affect the mount itself or does it affect the service endpoint that the
  // mount points to?  The chosen behavior is that it affects the service
  // endpoint.  To modify the mount point's ACL, use ResolveToMountTable
  // to get an endpoint and call SetACL on that.  This means that clients
  // must know when a name refers to a mount point to change its ACL.
  SetACL(acl access.TaggedACLMap, etag string) error {access.Admin}

  // GetACL returns the complete, current ACL for an object.  The returned etag
  // can be passed to a subsequent call to SetACL for optimistic concurrency
  // control. A successful call to SetACL will invalidate etag, and the client
  // must call GetACL again to get the current etag.
  GetACL() (acl access.TaggedACLMap, etag string | error) {access.Admin}
}
