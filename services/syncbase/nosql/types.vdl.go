// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Source: types.vdl

package nosql

import (
	// VDL system imports
	"fmt"
	"v.io/v23/vdl"

	// VDL user imports
	"v.io/v23/security/access"
)

// BatchOptions configures a batch.
// TODO(sadovsky): Add more options, e.g. to configure isolation, timeouts,
// whether to track the read set and/or write set, etc.
// TODO(sadovsky): Maybe add a DefaultBatchOptions() function that initializes
// BatchOptions with our desired defaults. Clients would be encouraged to
// initialize their BatchOptions object using that function and then modify it
// to their liking.
type BatchOptions struct {
	// Arbitrary string, typically used to describe the intent behind a batch.
	// Hints are surfaced to clients during conflict resolution.
	// TODO(sadovsky): Use "any" here?
	Hint string
	// ReadOnly specifies whether the batch should allow writes.
	// If ReadOnly is set to true, Abort() should be used to release any resources
	// associated with this batch (though it is not strictly required), and
	// Commit() will always fail.
	ReadOnly bool
}

func (BatchOptions) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.BatchOptions"`
}) {
}

// PrefixPermissions represents a pair of (prefix, perms).
type PrefixPermissions struct {
	Prefix string
	Perms  access.Permissions
}

func (PrefixPermissions) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.PrefixPermissions"`
}) {
}

// KeyValue is a key-value pair.
type KeyValue struct {
	Key   string
	Value []byte
}

func (KeyValue) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.KeyValue"`
}) {
}

// SyncGroupSpec contains the specification for a SyncGroup.
type SyncGroupSpec struct {
	// Human readable description.
	Description string
	// Permissions for the SyncGroup.
	Perms access.Permissions
	// SyncGroup prefixes (relative to the database).  Prefixes
	// must take the form "<tableName>/<rowKeyPrefix>" where
	// tableName is non-empty.
	Prefixes []string
	// Mount tables at which to advertise this SyncGroup. These
	// are the mount tables used for rendezvous in addition to the
	// one in the neighborhood. Typically, we will have only one
	// entry.  However, an array allows mount tables to be changed
	// over time.
	//
	// TODO(hpucha): Figure out a convention for
	// advertising SyncGroups in the mount table.
	MountTables []string
	// Option to change the privacy of the SyncGroup. Configures
	// whether blobs in a SyncGroup can be served to clients
	// holding blobrefs obtained from other SyncGroups.
	IsPrivate bool
}

func (SyncGroupSpec) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.SyncGroupSpec"`
}) {
}

// SyncGroupMemberInfo contains per-member metadata.
type SyncGroupMemberInfo struct {
	SyncPriority byte
}

func (SyncGroupMemberInfo) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.SyncGroupMemberInfo"`
}) {
}

// ResolverType defines the possible conflict resolution policies.
// A Conflict is defined as presence of two independent sets of updates
// originating from the same version of an object. Syncbase
// uses version vectors to determine sequence of changes to a given row. Hence
// if device A updates a row with key "foo" from version V3 to V4, then syncs
// with device B which further updates the same row from version V4 to V5 and
// then V5 is synced back to device A, device A will see V5 as a forward
// progression of "foo" and not a conflict with V3 of "foo". But in the
// meantime if device A had already updated "foo" again from version V4 to
// version V6 then there is a conflict between V5 and V6 with V4 being the
// common ancestor.
type ResolverType int

const (
	ResolverTypeLastWins ResolverType = iota
	ResolverTypeAppResolves
	ResolverTypeDefer
)

// ResolverTypeAll holds all labels for ResolverType.
var ResolverTypeAll = [...]ResolverType{ResolverTypeLastWins, ResolverTypeAppResolves, ResolverTypeDefer}

// ResolverTypeFromString creates a ResolverType from a string label.
func ResolverTypeFromString(label string) (x ResolverType, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ResolverType) Set(label string) error {
	switch label {
	case "LastWins", "lastwins":
		*x = ResolverTypeLastWins
		return nil
	case "AppResolves", "appresolves":
		*x = ResolverTypeAppResolves
		return nil
	case "Defer", "defer":
		*x = ResolverTypeDefer
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in nosql.ResolverType", label)
}

// String returns the string label of x.
func (x ResolverType) String() string {
	switch x {
	case ResolverTypeLastWins:
		return "LastWins"
	case ResolverTypeAppResolves:
		return "AppResolves"
	case ResolverTypeDefer:
		return "Defer"
	}
	return ""
}

func (ResolverType) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.ResolverType"`
	Enum struct{ LastWins, AppResolves, Defer string }
}) {
}

// SchemaMetadata maintains metadata related to the schema of a given database.
// There is one SchemaMetadata per database.
type SchemaMetadata struct {
	// Non negative Schema version number. Should be increased with every schema change
	// (e.g. adding fields to structs) that cannot be handled by previous
	// versions of the app.
	Version int64
	Policy  CrPolicy
}

func (SchemaMetadata) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.SchemaMetadata"`
}) {
}

// For a given row with a conflict, all rules are matched against the row.
// If no rules match the row, we default to "LastWins". If multiple
// rules match the row, ties are broken as follows:
//  1. If one match has a longer prefix than the other, take that one.
//  2. Else, if only one match specifies a type, take that one.
//  3. Else, the two matches are identical; take the last one in the Rules array.
type CrPolicy struct {
	Rules []CrRule
}

func (CrPolicy) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.CrPolicy"`
}) {
}

// CrRule provides a filter and the type of resolution to perform for a row
// under conflict that passes the filter.
type CrRule struct {
	// TableName is the name of the table that this rule applies to.
	TableName string
	// KeyPrefix represents the set of keys within the given table for which
	// this policy applies. TableName must not be empty if this field is set.
	KeyPrefix string
	// Type includes the full package path for the value type for which this
	// policy applies.
	Type string
	// Policy for resolving conflict.
	Resolver ResolverType
}

func (CrRule) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.CrRule"`
}) {
}

// BlobRef is a reference to a blob.
type BlobRef string

func (BlobRef) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.BlobRef"`
}) {
}

// FetchState represents the state transitions of a blob fetch.
type FetchState int

const (
	FetchStatePending FetchState = iota
	FetchStateLocating
	FetchStateFetching
	FetchStateDone
)

// FetchStateAll holds all labels for FetchState.
var FetchStateAll = [...]FetchState{FetchStatePending, FetchStateLocating, FetchStateFetching, FetchStateDone}

// FetchStateFromString creates a FetchState from a string label.
func FetchStateFromString(label string) (x FetchState, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *FetchState) Set(label string) error {
	switch label {
	case "Pending", "pending":
		*x = FetchStatePending
		return nil
	case "Locating", "locating":
		*x = FetchStateLocating
		return nil
	case "Fetching", "fetching":
		*x = FetchStateFetching
		return nil
	case "Done", "done":
		*x = FetchStateDone
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in nosql.FetchState", label)
}

// String returns the string label of x.
func (x FetchState) String() string {
	switch x {
	case FetchStatePending:
		return "Pending"
	case FetchStateLocating:
		return "Locating"
	case FetchStateFetching:
		return "Fetching"
	case FetchStateDone:
		return "Done"
	}
	return ""
}

func (FetchState) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.FetchState"`
	Enum struct{ Pending, Locating, Fetching, Done string }
}) {
}

// FetchStatus describes the progress of an asynchronous blob fetch.
type FetchStatus struct {
	State    FetchState // State of the blob fetch request.
	Received uint64     // Total number of bytes received.
	Total    uint64     // Blob size.
}

func (FetchStatus) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.FetchStatus"`
}) {
}

// StoreChange is the new value for a watched entity.
// TODO(rogulenko): Consider adding the Shell state.
type StoreChange struct {
	// Value is the new value for the row if the Change state equals to Exists,
	// otherwise the Value is nil.
	Value []byte
	// FromSync indicates whether the change came from sync. If FromSync is
	// false, then the change originated from the local device.
	FromSync bool
}

func (StoreChange) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.StoreChange"`
}) {
}

func init() {
	vdl.Register((*BatchOptions)(nil))
	vdl.Register((*PrefixPermissions)(nil))
	vdl.Register((*KeyValue)(nil))
	vdl.Register((*SyncGroupSpec)(nil))
	vdl.Register((*SyncGroupMemberInfo)(nil))
	vdl.Register((*ResolverType)(nil))
	vdl.Register((*SchemaMetadata)(nil))
	vdl.Register((*CrPolicy)(nil))
	vdl.Register((*CrRule)(nil))
	vdl.Register((*BlobRef)(nil))
	vdl.Register((*FetchState)(nil))
	vdl.Register((*FetchStatus)(nil))
	vdl.Register((*StoreChange)(nil))
}

const NullBlobRef = BlobRef("")
