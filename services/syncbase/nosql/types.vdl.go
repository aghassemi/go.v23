// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Source: types.vdl

package nosql

import (
	// VDL system imports
	"fmt"
	"v.io/v23/vdl"

	// VDL user imports
	"v.io/v23/security/access"
)

// BatchOptions configures a batch.
// TODO(sadovsky): Add more options, e.g. to configure isolation, timeouts,
// whether to track the read set and/or write set, etc.
// TODO(sadovsky): Maybe add a DefaultBatchOptions() function that initializes
// BatchOptions with our desired defaults. Clients would be encouraged to
// initialize their BatchOptions object using that function and then modify it
// to their liking.
type BatchOptions struct {
	// Arbitrary string, typically used to describe the intent behind a batch.
	// Hints are surfaced to clients during conflict resolution.
	// TODO(sadovsky): Use "any" here?
	Hint string
	// ReadOnly specifies whether the batch should allow writes.
	// If ReadOnly is set to true, Abort() should be used to release any resources
	// associated with this batch (though it is not strictly required), and
	// Commit() will always fail.
	ReadOnly bool
}

func (BatchOptions) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.BatchOptions"`
}) {
}

// PrefixPermissions represents a pair of (prefix, perms).
type PrefixPermissions struct {
	Prefix string
	Perms  access.Permissions
}

func (PrefixPermissions) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.PrefixPermissions"`
}) {
}

// KeyValue is a key-value pair.
type KeyValue struct {
	Key   string
	Value []byte
}

func (KeyValue) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.KeyValue"`
}) {
}

// SyncGroupSpec contains the specification for a SyncGroup.
type SyncGroupSpec struct {
	// Human readable description.
	Description string
	// Permissions for the SyncGroup.
	Perms access.Permissions
	// SyncGroup prefixes (relative to the database).  Prefixes
	// must take the form "<tableName>/<rowKeyPrefix>" where
	// tableName is non-empty.
	Prefixes []string
	// Mount tables at which to advertise this SyncGroup. These
	// are the mount tables used for rendezvous in addition to the
	// one in the neighborhood. Typically, we will have only one
	// entry.  However, an array allows mount tables to be changed
	// over time.
	//
	// TODO(hpucha): Figure out a convention for
	// advertising SyncGroups in the mount table.
	MountTables []string
	// Option to change the privacy of the SyncGroup. Configures
	// whether blobs in a SyncGroup can be served to clients
	// holding blobrefs obtained from other SyncGroups.
	IsPrivate bool
}

func (SyncGroupSpec) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.SyncGroupSpec"`
}) {
}

// SyncGroupMemberInfo contains per-member metadata.
type SyncGroupMemberInfo struct {
	SyncPriority byte
}

func (SyncGroupMemberInfo) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.SyncGroupMemberInfo"`
}) {
}

// ResolverType defines the possible conflict resolution policies.
// A Conflict is defined as presence of two independent sets of updates
// originating from the same version of an object. Syncbase
// uses version vectors to determine sequence of changes to a given row. Hence
// if device A updates a row with key "foo" from version V3 to V4, then syncs
// with device B which further updates the same row from version V4 to V5 and
// then V5 is synced back to device A, device A will see V5 as a forward
// progression of "foo" and not a conflict with V3 of "foo". But in the
// meantime if device A had already updated "foo" again from version V4 to
// version V6 then there is a conflict between V5 and V6 with V4 being the
// common ancestor.
type ResolverType int

const (
	ResolverTypeLastWins ResolverType = iota
	ResolverTypeAppResolves
	ResolverTypeDefer
)

// ResolverTypeAll holds all labels for ResolverType.
var ResolverTypeAll = [...]ResolverType{ResolverTypeLastWins, ResolverTypeAppResolves, ResolverTypeDefer}

// ResolverTypeFromString creates a ResolverType from a string label.
func ResolverTypeFromString(label string) (x ResolverType, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ResolverType) Set(label string) error {
	switch label {
	case "LastWins", "lastwins":
		*x = ResolverTypeLastWins
		return nil
	case "AppResolves", "appresolves":
		*x = ResolverTypeAppResolves
		return nil
	case "Defer", "defer":
		*x = ResolverTypeDefer
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in nosql.ResolverType", label)
}

// String returns the string label of x.
func (x ResolverType) String() string {
	switch x {
	case ResolverTypeLastWins:
		return "LastWins"
	case ResolverTypeAppResolves:
		return "AppResolves"
	case ResolverTypeDefer:
		return "Defer"
	}
	return ""
}

func (ResolverType) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.ResolverType"`
	Enum struct{ LastWins, AppResolves, Defer string }
}) {
}

// SchemaMetadata maintains metadata related to the schema of a given database.
// There is one SchemaMetadata per database.
type SchemaMetadata struct {
	// Non negative Schema version number. Should be increased with every schema change
	// (e.g. adding fields to structs) that cannot be handled by previous
	// versions of the app.
	Version int64
	Policy  CrPolicy
}

func (SchemaMetadata) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.SchemaMetadata"`
}) {
}

// For a given row with a conflict, all rules are matched against the row.
// If no rules match the row, we default to "LastWins". If multiple
// rules match the row, ties are broken as follows:
//  1. If one match has a longer prefix than the other, take that one.
//  2. Else, if only one match specifies a type, take that one.
//  3. Else, the two matches are identical; take the last one in the Rules array.
type CrPolicy struct {
	Rules []CrRule
}

func (CrPolicy) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.CrPolicy"`
}) {
}

// CrRule provides a filter and the type of resolution to perform for a row
// under conflict that passes the filter.
type CrRule struct {
	// TableName is the name of the table that this rule applies to.
	TableName string
	// KeyPrefix represents the set of keys within the given table for which
	// this policy applies. TableName must not be empty if this field is set.
	KeyPrefix string
	// Type includes the full package path for the value type for which this
	// policy applies.
	Type string
	// Policy for resolving conflict.
	Resolver ResolverType
}

func (CrRule) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.CrRule"`
}) {
}

// BlobRef is a reference to a blob.
type BlobRef string

func (BlobRef) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.BlobRef"`
}) {
}

// FetchState represents the state transitions of a blob fetch.
type FetchState int

const (
	FetchStatePending FetchState = iota
	FetchStateLocating
	FetchStateFetching
	FetchStateDone
)

// FetchStateAll holds all labels for FetchState.
var FetchStateAll = [...]FetchState{FetchStatePending, FetchStateLocating, FetchStateFetching, FetchStateDone}

// FetchStateFromString creates a FetchState from a string label.
func FetchStateFromString(label string) (x FetchState, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *FetchState) Set(label string) error {
	switch label {
	case "Pending", "pending":
		*x = FetchStatePending
		return nil
	case "Locating", "locating":
		*x = FetchStateLocating
		return nil
	case "Fetching", "fetching":
		*x = FetchStateFetching
		return nil
	case "Done", "done":
		*x = FetchStateDone
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in nosql.FetchState", label)
}

// String returns the string label of x.
func (x FetchState) String() string {
	switch x {
	case FetchStatePending:
		return "Pending"
	case FetchStateLocating:
		return "Locating"
	case FetchStateFetching:
		return "Fetching"
	case FetchStateDone:
		return "Done"
	}
	return ""
}

func (FetchState) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.FetchState"`
	Enum struct{ Pending, Locating, Fetching, Done string }
}) {
}

// FetchStatus describes the progress of an asynchronous blob fetch.
type FetchStatus struct {
	State    FetchState // State of the blob fetch request.
	Received uint64     // Total number of bytes received.
	Total    uint64     // Blob size.
}

func (FetchStatus) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.FetchStatus"`
}) {
}

// ResumeMarker is a pointer in the database event log.
type ResumeMarker string

func (ResumeMarker) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.ResumeMarker"`
}) {
}

// TablePrefixRange describes a prefix range in a table.
type TablePrefixRange struct {
	Table  string
	Prefix string
}

func (TablePrefixRange) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.TablePrefixRange"`
}) {
}

// WatchRequest specifies which rows should be watched and a starting point
// in the database event log from which to receive updates.
type WatchRequest struct {
	// Ranges specifies the subset of the database for which the client wants
	// updates.
	Ranges []TablePrefixRange
	// ResumeMarker is the starting point in the database event log from which
	// to receive updates.
	ResumeMarker ResumeMarker
}

func (WatchRequest) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.WatchRequest"`
}) {
}

// ChangeType describes the type of the row change: Put or Delete.
// TODO(rogulenko): Consider adding the Shell type.
type ChangeType int

const (
	ChangeTypePut ChangeType = iota
	ChangeTypeDelete
)

// ChangeTypeAll holds all labels for ChangeType.
var ChangeTypeAll = [...]ChangeType{ChangeTypePut, ChangeTypeDelete}

// ChangeTypeFromString creates a ChangeType from a string label.
func ChangeTypeFromString(label string) (x ChangeType, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *ChangeType) Set(label string) error {
	switch label {
	case "Put", "put":
		*x = ChangeTypePut
		return nil
	case "Delete", "delete":
		*x = ChangeTypeDelete
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in nosql.ChangeType", label)
}

// String returns the string label of x.
func (x ChangeType) String() string {
	switch x {
	case ChangeTypePut:
		return "Put"
	case ChangeTypeDelete:
		return "Delete"
	}
	return ""
}

func (ChangeType) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.ChangeType"`
	Enum struct{ Put, Delete string }
}) {
}

// Change is the new value for a watched entity.
type Change struct {
	// Table is the name of the table that contains the changed row.
	Table string
	// Row is the key of the changed row.
	Row string
	// ChangeType describes the type of the change. If the ChangeType equals to
	// Put, then the row exists in the table and the Value contains the new
	// value for this row. If the state equals to Delete, then the row was
	// removed from the table.
	ChangeType ChangeType
	// Value is the new value for the row if the state equals to Put,
	// otherwise the Value is nil.
	Value []byte
	// ResumeMarker provides a compact representation of all the messages
	// that have been received by the caller for the given Watch call.
	// This marker can be provided in the Request message to allow the caller
	// to resume the stream watching at a specific point without fetching the
	// initial state.
	ResumeMarker ResumeMarker
	// FromSync indicates whether the change came from sync. If FromSync is
	// false, then the change originated from the local device.
	FromSync bool
	// If true, this Change is followed by more Changes that are in the
	// same batch as this Change.
	Continued bool
}

func (Change) __VDLReflect(struct {
	Name string `vdl:"v.io/syncbase/v23/services/syncbase/nosql.Change"`
}) {
}

func init() {
	vdl.Register((*BatchOptions)(nil))
	vdl.Register((*PrefixPermissions)(nil))
	vdl.Register((*KeyValue)(nil))
	vdl.Register((*SyncGroupSpec)(nil))
	vdl.Register((*SyncGroupMemberInfo)(nil))
	vdl.Register((*ResolverType)(nil))
	vdl.Register((*SchemaMetadata)(nil))
	vdl.Register((*CrPolicy)(nil))
	vdl.Register((*CrRule)(nil))
	vdl.Register((*BlobRef)(nil))
	vdl.Register((*FetchState)(nil))
	vdl.Register((*FetchStatus)(nil))
	vdl.Register((*ResumeMarker)(nil))
	vdl.Register((*TablePrefixRange)(nil))
	vdl.Register((*WatchRequest)(nil))
	vdl.Register((*ChangeType)(nil))
	vdl.Register((*Change)(nil))
}

const NullBlobRef = BlobRef("")
