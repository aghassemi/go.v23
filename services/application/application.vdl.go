// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: application

// Package application defines types for describing applications.
package application

import (
	"fmt"
	"time"
	"v.io/v23/security"
	"v.io/v23/vdl"
	time_2 "v.io/v23/vdlroot/time"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// SignedFile represents a file accompanied by a signature of its contents.
type SignedFile struct {
	//  File is the object name of the file.
	File string
	// Signature represents a signature on the sha256 hash of the file
	// contents by the publisher principal.
	Signature security.Signature
}

func (SignedFile) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/application.SignedFile"`
}) {
}

func (m *SignedFile) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("File")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.File), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Signature")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Signature.FillVDLTarget(fieldTarget5, tt.NonOptional().Field(1).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *SignedFile) MakeVDLTarget() vdl.Target {
	return &SignedFileTarget{Value: m}
}

type SignedFileTarget struct {
	Value           *SignedFile
	fileTarget      vdl.StringTarget
	signatureTarget security.SignatureTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *SignedFileTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*SignedFile)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *SignedFileTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "File":
		t.fileTarget.Value = &t.Value.File
		target, err := &t.fileTarget, error(nil)
		return nil, target, err
	case "Signature":
		t.signatureTarget.Value = &t.Value.Signature
		target, err := &t.signatureTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/services/application.SignedFile", name)
	}
}
func (t *SignedFileTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *SignedFileTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// Packages represents a set of packages. The map key is the local
// file/directory name, relative to the instance's packages directory, where the
// package should be installed. For archives, this name represents a directory
// into which the archive is to be extracted, and for regular files it
// represents the name for the file.  The map value is the package
// specification.
//
// Each object's media type determines how to install it.
//
// For example, with key=pkg1,value=SignedFile{File:binaryrepo/configfiles} (an
// archive), the "configfiles" package will be installed under the "pkg1"
// directory. With key=pkg2,value=SignedFile{File:binaryrepo/binfile} (a
// binary), the "binfile" file will be installed as the "pkg2" file.
//
// The keys must be valid file/directory names, without path separators.
//
// Any number of packages may be specified.
type Packages map[string]SignedFile

func (Packages) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/application.Packages"`
}) {
}

func (m *Packages) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	mapTarget1, err := t.StartMap(tt, len((*m)))
	if err != nil {
		return err
	}
	for key3, value5 := range *m {
		keyTarget2, err := mapTarget1.StartKey()
		if err != nil {
			return err
		}
		if err := keyTarget2.FromString(string(key3), tt.NonOptional().Key()); err != nil {
			return err
		}
		valueTarget4, err := mapTarget1.FinishKeyStartField(keyTarget2)
		if err != nil {
			return err
		}

		if err := value5.FillVDLTarget(valueTarget4, tt.NonOptional().Elem()); err != nil {
			return err
		}
		if err := mapTarget1.FinishField(keyTarget2, valueTarget4); err != nil {
			return err
		}
	}
	if err := t.FinishMap(mapTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Packages) MakeVDLTarget() vdl.Target {
	return &PackagesTarget{Value: m}
}

type PackagesTarget struct {
	Value      *Packages
	currKey    string
	currElem   SignedFile
	keyTarget  vdl.StringTarget
	elemTarget SignedFileTarget
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *PackagesTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {

	if ttWant := vdl.TypeOf((*Packages)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	*t.Value = make(Packages)
	return t, nil
}
func (t *PackagesTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	t.keyTarget.Value = &t.currKey
	target, err := &t.keyTarget, error(nil)
	return target, err
}
func (t *PackagesTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = SignedFile{}
	t.elemTarget.Value = &t.currElem
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *PackagesTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *PackagesTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}

	return nil
}

// Envelope is a collection of metadata that describes an application.
type Envelope struct {
	// Title is the publisher-assigned application title.  Application
	// installations with the same title are considered as belonging to the
	// same application by the application management system.
	//
	// A change in the title signals a new application.
	Title string
	// Args is an array of command-line arguments to be used when executing
	// the binary.
	Args []string
	// Binary identifies the application binary.
	Binary SignedFile
	// Publisher represents the set of blessings that have been bound to
	// the principal who published this binary.
	Publisher security.Blessings
	// Env is an array that stores the environment variable values to be
	// used when executing the binary.
	Env []string
	// Packages is the set of packages to install on the local filesystem
	// before executing the binary
	Packages Packages
	// Restarts specifies how many times the device manager will attempt
	// to automatically restart an application that has crashed before
	// giving up and marking the application as NotRunning.
	Restarts int32
	// RestartTimeWindow is the time window within which an
	// application exit is considered a crash that counts against the
	// Restarts budget. If the application crashes after less than
	// RestartTimeWindow time for Restarts consecutive times, the
	// application is marked NotRunning and no more restart attempts
	// are made. If the application has run continuously for more
	// than RestartTimeWindow, subsequent crashes will again benefit
	// from up to Restarts restarts (that is, the Restarts budget is
	// reset by a successful run of at least RestartTimeWindow
	// duration).
	RestartTimeWindow time.Duration
}

func (Envelope) __VDLReflect(struct {
	Name string `vdl:"v.io/v23/services/application.Envelope"`
}) {
}

func (m *Envelope) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Title")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Title), tt.NonOptional().Field(0).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Args")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget6, err := fieldTarget5.StartList(tt.NonOptional().Field(1).Type, len(m.Args))
		if err != nil {
			return err
		}
		for i, elem8 := range m.Args {
			elemTarget7, err := listTarget6.StartElem(i)
			if err != nil {
				return err
			}
			if err := elemTarget7.FromString(string(elem8), tt.NonOptional().Field(1).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget6.FinishElem(elemTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget5.FinishList(listTarget6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("Binary")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Binary.FillVDLTarget(fieldTarget10, tt.NonOptional().Field(2).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	var wireValue11 security.WireBlessings
	if err := security.WireBlessingsFromNative(&wireValue11, m.Publisher); err != nil {
		return err
	}

	keyTarget12, fieldTarget13, err := fieldsTarget1.StartField("Publisher")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue11.FillVDLTarget(fieldTarget13, tt.NonOptional().Field(3).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget12, fieldTarget13); err != nil {
			return err
		}
	}
	keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("Env")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget16, err := fieldTarget15.StartList(tt.NonOptional().Field(4).Type, len(m.Env))
		if err != nil {
			return err
		}
		for i, elem18 := range m.Env {
			elemTarget17, err := listTarget16.StartElem(i)
			if err != nil {
				return err
			}
			if err := elemTarget17.FromString(string(elem18), tt.NonOptional().Field(4).Type.Elem()); err != nil {
				return err
			}
			if err := listTarget16.FinishElem(elemTarget17); err != nil {
				return err
			}
		}
		if err := fieldTarget15.FinishList(listTarget16); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
			return err
		}
	}
	keyTarget19, fieldTarget20, err := fieldsTarget1.StartField("Packages")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Packages.FillVDLTarget(fieldTarget20, tt.NonOptional().Field(5).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget19, fieldTarget20); err != nil {
			return err
		}
	}
	keyTarget21, fieldTarget22, err := fieldsTarget1.StartField("Restarts")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget22.FromInt(int64(m.Restarts), tt.NonOptional().Field(6).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget21, fieldTarget22); err != nil {
			return err
		}
	}
	var wireValue23 time_2.Duration
	if err := time_2.DurationFromNative(&wireValue23, m.RestartTimeWindow); err != nil {
		return err
	}

	keyTarget24, fieldTarget25, err := fieldsTarget1.StartField("RestartTimeWindow")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := wireValue23.FillVDLTarget(fieldTarget25, tt.NonOptional().Field(7).Type); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget24, fieldTarget25); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Envelope) MakeVDLTarget() vdl.Target {
	return &EnvelopeTarget{Value: m}
}

type EnvelopeTarget struct {
	Value                   *Envelope
	titleTarget             vdl.StringTarget
	argsTarget              vdl.StringSliceTarget
	binaryTarget            SignedFileTarget
	publisherTarget         security.WireBlessingsTarget
	envTarget               vdl.StringSliceTarget
	packagesTarget          PackagesTarget
	restartsTarget          vdl.Int32Target
	restartTimeWindowTarget time_2.DurationTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *EnvelopeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Envelope)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *EnvelopeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Title":
		t.titleTarget.Value = &t.Value.Title
		target, err := &t.titleTarget, error(nil)
		return nil, target, err
	case "Args":
		t.argsTarget.Value = &t.Value.Args
		target, err := &t.argsTarget, error(nil)
		return nil, target, err
	case "Binary":
		t.binaryTarget.Value = &t.Value.Binary
		target, err := &t.binaryTarget, error(nil)
		return nil, target, err
	case "Publisher":
		t.publisherTarget.Value = &t.Value.Publisher
		target, err := &t.publisherTarget, error(nil)
		return nil, target, err
	case "Env":
		t.envTarget.Value = &t.Value.Env
		target, err := &t.envTarget, error(nil)
		return nil, target, err
	case "Packages":
		t.packagesTarget.Value = &t.Value.Packages
		target, err := &t.packagesTarget, error(nil)
		return nil, target, err
	case "Restarts":
		t.restartsTarget.Value = &t.Value.Restarts
		target, err := &t.restartsTarget, error(nil)
		return nil, target, err
	case "RestartTimeWindow":
		t.restartTimeWindowTarget.Value = &t.Value.RestartTimeWindow
		target, err := &t.restartTimeWindowTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct v.io/v23/services/application.Envelope", name)
	}
}
func (t *EnvelopeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *EnvelopeTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

//////////////////////////////////////////////////
// Const definitions

// Device manager application envelopes must present this title.
const DeviceManagerTitle = "device manager"

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}

	// Register types.
	vdl.Register((*SignedFile)(nil))
	vdl.Register((*Packages)(nil))
	vdl.Register((*Envelope)(nil))

	return struct{}{}
}
