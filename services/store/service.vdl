package store

import (
  "veyron2/query"
  "veyron2/storage"
  "veyron2/services/watch"
  "veyron2/services/mounttable"
)

// TODO(jyh): Decide how to pass per-operation options (like priority and
// timeout info).

// Statable provides the Stat method.
type Statable interface {
	// Stat returns information about the receiver.
	Stat() (storage.Stat, error)

	// Exists returns true iff the receiver is present in the Store.
	Exists() (bool, error)
}

// Transactable provides the NewTransaction method.
type Transactable interface {
	// NewTransaction creates a transaction with the given options.  It returns
	// the name of the transaction relative to the receiver's name.  The client
	// must rebind to this new name to work with the receiver and its descendants
	// as part of the transaction.
	NewTransaction(Options []any) (string, error)
}

type DirOrObject interface {
	// Remove removes this Dir (and all its children, recursively) or Object.
	Remove() error

	// Query returns the sequence of elements that satisfy the query.
	Query(Q query.Query) stream<_, QueryResult> error

	Statable
	Transactable

	// Globbable is an API for finding all objects beneath this pattern that
	// match a pattern.
	mounttable.Globbable

	// GlobWatcher is an API for watching updates to objects beneath this value
	// that match a pattern.
	watch.GlobWatcher

	// QueryWatcher is an API for watching updates to objects beneath this
	// value that satisfy a query.
	watch.QueryWatcher
}

type DirSpecific interface {
	// Make creates this directory and any ancestor directories that do not
	// exist (i.e. equivalent to Unix's 'mkdir -p').  Make is idempotent.
	Make() error
}

// Dir is a directory containing Objects and other Dirs.
type Dir interface {
	DirSpecific
	DirOrObject
}

type ObjectSpecific interface {
	// Get returns the value for the Object.  The value returned is from the
	// most recent mutation of the entry in the Transaction, or from the
	// Transaction's snapshot if there is no mutation.
	Get() (storage.Entry, error)

	// Put modifies the value of the Object.
	Put(V any) (storage.Stat, error)
}

// ObjectService is the interface for a value in the store.
type Object interface {
	ObjectSpecific
	DirOrObject
}

type Transaction interface {
	// Commit commits the changes in the transaction to the store.  The
	// operation is atomic, so all mutations are performed, or none.  Returns an
	// error if the transaction aborted.
	Commit() error

	// Abort discards a transaction.  This is an optimization; transactions
	// eventually time out and get discarded.  However, live transactions
	// consume resources, so if you know that you won't be using a transaction
	// anymore, you should discard it explicitly.
	Abort() error
}

// NestedResult allows nested query results to be sent out-of-line.
// See QueryResult for a full explanation.
type NestedResult int64

// QueryResult is a single level result.  If the query contained nested
// queries, they will be sent as subsequent QueryResults.  If the
// QueryResult is for a known type, the value is stored in Value.
// If the result is for a dynamic type using selection, Fields will
// be populated appropriately and Value will be nil.
//
// Examples
// 1) Return Team objects: "/teamsapp/teams".Query("*:Team")
//    QueryResult{
//      NestedResult: 0,
//      Name: "hornets",
//      Fields: nil,
//      Value: Team{Location: "CA", Mascot:"Buzz"},
//    },
//    QueryResult{
//      NestedResult: 0,
//      Name: "sharks",
//      Fields: nil,
//      Value: Team{Location: "NY", Mascot:"Jaws"},
//    }
//
// 2) Return just the mascot names: "/teamsapp/teams".Query("*:Team{Mascot}")
//    QueryResult{
//      NestedResult: 0,
//      Name: "hornets",
//      Fields: {"Mascot": "Buzz"},
//      Value: nil,
//    },
//    QueryResult{
//      NestedResult: 0,
//      Name: "sharks",
//      Fields: {"Mascot": "Jaws"},
//      Value: nil
//    }
//
// 3) Return the players for each team: "/teamsapp/teams".Query("*:Team{., players/*:Player")
//    QueryResult{
//      NestedResult: 0,
//      Name: "hornets",
//      Fields: {
//        ".": Team{Location: "CA", Mascot: "Buzz"},
//        // Any subsequent QueryResult with a NestedResult of 1 should be
//        // materialized in this field.
//        "players": NestedResult(1),
//      },
//      Value:nil
//    },
//    QueryResult{
//      NestedResult: 1,
//      Name: "John",
//      Fields: nil,
//      Value: Player{Age: 23, Hometown: "New York"},
//    },
//    QueryResult{
//      NestedResult: 1,
//      Name: "Julie",
//      Fields: nil,
//      Value: Player{Age: 24, Hometown: "Charlotte"},
//    },
//    QueryResult{
//      NestedResult: 0,
//      Name: "sharks",
//      Fields:
//        ".": Team{Location: "NY", Mascot: "Jaws"},
//        "players": NestedResult(2),
//      },
//      Value:nil
//    },
//    QueryResult{
//      NestedResult: 2,
//      Name: "Jamie",
//      Fields: nil,
//      Value: Player{Age: 20, Hometown: "Seattle"},
//    },
//    QueryResult{
//      NestedResult: 2,
//      Name: "Jacob",
//      Fields: nil,
//      Value: Player{Age: 25, Hometown: "Miami"},
//    }
//
// Nested results may in turn contain their own nested results.  A
// NestedResult value is always greater than the parent's NestedResult value.
// In a stream of results, a decrease in the NestedResult values means
// that the group is finished.  Here is an example result stream containing
// only the NestedResult values.  The parentheses show the grouping.
//  (0 (1 (2, 2), 1 (3), 1 (4, 4, 4)), (0 (1, 1 (5, 5)))
type QueryResult struct {
	// NestedResult, if non-zero, specifies which previous result contains
	// this result.
	NestedResult NestedResult
	// Name is the Object name of this value.  It is relative to the query
	// root or, if NestedResult is non-zero, to the parent result.
	Name string
	// Fields will be non-nil if this query result is of a dynamic type
	// specified by the selection operator. The keys will be the names
	// used in the selection.  If a field represents a subquery, the
	// value will be a NestedResult and subsequent QueryResults will
	// have the same valued NestedResult.  See the example above.
	Fields map[string]any
	// Value will be non-nil if this query result is of a known type.
	Value any
}
