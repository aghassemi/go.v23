// This file was auto-generated by the veyron vdl tool.
// Source: service.vdl

package store

import (
	"veyron2/query"

	"veyron2/services/mounttable"

	"veyron2/services/watch"

	"veyron2/storage"

	// The non-user imports are prefixed with "_gen_" to prevent collisions.
	_gen_io "io"
	_gen_context "veyron2/context"
	_gen_ipc "veyron2/ipc"
	_gen_naming "veyron2/naming"
	_gen_rt "veyron2/rt"
	_gen_vdlutil "veyron2/vdl/vdlutil"
	_gen_wiretype "veyron2/wiretype"
)

// TransactionID is a transaction identifier.  The identifier is chosen by the
// client.
//
// TransactionIDs do not span store instances.  If you use the same
// TransactionID with two different store instances, the transactions are
// separate, and must be committed separately.  Don't do that, it will lead to
// confusion.  Use fresh TransactionIDs for each store instance.
//
// TODO(jyh): Consider using a larger identifier space to reduce chance of
// collisions.
type TransactionID uint64

// Stat provides information about an entry in the store.
//
// TODO(jyh): Specify versioning more precisely.
type Stat struct {
	// ID is the unique identifier of the entry.
	ID storage.ID
	// MTimeNS is the last modification time in Unix nanoseconds (see time.UnixNano).
	//
	// TODO(jyh): Use Veyron Time when it gets implemented.
	MTimeNS int64
	// Attrs are the attributes associated with the entry.
	Attrs []_gen_vdlutil.Any
}

// Conflict represents a conflicting update in the store.
type Conflict struct {
	// Ty is the IDL name of the type.
	Ty string
	// ID is the identifier for the entry.
	ID storage.ID
	// Local is the local value for the entry.
	Local Entry
	// Remove is the conflicting update.
	Remote Entry
	// Root is a common ancestor.
	Root Entry
}

// Entry represents a value at some point in time in the store.
type Entry struct {
	// Stat is the entry's metadata.
	Stat Stat
	// Value is the value of the entry.
	Value _gen_vdlutil.Any
}

// NestedResult allows nested query results to be sent out-of-line.
// See QueryResult for a full explanation.
type NestedResult int64

// QueryResult is a single level result.  If the query contained nested
// queries, they will be sent as subsequent QueryResults.  If the
// QueryResult is for a known type, the value is stored in Value.
// If the result is for a dynamic type using selection, Fields will
// be populated appropriately and Value will be nil.
//
// Examples
// 1) Return Team objects: "/teamsapp/teams".Query("*:Team")
//    QueryResult{
//      NestedResult: 0,
//      Name: "hornets",
//      Fields: nil,
//      Value: Team{Location: "CA", Mascot:"Buzz"},
//    },
//    QueryResult{
//      NestedResult: 0,
//      Name: "sharks",
//      Fields: nil,
//      Value: Team{Location: "NY", Mascot:"Jaws"},
//    }
//
// 2) Return just the mascot names: "/teamsapp/teams".Query("*:Team{Mascot}")
//    QueryResult{
//      NestedResult: 0,
//      Name: "hornets",
//      Fields: {"Mascot": "Buzz"},
//      Value: nil,
//    },
//    QueryResult{
//      NestedResult: 0,
//      Name: "sharks",
//      Fields: {"Mascot": "Jaws"},
//      Value: nil
//    }
//
// 3) Return the players for each team: "/teamsapp/teams".Query("*:Team{., players/*:Player")
//    QueryResult{
//      NestedResult: 0,
//      Name: "hornets",
//      Fields: {
//        ".": Team{Location: "CA", Mascot: "Buzz"},
//        // Any subsequent QueryResult with a NestedResult of 1 should be
//        // materialized in this field.
//        "players": NestedResult(1),
//      },
//      Value:nil
//    },
//    QueryResult{
//      NestedResult: 1,
//      Name: "John",
//      Fields: nil,
//      Value: Player{Age: 23, Hometown: "New York"},
//    },
//    QueryResult{
//      NestedResult: 1,
//      Name: "Julie",
//      Fields: nil,
//      Value: Player{Age: 24, Hometown: "Charlotte"},
//    },
//    QueryResult{
//      NestedResult: 0,
//      Name: "sharks",
//      Fields:
//        ".": Team{Location: "NY", Mascot: "Jaws"},
//        "players": NestedResult(2),
//      },
//      Value:nil
//    },
//    QueryResult{
//      NestedResult: 2,
//      Name: "Jamie",
//      Fields: nil,
//      Value: Player{Age: 20, Hometown: "Seattle"},
//    },
//    QueryResult{
//      NestedResult: 2,
//      Name: "Jacob",
//      Fields: nil,
//      Value: Player{Age: 25, Hometown: "Miami"},
//    }
//
// Nested results may in turn contain their own nested results.  A
// NestedResult value is always greater than the parent's NestedResult value.
// In a stream of results, a decrease in the NestedResult values means
// that the group is finished.  Here is an example result stream containing
// only the NestedResult values.  The parentheses show the grouping.
//  (0 (1 (2, 2), 1 (3), 1 (4, 4, 4)), (0 (1, 1 (5, 5)))
type QueryResult struct {
	// NestedResult, if non-zero, specifies which previous result contains
	// this result.
	NestedResult NestedResult
	// Name is the Object name of this value.  It is relative to the query
	// root or, if NestedResult is non-zero, to the parent result.
	Name string
	// Fields will be non-nil if this query result is of a dynamic type
	// specified by the selection operator. The keys will be the names
	// used in the selection.  If a field represents a subquery, the
	// value will be a NestedResult and subsequent QueryResults will
	// have the same valued NestedResult.  See the example above.
	Fields map[string]_gen_vdlutil.Any
	// Value will be non-nil if this query result is of a known type.
	Value _gen_vdlutil.Any
}

const (
	// The Store has Object name "<mount>/.store", where <mount> is the
	// Object name of the mount point.
	// An Object with path <path> has Object name "<mount>/<path>".
	StoreSuffix = ".store"
)

// TODO(bprosnitz) Remove this line once signatures are updated to use typevals.
// It corrects a bug where _gen_wiretype is unused in VDL pacakges where only bootstrap types are used on interfaces.
const _ = _gen_wiretype.TypeIDInvalid

// ObjectService is the interface for a value in the store.
// Object is the interface the client binds and uses.
// Object_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type Object_ExcludingUniversal interface {
	mounttable.Globable_ExcludingUniversal
	// GlobWatcher allows a client to receive updates for changes to objects
	// that match a pattern.  See the package comments for details.
	watch.GlobWatcher_ExcludingUniversal
	// QueryWatcher allows a client to receive updates for changes to objects
	// that match a query.  See the package comments for details.
	watch.QueryWatcher_ExcludingUniversal
	// Exists returns true iff the Entry has a value.
	Exists(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (reply bool, err error)
	// Get returns the value for the Object.  The value returned is from the
	// most recent mutation of the entry in the Transaction, or from the
	// Transaction's snapshot if there is no mutation.
	Get(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (reply Entry, err error)
	// Put modifies the value of the Object.
	Put(ctx _gen_context.T, TID TransactionID, V _gen_vdlutil.Any, opts ..._gen_ipc.CallOpt) (reply Stat, err error)
	// Remove removes the Object.
	Remove(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (err error)
	// SetAttr changes the attributes of the entry, such as permissions and
	// replication groups.  Attributes are associated with the value, not the
	// path.
	SetAttr(ctx _gen_context.T, TID TransactionID, Attrs []_gen_vdlutil.Any, opts ..._gen_ipc.CallOpt) (err error)
	// Stat returns entry info.
	Stat(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (reply Stat, err error)
	// Query returns the sequence of elements that satisfy the query.
	Query(ctx _gen_context.T, TID TransactionID, Q query.Query, opts ..._gen_ipc.CallOpt) (reply ObjectQueryStream, err error)
	// GlobT finds objects beneath this value that match the given pattern.
	// This is the same as Glob, but operates within a transaction.
	GlobT(ctx _gen_context.T, TID TransactionID, pattern string, opts ..._gen_ipc.CallOpt) (reply ObjectGlobTStream, err error)
}
type Object interface {
	_gen_ipc.UniversalServiceMethods
	Object_ExcludingUniversal
}

// ObjectService is the interface the server implements.
type ObjectService interface {
	mounttable.GlobableService
	// GlobWatcher allows a client to receive updates for changes to objects
	// that match a pattern.  See the package comments for details.
	watch.GlobWatcherService
	// QueryWatcher allows a client to receive updates for changes to objects
	// that match a query.  See the package comments for details.
	watch.QueryWatcherService
	// Exists returns true iff the Entry has a value.
	Exists(context _gen_ipc.ServerContext, TID TransactionID) (reply bool, err error)
	// Get returns the value for the Object.  The value returned is from the
	// most recent mutation of the entry in the Transaction, or from the
	// Transaction's snapshot if there is no mutation.
	Get(context _gen_ipc.ServerContext, TID TransactionID) (reply Entry, err error)
	// Put modifies the value of the Object.
	Put(context _gen_ipc.ServerContext, TID TransactionID, V _gen_vdlutil.Any) (reply Stat, err error)
	// Remove removes the Object.
	Remove(context _gen_ipc.ServerContext, TID TransactionID) (err error)
	// SetAttr changes the attributes of the entry, such as permissions and
	// replication groups.  Attributes are associated with the value, not the
	// path.
	SetAttr(context _gen_ipc.ServerContext, TID TransactionID, Attrs []_gen_vdlutil.Any) (err error)
	// Stat returns entry info.
	Stat(context _gen_ipc.ServerContext, TID TransactionID) (reply Stat, err error)
	// Query returns the sequence of elements that satisfy the query.
	Query(context _gen_ipc.ServerContext, TID TransactionID, Q query.Query, stream ObjectServiceQueryStream) (err error)
	// GlobT finds objects beneath this value that match the given pattern.
	// This is the same as Glob, but operates within a transaction.
	GlobT(context _gen_ipc.ServerContext, TID TransactionID, pattern string, stream ObjectServiceGlobTStream) (err error)
}

// ObjectQueryStream is the interface for streaming responses of the method
// Query in the service interface Object.
type ObjectQueryStream interface {

	// Advance stages an element so the client can retrieve it
	// with Value.  Advance returns true iff there is an
	// element to retrieve.  The client must call Advance before
	// calling Value.  The client must call Cancel if it does
	// not iterate through all elements (i.e. until Advance
	// returns false).  Advance may block if an element is not
	// immediately available.
	Advance() bool

	// Value returns the element that was staged by Advance.
	// Value may panic if Advance returned false or was not
	// called at all.  Value does not block.
	Value() QueryResult

	// Err returns a non-nil error iff the stream encountered
	// any errors.  Err does not block.
	Err() error

	// Finish blocks until the server is done and returns the positional
	// return values for call.
	//
	// If Cancel has been called, Finish will return immediately; the output of
	// Finish could either be an error signalling cancelation, or the correct
	// positional return values from the server depending on the timing of the
	// call.
	//
	// Calling Finish is mandatory for releasing stream resources, unless Cancel
	// has been called or any of the other methods return a non-EOF error.
	// Finish should be called at most once.
	Finish() (err error)

	// Cancel cancels the RPC, notifying the server to stop processing.  It
	// is safe to call Cancel concurrently with any of the other stream methods.
	// Calling Cancel after Finish has returned is a no-op.
	Cancel()
}

// Implementation of the ObjectQueryStream interface that is not exported.
type implObjectQueryStream struct {
	clientCall _gen_ipc.Call
	val        QueryResult
	err        error
}

func (c *implObjectQueryStream) Advance() bool {
	c.val = QueryResult{}
	c.err = c.clientCall.Recv(&c.val)
	return c.err == nil
}

func (c *implObjectQueryStream) Value() QueryResult {
	return c.val
}

func (c *implObjectQueryStream) Err() error {
	if c.err == _gen_io.EOF {
		return nil
	}
	return c.err
}

func (c *implObjectQueryStream) Finish() (err error) {
	if ierr := c.clientCall.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c *implObjectQueryStream) Cancel() {
	c.clientCall.Cancel()
}

// ObjectServiceQueryStream is the interface for streaming responses of the method
// Query in the service interface Object.
type ObjectServiceQueryStream interface {
	// Send places the item onto the output stream, blocking if there is no buffer
	// space available.  If the client has canceled, an error is returned.
	Send(item QueryResult) error
}

// Implementation of the ObjectServiceQueryStream interface that is not exported.
type implObjectServiceQueryStream struct {
	serverCall _gen_ipc.ServerCall
}

func (s *implObjectServiceQueryStream) Send(item QueryResult) error {
	return s.serverCall.Send(item)
}

// ObjectGlobTStream is the interface for streaming responses of the method
// GlobT in the service interface Object.
type ObjectGlobTStream interface {

	// Advance stages an element so the client can retrieve it
	// with Value.  Advance returns true iff there is an
	// element to retrieve.  The client must call Advance before
	// calling Value.  The client must call Cancel if it does
	// not iterate through all elements (i.e. until Advance
	// returns false).  Advance may block if an element is not
	// immediately available.
	Advance() bool

	// Value returns the element that was staged by Advance.
	// Value may panic if Advance returned false or was not
	// called at all.  Value does not block.
	Value() string

	// Err returns a non-nil error iff the stream encountered
	// any errors.  Err does not block.
	Err() error

	// Finish blocks until the server is done and returns the positional
	// return values for call.
	//
	// If Cancel has been called, Finish will return immediately; the output of
	// Finish could either be an error signalling cancelation, or the correct
	// positional return values from the server depending on the timing of the
	// call.
	//
	// Calling Finish is mandatory for releasing stream resources, unless Cancel
	// has been called or any of the other methods return a non-EOF error.
	// Finish should be called at most once.
	Finish() (err error)

	// Cancel cancels the RPC, notifying the server to stop processing.  It
	// is safe to call Cancel concurrently with any of the other stream methods.
	// Calling Cancel after Finish has returned is a no-op.
	Cancel()
}

// Implementation of the ObjectGlobTStream interface that is not exported.
type implObjectGlobTStream struct {
	clientCall _gen_ipc.Call
	val        string
	err        error
}

func (c *implObjectGlobTStream) Advance() bool {
	c.err = c.clientCall.Recv(&c.val)
	return c.err == nil
}

func (c *implObjectGlobTStream) Value() string {
	return c.val
}

func (c *implObjectGlobTStream) Err() error {
	if c.err == _gen_io.EOF {
		return nil
	}
	return c.err
}

func (c *implObjectGlobTStream) Finish() (err error) {
	if ierr := c.clientCall.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c *implObjectGlobTStream) Cancel() {
	c.clientCall.Cancel()
}

// ObjectServiceGlobTStream is the interface for streaming responses of the method
// GlobT in the service interface Object.
type ObjectServiceGlobTStream interface {
	// Send places the item onto the output stream, blocking if there is no buffer
	// space available.  If the client has canceled, an error is returned.
	Send(item string) error
}

// Implementation of the ObjectServiceGlobTStream interface that is not exported.
type implObjectServiceGlobTStream struct {
	serverCall _gen_ipc.ServerCall
}

func (s *implObjectServiceGlobTStream) Send(item string) error {
	return s.serverCall.Send(item)
}

// BindObject returns the client stub implementing the Object
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindObject(name string, opts ..._gen_ipc.BindOpt) (Object, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		client = _gen_rt.R().Client()
	case 1:
		switch o := opts[0].(type) {
		case _gen_ipc.Client:
			client = o
		default:
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubObject{client: client, name: name}
	stub.Globable_ExcludingUniversal, _ = mounttable.BindGlobable(name, client)
	stub.GlobWatcher_ExcludingUniversal, _ = watch.BindGlobWatcher(name, client)
	stub.QueryWatcher_ExcludingUniversal, _ = watch.BindQueryWatcher(name, client)

	return stub, nil
}

// NewServerObject creates a new server stub.
//
// It takes a regular server implementing the ObjectService
// interface, and returns a new server stub.
func NewServerObject(server ObjectService) interface{} {
	return &ServerStubObject{
		ServerStubGlobable:     *mounttable.NewServerGlobable(server).(*mounttable.ServerStubGlobable),
		ServerStubGlobWatcher:  *watch.NewServerGlobWatcher(server).(*watch.ServerStubGlobWatcher),
		ServerStubQueryWatcher: *watch.NewServerQueryWatcher(server).(*watch.ServerStubQueryWatcher),
		service:                server,
	}
}

// clientStubObject implements Object.
type clientStubObject struct {
	mounttable.Globable_ExcludingUniversal
	watch.GlobWatcher_ExcludingUniversal
	watch.QueryWatcher_ExcludingUniversal

	client _gen_ipc.Client
	name   string
}

func (__gen_c *clientStubObject) Exists(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (reply bool, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "Exists", []interface{}{TID}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObject) Get(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (reply Entry, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "Get", []interface{}{TID}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObject) Put(ctx _gen_context.T, TID TransactionID, V _gen_vdlutil.Any, opts ..._gen_ipc.CallOpt) (reply Stat, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "Put", []interface{}{TID, V}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObject) Remove(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "Remove", []interface{}{TID}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObject) SetAttr(ctx _gen_context.T, TID TransactionID, Attrs []_gen_vdlutil.Any, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "SetAttr", []interface{}{TID, Attrs}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObject) Stat(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (reply Stat, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "Stat", []interface{}{TID}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObject) Query(ctx _gen_context.T, TID TransactionID, Q query.Query, opts ..._gen_ipc.CallOpt) (reply ObjectQueryStream, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "Query", []interface{}{TID, Q}, opts...); err != nil {
		return
	}
	reply = &implObjectQueryStream{clientCall: call}
	return
}

func (__gen_c *clientStubObject) GlobT(ctx _gen_context.T, TID TransactionID, pattern string, opts ..._gen_ipc.CallOpt) (reply ObjectGlobTStream, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "GlobT", []interface{}{TID, pattern}, opts...); err != nil {
		return
	}
	reply = &implObjectGlobTStream{clientCall: call}
	return
}

func (__gen_c *clientStubObject) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObject) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObject) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubObject wraps a server that implements
// ObjectService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubObject struct {
	mounttable.ServerStubGlobable
	watch.ServerStubGlobWatcher
	watch.ServerStubQueryWatcher

	service ObjectService
}

func (__gen_s *ServerStubObject) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	if resp, err := __gen_s.ServerStubGlobable.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	if resp, err := __gen_s.ServerStubGlobWatcher.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	if resp, err := __gen_s.ServerStubQueryWatcher.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	switch method {
	case "Exists":
		return []interface{}{}, nil
	case "Get":
		return []interface{}{}, nil
	case "Put":
		return []interface{}{}, nil
	case "Remove":
		return []interface{}{}, nil
	case "SetAttr":
		return []interface{}{}, nil
	case "Stat":
		return []interface{}{}, nil
	case "Query":
		return []interface{}{}, nil
	case "GlobT":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubObject) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["Exists"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 2},
			{Name: "", Type: 66},
		},
	}
	result.Methods["Get"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 72},
			{Name: "", Type: 66},
		},
	}
	result.Methods["GlobT"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
			{Name: "pattern", Type: 3},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 66},
		},

		OutStream: 3,
	}
	result.Methods["Put"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
			{Name: "V", Type: 69},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 71},
			{Name: "", Type: 66},
		},
	}
	result.Methods["Query"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
			{Name: "Q", Type: 73},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 66},
		},

		OutStream: 76,
	}
	result.Methods["Remove"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 66},
		},
	}
	result.Methods["SetAttr"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
			{Name: "Attrs", Type: 70},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 66},
		},
	}
	result.Methods["Stat"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 71},
			{Name: "", Type: 66},
		},
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x35, Name: "veyron2/services/store.TransactionID", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x32, Name: "byte", Tags: []string(nil)}, _gen_wiretype.ArrayType{Elem: 0x43, Len: 0x10, Name: "veyron2/storage.ID", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "anydata", Tags: []string(nil)}, _gen_wiretype.SliceType{Elem: 0x45, Name: "", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x44, Name: "ID"},
				_gen_wiretype.FieldType{Type: 0x25, Name: "MTimeNS"},
				_gen_wiretype.FieldType{Type: 0x46, Name: "Attrs"},
			},
			"veyron2/services/store.Stat", []string(nil)},
		_gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x47, Name: "Stat"},
				_gen_wiretype.FieldType{Type: 0x45, Name: "Value"},
			},
			"veyron2/services/store.Entry", []string(nil)},
		_gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x3, Name: "Stmt"},
			},
			"veyron2/query.Query", []string(nil)},
		_gen_wiretype.NamedPrimitiveType{Type: 0x25, Name: "veyron2/services/store.NestedResult", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x3, Elem: 0x45, Name: "", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x4a, Name: "NestedResult"},
				_gen_wiretype.FieldType{Type: 0x3, Name: "Name"},
				_gen_wiretype.FieldType{Type: 0x4b, Name: "Fields"},
				_gen_wiretype.FieldType{Type: 0x45, Name: "Value"},
			},
			"veyron2/services/store.QueryResult", []string(nil)},
	}
	var ss _gen_ipc.ServiceSignature
	var firstAdded int
	ss, _ = __gen_s.ServerStubGlobable.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}
	ss, _ = __gen_s.ServerStubGlobWatcher.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}
	ss, _ = __gen_s.ServerStubQueryWatcher.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}

	return result, nil
}

func (__gen_s *ServerStubObject) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubObject) Exists(call _gen_ipc.ServerCall, TID TransactionID) (reply bool, err error) {
	reply, err = __gen_s.service.Exists(call, TID)
	return
}

func (__gen_s *ServerStubObject) Get(call _gen_ipc.ServerCall, TID TransactionID) (reply Entry, err error) {
	reply, err = __gen_s.service.Get(call, TID)
	return
}

func (__gen_s *ServerStubObject) Put(call _gen_ipc.ServerCall, TID TransactionID, V _gen_vdlutil.Any) (reply Stat, err error) {
	reply, err = __gen_s.service.Put(call, TID, V)
	return
}

func (__gen_s *ServerStubObject) Remove(call _gen_ipc.ServerCall, TID TransactionID) (err error) {
	err = __gen_s.service.Remove(call, TID)
	return
}

func (__gen_s *ServerStubObject) SetAttr(call _gen_ipc.ServerCall, TID TransactionID, Attrs []_gen_vdlutil.Any) (err error) {
	err = __gen_s.service.SetAttr(call, TID, Attrs)
	return
}

func (__gen_s *ServerStubObject) Stat(call _gen_ipc.ServerCall, TID TransactionID) (reply Stat, err error) {
	reply, err = __gen_s.service.Stat(call, TID)
	return
}

func (__gen_s *ServerStubObject) Query(call _gen_ipc.ServerCall, TID TransactionID, Q query.Query) (err error) {
	stream := &implObjectServiceQueryStream{serverCall: call}
	err = __gen_s.service.Query(call, TID, Q, stream)
	return
}

func (__gen_s *ServerStubObject) GlobT(call _gen_ipc.ServerCall, TID TransactionID, pattern string) (err error) {
	stream := &implObjectServiceGlobTStream{serverCall: call}
	err = __gen_s.service.GlobT(call, TID, pattern, stream)
	return
}

// Store is the client interface to the storage system.
// Store is the interface the client binds and uses.
// Store_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type Store_ExcludingUniversal interface {
	// CreateTransaction creates the transaction and sets the options for it.
	CreateTransaction(ctx _gen_context.T, TID TransactionID, Options []_gen_vdlutil.Any, opts ..._gen_ipc.CallOpt) (err error)
	// Commit commits the changes in the transaction to the store.  The
	// operation is atomic, so all mutations are performed, or none.  Returns an
	// error if the transaction aborted.
	Commit(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (err error)
	// Abort discards a transaction.  This is an optimization; transactions
	// eventually time out and get discarded.  However, live transactions
	// consume resources, so if you know that you won't be using a transaction
	// anymore, you should discard it explicitly.
	Abort(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (err error)
	// ReadConflicts returns the stream of conflicts to store values.  A
	// conflict occurs when there is a concurrent modification to a value.
	ReadConflicts(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply StoreReadConflictsStream, err error)
}
type Store interface {
	_gen_ipc.UniversalServiceMethods
	Store_ExcludingUniversal
}

// StoreService is the interface the server implements.
type StoreService interface {

	// CreateTransaction creates the transaction and sets the options for it.
	CreateTransaction(context _gen_ipc.ServerContext, TID TransactionID, Options []_gen_vdlutil.Any) (err error)
	// Commit commits the changes in the transaction to the store.  The
	// operation is atomic, so all mutations are performed, or none.  Returns an
	// error if the transaction aborted.
	Commit(context _gen_ipc.ServerContext, TID TransactionID) (err error)
	// Abort discards a transaction.  This is an optimization; transactions
	// eventually time out and get discarded.  However, live transactions
	// consume resources, so if you know that you won't be using a transaction
	// anymore, you should discard it explicitly.
	Abort(context _gen_ipc.ServerContext, TID TransactionID) (err error)
	// ReadConflicts returns the stream of conflicts to store values.  A
	// conflict occurs when there is a concurrent modification to a value.
	ReadConflicts(context _gen_ipc.ServerContext, stream StoreServiceReadConflictsStream) (err error)
}

// StoreReadConflictsStream is the interface for streaming responses of the method
// ReadConflicts in the service interface Store.
type StoreReadConflictsStream interface {

	// Advance stages an element so the client can retrieve it
	// with Value.  Advance returns true iff there is an
	// element to retrieve.  The client must call Advance before
	// calling Value.  The client must call Cancel if it does
	// not iterate through all elements (i.e. until Advance
	// returns false).  Advance may block if an element is not
	// immediately available.
	Advance() bool

	// Value returns the element that was staged by Advance.
	// Value may panic if Advance returned false or was not
	// called at all.  Value does not block.
	Value() Conflict

	// Err returns a non-nil error iff the stream encountered
	// any errors.  Err does not block.
	Err() error

	// Finish blocks until the server is done and returns the positional
	// return values for call.
	//
	// If Cancel has been called, Finish will return immediately; the output of
	// Finish could either be an error signalling cancelation, or the correct
	// positional return values from the server depending on the timing of the
	// call.
	//
	// Calling Finish is mandatory for releasing stream resources, unless Cancel
	// has been called or any of the other methods return a non-EOF error.
	// Finish should be called at most once.
	Finish() (err error)

	// Cancel cancels the RPC, notifying the server to stop processing.  It
	// is safe to call Cancel concurrently with any of the other stream methods.
	// Calling Cancel after Finish has returned is a no-op.
	Cancel()
}

// Implementation of the StoreReadConflictsStream interface that is not exported.
type implStoreReadConflictsStream struct {
	clientCall _gen_ipc.Call
	val        Conflict
	err        error
}

func (c *implStoreReadConflictsStream) Advance() bool {
	c.val = Conflict{}
	c.err = c.clientCall.Recv(&c.val)
	return c.err == nil
}

func (c *implStoreReadConflictsStream) Value() Conflict {
	return c.val
}

func (c *implStoreReadConflictsStream) Err() error {
	if c.err == _gen_io.EOF {
		return nil
	}
	return c.err
}

func (c *implStoreReadConflictsStream) Finish() (err error) {
	if ierr := c.clientCall.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c *implStoreReadConflictsStream) Cancel() {
	c.clientCall.Cancel()
}

// StoreServiceReadConflictsStream is the interface for streaming responses of the method
// ReadConflicts in the service interface Store.
type StoreServiceReadConflictsStream interface {
	// Send places the item onto the output stream, blocking if there is no buffer
	// space available.  If the client has canceled, an error is returned.
	Send(item Conflict) error
}

// Implementation of the StoreServiceReadConflictsStream interface that is not exported.
type implStoreServiceReadConflictsStream struct {
	serverCall _gen_ipc.ServerCall
}

func (s *implStoreServiceReadConflictsStream) Send(item Conflict) error {
	return s.serverCall.Send(item)
}

// BindStore returns the client stub implementing the Store
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindStore(name string, opts ..._gen_ipc.BindOpt) (Store, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		client = _gen_rt.R().Client()
	case 1:
		switch o := opts[0].(type) {
		case _gen_ipc.Client:
			client = o
		default:
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubStore{client: client, name: name}

	return stub, nil
}

// NewServerStore creates a new server stub.
//
// It takes a regular server implementing the StoreService
// interface, and returns a new server stub.
func NewServerStore(server StoreService) interface{} {
	return &ServerStubStore{
		service: server,
	}
}

// clientStubStore implements Store.
type clientStubStore struct {
	client _gen_ipc.Client
	name   string
}

func (__gen_c *clientStubStore) CreateTransaction(ctx _gen_context.T, TID TransactionID, Options []_gen_vdlutil.Any, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "CreateTransaction", []interface{}{TID, Options}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubStore) Commit(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "Commit", []interface{}{TID}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubStore) Abort(ctx _gen_context.T, TID TransactionID, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "Abort", []interface{}{TID}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubStore) ReadConflicts(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply StoreReadConflictsStream, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "ReadConflicts", nil, opts...); err != nil {
		return
	}
	reply = &implStoreReadConflictsStream{clientCall: call}
	return
}

func (__gen_c *clientStubStore) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubStore) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubStore) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client.StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubStore wraps a server that implements
// StoreService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubStore struct {
	service StoreService
}

func (__gen_s *ServerStubStore) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	switch method {
	case "CreateTransaction":
		return []interface{}{}, nil
	case "Commit":
		return []interface{}{}, nil
	case "Abort":
		return []interface{}{}, nil
	case "ReadConflicts":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubStore) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["Abort"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 68},
		},
	}
	result.Methods["Commit"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 68},
		},
	}
	result.Methods["CreateTransaction"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "TID", Type: 65},
			{Name: "Options", Type: 67},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 68},
		},
	}
	result.Methods["ReadConflicts"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 68},
		},

		OutStream: 73,
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x35, Name: "veyron2/services/store.TransactionID", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "anydata", Tags: []string(nil)}, _gen_wiretype.SliceType{Elem: 0x42, Name: "", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x32, Name: "byte", Tags: []string(nil)}, _gen_wiretype.ArrayType{Elem: 0x45, Len: 0x10, Name: "veyron2/storage.ID", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x46, Name: "ID"},
				_gen_wiretype.FieldType{Type: 0x25, Name: "MTimeNS"},
				_gen_wiretype.FieldType{Type: 0x43, Name: "Attrs"},
			},
			"veyron2/services/store.Stat", []string(nil)},
		_gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x47, Name: "Stat"},
				_gen_wiretype.FieldType{Type: 0x42, Name: "Value"},
			},
			"veyron2/services/store.Entry", []string(nil)},
		_gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x3, Name: "Ty"},
				_gen_wiretype.FieldType{Type: 0x46, Name: "ID"},
				_gen_wiretype.FieldType{Type: 0x48, Name: "Local"},
				_gen_wiretype.FieldType{Type: 0x48, Name: "Remote"},
				_gen_wiretype.FieldType{Type: 0x48, Name: "Root"},
			},
			"veyron2/services/store.Conflict", []string(nil)},
	}

	return result, nil
}

func (__gen_s *ServerStubStore) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubStore) CreateTransaction(call _gen_ipc.ServerCall, TID TransactionID, Options []_gen_vdlutil.Any) (err error) {
	err = __gen_s.service.CreateTransaction(call, TID, Options)
	return
}

func (__gen_s *ServerStubStore) Commit(call _gen_ipc.ServerCall, TID TransactionID) (err error) {
	err = __gen_s.service.Commit(call, TID)
	return
}

func (__gen_s *ServerStubStore) Abort(call _gen_ipc.ServerCall, TID TransactionID) (err error) {
	err = __gen_s.service.Abort(call, TID)
	return
}

func (__gen_s *ServerStubStore) ReadConflicts(call _gen_ipc.ServerCall) (err error) {
	stream := &implStoreServiceReadConflictsStream{serverCall: call}
	err = __gen_s.service.ReadConflicts(call, stream)
	return
}
