// This file was auto-generated by the veyron vdl tool.
// Source: service.vdl

package store

import (
	"veyron2/query"

	"veyron2/security"

	"veyron2/services/mounttable"

	"veyron2/services/watch"

	"veyron2/storage"

	// The non-user imports are prefixed with "_gen_" to prevent collisions.
	_gen_io "io"
	_gen_veyron2 "veyron2"
	_gen_context "veyron2/context"
	_gen_ipc "veyron2/ipc"
	_gen_naming "veyron2/naming"
	_gen_vdlutil "veyron2/vdl/vdlutil"
	_gen_wiretype "veyron2/wiretype"
)

// SyncGroupConfig contains config info for a SyncGroup.
type SyncGroupConfig struct {
	// Human readable description.
	Description string
	// Options. Can communicate preferences like
	// TTL on the SyncGroup information cached from
	// the SyncGroup server.
	Options map[string]_gen_vdlutil.Any
	// ACL for the SyncGroup.
	ACL security.ACL
}

// NestedResult allows nested query results to be sent out-of-line.
// See QueryResult for a full explanation.
type NestedResult int64

// QueryResult is a single level result.  If the query contained nested
// queries, they will be sent as subsequent QueryResults.  If the
// QueryResult is for a known type, the value is stored in Value.
// If the result is for a dynamic type using selection, Fields will
// be populated appropriately and Value will be nil.
//
// Examples
// 1) Return Team objects: "/teamsapp/teams".Query("*:Team")
//    QueryResult{
//      NestedResult: 0,
//      Name: "hornets",
//      Fields: nil,
//      Value: Team{Location: "CA", Mascot:"Buzz"},
//    },
//    QueryResult{
//      NestedResult: 0,
//      Name: "sharks",
//      Fields: nil,
//      Value: Team{Location: "NY", Mascot:"Jaws"},
//    }
//
// 2) Return just the mascot names: "/teamsapp/teams".Query("*:Team{Mascot}")
//    QueryResult{
//      NestedResult: 0,
//      Name: "hornets",
//      Fields: {"Mascot": "Buzz"},
//      Value: nil,
//    },
//    QueryResult{
//      NestedResult: 0,
//      Name: "sharks",
//      Fields: {"Mascot": "Jaws"},
//      Value: nil
//    }
//
// 3) Return the players for each team: "/teamsapp/teams".Query("*:Team{., players/*:Player")
//    QueryResult{
//      NestedResult: 0,
//      Name: "hornets",
//      Fields: {
//        ".": Team{Location: "CA", Mascot: "Buzz"},
//        // Any subsequent QueryResult with a NestedResult of 1 should be
//        // materialized in this field.
//        "players": NestedResult(1),
//      },
//      Value:nil
//    },
//    QueryResult{
//      NestedResult: 1,
//      Name: "John",
//      Fields: nil,
//      Value: Player{Age: 23, Hometown: "New York"},
//    },
//    QueryResult{
//      NestedResult: 1,
//      Name: "Julie",
//      Fields: nil,
//      Value: Player{Age: 24, Hometown: "Charlotte"},
//    },
//    QueryResult{
//      NestedResult: 0,
//      Name: "sharks",
//      Fields:
//        ".": Team{Location: "NY", Mascot: "Jaws"},
//        "players": NestedResult(2),
//      },
//      Value:nil
//    },
//    QueryResult{
//      NestedResult: 2,
//      Name: "Jamie",
//      Fields: nil,
//      Value: Player{Age: 20, Hometown: "Seattle"},
//    },
//    QueryResult{
//      NestedResult: 2,
//      Name: "Jacob",
//      Fields: nil,
//      Value: Player{Age: 25, Hometown: "Miami"},
//    }
//
// Nested results may in turn contain their own nested results.  A
// NestedResult value is always greater than the parent's NestedResult value.
// In a stream of results, a decrease in the NestedResult values means
// that the group is finished.  Here is an example result stream containing
// only the NestedResult values.  The parentheses show the grouping.
//  (0 (1 (2, 2), 1 (3), 1 (4, 4, 4)), (0 (1, 1 (5, 5)))
type QueryResult struct {
	// NestedResult, if non-zero, specifies which previous result contains
	// this result.
	NestedResult NestedResult
	// Name is the Object name of this value.  It is relative to the query
	// root or, if NestedResult is non-zero, to the parent result.
	Name string
	// Fields will be non-nil if this query result is of a dynamic type
	// specified by the selection operator. The keys will be the names
	// used in the selection.  If a field represents a subquery, the
	// value will be a NestedResult and subsequent QueryResults will
	// have the same valued NestedResult.  See the example above.
	Fields map[string]_gen_vdlutil.Any
	// Value will be non-nil if this query result is of a known type.
	Value _gen_vdlutil.Any
}

// TODO(bprosnitz) Remove this line once signatures are updated to use typevals.
// It corrects a bug where _gen_wiretype is unused in VDL pacakges where only bootstrap types are used on interfaces.
const _ = _gen_wiretype.TypeIDInvalid

// Statable provides the Stat method.
// Statable is the interface the client binds and uses.
// Statable_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type Statable_ExcludingUniversal interface {
	// Stat returns information about the receiver.
	Stat(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply storage.Stat, err error)
	// Exists returns true iff the receiver is present in the Store.
	Exists(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply bool, err error)
}
type Statable interface {
	_gen_ipc.UniversalServiceMethods
	Statable_ExcludingUniversal
}

// StatableService is the interface the server implements.
type StatableService interface {

	// Stat returns information about the receiver.
	Stat(context _gen_ipc.ServerContext) (reply storage.Stat, err error)
	// Exists returns true iff the receiver is present in the Store.
	Exists(context _gen_ipc.ServerContext) (reply bool, err error)
}

// BindStatable returns the client stub implementing the Statable
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindStatable(name string, opts ..._gen_ipc.BindOpt) (Statable, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubStatable{defaultClient: client, name: name}

	return stub, nil
}

// NewServerStatable creates a new server stub.
//
// It takes a regular server implementing the StatableService
// interface, and returns a new server stub.
func NewServerStatable(server StatableService) interface{} {
	return &ServerStubStatable{
		service: server,
	}
}

// clientStubStatable implements Statable.
type clientStubStatable struct {
	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubStatable) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubStatable) Stat(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply storage.Stat, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Stat", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubStatable) Exists(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply bool, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Exists", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubStatable) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubStatable) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubStatable) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubStatable wraps a server that implements
// StatableService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubStatable struct {
	service StatableService
}

func (__gen_s *ServerStubStatable) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	switch method {
	case "Stat":
		return []interface{}{}, nil
	case "Exists":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubStatable) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["Exists"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 2},
			{Name: "", Type: 71},
		},
	}
	result.Methods["Stat"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 70},
			{Name: "", Type: 71},
		},
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x23, Name: "veyron2/storage.Kind", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x32, Name: "byte", Tags: []string(nil)}, _gen_wiretype.ArrayType{Elem: 0x42, Len: 0x10, Name: "veyron2/storage.ID", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "anydata", Tags: []string(nil)}, _gen_wiretype.SliceType{Elem: 0x44, Name: "", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x41, Name: "Kind"},
				_gen_wiretype.FieldType{Type: 0x43, Name: "ID"},
				_gen_wiretype.FieldType{Type: 0x25, Name: "MTimeNS"},
				_gen_wiretype.FieldType{Type: 0x45, Name: "Attrs"},
			},
			"veyron2/storage.Stat", []string(nil)},
		_gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}}

	return result, nil
}

func (__gen_s *ServerStubStatable) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubStatable) Stat(call _gen_ipc.ServerCall) (reply storage.Stat, err error) {
	reply, err = __gen_s.service.Stat(call)
	return
}

func (__gen_s *ServerStubStatable) Exists(call _gen_ipc.ServerCall) (reply bool, err error) {
	reply, err = __gen_s.service.Exists(call)
	return
}

// Transactable provides the NewTransaction method.
// Transactable is the interface the client binds and uses.
// Transactable_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type Transactable_ExcludingUniversal interface {
	// NewTransaction creates a transaction with the given options.  It returns
	// the name of the transaction relative to the receiver's name.  The client
	// must rebind to this new name to work with the receiver and its descendants
	// as part of the transaction.
	NewTransaction(ctx _gen_context.T, Options []_gen_vdlutil.Any, opts ..._gen_ipc.CallOpt) (reply string, err error)
}
type Transactable interface {
	_gen_ipc.UniversalServiceMethods
	Transactable_ExcludingUniversal
}

// TransactableService is the interface the server implements.
type TransactableService interface {

	// NewTransaction creates a transaction with the given options.  It returns
	// the name of the transaction relative to the receiver's name.  The client
	// must rebind to this new name to work with the receiver and its descendants
	// as part of the transaction.
	NewTransaction(context _gen_ipc.ServerContext, Options []_gen_vdlutil.Any) (reply string, err error)
}

// BindTransactable returns the client stub implementing the Transactable
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindTransactable(name string, opts ..._gen_ipc.BindOpt) (Transactable, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubTransactable{defaultClient: client, name: name}

	return stub, nil
}

// NewServerTransactable creates a new server stub.
//
// It takes a regular server implementing the TransactableService
// interface, and returns a new server stub.
func NewServerTransactable(server TransactableService) interface{} {
	return &ServerStubTransactable{
		service: server,
	}
}

// clientStubTransactable implements Transactable.
type clientStubTransactable struct {
	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubTransactable) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubTransactable) NewTransaction(ctx _gen_context.T, Options []_gen_vdlutil.Any, opts ..._gen_ipc.CallOpt) (reply string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "NewTransaction", []interface{}{Options}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubTransactable) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubTransactable) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubTransactable) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubTransactable wraps a server that implements
// TransactableService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubTransactable struct {
	service TransactableService
}

func (__gen_s *ServerStubTransactable) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	switch method {
	case "NewTransaction":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubTransactable) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["NewTransaction"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "Options", Type: 66},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 3},
			{Name: "", Type: 67},
		},
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "anydata", Tags: []string(nil)}, _gen_wiretype.SliceType{Elem: 0x41, Name: "", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}}

	return result, nil
}

func (__gen_s *ServerStubTransactable) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubTransactable) NewTransaction(call _gen_ipc.ServerCall, Options []_gen_vdlutil.Any) (reply string, err error) {
	reply, err = __gen_s.service.NewTransaction(call, Options)
	return
}

// DirOrObject is the interface the client binds and uses.
// DirOrObject_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type DirOrObject_ExcludingUniversal interface {
	// Statable provides the Stat method.
	Statable_ExcludingUniversal
	// Transactable provides the NewTransaction method.
	Transactable_ExcludingUniversal
	mounttable.Globbable_ExcludingUniversal
	// GlobWatcher allows a client to receive updates for changes to objects
	// that match a pattern.  See the package comments for details.
	watch.GlobWatcher_ExcludingUniversal
	// QueryWatcher allows a client to receive updates for changes to objects
	// that match a query.  See the package comments for details.
	watch.QueryWatcher_ExcludingUniversal
	// Remove removes this Dir (and all its children, recursively) or Object.
	Remove(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (err error)
	// Query returns the sequence of elements that satisfy the query.
	Query(ctx _gen_context.T, Q query.Query, opts ..._gen_ipc.CallOpt) (reply DirOrObjectQueryCall, err error)
}
type DirOrObject interface {
	_gen_ipc.UniversalServiceMethods
	DirOrObject_ExcludingUniversal
}

// DirOrObjectService is the interface the server implements.
type DirOrObjectService interface {

	// Statable provides the Stat method.
	StatableService
	// Transactable provides the NewTransaction method.
	TransactableService
	mounttable.GlobbableService
	// GlobWatcher allows a client to receive updates for changes to objects
	// that match a pattern.  See the package comments for details.
	watch.GlobWatcherService
	// QueryWatcher allows a client to receive updates for changes to objects
	// that match a query.  See the package comments for details.
	watch.QueryWatcherService
	// Remove removes this Dir (and all its children, recursively) or Object.
	Remove(context _gen_ipc.ServerContext) (err error)
	// Query returns the sequence of elements that satisfy the query.
	Query(context _gen_ipc.ServerContext, Q query.Query, stream DirOrObjectServiceQueryStream) (err error)
}

// DirOrObjectQueryCall is the interface for call object of the method
// Query in the service interface DirOrObject.
type DirOrObjectQueryCall interface {
	// RecvStream returns the recv portion of the stream
	RecvStream() interface {
		// Advance stages an element so the client can retrieve it
		// with Value.  Advance returns true iff there is an
		// element to retrieve.  The client must call Advance before
		// calling Value. Advance may block if an element is not
		// immediately available.
		Advance() bool

		// Value returns the element that was staged by Advance.
		// Value may panic if Advance returned false or was not
		// called at all.  Value does not block.
		Value() QueryResult

		// Err returns a non-nil error iff the stream encountered
		// any errors.  Err does not block.
		Err() error
	}

	// Finish blocks until the server is done and returns the positional
	// return values for call.
	//
	// If Cancel has been called, Finish will return immediately; the output of
	// Finish could either be an error signalling cancelation, or the correct
	// positional return values from the server depending on the timing of the
	// call.
	//
	// Calling Finish is mandatory for releasing stream resources, unless Cancel
	// has been called or any of the other methods return an error.
	// Finish should be called at most once.
	Finish() (err error)

	// Cancel cancels the RPC, notifying the server to stop processing.  It
	// is safe to call Cancel concurrently with any of the other stream methods.
	// Calling Cancel after Finish has returned is a no-op.
	Cancel()
}

type implDirOrObjectQueryStreamIterator struct {
	clientCall _gen_ipc.Call
	val        QueryResult
	err        error
}

func (c *implDirOrObjectQueryStreamIterator) Advance() bool {
	c.val = QueryResult{}
	c.err = c.clientCall.Recv(&c.val)
	return c.err == nil
}

func (c *implDirOrObjectQueryStreamIterator) Value() QueryResult {
	return c.val
}

func (c *implDirOrObjectQueryStreamIterator) Err() error {
	if c.err == _gen_io.EOF {
		return nil
	}
	return c.err
}

// Implementation of the DirOrObjectQueryCall interface that is not exported.
type implDirOrObjectQueryCall struct {
	clientCall _gen_ipc.Call
	readStream implDirOrObjectQueryStreamIterator
}

func (c *implDirOrObjectQueryCall) RecvStream() interface {
	Advance() bool
	Value() QueryResult
	Err() error
} {
	return &c.readStream
}

func (c *implDirOrObjectQueryCall) Finish() (err error) {
	if ierr := c.clientCall.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (c *implDirOrObjectQueryCall) Cancel() {
	c.clientCall.Cancel()
}

type implDirOrObjectServiceQueryStreamSender struct {
	serverCall _gen_ipc.ServerCall
}

func (s *implDirOrObjectServiceQueryStreamSender) Send(item QueryResult) error {
	return s.serverCall.Send(item)
}

// DirOrObjectServiceQueryStream is the interface for streaming responses of the method
// Query in the service interface DirOrObject.
type DirOrObjectServiceQueryStream interface {
	// SendStream returns the send portion of the stream.
	SendStream() interface {
		// Send places the item onto the output stream, blocking if there is no buffer
		// space available.  If the client has canceled, an error is returned.
		Send(item QueryResult) error
	}
}

// Implementation of the DirOrObjectServiceQueryStream interface that is not exported.
type implDirOrObjectServiceQueryStream struct {
	writer implDirOrObjectServiceQueryStreamSender
}

func (s *implDirOrObjectServiceQueryStream) SendStream() interface {
	// Send places the item onto the output stream, blocking if there is no buffer
	// space available.  If the client has canceled, an error is returned.
	Send(item QueryResult) error
} {
	return &s.writer
}

// BindDirOrObject returns the client stub implementing the DirOrObject
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindDirOrObject(name string, opts ..._gen_ipc.BindOpt) (DirOrObject, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubDirOrObject{defaultClient: client, name: name}
	stub.Statable_ExcludingUniversal, _ = BindStatable(name, client)
	stub.Transactable_ExcludingUniversal, _ = BindTransactable(name, client)
	stub.Globbable_ExcludingUniversal, _ = mounttable.BindGlobbable(name, client)
	stub.GlobWatcher_ExcludingUniversal, _ = watch.BindGlobWatcher(name, client)
	stub.QueryWatcher_ExcludingUniversal, _ = watch.BindQueryWatcher(name, client)

	return stub, nil
}

// NewServerDirOrObject creates a new server stub.
//
// It takes a regular server implementing the DirOrObjectService
// interface, and returns a new server stub.
func NewServerDirOrObject(server DirOrObjectService) interface{} {
	return &ServerStubDirOrObject{
		ServerStubStatable:     *NewServerStatable(server).(*ServerStubStatable),
		ServerStubTransactable: *NewServerTransactable(server).(*ServerStubTransactable),
		ServerStubGlobbable:    *mounttable.NewServerGlobbable(server).(*mounttable.ServerStubGlobbable),
		ServerStubGlobWatcher:  *watch.NewServerGlobWatcher(server).(*watch.ServerStubGlobWatcher),
		ServerStubQueryWatcher: *watch.NewServerQueryWatcher(server).(*watch.ServerStubQueryWatcher),
		service:                server,
	}
}

// clientStubDirOrObject implements DirOrObject.
type clientStubDirOrObject struct {
	Statable_ExcludingUniversal
	Transactable_ExcludingUniversal
	mounttable.Globbable_ExcludingUniversal
	watch.GlobWatcher_ExcludingUniversal
	watch.QueryWatcher_ExcludingUniversal

	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubDirOrObject) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubDirOrObject) Remove(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Remove", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubDirOrObject) Query(ctx _gen_context.T, Q query.Query, opts ..._gen_ipc.CallOpt) (reply DirOrObjectQueryCall, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Query", []interface{}{Q}, opts...); err != nil {
		return
	}
	reply = &implDirOrObjectQueryCall{clientCall: call, readStream: implDirOrObjectQueryStreamIterator{clientCall: call}}
	return
}

func (__gen_c *clientStubDirOrObject) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubDirOrObject) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubDirOrObject) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubDirOrObject wraps a server that implements
// DirOrObjectService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubDirOrObject struct {
	ServerStubStatable
	ServerStubTransactable
	mounttable.ServerStubGlobbable
	watch.ServerStubGlobWatcher
	watch.ServerStubQueryWatcher

	service DirOrObjectService
}

func (__gen_s *ServerStubDirOrObject) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	if resp, err := __gen_s.ServerStubStatable.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	if resp, err := __gen_s.ServerStubTransactable.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	if resp, err := __gen_s.ServerStubGlobbable.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	if resp, err := __gen_s.ServerStubGlobWatcher.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	if resp, err := __gen_s.ServerStubQueryWatcher.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	switch method {
	case "Remove":
		return []interface{}{}, nil
	case "Query":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubDirOrObject) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["Query"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "Q", Type: 66},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 65},
		},

		OutStream: 70,
	}
	result.Methods["Remove"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x3, Name: "Stmt"},
			},
			"veyron2/query.Query", []string(nil)},
		_gen_wiretype.NamedPrimitiveType{Type: 0x25, Name: "veyron2/services/store.NestedResult", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "anydata", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x3, Elem: 0x44, Name: "", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x43, Name: "NestedResult"},
				_gen_wiretype.FieldType{Type: 0x3, Name: "Name"},
				_gen_wiretype.FieldType{Type: 0x45, Name: "Fields"},
				_gen_wiretype.FieldType{Type: 0x44, Name: "Value"},
			},
			"veyron2/services/store.QueryResult", []string(nil)},
	}
	var ss _gen_ipc.ServiceSignature
	var firstAdded int
	ss, _ = __gen_s.ServerStubStatable.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}
	ss, _ = __gen_s.ServerStubTransactable.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}
	ss, _ = __gen_s.ServerStubGlobbable.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}
	ss, _ = __gen_s.ServerStubGlobWatcher.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}
	ss, _ = __gen_s.ServerStubQueryWatcher.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}

	return result, nil
}

func (__gen_s *ServerStubDirOrObject) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubDirOrObject) Remove(call _gen_ipc.ServerCall) (err error) {
	err = __gen_s.service.Remove(call)
	return
}

func (__gen_s *ServerStubDirOrObject) Query(call _gen_ipc.ServerCall, Q query.Query) (err error) {
	stream := &implDirOrObjectServiceQueryStream{writer: implDirOrObjectServiceQueryStreamSender{serverCall: call}}
	err = __gen_s.service.Query(call, Q, stream)
	return
}

// SyncGroup is the interface to a SyncGroup in the store.
// SyncGroup is the interface the client binds and uses.
// SyncGroup_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type SyncGroup_ExcludingUniversal interface {
	// CreateSyncGroup creates a new SyncGroup with the given config at the
	// SyncGroup server and the corresponding local state in the Store.
	// Requires: Receiver must exist in the Store; client must have
	// Admin access on the receiver; Store must have Write permission
	// at the SyncGroup server; SyncGroup name must not exist at the
	// SyncGroup server; receiver must not have any ancestor SyncGroups.
	CreateSyncGroup(ctx _gen_context.T, name string, config SyncGroupConfig, opts ..._gen_ipc.CallOpt) (err error)
	// JoinSyncGroup joins a SyncGroup with the specified global Veyron name,
	// and creates local state in the Store.
	// Requires: If receiver does not exist in the Store, client must be allowed to
	// create a new object at the parent; in this case, a new object is created
	// with the receiver name, and a nil ACL;
	// In case of peer SyncGroups, if the root object of the SyncGroup already
	// exists in the Store, receiver must be that root
	// object. Store must have Read and Write permission on the SyncGroup at
	// the SyncGroup server.
	JoinSyncGroup(ctx _gen_context.T, name string, opts ..._gen_ipc.CallOpt) (err error)
	// LeaveSyncGroup leaves the SyncGroup. Upon leaving, all objects in the sub-tree will
	// be given new object IDs if there are no remaining peer SyncGroups.
	// Data will continue to be accessible under the names
	// used before leaving the SyncGroup.
	// Requires: client must have Admin access at the receiver.
	LeaveSyncGroup(ctx _gen_context.T, name string, opts ..._gen_ipc.CallOpt) (err error)
	// DestroySyncGroup destroys the SyncGroup. Destroy causes the local Store to leave the
	// SyncGroup, and destroys the SyncGroup at the SyncGroup server.
	// Requires: Store must have Admin permission on the SyncGroup;
	// client must have Admin access at the receiver.
	DestroySyncGroup(ctx _gen_context.T, name string, opts ..._gen_ipc.CallOpt) (err error)
	// EjectFromSyncGroup ejects a member from the SyncGroup.
	// Requires: Store must have Admin permission on the SyncGroup;
	// client must have Admin access at the receiver.
	EjectFromSyncGroup(ctx _gen_context.T, name string, member string, opts ..._gen_ipc.CallOpt) (err error)
	// GetSyncGroupConfig gets the config info of the SyncGroup. eTag allows for atomic
	// read-modify-write of the config by providing optimistic concurrency control.
	// Requires: Store must have Read permission on the SyncGroup;
	// client must have Admin access at the receiver.
	GetSyncGroupConfig(ctx _gen_context.T, name string, opts ..._gen_ipc.CallOpt) (config SyncGroupConfig, eTag string, err error)
	// SetSyncGroupConfig sets the config info of the SyncGroup. eTag value may be either empty,
	// or the value from a recent Get. If not empty, Set will only succeed if eTag at
	// the server matches that specified in Set.
	// Requires: Store must have Admin permission on the SyncGroup;
	// client must have Admin access at the receiver.
	SetSyncGroupConfig(ctx _gen_context.T, name string, config SyncGroupConfig, eTag string, opts ..._gen_ipc.CallOpt) (err error)
	// GetMembersOfSyncGroup gets the Veyron names of the Stores that joined
	// this SyncGroup.
	// Requires: Store must have Read permission on the SyncGroup;
	// client must have Admin access at the receiver.
	GetMembersOfSyncGroup(ctx _gen_context.T, name string, opts ..._gen_ipc.CallOpt) (reply []string, err error)
}
type SyncGroup interface {
	_gen_ipc.UniversalServiceMethods
	SyncGroup_ExcludingUniversal
}

// SyncGroupService is the interface the server implements.
type SyncGroupService interface {

	// CreateSyncGroup creates a new SyncGroup with the given config at the
	// SyncGroup server and the corresponding local state in the Store.
	// Requires: Receiver must exist in the Store; client must have
	// Admin access on the receiver; Store must have Write permission
	// at the SyncGroup server; SyncGroup name must not exist at the
	// SyncGroup server; receiver must not have any ancestor SyncGroups.
	CreateSyncGroup(context _gen_ipc.ServerContext, name string, config SyncGroupConfig) (err error)
	// JoinSyncGroup joins a SyncGroup with the specified global Veyron name,
	// and creates local state in the Store.
	// Requires: If receiver does not exist in the Store, client must be allowed to
	// create a new object at the parent; in this case, a new object is created
	// with the receiver name, and a nil ACL;
	// In case of peer SyncGroups, if the root object of the SyncGroup already
	// exists in the Store, receiver must be that root
	// object. Store must have Read and Write permission on the SyncGroup at
	// the SyncGroup server.
	JoinSyncGroup(context _gen_ipc.ServerContext, name string) (err error)
	// LeaveSyncGroup leaves the SyncGroup. Upon leaving, all objects in the sub-tree will
	// be given new object IDs if there are no remaining peer SyncGroups.
	// Data will continue to be accessible under the names
	// used before leaving the SyncGroup.
	// Requires: client must have Admin access at the receiver.
	LeaveSyncGroup(context _gen_ipc.ServerContext, name string) (err error)
	// DestroySyncGroup destroys the SyncGroup. Destroy causes the local Store to leave the
	// SyncGroup, and destroys the SyncGroup at the SyncGroup server.
	// Requires: Store must have Admin permission on the SyncGroup;
	// client must have Admin access at the receiver.
	DestroySyncGroup(context _gen_ipc.ServerContext, name string) (err error)
	// EjectFromSyncGroup ejects a member from the SyncGroup.
	// Requires: Store must have Admin permission on the SyncGroup;
	// client must have Admin access at the receiver.
	EjectFromSyncGroup(context _gen_ipc.ServerContext, name string, member string) (err error)
	// GetSyncGroupConfig gets the config info of the SyncGroup. eTag allows for atomic
	// read-modify-write of the config by providing optimistic concurrency control.
	// Requires: Store must have Read permission on the SyncGroup;
	// client must have Admin access at the receiver.
	GetSyncGroupConfig(context _gen_ipc.ServerContext, name string) (config SyncGroupConfig, eTag string, err error)
	// SetSyncGroupConfig sets the config info of the SyncGroup. eTag value may be either empty,
	// or the value from a recent Get. If not empty, Set will only succeed if eTag at
	// the server matches that specified in Set.
	// Requires: Store must have Admin permission on the SyncGroup;
	// client must have Admin access at the receiver.
	SetSyncGroupConfig(context _gen_ipc.ServerContext, name string, config SyncGroupConfig, eTag string) (err error)
	// GetMembersOfSyncGroup gets the Veyron names of the Stores that joined
	// this SyncGroup.
	// Requires: Store must have Read permission on the SyncGroup;
	// client must have Admin access at the receiver.
	GetMembersOfSyncGroup(context _gen_ipc.ServerContext, name string) (reply []string, err error)
}

// BindSyncGroup returns the client stub implementing the SyncGroup
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindSyncGroup(name string, opts ..._gen_ipc.BindOpt) (SyncGroup, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubSyncGroup{defaultClient: client, name: name}

	return stub, nil
}

// NewServerSyncGroup creates a new server stub.
//
// It takes a regular server implementing the SyncGroupService
// interface, and returns a new server stub.
func NewServerSyncGroup(server SyncGroupService) interface{} {
	return &ServerStubSyncGroup{
		service: server,
	}
}

// clientStubSyncGroup implements SyncGroup.
type clientStubSyncGroup struct {
	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubSyncGroup) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubSyncGroup) CreateSyncGroup(ctx _gen_context.T, name string, config SyncGroupConfig, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "CreateSyncGroup", []interface{}{name, config}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubSyncGroup) JoinSyncGroup(ctx _gen_context.T, name string, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "JoinSyncGroup", []interface{}{name}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubSyncGroup) LeaveSyncGroup(ctx _gen_context.T, name string, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "LeaveSyncGroup", []interface{}{name}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubSyncGroup) DestroySyncGroup(ctx _gen_context.T, name string, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "DestroySyncGroup", []interface{}{name}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubSyncGroup) EjectFromSyncGroup(ctx _gen_context.T, name string, member string, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "EjectFromSyncGroup", []interface{}{name, member}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubSyncGroup) GetSyncGroupConfig(ctx _gen_context.T, name string, opts ..._gen_ipc.CallOpt) (config SyncGroupConfig, eTag string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetSyncGroupConfig", []interface{}{name}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&config, &eTag, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubSyncGroup) SetSyncGroupConfig(ctx _gen_context.T, name string, config SyncGroupConfig, eTag string, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "SetSyncGroupConfig", []interface{}{name, config, eTag}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubSyncGroup) GetMembersOfSyncGroup(ctx _gen_context.T, name string, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMembersOfSyncGroup", []interface{}{name}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubSyncGroup) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubSyncGroup) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubSyncGroup) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubSyncGroup wraps a server that implements
// SyncGroupService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubSyncGroup struct {
	service SyncGroupService
}

func (__gen_s *ServerStubSyncGroup) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	switch method {
	case "CreateSyncGroup":
		return []interface{}{}, nil
	case "JoinSyncGroup":
		return []interface{}{}, nil
	case "LeaveSyncGroup":
		return []interface{}{}, nil
	case "DestroySyncGroup":
		return []interface{}{}, nil
	case "EjectFromSyncGroup":
		return []interface{}{}, nil
	case "GetSyncGroupConfig":
		return []interface{}{}, nil
	case "SetSyncGroupConfig":
		return []interface{}{}, nil
	case "GetMembersOfSyncGroup":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubSyncGroup) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["CreateSyncGroup"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "name", Type: 3},
			{Name: "config", Type: 72},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 73},
		},
	}
	result.Methods["DestroySyncGroup"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "name", Type: 3},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 73},
		},
	}
	result.Methods["EjectFromSyncGroup"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "name", Type: 3},
			{Name: "member", Type: 3},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 73},
		},
	}
	result.Methods["GetMembersOfSyncGroup"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "name", Type: 3},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 61},
			{Name: "", Type: 73},
		},
	}
	result.Methods["GetSyncGroupConfig"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "name", Type: 3},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "config", Type: 72},
			{Name: "eTag", Type: 3},
			{Name: "err", Type: 73},
		},
	}
	result.Methods["JoinSyncGroup"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "name", Type: 3},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 73},
		},
	}
	result.Methods["LeaveSyncGroup"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "name", Type: 3},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 73},
		},
	}
	result.Methods["SetSyncGroupConfig"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "name", Type: 3},
			{Name: "config", Type: 72},
			{Name: "eTag", Type: 3},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 73},
		},
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "anydata", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x3, Elem: 0x41, Name: "", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x3, Name: "veyron2/security.BlessingPattern", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x34, Name: "veyron2/security.LabelSet", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x43, Elem: 0x44, Name: "", Tags: []string(nil)}, _gen_wiretype.MapType{Key: 0x3, Elem: 0x44, Name: "", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x45, Name: "In"},
				_gen_wiretype.FieldType{Type: 0x46, Name: "NotIn"},
			},
			"veyron2/security.ACL", []string(nil)},
		_gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x3, Name: "Description"},
				_gen_wiretype.FieldType{Type: 0x42, Name: "Options"},
				_gen_wiretype.FieldType{Type: 0x47, Name: "ACL"},
			},
			"veyron2/services/store.SyncGroupConfig", []string(nil)},
		_gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}}

	return result, nil
}

func (__gen_s *ServerStubSyncGroup) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubSyncGroup) CreateSyncGroup(call _gen_ipc.ServerCall, name string, config SyncGroupConfig) (err error) {
	err = __gen_s.service.CreateSyncGroup(call, name, config)
	return
}

func (__gen_s *ServerStubSyncGroup) JoinSyncGroup(call _gen_ipc.ServerCall, name string) (err error) {
	err = __gen_s.service.JoinSyncGroup(call, name)
	return
}

func (__gen_s *ServerStubSyncGroup) LeaveSyncGroup(call _gen_ipc.ServerCall, name string) (err error) {
	err = __gen_s.service.LeaveSyncGroup(call, name)
	return
}

func (__gen_s *ServerStubSyncGroup) DestroySyncGroup(call _gen_ipc.ServerCall, name string) (err error) {
	err = __gen_s.service.DestroySyncGroup(call, name)
	return
}

func (__gen_s *ServerStubSyncGroup) EjectFromSyncGroup(call _gen_ipc.ServerCall, name string, member string) (err error) {
	err = __gen_s.service.EjectFromSyncGroup(call, name, member)
	return
}

func (__gen_s *ServerStubSyncGroup) GetSyncGroupConfig(call _gen_ipc.ServerCall, name string) (config SyncGroupConfig, eTag string, err error) {
	config, eTag, err = __gen_s.service.GetSyncGroupConfig(call, name)
	return
}

func (__gen_s *ServerStubSyncGroup) SetSyncGroupConfig(call _gen_ipc.ServerCall, name string, config SyncGroupConfig, eTag string) (err error) {
	err = __gen_s.service.SetSyncGroupConfig(call, name, config, eTag)
	return
}

func (__gen_s *ServerStubSyncGroup) GetMembersOfSyncGroup(call _gen_ipc.ServerCall, name string) (reply []string, err error) {
	reply, err = __gen_s.service.GetMembersOfSyncGroup(call, name)
	return
}

// DirSpecific is the interface the client binds and uses.
// DirSpecific_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type DirSpecific_ExcludingUniversal interface {
	// SyncGroup is the interface to a SyncGroup in the store.
	SyncGroup_ExcludingUniversal
	// Make creates this directory and any ancestor directories that do not
	// exist (i.e. equivalent to Unix's 'mkdir -p').  Make is idempotent.
	Make(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (err error)
	// GetSyncGroupNames returns the global names of all SyncGroups attached
	// to this directory.
	GetSyncGroupNames(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error)
}
type DirSpecific interface {
	_gen_ipc.UniversalServiceMethods
	DirSpecific_ExcludingUniversal
}

// DirSpecificService is the interface the server implements.
type DirSpecificService interface {

	// SyncGroup is the interface to a SyncGroup in the store.
	SyncGroupService
	// Make creates this directory and any ancestor directories that do not
	// exist (i.e. equivalent to Unix's 'mkdir -p').  Make is idempotent.
	Make(context _gen_ipc.ServerContext) (err error)
	// GetSyncGroupNames returns the global names of all SyncGroups attached
	// to this directory.
	GetSyncGroupNames(context _gen_ipc.ServerContext) (reply []string, err error)
}

// BindDirSpecific returns the client stub implementing the DirSpecific
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindDirSpecific(name string, opts ..._gen_ipc.BindOpt) (DirSpecific, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubDirSpecific{defaultClient: client, name: name}
	stub.SyncGroup_ExcludingUniversal, _ = BindSyncGroup(name, client)

	return stub, nil
}

// NewServerDirSpecific creates a new server stub.
//
// It takes a regular server implementing the DirSpecificService
// interface, and returns a new server stub.
func NewServerDirSpecific(server DirSpecificService) interface{} {
	return &ServerStubDirSpecific{
		ServerStubSyncGroup: *NewServerSyncGroup(server).(*ServerStubSyncGroup),
		service:             server,
	}
}

// clientStubDirSpecific implements DirSpecific.
type clientStubDirSpecific struct {
	SyncGroup_ExcludingUniversal

	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubDirSpecific) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubDirSpecific) Make(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Make", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubDirSpecific) GetSyncGroupNames(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetSyncGroupNames", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubDirSpecific) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubDirSpecific) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubDirSpecific) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubDirSpecific wraps a server that implements
// DirSpecificService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubDirSpecific struct {
	ServerStubSyncGroup

	service DirSpecificService
}

func (__gen_s *ServerStubDirSpecific) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	if resp, err := __gen_s.ServerStubSyncGroup.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	switch method {
	case "Make":
		return []interface{}{}, nil
	case "GetSyncGroupNames":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubDirSpecific) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["GetSyncGroupNames"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 61},
			{Name: "", Type: 65},
		},
	}
	result.Methods["Make"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}}
	var ss _gen_ipc.ServiceSignature
	var firstAdded int
	ss, _ = __gen_s.ServerStubSyncGroup.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}

	return result, nil
}

func (__gen_s *ServerStubDirSpecific) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubDirSpecific) Make(call _gen_ipc.ServerCall) (err error) {
	err = __gen_s.service.Make(call)
	return
}

func (__gen_s *ServerStubDirSpecific) GetSyncGroupNames(call _gen_ipc.ServerCall) (reply []string, err error) {
	reply, err = __gen_s.service.GetSyncGroupNames(call)
	return
}

// Dir is a directory containing Objects and other Dirs.
// Dir is the interface the client binds and uses.
// Dir_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type Dir_ExcludingUniversal interface {
	DirSpecific_ExcludingUniversal
	DirOrObject_ExcludingUniversal
}
type Dir interface {
	_gen_ipc.UniversalServiceMethods
	Dir_ExcludingUniversal
}

// DirService is the interface the server implements.
type DirService interface {
	DirSpecificService
	DirOrObjectService
}

// BindDir returns the client stub implementing the Dir
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindDir(name string, opts ..._gen_ipc.BindOpt) (Dir, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubDir{defaultClient: client, name: name}
	stub.DirSpecific_ExcludingUniversal, _ = BindDirSpecific(name, client)
	stub.DirOrObject_ExcludingUniversal, _ = BindDirOrObject(name, client)

	return stub, nil
}

// NewServerDir creates a new server stub.
//
// It takes a regular server implementing the DirService
// interface, and returns a new server stub.
func NewServerDir(server DirService) interface{} {
	return &ServerStubDir{
		ServerStubDirSpecific: *NewServerDirSpecific(server).(*ServerStubDirSpecific),
		ServerStubDirOrObject: *NewServerDirOrObject(server).(*ServerStubDirOrObject),
		service:               server,
	}
}

// clientStubDir implements Dir.
type clientStubDir struct {
	DirSpecific_ExcludingUniversal
	DirOrObject_ExcludingUniversal

	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubDir) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubDir) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubDir) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubDir) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubDir wraps a server that implements
// DirService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubDir struct {
	ServerStubDirSpecific
	ServerStubDirOrObject

	service DirService
}

func (__gen_s *ServerStubDir) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	if resp, err := __gen_s.ServerStubDirSpecific.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	if resp, err := __gen_s.ServerStubDirOrObject.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	return nil, nil
}

func (__gen_s *ServerStubDir) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}

	result.TypeDefs = []_gen_vdlutil.Any{}
	var ss _gen_ipc.ServiceSignature
	var firstAdded int
	ss, _ = __gen_s.ServerStubDirSpecific.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}
	ss, _ = __gen_s.ServerStubDirOrObject.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}

	return result, nil
}

func (__gen_s *ServerStubDir) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

// ObjectSpecific is the interface the client binds and uses.
// ObjectSpecific_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type ObjectSpecific_ExcludingUniversal interface {
	// Get returns the value for the Object.  The value returned is from the
	// most recent mutation of the entry in the Transaction, or from the
	// Transaction's snapshot if there is no mutation.
	Get(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply storage.Entry, err error)
	// Put modifies the value of the Object.
	Put(ctx _gen_context.T, V _gen_vdlutil.Any, opts ..._gen_ipc.CallOpt) (reply storage.Stat, err error)
}
type ObjectSpecific interface {
	_gen_ipc.UniversalServiceMethods
	ObjectSpecific_ExcludingUniversal
}

// ObjectSpecificService is the interface the server implements.
type ObjectSpecificService interface {

	// Get returns the value for the Object.  The value returned is from the
	// most recent mutation of the entry in the Transaction, or from the
	// Transaction's snapshot if there is no mutation.
	Get(context _gen_ipc.ServerContext) (reply storage.Entry, err error)
	// Put modifies the value of the Object.
	Put(context _gen_ipc.ServerContext, V _gen_vdlutil.Any) (reply storage.Stat, err error)
}

// BindObjectSpecific returns the client stub implementing the ObjectSpecific
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindObjectSpecific(name string, opts ..._gen_ipc.BindOpt) (ObjectSpecific, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubObjectSpecific{defaultClient: client, name: name}

	return stub, nil
}

// NewServerObjectSpecific creates a new server stub.
//
// It takes a regular server implementing the ObjectSpecificService
// interface, and returns a new server stub.
func NewServerObjectSpecific(server ObjectSpecificService) interface{} {
	return &ServerStubObjectSpecific{
		service: server,
	}
}

// clientStubObjectSpecific implements ObjectSpecific.
type clientStubObjectSpecific struct {
	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubObjectSpecific) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubObjectSpecific) Get(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply storage.Entry, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Get", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObjectSpecific) Put(ctx _gen_context.T, V _gen_vdlutil.Any, opts ..._gen_ipc.CallOpt) (reply storage.Stat, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Put", []interface{}{V}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObjectSpecific) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObjectSpecific) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObjectSpecific) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubObjectSpecific wraps a server that implements
// ObjectSpecificService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubObjectSpecific struct {
	service ObjectSpecificService
}

func (__gen_s *ServerStubObjectSpecific) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	switch method {
	case "Get":
		return []interface{}{}, nil
	case "Put":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubObjectSpecific) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["Get"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 71},
			{Name: "", Type: 72},
		},
	}
	result.Methods["Put"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{
			{Name: "V", Type: 68},
		},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 70},
			{Name: "", Type: 72},
		},
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x23, Name: "veyron2/storage.Kind", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x32, Name: "byte", Tags: []string(nil)}, _gen_wiretype.ArrayType{Elem: 0x42, Len: 0x10, Name: "veyron2/storage.ID", Tags: []string(nil)}, _gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "anydata", Tags: []string(nil)}, _gen_wiretype.SliceType{Elem: 0x44, Name: "", Tags: []string(nil)}, _gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x41, Name: "Kind"},
				_gen_wiretype.FieldType{Type: 0x43, Name: "ID"},
				_gen_wiretype.FieldType{Type: 0x25, Name: "MTimeNS"},
				_gen_wiretype.FieldType{Type: 0x45, Name: "Attrs"},
			},
			"veyron2/storage.Stat", []string(nil)},
		_gen_wiretype.StructType{
			[]_gen_wiretype.FieldType{
				_gen_wiretype.FieldType{Type: 0x46, Name: "Stat"},
				_gen_wiretype.FieldType{Type: 0x44, Name: "Value"},
			},
			"veyron2/storage.Entry", []string(nil)},
		_gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}}

	return result, nil
}

func (__gen_s *ServerStubObjectSpecific) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubObjectSpecific) Get(call _gen_ipc.ServerCall) (reply storage.Entry, err error) {
	reply, err = __gen_s.service.Get(call)
	return
}

func (__gen_s *ServerStubObjectSpecific) Put(call _gen_ipc.ServerCall, V _gen_vdlutil.Any) (reply storage.Stat, err error) {
	reply, err = __gen_s.service.Put(call, V)
	return
}

// ObjectService is the interface for a value in the store.
// Object is the interface the client binds and uses.
// Object_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type Object_ExcludingUniversal interface {
	ObjectSpecific_ExcludingUniversal
	DirOrObject_ExcludingUniversal
}
type Object interface {
	_gen_ipc.UniversalServiceMethods
	Object_ExcludingUniversal
}

// ObjectService is the interface the server implements.
type ObjectService interface {
	ObjectSpecificService
	DirOrObjectService
}

// BindObject returns the client stub implementing the Object
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindObject(name string, opts ..._gen_ipc.BindOpt) (Object, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubObject{defaultClient: client, name: name}
	stub.ObjectSpecific_ExcludingUniversal, _ = BindObjectSpecific(name, client)
	stub.DirOrObject_ExcludingUniversal, _ = BindDirOrObject(name, client)

	return stub, nil
}

// NewServerObject creates a new server stub.
//
// It takes a regular server implementing the ObjectService
// interface, and returns a new server stub.
func NewServerObject(server ObjectService) interface{} {
	return &ServerStubObject{
		ServerStubObjectSpecific: *NewServerObjectSpecific(server).(*ServerStubObjectSpecific),
		ServerStubDirOrObject:    *NewServerDirOrObject(server).(*ServerStubDirOrObject),
		service:                  server,
	}
}

// clientStubObject implements Object.
type clientStubObject struct {
	ObjectSpecific_ExcludingUniversal
	DirOrObject_ExcludingUniversal

	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubObject) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubObject) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObject) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubObject) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubObject wraps a server that implements
// ObjectService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubObject struct {
	ServerStubObjectSpecific
	ServerStubDirOrObject

	service ObjectService
}

func (__gen_s *ServerStubObject) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	if resp, err := __gen_s.ServerStubObjectSpecific.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	if resp, err := __gen_s.ServerStubDirOrObject.GetMethodTags(call, method); resp != nil || err != nil {
		return resp, err
	}
	return nil, nil
}

func (__gen_s *ServerStubObject) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}

	result.TypeDefs = []_gen_vdlutil.Any{}
	var ss _gen_ipc.ServiceSignature
	var firstAdded int
	ss, _ = __gen_s.ServerStubObjectSpecific.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}
	ss, _ = __gen_s.ServerStubDirOrObject.Signature(call)
	firstAdded = len(result.TypeDefs)
	for k, v := range ss.Methods {
		for i, _ := range v.InArgs {
			if v.InArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.InArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		for i, _ := range v.OutArgs {
			if v.OutArgs[i].Type >= _gen_wiretype.TypeIDFirst {
				v.OutArgs[i].Type += _gen_wiretype.TypeID(firstAdded)
			}
		}
		if v.InStream >= _gen_wiretype.TypeIDFirst {
			v.InStream += _gen_wiretype.TypeID(firstAdded)
		}
		if v.OutStream >= _gen_wiretype.TypeIDFirst {
			v.OutStream += _gen_wiretype.TypeID(firstAdded)
		}
		result.Methods[k] = v
	}
	//TODO(bprosnitz) combine type definitions from embeded interfaces in a way that doesn't cause duplication.
	for _, d := range ss.TypeDefs {
		switch wt := d.(type) {
		case _gen_wiretype.SliceType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.ArrayType:
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.MapType:
			if wt.Key >= _gen_wiretype.TypeIDFirst {
				wt.Key += _gen_wiretype.TypeID(firstAdded)
			}
			if wt.Elem >= _gen_wiretype.TypeIDFirst {
				wt.Elem += _gen_wiretype.TypeID(firstAdded)
			}
			d = wt
		case _gen_wiretype.StructType:
			for i, fld := range wt.Fields {
				if fld.Type >= _gen_wiretype.TypeIDFirst {
					wt.Fields[i].Type += _gen_wiretype.TypeID(firstAdded)
				}
			}
			d = wt
			// NOTE: other types are missing, but we are upgrading anyways.
		}
		result.TypeDefs = append(result.TypeDefs, d)
	}

	return result, nil
}

func (__gen_s *ServerStubObject) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

// Transaction is the interface the client binds and uses.
// Transaction_ExcludingUniversal is the interface without internal framework-added methods
// to enable embedding without method collisions.  Not to be used directly by clients.
type Transaction_ExcludingUniversal interface {
	// Commit commits the changes in the transaction to the store.  The
	// operation is atomic, so all mutations are performed, or none.  Returns an
	// error if the transaction aborted.
	Commit(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (err error)
	// Abort discards a transaction.  This is an optimization; transactions
	// eventually time out and get discarded.  However, live transactions
	// consume resources, so if you know that you won't be using a transaction
	// anymore, you should discard it explicitly.
	Abort(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (err error)
}
type Transaction interface {
	_gen_ipc.UniversalServiceMethods
	Transaction_ExcludingUniversal
}

// TransactionService is the interface the server implements.
type TransactionService interface {

	// Commit commits the changes in the transaction to the store.  The
	// operation is atomic, so all mutations are performed, or none.  Returns an
	// error if the transaction aborted.
	Commit(context _gen_ipc.ServerContext) (err error)
	// Abort discards a transaction.  This is an optimization; transactions
	// eventually time out and get discarded.  However, live transactions
	// consume resources, so if you know that you won't be using a transaction
	// anymore, you should discard it explicitly.
	Abort(context _gen_ipc.ServerContext) (err error)
}

// BindTransaction returns the client stub implementing the Transaction
// interface.
//
// If no _gen_ipc.Client is specified, the default _gen_ipc.Client in the
// global Runtime is used.
func BindTransaction(name string, opts ..._gen_ipc.BindOpt) (Transaction, error) {
	var client _gen_ipc.Client
	switch len(opts) {
	case 0:
		// Do nothing.
	case 1:
		if clientOpt, ok := opts[0].(_gen_ipc.Client); opts[0] == nil || ok {
			client = clientOpt
		} else {
			return nil, _gen_vdlutil.ErrUnrecognizedOption
		}
	default:
		return nil, _gen_vdlutil.ErrTooManyOptionsToBind
	}
	stub := &clientStubTransaction{defaultClient: client, name: name}

	return stub, nil
}

// NewServerTransaction creates a new server stub.
//
// It takes a regular server implementing the TransactionService
// interface, and returns a new server stub.
func NewServerTransaction(server TransactionService) interface{} {
	return &ServerStubTransaction{
		service: server,
	}
}

// clientStubTransaction implements Transaction.
type clientStubTransaction struct {
	defaultClient _gen_ipc.Client
	name          string
}

func (__gen_c *clientStubTransaction) client(ctx _gen_context.T) _gen_ipc.Client {
	if __gen_c.defaultClient != nil {
		return __gen_c.defaultClient
	}
	return _gen_veyron2.RuntimeFromContext(ctx).Client()
}

func (__gen_c *clientStubTransaction) Commit(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Commit", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubTransaction) Abort(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Abort", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubTransaction) UnresolveStep(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply []string, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "UnresolveStep", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubTransaction) Signature(ctx _gen_context.T, opts ..._gen_ipc.CallOpt) (reply _gen_ipc.ServiceSignature, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "Signature", nil, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

func (__gen_c *clientStubTransaction) GetMethodTags(ctx _gen_context.T, method string, opts ..._gen_ipc.CallOpt) (reply []interface{}, err error) {
	var call _gen_ipc.Call
	if call, err = __gen_c.client(ctx).StartCall(ctx, __gen_c.name, "GetMethodTags", []interface{}{method}, opts...); err != nil {
		return
	}
	if ierr := call.Finish(&reply, &err); ierr != nil {
		err = ierr
	}
	return
}

// ServerStubTransaction wraps a server that implements
// TransactionService and provides an object that satisfies
// the requirements of veyron2/ipc.ReflectInvoker.
type ServerStubTransaction struct {
	service TransactionService
}

func (__gen_s *ServerStubTransaction) GetMethodTags(call _gen_ipc.ServerCall, method string) ([]interface{}, error) {
	// TODO(bprosnitz) GetMethodTags() will be replaces with Signature().
	// Note: This exhibits some weird behavior like returning a nil error if the method isn't found.
	// This will change when it is replaced with Signature().
	switch method {
	case "Commit":
		return []interface{}{}, nil
	case "Abort":
		return []interface{}{}, nil
	default:
		return nil, nil
	}
}

func (__gen_s *ServerStubTransaction) Signature(call _gen_ipc.ServerCall) (_gen_ipc.ServiceSignature, error) {
	result := _gen_ipc.ServiceSignature{Methods: make(map[string]_gen_ipc.MethodSignature)}
	result.Methods["Abort"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}
	result.Methods["Commit"] = _gen_ipc.MethodSignature{
		InArgs: []_gen_ipc.MethodArgument{},
		OutArgs: []_gen_ipc.MethodArgument{
			{Name: "", Type: 65},
		},
	}

	result.TypeDefs = []_gen_vdlutil.Any{
		_gen_wiretype.NamedPrimitiveType{Type: 0x1, Name: "error", Tags: []string(nil)}}

	return result, nil
}

func (__gen_s *ServerStubTransaction) UnresolveStep(call _gen_ipc.ServerCall) (reply []string, err error) {
	if unresolver, ok := __gen_s.service.(_gen_ipc.Unresolver); ok {
		return unresolver.UnresolveStep(call)
	}
	if call.Server() == nil {
		return
	}
	var published []string
	if published, err = call.Server().Published(); err != nil || published == nil {
		return
	}
	reply = make([]string, len(published))
	for i, p := range published {
		reply[i] = _gen_naming.Join(p, call.Name())
	}
	return
}

func (__gen_s *ServerStubTransaction) Commit(call _gen_ipc.ServerCall) (err error) {
	err = __gen_s.service.Commit(call)
	return
}

func (__gen_s *ServerStubTransaction) Abort(call _gen_ipc.ServerCall) (err error) {
	err = __gen_s.service.Abort(call)
	return
}
