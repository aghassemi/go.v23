// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Package: signature

// Package signature defines types representing interface and method signatures.
package signature

import (
	"fmt"
	"reflect"
	"v.io/v23/vdl"
)

var _ = __VDLInit() // Must be first; see __VDLInit comments for details.

//////////////////////////////////////////////////
// Type definitions

// Embed describes the signature of an embedded interface.
type Embed struct {
	Name    string
	PkgPath string
	Doc     string
}

func (Embed) __VDLReflect(struct {
	Name string `vdl:"signature.Embed"`
}) {
}

func (m *Embed) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.PkgPath == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("PkgPath"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("PkgPath")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.PkgPath), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Doc == "")
	if var10 {
		if err := fieldsTarget1.ZeroField("Doc"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Doc")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromString(string(m.Doc), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Embed) MakeVDLTarget() vdl.Target {
	return &EmbedTarget{Value: m}
}

type EmbedTarget struct {
	Value         *Embed
	nameTarget    vdl.StringTarget
	pkgPathTarget vdl.StringTarget
	docTarget     vdl.StringTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *EmbedTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Embed)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *EmbedTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "PkgPath":
		t.pkgPathTarget.Value = &t.Value.PkgPath
		target, err := &t.pkgPathTarget, error(nil)
		return nil, target, err
	case "Doc":
		t.docTarget.Value = &t.Value.Doc
		target, err := &t.docTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct signature.Embed", name)
	}
}
func (t *EmbedTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *EmbedTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "PkgPath":
		t.Value.PkgPath = ""
		return nil
	case "Doc":
		t.Value.Doc = ""
		return nil
	default:
		return fmt.Errorf("field %s not in struct signature.Embed", name)
	}
}
func (t *EmbedTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *Embed) VDLRead(dec vdl.Decoder) error {
	*x = Embed{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if dec.Type().Kind() != vdl.Struct {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Name":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "PkgPath":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.PkgPath, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Doc":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Doc, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// Arg describes the signature of a single argument.
type Arg struct {
	Name string
	Doc  string
	Type *vdl.Type // Type of the argument.
}

func (Arg) __VDLReflect(struct {
	Name string `vdl:"signature.Arg"`
}) {
}

func (m *Arg) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Doc == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("Doc"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Doc")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.Doc), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Type == nil || m.Type == vdl.AnyType)
	if var10 {
		if err := fieldsTarget1.ZeroField("Type"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Type")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			typeObjectVal11 := m.Type
			if typeObjectVal11 == nil {
				typeObjectVal11 = vdl.AnyType
			}
			if err := fieldTarget9.FromTypeObject(typeObjectVal11); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Arg) MakeVDLTarget() vdl.Target {
	return &ArgTarget{Value: m}
}

type ArgTarget struct {
	Value      *Arg
	nameTarget vdl.StringTarget
	docTarget  vdl.StringTarget
	typeTarget vdl.TypeObjectTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ArgTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Arg)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *ArgTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Doc":
		t.docTarget.Value = &t.Value.Doc
		target, err := &t.docTarget, error(nil)
		return nil, target, err
	case "Type":
		t.typeTarget.Value = &t.Value.Type
		target, err := &t.typeTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct signature.Arg", name)
	}
}
func (t *ArgTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ArgTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Doc":
		t.Value.Doc = ""
		return nil
	case "Type":
		t.Value.Type = vdl.AnyType
		return nil
	default:
		return fmt.Errorf("field %s not in struct signature.Arg", name)
	}
}
func (t *ArgTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

func (x *Arg) VDLRead(dec vdl.Decoder) error {
	*x = Arg{
		Type: vdl.AnyType,
	}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if dec.Type().Kind() != vdl.Struct {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Name":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Doc":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Doc, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Type":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Type, err = dec.DecodeTypeObject(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

// Method describes the signature of an interface method.
type Method struct {
	Name      string
	Doc       string
	InArgs    []Arg        // Input arguments
	OutArgs   []Arg        // Output arguments
	InStream  *Arg         // Input stream (optional)
	OutStream *Arg         // Output stream (optional)
	Tags      []*vdl.Value // Method tags
}

func (Method) __VDLReflect(struct {
	Name string `vdl:"signature.Method"`
}) {
}

func (m *Method) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.Doc == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("Doc"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("Doc")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.Doc), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var var10 bool
	if len(m.InArgs) == 0 {
		var10 = true
	}
	if var10 {
		if err := fieldsTarget1.ZeroField("InArgs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("InArgs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget11, err := fieldTarget9.StartList(tt.NonOptional().Field(2).Type, len(m.InArgs))
			if err != nil {
				return err
			}
			for i, elem13 := range m.InArgs {
				elemTarget12, err := listTarget11.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem13.FillVDLTarget(elemTarget12, tt.NonOptional().Field(2).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget11.FinishElem(elemTarget12); err != nil {
					return err
				}
			}
			if err := fieldTarget9.FinishList(listTarget11); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var var16 bool
	if len(m.OutArgs) == 0 {
		var16 = true
	}
	if var16 {
		if err := fieldsTarget1.ZeroField("OutArgs"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget14, fieldTarget15, err := fieldsTarget1.StartField("OutArgs")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget17, err := fieldTarget15.StartList(tt.NonOptional().Field(3).Type, len(m.OutArgs))
			if err != nil {
				return err
			}
			for i, elem19 := range m.OutArgs {
				elemTarget18, err := listTarget17.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem19.FillVDLTarget(elemTarget18, tt.NonOptional().Field(3).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget17.FinishElem(elemTarget18); err != nil {
					return err
				}
			}
			if err := fieldTarget15.FinishList(listTarget17); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget14, fieldTarget15); err != nil {
				return err
			}
		}
	}
	var22 := (m.InStream == (*Arg)(nil))
	if var22 {
		if err := fieldsTarget1.ZeroField("InStream"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget20, fieldTarget21, err := fieldsTarget1.StartField("InStream")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.InStream.FillVDLTarget(fieldTarget21, tt.NonOptional().Field(4).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget20, fieldTarget21); err != nil {
				return err
			}
		}
	}
	var25 := (m.OutStream == (*Arg)(nil))
	if var25 {
		if err := fieldsTarget1.ZeroField("OutStream"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget23, fieldTarget24, err := fieldsTarget1.StartField("OutStream")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			if err := m.OutStream.FillVDLTarget(fieldTarget24, tt.NonOptional().Field(5).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget23, fieldTarget24); err != nil {
				return err
			}
		}
	}
	var var28 bool
	if len(m.Tags) == 0 {
		var28 = true
	}
	if var28 {
		if err := fieldsTarget1.ZeroField("Tags"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget26, fieldTarget27, err := fieldsTarget1.StartField("Tags")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget29, err := fieldTarget27.StartList(tt.NonOptional().Field(6).Type, len(m.Tags))
			if err != nil {
				return err
			}
			for i, elem31 := range m.Tags {
				elemTarget30, err := listTarget29.StartElem(i)
				if err != nil {
					return err
				}

				if err := vdl.FromValue(elemTarget30, elem31); err != nil {
					return err
				}
				if err := listTarget29.FinishElem(elemTarget30); err != nil {
					return err
				}
			}
			if err := fieldTarget27.FinishList(listTarget29); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget26, fieldTarget27); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Method) MakeVDLTarget() vdl.Target {
	return &MethodTarget{Value: m}
}

type MethodTarget struct {
	Value           *Method
	nameTarget      vdl.StringTarget
	docTarget       vdl.StringTarget
	inArgsTarget    __VDLTarget1_list
	outArgsTarget   __VDLTarget1_list
	inStreamTarget  __VDLTarget2_optional
	outStreamTarget __VDLTarget2_optional
	tagsTarget      __VDLTarget3_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *MethodTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Method)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *MethodTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "Doc":
		t.docTarget.Value = &t.Value.Doc
		target, err := &t.docTarget, error(nil)
		return nil, target, err
	case "InArgs":
		t.inArgsTarget.Value = &t.Value.InArgs
		target, err := &t.inArgsTarget, error(nil)
		return nil, target, err
	case "OutArgs":
		t.outArgsTarget.Value = &t.Value.OutArgs
		target, err := &t.outArgsTarget, error(nil)
		return nil, target, err
	case "InStream":
		t.inStreamTarget.Value = &t.Value.InStream
		target, err := &t.inStreamTarget, error(nil)
		return nil, target, err
	case "OutStream":
		t.outStreamTarget.Value = &t.Value.OutStream
		target, err := &t.outStreamTarget, error(nil)
		return nil, target, err
	case "Tags":
		t.tagsTarget.Value = &t.Value.Tags
		target, err := &t.tagsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct signature.Method", name)
	}
}
func (t *MethodTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *MethodTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "Doc":
		t.Value.Doc = ""
		return nil
	case "InArgs":
		t.Value.InArgs = []Arg(nil)
		return nil
	case "OutArgs":
		t.Value.OutArgs = []Arg(nil)
		return nil
	case "InStream":
		t.Value.InStream = (*Arg)(nil)
		return nil
	case "OutStream":
		t.Value.OutStream = (*Arg)(nil)
		return nil
	case "Tags":
		t.Value.Tags = []*vdl.Value(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct signature.Method", name)
	}
}
func (t *MethodTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []Arg
type __VDLTarget1_list struct {
	Value      *[]Arg
	elemTarget ArgTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget1_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Arg)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Arg, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget1_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget1_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget1_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// Optional Arg
type __VDLTarget2_optional struct {
	Value      **Arg
	elemTarget ArgTarget
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *__VDLTarget2_optional) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if *t.Value == nil {
		*t.Value = &Arg{
			Type: vdl.AnyType,
		}
	}
	t.elemTarget.Value = *t.Value
	target, err := &t.elemTarget, error(nil)
	if err != nil {
		return nil, err
	}
	return target.StartFields(tt)
}
func (t *__VDLTarget2_optional) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}
func (t *__VDLTarget2_optional) FromNil(tt *vdl.Type) error {
	*t.Value = (*Arg)(nil)
	return nil
}

// []*vdl.Value
type __VDLTarget3_list struct {
	Value *[]*vdl.Value

	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget3_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]*vdl.Value)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]*vdl.Value, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget3_list) StartElem(index int) (elem vdl.Target, _ error) {
	target, err := vdl.ReflectTarget(reflect.ValueOf(&(*t.Value)[index]))
	return target, err
}
func (t *__VDLTarget3_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget3_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x *Method) VDLRead(dec vdl.Decoder) error {
	*x = Method{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if dec.Type().Kind() != vdl.Struct {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Name":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Doc":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Doc, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "InArgs":
			match++
			if err = __VDLRead1_list(dec, &x.InArgs); err != nil {
				return err
			}
		case "OutArgs":
			match++
			if err = __VDLRead1_list(dec, &x.OutArgs); err != nil {
				return err
			}
		case "InStream":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if !vdl.Compatible(dec.Type(), vdl.TypeOf(x.InStream)) {
					return fmt.Errorf("incompatible optional %T, from %v", x.InStream, dec.Type())
				}
				x.InStream = nil
				if err = dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.InStream = new(Arg)
				dec.IgnoreNextStartValue()
				if err = x.InStream.VDLRead(dec); err != nil {
					return err
				}
			}
		case "OutStream":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if dec.IsNil() {
				if !vdl.Compatible(dec.Type(), vdl.TypeOf(x.OutStream)) {
					return fmt.Errorf("incompatible optional %T, from %v", x.OutStream, dec.Type())
				}
				x.OutStream = nil
				if err = dec.FinishValue(); err != nil {
					return err
				}
			} else {
				x.OutStream = new(Arg)
				dec.IgnoreNextStartValue()
				if err = x.OutStream.VDLRead(dec); err != nil {
					return err
				}
			}
		case "Tags":
			match++
			if err = __VDLRead2_list(dec, &x.Tags); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead1_list(dec vdl.Decoder, x *[]Arg) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if k := dec.Type().Kind(); k != vdl.Array && k != vdl.List {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
	case len > 0:
		*x = make([]Arg, 0, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Arg
		if err = elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLRead2_list(dec vdl.Decoder, x *[]*vdl.Value) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if k := dec.Type().Kind(); k != vdl.Array && k != vdl.List {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
	case len > 0:
		*x = make([]*vdl.Value, 0, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem *vdl.Value
		// TODO(toddw): implement any
		*x = append(*x, elem)
	}
}

// Interface describes the signature of an interface.
type Interface struct {
	Name    string
	PkgPath string
	Doc     string
	Embeds  []Embed  // No special ordering.
	Methods []Method // Ordered by method name.
}

func (Interface) __VDLReflect(struct {
	Name string `vdl:"signature.Interface"`
}) {
}

func (m *Interface) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}
	var4 := (m.Name == "")
	if var4 {
		if err := fieldsTarget1.ZeroField("Name"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Name")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget3.FromString(string(m.Name), tt.NonOptional().Field(0).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
				return err
			}
		}
	}
	var7 := (m.PkgPath == "")
	if var7 {
		if err := fieldsTarget1.ZeroField("PkgPath"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget5, fieldTarget6, err := fieldsTarget1.StartField("PkgPath")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget6.FromString(string(m.PkgPath), tt.NonOptional().Field(1).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget5, fieldTarget6); err != nil {
				return err
			}
		}
	}
	var10 := (m.Doc == "")
	if var10 {
		if err := fieldsTarget1.ZeroField("Doc"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget8, fieldTarget9, err := fieldsTarget1.StartField("Doc")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}
			if err := fieldTarget9.FromString(string(m.Doc), tt.NonOptional().Field(2).Type); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget8, fieldTarget9); err != nil {
				return err
			}
		}
	}
	var var13 bool
	if len(m.Embeds) == 0 {
		var13 = true
	}
	if var13 {
		if err := fieldsTarget1.ZeroField("Embeds"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Embeds")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget14, err := fieldTarget12.StartList(tt.NonOptional().Field(3).Type, len(m.Embeds))
			if err != nil {
				return err
			}
			for i, elem16 := range m.Embeds {
				elemTarget15, err := listTarget14.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem16.FillVDLTarget(elemTarget15, tt.NonOptional().Field(3).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget14.FinishElem(elemTarget15); err != nil {
					return err
				}
			}
			if err := fieldTarget12.FinishList(listTarget14); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
				return err
			}
		}
	}
	var var19 bool
	if len(m.Methods) == 0 {
		var19 = true
	}
	if var19 {
		if err := fieldsTarget1.ZeroField("Methods"); err != nil && err != vdl.ErrFieldNoExist {
			return err
		}
	} else {
		keyTarget17, fieldTarget18, err := fieldsTarget1.StartField("Methods")
		if err != vdl.ErrFieldNoExist {
			if err != nil {
				return err
			}

			listTarget20, err := fieldTarget18.StartList(tt.NonOptional().Field(4).Type, len(m.Methods))
			if err != nil {
				return err
			}
			for i, elem22 := range m.Methods {
				elemTarget21, err := listTarget20.StartElem(i)
				if err != nil {
					return err
				}

				if err := elem22.FillVDLTarget(elemTarget21, tt.NonOptional().Field(4).Type.Elem()); err != nil {
					return err
				}
				if err := listTarget20.FinishElem(elemTarget21); err != nil {
					return err
				}
			}
			if err := fieldTarget18.FinishList(listTarget20); err != nil {
				return err
			}
			if err := fieldsTarget1.FinishField(keyTarget17, fieldTarget18); err != nil {
				return err
			}
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Interface) MakeVDLTarget() vdl.Target {
	return &InterfaceTarget{Value: m}
}

type InterfaceTarget struct {
	Value         *Interface
	nameTarget    vdl.StringTarget
	pkgPathTarget vdl.StringTarget
	docTarget     vdl.StringTarget
	embedsTarget  __VDLTarget4_list
	methodsTarget __VDLTarget5_list
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *InterfaceTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {

	if ttWant := vdl.TypeOf((*Interface)(nil)).Elem(); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	return t, nil
}
func (t *InterfaceTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Name":
		t.nameTarget.Value = &t.Value.Name
		target, err := &t.nameTarget, error(nil)
		return nil, target, err
	case "PkgPath":
		t.pkgPathTarget.Value = &t.Value.PkgPath
		target, err := &t.pkgPathTarget, error(nil)
		return nil, target, err
	case "Doc":
		t.docTarget.Value = &t.Value.Doc
		target, err := &t.docTarget, error(nil)
		return nil, target, err
	case "Embeds":
		t.embedsTarget.Value = &t.Value.Embeds
		target, err := &t.embedsTarget, error(nil)
		return nil, target, err
	case "Methods":
		t.methodsTarget.Value = &t.Value.Methods
		target, err := &t.methodsTarget, error(nil)
		return nil, target, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct signature.Interface", name)
	}
}
func (t *InterfaceTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *InterfaceTarget) ZeroField(name string) error {
	switch name {
	case "Name":
		t.Value.Name = ""
		return nil
	case "PkgPath":
		t.Value.PkgPath = ""
		return nil
	case "Doc":
		t.Value.Doc = ""
		return nil
	case "Embeds":
		t.Value.Embeds = []Embed(nil)
		return nil
	case "Methods":
		t.Value.Methods = []Method(nil)
		return nil
	default:
		return fmt.Errorf("field %s not in struct signature.Interface", name)
	}
}
func (t *InterfaceTarget) FinishFields(_ vdl.FieldsTarget) error {

	return nil
}

// []Embed
type __VDLTarget4_list struct {
	Value      *[]Embed
	elemTarget EmbedTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget4_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Embed)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Embed, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget4_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget4_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget4_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

// []Method
type __VDLTarget5_list struct {
	Value      *[]Method
	elemTarget MethodTarget
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *__VDLTarget5_list) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {

	if ttWant := vdl.TypeOf((*[]Method)(nil)); !vdl.Compatible(tt, ttWant) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, ttWant)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]Method, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *__VDLTarget5_list) StartElem(index int) (elem vdl.Target, _ error) {
	t.elemTarget.Value = &(*t.Value)[index]
	target, err := &t.elemTarget, error(nil)
	return target, err
}
func (t *__VDLTarget5_list) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *__VDLTarget5_list) FinishList(elem vdl.ListTarget) error {

	return nil
}

func (x *Interface) VDLRead(dec vdl.Decoder) error {
	*x = Interface{}
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if dec.Type().Kind() != vdl.Struct {
		return fmt.Errorf("incompatible struct %T, from %v", *x, dec.Type())
	}
	match := 0
	for {
		f, err := dec.NextField()
		if err != nil {
			return err
		}
		switch f {
		case "":
			if match == 0 && dec.Type().NumField() > 0 {
				return fmt.Errorf("no matching fields in struct %T, from %v", *x, dec.Type())
			}
			return dec.FinishValue()
		case "Name":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Name, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "PkgPath":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.PkgPath, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Doc":
			match++
			if err = dec.StartValue(); err != nil {
				return err
			}
			if x.Doc, err = dec.DecodeString(); err != nil {
				return err
			}
			if err = dec.FinishValue(); err != nil {
				return err
			}
		case "Embeds":
			match++
			if err = __VDLRead3_list(dec, &x.Embeds); err != nil {
				return err
			}
		case "Methods":
			match++
			if err = __VDLRead4_list(dec, &x.Methods); err != nil {
				return err
			}
		default:
			if err = dec.SkipValue(); err != nil {
				return err
			}
		}
	}
}

func __VDLRead3_list(dec vdl.Decoder, x *[]Embed) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if k := dec.Type().Kind(); k != vdl.Array && k != vdl.List {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
	case len > 0:
		*x = make([]Embed, 0, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Embed
		if err = elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

func __VDLRead4_list(dec vdl.Decoder, x *[]Method) error {
	var err error
	if err = dec.StartValue(); err != nil {
		return err
	}
	if k := dec.Type().Kind(); k != vdl.Array && k != vdl.List {
		return fmt.Errorf("incompatible list %T, from %v", *x, dec.Type())
	}
	switch len := dec.LenHint(); {
	case len == 0:
		*x = nil
	case len > 0:
		*x = make([]Method, 0, len)
	}
	for {
		switch done, err := dec.NextEntry(); {
		case err != nil:
			return err
		case done:
			return dec.FinishValue()
		}
		var elem Method
		if err = elem.VDLRead(dec); err != nil {
			return err
		}
		*x = append(*x, elem)
	}
}

var __VDLInitCalled bool

// __VDLInit performs vdl initialization.  It is safe to call multiple times.
// If you have an init ordering issue, just insert the following line verbatim
// into your source files in this package, right after the "package foo" clause:
//
//    var _ = __VDLInit()
//
// The purpose of this function is to ensure that vdl initialization occurs in
// the right order, and very early in the init sequence.  In particular, vdl
// registration and package variable initialization needs to occur before
// functions like vdl.TypeOf will work properly.
//
// This function returns a dummy value, so that it can be used to initialize the
// first var in the file, to take advantage of Go's defined init order.
func __VDLInit() struct{} {
	if __VDLInitCalled {
		return struct{}{}
	}
	__VDLInitCalled = true

	// Register types.
	vdl.Register((*Embed)(nil))
	vdl.Register((*Arg)(nil))
	vdl.Register((*Method)(nil))
	vdl.Register((*Interface)(nil))

	return struct{}{}
}
