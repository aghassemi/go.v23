// Copyright 2015 The Vanadium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file was auto-generated by the vanadium vdl tool.
// Source: config.vdl

// Package vdltool defines types used by the vdl tool itself, including the
// format of vdl.config files.
package vdltool

import (
	"fmt"
	"v.io/v23/vdl"
)

// Config specifies the configuration for the vdl tool.  This is typically
// represented in optional "vdl.config" files in each vdl source package.  Each
// vdl.config file implicitly imports this package.  E.g. you may refer to
// vdltool.Config in the "vdl.config" file without explicitly importing vdltool.
type Config struct {
	// GenLanguages restricts the set of code generation languages.  If the set is
	// empty, all supported languages are allowed to be generated.
	GenLanguages map[GenLanguage]struct{}
	// Language-specific configurations.
	Go         GoConfig
	Java       JavaConfig
	Javascript JavascriptConfig
}

func (Config) __VDLReflect(struct {
	Name string `vdl:"vdltool.Config"`
}) {
}

func (m *Config) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_config_vdltool_Config == nil || __VDLTypeconfig0 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("GenLanguages")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		setTarget4, err := fieldTarget3.StartSet(__VDLTypeconfig1, len(m.GenLanguages))
		if err != nil {
			return err
		}
		for key6 := range m.GenLanguages {
			keyTarget5, err := setTarget4.StartKey()
			if err != nil {
				return err
			}

			if err := key6.FillVDLTarget(keyTarget5, __VDLType_config_vdltool_GenLanguage); err != nil {
				return err
			}
			if err := setTarget4.FinishKey(keyTarget5); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishSet(setTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget7, fieldTarget8, err := fieldsTarget1.StartField("Go")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Go.FillVDLTarget(fieldTarget8, __VDLType_config_vdltool_GoConfig); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget7, fieldTarget8); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("Java")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Java.FillVDLTarget(fieldTarget10, __VDLType_config_vdltool_JavaConfig); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	keyTarget11, fieldTarget12, err := fieldsTarget1.StartField("Javascript")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		if err := m.Javascript.FillVDLTarget(fieldTarget12, __VDLType_config_vdltool_JavascriptConfig); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget11, fieldTarget12); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *Config) MakeVDLTarget() vdl.Target {
	return &ConfigTarget{Value: m}
}

type ConfigTarget struct {
	Value *Config
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *ConfigTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_config_vdltool_Config) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_config_vdltool_Config)
	}
	return t, nil
}
func (t *ConfigTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "GenLanguages":
		val, err := &config7365745b76646c746f6f6c2e47656e4c616e677561676520656e756d7b476f3b4a6176613b4a6176617363726970747d5dTarget{Value: &t.Value.GenLanguages}, error(nil)
		return nil, val, err
	case "Go":
		val, err := &GoConfigTarget{Value: &t.Value.Go}, error(nil)
		return nil, val, err
	case "Java":
		val, err := &JavaConfigTarget{Value: &t.Value.Java}, error(nil)
		return nil, val, err
	case "Javascript":
		val, err := &JavascriptConfigTarget{Value: &t.Value.Javascript}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_config_vdltool_Config)
	}
}
func (t *ConfigTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *ConfigTarget) FinishFields(_ vdl.FieldsTarget) error {
	return nil
}

type config7365745b76646c746f6f6c2e47656e4c616e677561676520656e756d7b476f3b4a6176613b4a6176617363726970747d5dTarget struct {
	Value   *map[GenLanguage]struct{}
	currKey GenLanguage
	vdl.TargetBase
	vdl.SetTargetBase
}

func (t *config7365745b76646c746f6f6c2e47656e4c616e677561676520656e756d7b476f3b4a6176613b4a6176617363726970747d5dTarget) StartSet(tt *vdl.Type, len int) (vdl.SetTarget, error) {
	if !vdl.Compatible(tt, __VDLTypeconfig1) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLTypeconfig1)
	}
	*t.Value = make(map[GenLanguage]struct{})
	return t, nil
}
func (t *config7365745b76646c746f6f6c2e47656e4c616e677561676520656e756d7b476f3b4a6176613b4a6176617363726970747d5dTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = GenLanguageGo
	return &GenLanguageTarget{Value: &t.currKey}, error(nil)
}
func (t *config7365745b76646c746f6f6c2e47656e4c616e677561676520656e756d7b476f3b4a6176613b4a6176617363726970747d5dTarget) FinishKey(key vdl.Target) error {
	(*t.Value)[t.currKey] = struct{}{}
	return nil
}
func (t *config7365745b76646c746f6f6c2e47656e4c616e677561676520656e756d7b476f3b4a6176613b4a6176617363726970747d5dTarget) FinishSet(list vdl.SetTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}
	return nil
}

type GenLanguageTarget struct {
	Value *GenLanguage
	vdl.TargetBase
}

func (t *GenLanguageTarget) FromEnumLabel(src string, tt *vdl.Type) error {
	if !vdl.Compatible(tt, __VDLType_config_vdltool_GenLanguage) {
		return fmt.Errorf("type %v incompatible with %v", tt, __VDLType_config_vdltool_GenLanguage)
	}
	switch src {
	case "Go":
		*t.Value = 0
	case "Java":
		*t.Value = 1
	case "Javascript":
		*t.Value = 2
	default:
		return fmt.Errorf("label %s not in enum %v", src, __VDLType_config_vdltool_GenLanguage)
	}
	return nil
}

type GoConfigTarget struct {
	Value *GoConfig
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *GoConfigTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_config_vdltool_GoConfig) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_config_vdltool_GoConfig)
	}
	return t, nil
}
func (t *GoConfigTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "WireToNativeTypes":
		val, err := &config6d61705b737472696e675d76646c746f6f6c2e476f54797065207374727563747b5479706520737472696e673b496d706f727473205b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677d7dTarget{Value: &t.Value.WireToNativeTypes}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_config_vdltool_GoConfig)
	}
}
func (t *GoConfigTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *GoConfigTarget) FinishFields(_ vdl.FieldsTarget) error {
	return nil
}

type config6d61705b737472696e675d76646c746f6f6c2e476f54797065207374727563747b5479706520737472696e673b496d706f727473205b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677d7dTarget struct {
	Value    *map[string]GoType
	currKey  string
	currElem GoType
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *config6d61705b737472696e675d76646c746f6f6c2e476f54797065207374727563747b5479706520737472696e673b496d706f727473205b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677d7dTarget) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLTypeconfig3) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLTypeconfig3)
	}
	*t.Value = make(map[string]GoType)
	return t, nil
}
func (t *config6d61705b737472696e675d76646c746f6f6c2e476f54797065207374727563747b5479706520737472696e673b496d706f727473205b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677d7dTarget) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	return &vdl.StringTarget{Value: &t.currKey}, error(nil)
}
func (t *config6d61705b737472696e675d76646c746f6f6c2e476f54797065207374727563747b5479706520737472696e673b496d706f727473205b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677d7dTarget) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = GoType{}
	return &GoTypeTarget{Value: &t.currElem}, error(nil)
}
func (t *config6d61705b737472696e675d76646c746f6f6c2e476f54797065207374727563747b5479706520737472696e673b496d706f727473205b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677d7dTarget) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *config6d61705b737472696e675d76646c746f6f6c2e476f54797065207374727563747b5479706520737472696e673b496d706f727473205b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677d7dTarget) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}
	return nil
}

type GoTypeTarget struct {
	Value *GoType
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *GoTypeTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_config_vdltool_GoType) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_config_vdltool_GoType)
	}
	return t, nil
}
func (t *GoTypeTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Type":
		val, err := &vdl.StringTarget{Value: &t.Value.Type}, error(nil)
		return nil, val, err
	case "Imports":
		val, err := &config5b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677dTarget{Value: &t.Value.Imports}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_config_vdltool_GoType)
	}
}
func (t *GoTypeTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *GoTypeTarget) FinishFields(_ vdl.FieldsTarget) error {
	return nil
}

type config5b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677dTarget struct {
	Value *[]GoImport
	vdl.TargetBase
	vdl.ListTargetBase
}

func (t *config5b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677dTarget) StartList(tt *vdl.Type, len int) (vdl.ListTarget, error) {
	if !vdl.Compatible(tt, __VDLTypeconfig2) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLTypeconfig2)
	}
	if cap(*t.Value) < len {
		*t.Value = make([]GoImport, len)
	} else {
		*t.Value = (*t.Value)[:len]
	}
	return t, nil
}
func (t *config5b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677dTarget) StartElem(index int) (elem vdl.Target, _ error) {
	return &GoImportTarget{Value: &(*t.Value)[index]}, error(nil)
}
func (t *config5b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677dTarget) FinishElem(elem vdl.Target) error {
	return nil
}
func (t *config5b5d76646c746f6f6c2e476f496d706f7274207374727563747b5061746820737472696e673b4e616d6520737472696e677dTarget) FinishList(elem vdl.ListTarget) error {
	return nil
}

type GoImportTarget struct {
	Value *GoImport
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *GoImportTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_config_vdltool_GoImport) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_config_vdltool_GoImport)
	}
	return t, nil
}
func (t *GoImportTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "Path":
		val, err := &vdl.StringTarget{Value: &t.Value.Path}, error(nil)
		return nil, val, err
	case "Name":
		val, err := &vdl.StringTarget{Value: &t.Value.Name}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_config_vdltool_GoImport)
	}
}
func (t *GoImportTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *GoImportTarget) FinishFields(_ vdl.FieldsTarget) error {
	return nil
}

type JavaConfigTarget struct {
	Value *JavaConfig
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *JavaConfigTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_config_vdltool_JavaConfig) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_config_vdltool_JavaConfig)
	}
	return t, nil
}
func (t *JavaConfigTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	case "WireToNativeTypes":
		val, err := &config6d61705b737472696e675d737472696e67Target{Value: &t.Value.WireToNativeTypes}, error(nil)
		return nil, val, err
	case "WireTypeRenames":
		val, err := &config6d61705b737472696e675d737472696e67Target{Value: &t.Value.WireTypeRenames}, error(nil)
		return nil, val, err
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_config_vdltool_JavaConfig)
	}
}
func (t *JavaConfigTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *JavaConfigTarget) FinishFields(_ vdl.FieldsTarget) error {
	return nil
}

type config6d61705b737472696e675d737472696e67Target struct {
	Value    *map[string]string
	currKey  string
	currElem string
	vdl.TargetBase
	vdl.MapTargetBase
}

func (t *config6d61705b737472696e675d737472696e67Target) StartMap(tt *vdl.Type, len int) (vdl.MapTarget, error) {
	if !vdl.Compatible(tt, __VDLTypeconfig4) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLTypeconfig4)
	}
	*t.Value = make(map[string]string)
	return t, nil
}
func (t *config6d61705b737472696e675d737472696e67Target) StartKey() (key vdl.Target, _ error) {
	t.currKey = ""
	return &vdl.StringTarget{Value: &t.currKey}, error(nil)
}
func (t *config6d61705b737472696e675d737472696e67Target) FinishKeyStartField(key vdl.Target) (field vdl.Target, _ error) {
	t.currElem = ""
	return &vdl.StringTarget{Value: &t.currElem}, error(nil)
}
func (t *config6d61705b737472696e675d737472696e67Target) FinishField(key, field vdl.Target) error {
	(*t.Value)[t.currKey] = t.currElem
	return nil
}
func (t *config6d61705b737472696e675d737472696e67Target) FinishMap(elem vdl.MapTarget) error {
	if len(*t.Value) == 0 {
		*t.Value = nil
	}
	return nil
}

type JavascriptConfigTarget struct {
	Value *JavascriptConfig
	vdl.TargetBase
	vdl.FieldsTargetBase
}

func (t *JavascriptConfigTarget) StartFields(tt *vdl.Type) (vdl.FieldsTarget, error) {
	if !vdl.Compatible(tt, __VDLType_config_vdltool_JavascriptConfig) {
		return nil, fmt.Errorf("type %v incompatible with %v", tt, __VDLType_config_vdltool_JavascriptConfig)
	}
	return t, nil
}
func (t *JavascriptConfigTarget) StartField(name string) (key, field vdl.Target, _ error) {
	switch name {
	default:
		return nil, nil, fmt.Errorf("field %s not in struct %v", name, __VDLType_config_vdltool_JavascriptConfig)
	}
}
func (t *JavascriptConfigTarget) FinishField(_, _ vdl.Target) error {
	return nil
}
func (t *JavascriptConfigTarget) FinishFields(_ vdl.FieldsTarget) error {
	return nil
}

// GenLanguage enumerates the known code generation languages.
type GenLanguage int

const (
	GenLanguageGo GenLanguage = iota
	GenLanguageJava
	GenLanguageJavascript
)

// GenLanguageAll holds all labels for GenLanguage.
var GenLanguageAll = [...]GenLanguage{GenLanguageGo, GenLanguageJava, GenLanguageJavascript}

// GenLanguageFromString creates a GenLanguage from a string label.
func GenLanguageFromString(label string) (x GenLanguage, err error) {
	err = x.Set(label)
	return
}

// Set assigns label to x.
func (x *GenLanguage) Set(label string) error {
	switch label {
	case "Go", "go":
		*x = GenLanguageGo
		return nil
	case "Java", "java":
		*x = GenLanguageJava
		return nil
	case "Javascript", "javascript":
		*x = GenLanguageJavascript
		return nil
	}
	*x = -1
	return fmt.Errorf("unknown label %q in vdltool.GenLanguage", label)
}

// String returns the string label of x.
func (x GenLanguage) String() string {
	switch x {
	case GenLanguageGo:
		return "Go"
	case GenLanguageJava:
		return "Java"
	case GenLanguageJavascript:
		return "Javascript"
	}
	return ""
}

func (GenLanguage) __VDLReflect(struct {
	Name string `vdl:"vdltool.GenLanguage"`
	Enum struct{ Go, Java, Javascript string }
}) {
}

func (m *GenLanguage) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if err := t.FromEnumLabel((*m).String(), __VDLType_config_vdltool_GenLanguage); err != nil {
		return err
	}
	return nil
}

func (m *GenLanguage) MakeVDLTarget() vdl.Target {
	return &GenLanguageTarget{Value: m}
}

// GoConfig specifies go specific configuration.
type GoConfig struct {
	// WireToNativeTypes specifies the mapping from a VDL wire type to its Go
	// native type representation.  This is rarely used and easy to configure
	// incorrectly; usage is currently restricted to packages that are explicitly
	// whitelisted.
	//
	// WireToNativeTypes are meant for scenarios where there is an idiomatic Go
	// type used in your code, but you need a standard VDL representation for wire
	// compatibility.  E.g. the VDL time package defines Duration and Time for
	// wire compatibility, but we want the generated code to use the standard Go
	// time package.
	//
	// The key of the map is the name of the VDL type (aka WireType), which must
	// be defined in the vdl package associated with the vdl.config file.
	//
	// The code generator assumes the existence of a pair of conversion functions
	// converting between the wire and native types, and will automatically call
	// vdl.RegisterNative with these function names.
	//
	// Assuming the name of the WireType is Foo:
	//   func fooToNative(x Foo, n *Native) error
	//   func fooFromNative(x *Foo, n Native) error
	WireToNativeTypes map[string]GoType
}

func (GoConfig) __VDLReflect(struct {
	Name string `vdl:"vdltool.GoConfig"`
}) {
}

func (m *GoConfig) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_config_vdltool_GoConfig == nil || __VDLTypeconfig5 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("WireToNativeTypes")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(__VDLTypeconfig3, len(m.WireToNativeTypes))
		if err != nil {
			return err
		}
		for key6, value8 := range m.WireToNativeTypes {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromString(string(key6), vdl.StringType); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}

			if err := value8.FillVDLTarget(valueTarget7, __VDLType_config_vdltool_GoType); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *GoConfig) MakeVDLTarget() vdl.Target {
	return &GoConfigTarget{Value: m}
}

// GoType describes the Go type information associated with a VDL type.
// See v.io/x/ref/lib/vdl/testdata/native for examples.
type GoType struct {
	// Type is the Go type to use in generated code, instead of the VDL type.  If
	// the Go type requires additional imports, specify the type using the
	// standard local package name here, and also specify the import package in
	// Imports.
	Type string
	// Imports are the Go imports to use in generated code, required by the Type.
	Imports []GoImport
}

func (GoType) __VDLReflect(struct {
	Name string `vdl:"vdltool.GoType"`
}) {
}

func (m *GoType) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_config_vdltool_GoType == nil || __VDLTypeconfig6 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Type")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Type), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Imports")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		listTarget6, err := fieldTarget5.StartList(__VDLTypeconfig2, len(m.Imports))
		if err != nil {
			return err
		}
		for i, elem8 := range m.Imports {
			elemTarget7, err := listTarget6.StartElem(i)
			if err != nil {
				return err
			}

			if err := elem8.FillVDLTarget(elemTarget7, __VDLType_config_vdltool_GoImport); err != nil {
				return err
			}
			if err := listTarget6.FinishElem(elemTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget5.FinishList(listTarget6); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *GoType) MakeVDLTarget() vdl.Target {
	return &GoTypeTarget{Value: m}
}

// GoImport describes Go import information.
type GoImport struct {
	// Path is the package path that uniquely identifies the imported package.
	Path string
	// Name is the name of the package identified by Path.  Due to Go conventions,
	// it is typically just the basename of Path, but may be set to something
	// different if the imported package doesn't follow Go conventions.
	Name string
}

func (GoImport) __VDLReflect(struct {
	Name string `vdl:"vdltool.GoImport"`
}) {
}

func (m *GoImport) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_config_vdltool_GoImport == nil || __VDLTypeconfig7 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("Path")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget3.FromString(string(m.Path), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget4, fieldTarget5, err := fieldsTarget1.StartField("Name")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {
		if err := fieldTarget5.FromString(string(m.Name), vdl.StringType); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget4, fieldTarget5); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *GoImport) MakeVDLTarget() vdl.Target {
	return &GoImportTarget{Value: m}
}

// JavaConfig specifies java specific configuration.
type JavaConfig struct {
	// WireToNativeTypes specifies the mapping from a VDL wire type to its Java
	// native type representation.  This is rarely used and easy to configure
	// incorrectly; usage is currently restricted to packages that are explicitly
	// whitelisted.
	//
	// WireToNativeTypes are meant for scenarios where there is an idiomatic Java
	// type used in your code, but you need a standard VDL representation for wire
	// compatibility.  E.g. the VDL time package defines Duration and Time for
	// wire compatibility, but we want the generated code to use the org.joda.time
	// package.
	//
	// The key of the map is the name of the VDL type (aka WireType), which must
	// be defined in the vdl package associated with the vdl.config file.
	//
	// The code generator assumes that the conversion functions will be registered
	// in java vdl package.
	WireToNativeTypes map[string]string
	// WireTypeRenames specifies the mapping from a VDL wire type name to its
	// Java native type name.
	//
	// WireTypeRenames are meant for scenarios where the VDL wire name
	// conflicts in some way with the Java native names, e.g., a VDL Integer
	// type could be named VInteger for clarity.
	//
	// When combined with WireToNativeTypes, this feature allows us to attach
	// functions to VDL types.  For example, we may rename AccessList VDL type
	// into WireAccessList and then map WireAccessList to our Java native type
	// AccessList which defines functions on the VDL data.
	//
	// The key of the map is the name of the VDL wire type, which must be
	// defined in the vdl package associated with the vdl.config file.
	WireTypeRenames map[string]string
}

func (JavaConfig) __VDLReflect(struct {
	Name string `vdl:"vdltool.JavaConfig"`
}) {
}

func (m *JavaConfig) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_config_vdltool_JavaConfig == nil || __VDLTypeconfig8 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	keyTarget2, fieldTarget3, err := fieldsTarget1.StartField("WireToNativeTypes")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget4, err := fieldTarget3.StartMap(__VDLTypeconfig4, len(m.WireToNativeTypes))
		if err != nil {
			return err
		}
		for key6, value8 := range m.WireToNativeTypes {
			keyTarget5, err := mapTarget4.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget5.FromString(string(key6), vdl.StringType); err != nil {
				return err
			}
			valueTarget7, err := mapTarget4.FinishKeyStartField(keyTarget5)
			if err != nil {
				return err
			}
			if err := valueTarget7.FromString(string(value8), vdl.StringType); err != nil {
				return err
			}
			if err := mapTarget4.FinishField(keyTarget5, valueTarget7); err != nil {
				return err
			}
		}
		if err := fieldTarget3.FinishMap(mapTarget4); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget2, fieldTarget3); err != nil {
			return err
		}
	}
	keyTarget9, fieldTarget10, err := fieldsTarget1.StartField("WireTypeRenames")
	if err != vdl.ErrFieldNoExist && err != nil {
		return err
	}
	if err != vdl.ErrFieldNoExist {

		mapTarget11, err := fieldTarget10.StartMap(__VDLTypeconfig4, len(m.WireTypeRenames))
		if err != nil {
			return err
		}
		for key13, value15 := range m.WireTypeRenames {
			keyTarget12, err := mapTarget11.StartKey()
			if err != nil {
				return err
			}
			if err := keyTarget12.FromString(string(key13), vdl.StringType); err != nil {
				return err
			}
			valueTarget14, err := mapTarget11.FinishKeyStartField(keyTarget12)
			if err != nil {
				return err
			}
			if err := valueTarget14.FromString(string(value15), vdl.StringType); err != nil {
				return err
			}
			if err := mapTarget11.FinishField(keyTarget12, valueTarget14); err != nil {
				return err
			}
		}
		if err := fieldTarget10.FinishMap(mapTarget11); err != nil {
			return err
		}
		if err := fieldsTarget1.FinishField(keyTarget9, fieldTarget10); err != nil {
			return err
		}
	}
	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *JavaConfig) MakeVDLTarget() vdl.Target {
	return &JavaConfigTarget{Value: m}
}

// JavascriptConfig specifies javascript specific configuration.
type JavascriptConfig struct {
}

func (JavascriptConfig) __VDLReflect(struct {
	Name string `vdl:"vdltool.JavascriptConfig"`
}) {
}

func (m *JavascriptConfig) FillVDLTarget(t vdl.Target, tt *vdl.Type) error {
	if __VDLType_config_vdltool_JavascriptConfig == nil || __VDLTypeconfig9 == nil {
		panic("Initialization order error: types generated for FillVDLTarget not initialized. Consider moving caller to an init() block.")
	}
	fieldsTarget1, err := t.StartFields(tt)
	if err != nil {
		return err
	}

	if err := t.FinishFields(fieldsTarget1); err != nil {
		return err
	}
	return nil
}

func (m *JavascriptConfig) MakeVDLTarget() vdl.Target {
	return &JavascriptConfigTarget{Value: m}
}

func init() {
	vdl.Register((*Config)(nil))
	vdl.Register((*GenLanguage)(nil))
	vdl.Register((*GoConfig)(nil))
	vdl.Register((*GoType)(nil))
	vdl.Register((*GoImport)(nil))
	vdl.Register((*JavaConfig)(nil))
	vdl.Register((*JavascriptConfig)(nil))
}

var __VDLTypeconfig0 *vdl.Type = vdl.TypeOf((*Config)(nil))
var __VDLTypeconfig5 *vdl.Type = vdl.TypeOf((*GoConfig)(nil))
var __VDLTypeconfig7 *vdl.Type = vdl.TypeOf((*GoImport)(nil))
var __VDLTypeconfig6 *vdl.Type = vdl.TypeOf((*GoType)(nil))
var __VDLTypeconfig8 *vdl.Type = vdl.TypeOf((*JavaConfig)(nil))
var __VDLTypeconfig9 *vdl.Type = vdl.TypeOf((*JavascriptConfig)(nil))
var __VDLTypeconfig2 *vdl.Type = vdl.TypeOf([]GoImport(nil))
var __VDLTypeconfig4 *vdl.Type = vdl.TypeOf(map[string]string(nil))
var __VDLTypeconfig3 *vdl.Type = vdl.TypeOf(map[string]GoType(nil))
var __VDLTypeconfig1 *vdl.Type = vdl.TypeOf(map[GenLanguage]struct{}(nil))
var __VDLType_config_vdltool_Config *vdl.Type = vdl.TypeOf(Config{})
var __VDLType_config_vdltool_GenLanguage *vdl.Type = vdl.TypeOf(GenLanguageGo)
var __VDLType_config_vdltool_GoConfig *vdl.Type = vdl.TypeOf(GoConfig{})
var __VDLType_config_vdltool_GoImport *vdl.Type = vdl.TypeOf(GoImport{})
var __VDLType_config_vdltool_GoType *vdl.Type = vdl.TypeOf(GoType{})
var __VDLType_config_vdltool_JavaConfig *vdl.Type = vdl.TypeOf(JavaConfig{})
var __VDLType_config_vdltool_JavascriptConfig *vdl.Type = vdl.TypeOf(JavascriptConfig{})

func __VDLEnsureNativeBuilt_config() {
}
