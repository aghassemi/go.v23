// Package arith is an example of an IDL definition in veyron.  The syntax for
// IDL files is similar to, but not identical to, Go.  Here are the main
// concepts:
//   * PACKAGES - Just like in Go you must define the package at the beginning
//     of an IDL file, and everything defined in the file is part of this
//     package.  By convention all files in the same dir should be in the same
//     package.
//   * IMPORTS - Just like in Go you can import other idl packages, and you may
//     assign a local package name, or if unspecified the basename of the import
//     path is used as the import package name.
//   * DATA TYPES - Just like in Go you can define data types.  You get most of
//     the primitives (int32, float64, string, etc), the "error" built-in, and a
//     special "anydata" built-in described below.  In addition you can create
//     composite types like arrays, structs, etc.
//   * CONSTS - Just like in Go you can define constants, and numerics are
//     "infinite precision" within expressions.  Unlike Go numerics must be
//     typed to be used as const definitions or tags.
//   * INTERFACES - Just like in Go you can define interface types, which are
//     just a set of methods.  Interfaces can embed other interfaces.  Unlike
//     Go, you cannot use an interface as a data type; interfaces are purely
//     method sets.
//   * ERRORS - Errors may be defined in IDL files, and unlike Go they work
//     across separate address spaces.
package arith

// Test the import mechanism.
import (
	base "veyron2/idl/build/test_base"
)

type TagString string
type TagInt32 int32

// Constants.
const (
	// Yes shows that bools may be untyped.
	Yes      = true // yes trailing doc
	// No shows explicit boolean typing.
	No       = bool(false)
	// Hello shows using a user-defined type.
	Hello    = TagString("hello")
	// Int32 shows explicit integer typing.
	Int32    = int32(123)
	// Int64 shows explicit integer conversion from another type, and referencing
	// a constant from another package.
	Int64    = int64(Int32 + base.Five)
	// Float shows arithmetic expressions may be used.
	Float    = float64(3.0 / 2 + 0.5)
	// Mask shows bitwise operations.
	Mask     = uint64(0x1 << 8)
)

// Arith is an example of an interface definition for an arithmetic service.
// Things to note:
//   * There must be at least 1 out-arg, and the last out-arg must be error.
//   * All in-args must be named, and the first letter of each name must be
//     uppercase.  If you have more than 2 out-args (including the required
//     final error arg), they must be named with first letter uppercase.  This
//     is because the arg names will be used as field names in auto-generated
//     structs, and the fields must be exported.
type Arith interface {
	// Add is a typical method with multiple input and output arguments.
	Add(A int32, B int32) (int32, error)

	// DivMod shows that runs of args with the same type can use the short form,
	// just like Go.
	DivMod(A, B int32) (Quot, Remain int32, E error)

	// Sub shows that you can use data types defined in other packages.
	Sub(args base.Args) (int32, error)

	// Mul tries another data type defined in another package.
	Mul(nestedArgs base.NestedArgs) (int32, error)

	// GenError shows that it's fine to have no in args, and no out args other
	// than "error".  In addition GenError shows the usage of tags.  Tags are a
	// sequence of constants.  There's no requirement on uniqueness of types or
	// values, and regular const expressions may also be used.
	GenError() error {"foo", TagString("bar" + "z"), Hello, TagInt32(Int64 + 1)}

	// Count shows using only an int32 out-stream type, with no in-stream type.
	Count(Start int32) stream<_, int32> error

	// StreamingAdd shows a bidirectional stream.
	StreamingAdd() stream<int32, int32> (Total int32, E error)

	// QuoteAny shows the anydata type built-in type, representing a value of any
	// type.  In generated Go it's translated into idl.AnyData defined in
	// veyron/api/idl, with underlying type "interface{}".  For other generated
	// languages you get an object with similar semantics.
	QuoteAny(Any anydata) (anydata, error)
}

type Calculator interface {
	// A calculator can do basic arithmetic.
	Arith  // Arith provides the interface to basic arithmetic operations.
	// A calculator has basic advanced function support.
	AdvancedMath
	On() error  // On turns the calculator on.
	Off() error {"offtag"}  // Off turns the calculator off.
}

// Error ids, that allow stable error checking across different error messages
// and different address spaces.
errorid (
	// ErrIDFoo gets the conventional "veyron2/internal/lib/idl/test_arith.ErrIdFoo" id.
	ErrIDFoo
	// ErrIDBar overrides the id to be the same as ErrIDFoo.
	ErrIDBar = "veyron2/internal/lib/idl/test_arith.ErrIDFoo"
)

// CrossPkg is a test of cross-package data types.  By convention you should
// list data type definitions before interface definitions, but this is a test
// to ensure the data type gets ordered first in the generated code.
type CrossPkg struct {
	// A docs
	A base.MyInt2      // more A docs
	// B docs
	B base.MyArray2    // more B docs
	C base.MySlice2    // C docs
	// D docs
	D base.MyMap2
	E base.Args2       // E docs
	F base.NestedArgs  // F docs
	/* G docs */
	G base.Args        /* more G docs */
	H base.MyInt
	I base.MyArray
	J base.MySlice
	K base.MyMap
	L anydata          // Make sure anydata works in a struct
}
