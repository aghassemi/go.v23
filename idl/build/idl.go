// Package build provides utilities to parse idl files, and to generate code for
// different languages based on the idl.  The veyron idlc command is the main
// user of this library, but it may also be used by other tools or code.
package build

import (
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path"
	"unicode"

	"veyron2/ipc"
)

const (
	logPrefix = ""
	logFlags  = log.Lshortfile | log.Ltime | log.Lmicroseconds
)

var (
	vlog = log.New(ioutil.Discard, logPrefix, logFlags)
)

// SetVerbose tells the idl package to enable verbose logging.
func SetVerbose() {
	vlog = log.New(os.Stderr, logPrefix, logFlags)
}

// Env is the environment for parsing.  Always create a new Env via NewEnv; the
// zero Env can't resolve any types.
type Env struct {
	Errors Errors
	pkgs   pkgMap
}

// NewEnv creates a new Env, allowing up to maxErrors errors before we stop.
func NewEnv(maxErrors int) *Env {
	return &Env{
		Errors: Errors{MaxErrors: maxErrors},
		pkgs:   makePkgMap()}
}

// pkgMap is a map from the path name of a package to a compiled *Package.
type pkgMap map[string]*Package

func makePkgMap() (p pkgMap) {
	p = make(pkgMap)
	p[globalPackage.Name] = globalPackage
	return
}

// Pos captures positional information during parsing.
type Pos struct {
	Line int // Line number, starting at 1
	Col  int // Column number (character count), starting at 1
}

// Returns true iff this Pos has been initialized.  The zero Pos is invalid.
func (p Pos) IsValid() bool {
	return p.Line > 0 && p.Col > 0
}

func (p Pos) String() string {
	if !p.IsValid() {
		return "[no pos]"
	}
	// We try to keep the output the same as go/parser, so that errors look
	// consistent to the user.  That's also why we retain go/parser semantics
	// where lines and columns start at 1 (and not 0).
	return fmt.Sprintf("%v:%v", p.Line, p.Col)
}

// Representation of the components of an idl file.  These data types represent
// both the ast generated by the parse, as well as the results of the
// compilation that generators for different languages will use.
// TODO(toddw): Separate ast from compiled data.
//
// Here are the meanings of common fields:
//   Pos:       position of occurrence in *.idl file
//   Doc:       documentation string that occurs before the item
//   DocSuffix: documentation string that occurs after the item

// Field represents fields in structs as well as method arguments.
type Field struct {
	Name      string
	Type      Type
	Pos       Pos
	Doc       string
	DocSuffix string
}

// Method represents a method in an interface.
type Method struct {
	Name      string
	InArgs    []*Field
	OutArgs   []*Field
	InStream  *Field
	OutStream *Field
	Tags      []Const
	Pos       Pos
	Doc       string
	DocSuffix string

	tagExprs []constExpr
}

// EmbeddedInterface represents an interface embedded in another interface.
type EmbeddedInterface Field

// InterfaceComponent represents a component of an interface spec, which can
// either be a method signature or the name of another embedded interface.
type InterfaceComponent interface {
	SetDoc(string)
	SetDocSuffix(string)
	GetPos() Pos
	Verify(fname, iname string, env *Env)
}

func (m *Method) SetDoc(d string)       { m.Doc = d }
func (m *Method) SetDocSuffix(d string) { m.DocSuffix = d }
func (m *Method) GetPos() Pos           { return m.Pos }

func (e *EmbeddedInterface) SetDoc(d string)       { e.Doc = d }
func (e *EmbeddedInterface) SetDocSuffix(d string) { e.DocSuffix = d }
func (e *EmbeddedInterface) GetPos() Pos           { return e.Pos }
func (e *EmbeddedInterface) Verify(fname, iname string, env *Env) {
	msg := fmt.Sprintf("interface %v embedded interface %v", iname, e.Name)
	(*Field)(e).Verify(dontNeedName, fname, msg, false, env)
}

// Interface represents a set of methods and embedded interfaces.
type Interface struct {
	Name       string
	Components []InterfaceComponent
	Pos        Pos
	Doc        string
	Def        *TypeDef
}

// Methods returns the interface components that are methods (as opposed to
// other embedded interfaces).
func (iface *Interface) Methods() (methods []*Method) {
	for _, c := range iface.Components {
		if m, ok := c.(*Method); ok {
			methods = append(methods, m)
		}
	}
	return
}

// Embeds returns the interface components that are other embedded interfaces
// (as opposed to methods).
func (iface *Interface) Embeds() (embeds []*EmbeddedInterface) {
	for _, c := range iface.Components {
		if i, ok := c.(*EmbeddedInterface); ok {
			embeds = append(embeds, i)
		}
	}
	return
}

// Signature generates the service signature of the interface.
// This assumes that the the Interface is fully populated.
func (iface *Interface) Signature() *ipc.ServiceSignature {
	sig := &ipc.ServiceSignature{Methods: map[string]ipc.MethodSignature{}}
	wtc := wireTypeConverter{}
	for _, method := range iface.Methods() {
		ms := ipc.MethodSignature{}
		for _, inarg := range method.InArgs {
			ms.InArgs = append(ms.InArgs, ipc.MethodArgument{
				Name: inarg.Name,
				Type: wtc.WireTypeID(inarg.Type),
			})
		}
		for _, outarg := range method.OutArgs {
			ms.OutArgs = append(ms.OutArgs, ipc.MethodArgument{
				Name: outarg.Name,
				Type: wtc.WireTypeID(outarg.Type),
			})
		}
		if method.InStream != nil {
			ms.InStream = wtc.WireTypeID(method.InStream.Type)
		}
		if method.OutStream != nil {
			ms.OutStream = wtc.WireTypeID(method.OutStream.Type)
		}
		sig.Methods[method.Name] = ms
	}
	sig.TypeDefs = wtc.Defs
	return sig
}

// ErrorID represents an error id.
type ErrorID struct {
	Name      string // Name of the error id.
	ID        string // Error id; if empty we use PKGPATH.Name
	Pos       Pos
	Doc       string
	DocSuffix string
}

// Import represents an import definition, which is used to import other
// packages into an idl file.
type Import struct {
	LocalName string // LocalName of the import; if empty we use the last component of the path
	Path      string // Path of the import; e.g. "veyron/lib/idl"
	Pos       Pos
	used      bool // Was this import used during compilation?
}

// File represents an idl file, containing interfaces and structs.
type File struct {
	BaseName    string
	PackageName string
	PackagePos  Pos
	PackageDoc  string
	Imports     []*Import
	TypeDefs    []*TypeDef
	ConstDefs   []*ConstDef
	ErrorIDs    []*ErrorID
	Interfaces  []*Interface
	Package     *Package

	// PackageDeps holds the packages that this file actually depends on.  It may
	// be different from the user-supplied Imports, since we evaluate all consts
	// to their final typed value.  E.g. let's say we have three idl files:
	//   a/a.idl  type Foo int32; const A1 = Foo(1)
	//   b/b.idl  import "a";     const B1 = a.Foo(1); const B2 = a.A1 + 1
	//   c/c.idl  import "b";     const C1 = b.B1;     const C2 = b.B1 + 1
	//
	// The final type and value of the constants:
	//   A1 = a.Foo(1); B1 = a.Foo(1); C1 = a.Foo(1)
	//                  B2 = a.Foo(2); C2 = a.Foo(2)
	//
	// Note that C1 and C2 both have final type a.Foo, even though c.idl doesn't
	// explicitly import "a", and the generated c.go shouldn't import "b" since
	// it's not actually used anymore.
	PackageDeps map[*Package]bool
}

// Package represents an idl package, containing a set of files.
type Package struct {
	Name          string // e.g. "base"
	Path          string // e.g. "veyron/rt/base"
	Dir           string // e.g. "/home/user/veyron/v/src/veyron/rt/base"
	Files         []*File
	typeResolver  typeResolver
	constResolver constResolver
}

func NewPackage(name, path, dir string) *Package {
	return &Package{
		Name: name, Path: path, Dir: dir,
		typeResolver:  make(typeResolver),
		constResolver: make(constResolver),
	}
}

func (f *Field) String() string {
	return fmt.Sprintf("%+v", *f)
}

func (m *Method) String() string {
	return fmt.Sprintf("%+v", *m)
}

func (i *Interface) String() string {
	return fmt.Sprintf("%+v", *i)
}

func (e *ErrorID) String() string {
	return fmt.Sprintf("%+v", *e)
}

func (i *Import) String() string {
	return fmt.Sprintf("%+v", *i)
}

func (f *File) String() string {
	return fmt.Sprintf("%+v", *f)
}

type nameRequired bool

const (
	dontNeedName = nameRequired(false)
	mustHaveName = nameRequired(true)
)

func (t *TypeDef) Verify(nameReq nameRequired, fname, msg string, env *Env) {
	if st, ok := t.Base.(*StructType); ok {
		for _, f := range st.Fields {
			f.Verify(mustHaveName, fname, msg, false, env)
		}
	}
}

func (f *Field) Verify(nameReq nameRequired, fname, msg string, exportedReq bool, env *Env) {
	errmsg := fmt.Sprintf("%v:%v %v", fname, f.Pos, msg)
	if nameReq == mustHaveName && len(f.Name) == 0 {
		env.Errors.Errorf("%s has no name - all struct fields and method "+
			"input args must be named, and if there are more than 2 output args "+
			"in a method they all must be named",
			errmsg)
	}
	if !exportedReq && len(f.Name) > 0 && !unicode.IsUpper(([]rune(f.Name))[0]) {
		env.Errors.Errorf("%s has a non-exported field name %q - all struct "+
			"fields must be exported if they're named.",
			errmsg, f.Name)
	}
	// Sanity-check the compiler type resolution logic.
	if f.Type.Def() == nil {
		env.Errors.Errorf("%s internal error: type %v isn't resolved",
			errmsg, f.Type.Name())
	}
}

func (m *Method) VerifyArgs(nameReq nameRequired, fname, iname, kind string, args []*Field, env *Env) {
	for ax, arg := range args {
		msg := fmt.Sprintf("interface %v method %v %v arg #%v", iname, m.Name, kind, ax)
		if arg.Verify(nameReq, fname, msg, true, env); env.Errors.IsFull() {
			return
		}
	}
}

func (m *Method) Verify(fname, iname string, env *Env) {
	if len(m.Name) == 0 {
		env.Errors.Errorf("%v:%v interface %v method has no name", fname, m.Pos, iname)
	}
	errmsg := fmt.Sprintf("%v:%v interface %v method %v", fname, m.Pos, iname, m.Name)
	if len(m.Name) > 0 && !unicode.IsUpper(([]rune(m.Name))[0]) {
		env.Errors.Errorf("%s isn't exported.", errmsg)
	}
	// All input args must have a name.
	m.VerifyArgs(mustHaveName, fname, iname, "input", m.InArgs, env)

	// The last output arg must be type "error".
	if len(m.OutArgs) == 0 || m.OutArgs[len(m.OutArgs)-1].Type.Name() != "error" {
		env.Errors.Errorf("%s last output arg isn't type \"error\"", errmsg)
	}
	// If there's more than two output args (including the final "error"), all
	// of them must be named.  Otherwise we won't know what to call the fields in
	// any auto-generated reply struct (for non-go output languages).
	nameReq := dontNeedName
	if len(m.OutArgs) > 2 {
		nameReq = mustHaveName
	}
	m.VerifyArgs(nameReq, fname, iname, "output", m.OutArgs, env)

	// All tags must be valid.
	for tx, tag := range m.Tags {
		if !tag.IsValid() {
			env.Errors.Errorf("%s tag #%d isn't valid", errmsg, tx)
		}
	}
}

func (i *Interface) Verify(fname string, ix int, env *Env) {
	if len(i.Name) == 0 {
		env.Errors.Errorf("%v:%v interface #%v has no name", fname, i.Pos, ix)
	}
	errmsg := fmt.Sprintf("%v:%v interface %v", fname, i.Pos, i.Name)
	if len(i.Name) > 0 && !unicode.IsUpper(([]rune(i.Name))[0]) {
		env.Errors.Errorf("%s isn't exported", errmsg)
	}
	if len(i.Components) == 0 {
		env.Errors.Errorf("%s has no methods or embedded interfaces", errmsg)
	}
	for _, c := range i.Components {
		if c.Verify(fname, i.Name, env); env.Errors.IsFull() {
			return
		}
	}
}

func (i *Import) Verify(fname string, pkgNames map[string]struct{}, env *Env) {
	errmsg := fmt.Sprintf("%v:%v", fname, i.Pos)
	// LocalName is allowed to be empty; that means the last component of the Path
	// is used as the import package name.
	if len(i.Path) == 0 {
		env.Errors.Errorf("%s empty import path", errmsg)
	}
	name := i.Name()
	if _, exists := pkgNames[name]; exists {
		env.Errors.Errorf("%s duplicate import package name %v", errmsg, name)
	}
	pkgNames[name] = struct{}{}
}

func (f *File) Verify(pname string, env *Env) {
	if len(f.BaseName) == 0 {
		env.Errors.Errorf("empty file name in package %v", pname)
	}
	if pname != f.PackageName {
		env.Errors.Errorf("%v expected package %v, actual package %v", f.BaseName, pname, f.PackageName)
	}
	// We check for dups in the imports using pkgNames, which starts out with the
	// package name itself.
	pkgNames := map[string]struct{}{pname: struct{}{}}
	for _, imp := range f.Imports {
		if imp.Verify(f.BaseName, pkgNames, env); env.Errors.IsFull() {
			return
		}
	}
	for _, def := range f.TypeDefs {
		// Sanity-check the compiler type definition logic.
		if def.Base.Def() == nil {
			env.Errors.Errorf("%v internal error: package %v type %v isn't resolved",
				f.BaseName, pname, def.Name)
		} else {
			msg := fmt.Sprintf("struct type %s.%s", pname, def.Name)
			def.Verify(mustHaveName, f.BaseName, msg, env)
		}
	}
	for _, def := range f.ConstDefs {
		// Sanity-check the compiler const definition logic.
		if !def.Const.IsValid() {
			env.Errors.Errorf("%v internal error: package %v const %v isn't valid",
				f.BaseName, pname, def.Name)
		}
	}
	for ix, iface := range f.Interfaces {
		if iface.Verify(f.BaseName, ix, env); env.Errors.IsFull() {
			return
		}
	}
}

func (p *Package) Verify(env *Env) {
	if len(p.Name) == 0 {
		env.Errors.Errorf("empty package name")
	}
	// The package path may be empty if the user has compiled a package by
	// specifying directory, rather than specifying a package path.
	if len(p.Dir) == 0 {
		env.Errors.Errorf("empty package dir for package %v", p.Name)
	}
	if len(p.Files) == 0 {
		env.Errors.Errorf("no files in package %v", p.Name)
	}
	for _, file := range p.Files {
		if file.Verify(p.Name, env); env.Errors.IsFull() {
			return
		}
	}
}

// ResolvesType resolves the typeName to the type definition.
func (p *Package) ResolveType(typeName string) *TypeDef {
	return p.typeResolver[typeName]
}

// ResolvesConst resolves the name to the const definition.
func (p *Package) ResolveConst(name string) *ConstDef {
	return p.constResolver[name]
}

// Name returns the name of the import, which is either explicitly specified by
// the user, or implicitly determined by the base of the path.
func (i *Import) Name() string {
	if len(i.LocalName) > 0 {
		return i.LocalName
	}
	return path.Base(i.Path)
}

// LookupImportPath translates the pkgName into a package path name, based on
// the imports associated with the file.  Returns the empty string "" if the
// pkgName couldn't be found; every valid package path is non-empty.
func (f *File) LookupImportPath(pkgName string) string {
	// TODO(toddw): Create a map if this is too slow.  We probably don't care.
	for _, imp := range f.Imports {
		if imp.Name() == pkgName {
			imp.used = true
			return imp.Path
		}
	}
	return ""
}
