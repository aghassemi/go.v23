package build

import (
	"bytes"
	"fmt"
	"log"
	"math/big"
	"path"
	"sort"
	"strings"
	"text/template"
	"unicode"
	"unicode/utf8"
)

// javaGenPkgPrefix is the path prefix to be added to generated IDL package paths.
var javaGenPkgPrefix string = "com"

// SetJavaGenPkgPrefix sets the prefix that will be added to generated IDL package paths.
func SetJavaGenPkgPrefix(prefix string) {
	javaGenPkgPrefix = prefix
}

// javaGenPkgPath returns the Java package path given the Go package path.
func javaGenPkgPath(goPkgPath string) string {
	return path.Join(javaGenPkgPrefix, goPkgPath)
}

// JavaFileInfo stores the name and contents of the generated Java file.
type JavaFileInfo struct {
	Name string
	Data []byte
}

// GenJavaFiles generates Java files for all IDL files in the provided package,
// returning the list of generated Java files as a slice.  Since Java requires
// that each public class/interface gets defined in a separate file, this method
// will return one generated file per struct.  (Interfaces actually generate
// two files because we create separate interfaces for clients and services.)
// In addition, since Java doesn't support global variables (i.e., variables
// defined outside of a class), all constants are moved into a special "Consts"
// class and stored in a separate file.  Finally, package documentation (if any)
// is stored in a "package-info.java" file.
//
// Since Java doesn't support typedefs, all non-struct typedefs are removed
// from the IDL files during generation.  For example, if an IDL method takes
// and argument of type "A", and there is a typedef "type A int32", type "int32"
// is assigned to the argument.  This process is applied recursively until
// either a primitive type or a named struct is encountered.
//
// The current generator doesn't yet support the full set of IDL features.  In
// particular, we don't yet support error ids and unnamed composite types.  The
// last of these are the most difficult to support and we plan to remove their
// support from the IDL language.

// TODO(spetrovic): Run Java formatters on the generated files.
func GenJavaFiles(pkg *Package) (ret []JavaFileInfo) {
	// One file for package documentation (if any).
	if g := genJavaPackageFile(pkg); g != nil {
		ret = append(ret, *g)
	}
	// Single file for all constants' definitions.
	ret = append(ret, genJavaConstFile(pkg))
	for _, file := range pkg.Files {
		// Separate file for all struct typedefs.
		for _, tdef := range file.TypeDefs {
			if tdef.Name != "" {
				// We only handle struct typedefs as Java language doesn't
				// have any support for general typedefs (struct typedefs become
				// java classes).  All other typedefs are unrolled by the
				// generator and discarded.
				if s, ok := tdef.Base.(*StructType); ok {
					ret = append(ret, genJavaClassFile(file, tdef, s))
				}
			}
		}
		// Separate file for all interface definitions.
		for _, iface := range file.Interfaces {
			ret = append(ret, genJavaInterfaceFile(file, iface, false)) // client interface
			ret = append(ret, genJavaInterfaceFile(file, iface, true))  // service interface
		}
	}
	return
}

// genPackageFileJava generates the Java package info file, iff any package
// comments were specified in the package's IDL files.
func genJavaPackageFile(pkg *Package) *JavaFileInfo {
	for _, file := range pkg.Files {
		if file.PackageDoc != "" {
			var buf bytes.Buffer
			err := javaPkgTmpl.Execute(&buf, file)
			if err != nil {
				log.Fatalf("idl: couldn't execute package template: %v", err)
			}
			return &JavaFileInfo{
				Name: "package-info.java",
				Data: buf.Bytes(),
			}
		}
	}
	return nil
}

const javaPkgTmplStr = `
{{with $file := .}}// This file was auto-generated by the veyron idl tool.
// Source: {{$file.BaseName}}

{{javaDoc $file.PackageDoc}}
package {{javaPath (javaGenPkgPath $file.Package.Path)}};
{{end}}
`

// genConstFileJava generates the (single) Java file that contains constant
// definitions from all the IDL files.
func genJavaConstFile(pkg *Package) JavaFileInfo {
	data := struct {
		Package *Package
		Imports javaUserImports
	}{
		Package: pkg,
		Imports: javaConstImports(pkg),
	}
	var buf bytes.Buffer
	err := javaConstTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatal("idl: couldn't execute const template: %v", err)
	}
	return JavaFileInfo{
		Name: "Consts.java",
		Data: buf.Bytes(),
	}
}

const javaConstTmplStr = `{{with $data := .}}// This file was auto-generated by the veyron idl tool.
// Source(s):{{range $file := $data.Package.Files}} {{$file.BaseName}}{{end}}
package {{javaPath (javaGenPkgPath $data.Package.Path)}};

public class Consts { {{range $file := $data.Package.Files}}
	/* The following constants originate from file: {{$file.BaseName}}. */{{range $const := $file.ConstDefs}}
	{{$const.Doc}}	public static final {{javaConstType $data.Imports $const.Const}} {{toConstCase $const.Name}} = {{javaConstVal $const.Const}};{{$const.DocSuffix}}{{end}}{{end}}
}{{end}}
`

// genStructFile generates the Java class file for the provided struct.
func genJavaClassFile(f *File, tdef *TypeDef, s *StructType) JavaFileInfo {
	data := struct {
		File    *File
		TypeDef *TypeDef
		Struct  *StructType
		Imports javaUserImports
	}{
		File:    f,
		TypeDef: tdef,
		Struct:  s,
		Imports: javaStructImports(f, tdef, s),
	}
	var buf bytes.Buffer
	err := javaClassTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatalf("idl: couldn't execute struct template: %v", err)
	}
	return JavaFileInfo{
		Name: tdef.Name + ".java",
		Data: buf.Bytes(),
	}
}

const javaClassTmplStr = `
{{with $data := .}}// This file was auto-generated by the veyron idl tool.
// Source: {{$data.File.BaseName}}
package {{javaPath (javaGenPkgPath $data.File.Package.Path)}};
{{range $imp := javaImports $data.Imports $data.File.Package}}
import {{$imp}};{{end}}

{{javaDoc $data.TypeDef.Doc}}public class {{javaType $data.Imports $data.TypeDef false false}} { {{range $field := $data.Struct.Fields}}
	{{$field.Doc}}public {{javaType $data.Imports $field.Type.Def false false}} {{toCamelCase $field.Name}};{{$field.DocSuffix}}{{end}}
}{{end}}
`

// genJavaInterfaceFile generates the Java interface file for the provided
// interface.
func genJavaInterfaceFile(f *File, iface *Interface, isService bool) JavaFileInfo {
	data := struct {
		File      *File
		Interface *Interface
		Imports   javaUserImports
		IsService bool
	}{
		File:      f,
		Interface: iface,
		Imports:   javaInterfaceImports(f, iface, isService),
		IsService: isService,
	}
	var buf bytes.Buffer
	err := javaIfaceTmpl.Execute(&buf, data)
	if err != nil {
		log.Fatalf("idl: couldn't execute struct template: %v", err)
	}
	name := iface.Def.Name
	if isService {
		name += "Service"
	}
	name += ".java"
	return JavaFileInfo{
		Name: name,
		Data: buf.Bytes(),
	}
}

const javaIfaceTmplStr = `{{with $data := .}}{{with $iface := $data.Interface}}// This file was auto-generated by the veyron idl tool.
// Source: {{$data.File.BaseName}}
package {{javaPath (javaGenPkgPath $data.File.Package.Path)}};
{{range $imp := javaImports $data.Imports $data.File.Package}}
import {{$imp}};{{end}}

{{javaDoc $iface.Doc}}public interface {{javaType $data.Imports $iface.Def false $data.IsService}} {{javaExtends $data.Imports $iface $data.IsService}} { {{range $method := $iface.Methods}}{{if javaShouldPackOutArgs $data.Imports $method $data.IsService}}
	// {{$method.Name}}Out packages output arguments for method {{$method.Name}}.
	// TODO(spetrovic): should this be the same type for the service and the client?  If so, it needs
	// to be defined outside of the class and in its own file (ugh!!).
	public class {{$method.Name}}Out { {{range $arg := javaNonErrorOutArgs $method}}
		{{$arg.Doc}}public {{javaType $data.Imports $arg.Type.Def false $data.IsService}} {{toCamelCase $arg.Name}};{{$arg.DocSuffix}}{{end}}
	}{{end}}
	{{$method.Doc}}	public {{javaOutArgType $data.Imports $method $data.IsService}} {{toCamelCase $method.Name}}({{javaInArgs $data.Imports $method $data.IsService}}) throws {{javaName $data.Imports "com/veyron2/ipc/VeyronException"}};{{$method.DocSuffix}}{{end}}
}{{end}}{{end}}
`

// javaUserImports stores Java class imports found in user-specified code (i.e.,
// structs, interfaces, consts).  These imports are stores as a map of
// ClassName -> ClassPkgPath.
type javaUserImports map[string]string

// javaConstImports returns Java class imports originating in the constant
// definitions of all IDL files in the provided package.
func javaConstImports(pkg *Package) javaUserImports {
	var classPaths []string
	for _, file := range pkg.Files {
		for _, cdef := range file.ConstDefs {
			if cdef.Const.TypeDef == nil {
				// Untyped constant.  We infer the type from the value, which
				// must be of a bool, string, *bit.Int, or *bit.Rat type.  (Out
				// of these, only string translates into a classname.)
				if _, ok := cdef.Const.Val.(string); ok {
					classPaths = append(classPaths, "java/lang/String")
				}
				continue
			}
			classPaths = append(classPaths, javaClassPaths(cdef.Const.TypeDef, false, false)...)
		}
	}
	return genJavaUserImports(pkg.Path, classPaths)
}

// javaStructImports returns Java class imports originating in the provided
// struct definition.
func javaStructImports(f *File, tdef *TypeDef, s *StructType) javaUserImports {
	classPaths := javaClassPaths(tdef, false, false)
	for _, field := range s.Fields {
		classPaths = append(classPaths, javaClassPaths(field.Type.Def(), false, false)...)
	}
	return genJavaUserImports(f.Package.Path, classPaths)
}

// javaInterfaceImports returns Java class imports originating in the provided
// interface definition.
func javaInterfaceImports(f *File, iface *Interface, isService bool) javaUserImports {
	classPaths := javaClassPaths(iface.Def, false, isService)
	for _, m := range iface.Methods() {
		if javaIsStreamingMethod(m) {
			classPaths = append(classPaths, javaStreamClassPaths(m, isService)...)
		}
		if !isService {
			classPaths = append(classPaths, "com/veyron2/ipc/Client")
		} else {
			classPaths = append(classPaths, "com/veyron2/ipc/Context")
		}
		for _, iarg := range m.InArgs {
			classPaths = append(classPaths, javaClassPaths(iarg.Type.Def(), false, isService)...)
		}
		for _, oarg := range m.OutArgs {
			classPaths = append(classPaths, javaClassPaths(oarg.Type.Def(), false, isService)...)
		}
		classPaths = append(classPaths, "com/veyron2/ipc/VeyronException")
	}
	for _, e := range iface.Embeds() {
		classPaths = append(classPaths, javaClassPaths(e.Type.Def(), false, isService)...)
	}
	return genJavaUserImports(f.Package.Path, classPaths)
}

// genJavaUserImports generates the final list of Java class imports, given the
// list of class paths.
func genJavaUserImports(pkgPath string, classPaths []string) (ret javaUserImports) {
	// Sort all the class paths so that we get deterministic ordering;
	// it would be annoying for imported/non-imported class names to
	// change between runs.
	c := sort.StringSlice(classPaths)
	c.Sort()

	// Decide which class names to keep.  Here is the list of rules in order of
	// their preference:
	//   1) Prefer local classes.
	//   2) Prefer system classes (e.g., "java.lang.*").
	//   3) Prefer classes that are lexicographically smaller.
	ret = make(javaUserImports)
	for _, class := range c {
		cur, ok := ret[path.Base(class)]
		switch {
		case !ok:
			ret[path.Base(class)] = path.Dir(class)
		case path.Dir(class) == pkgPath:
			ret[path.Base(class)] = path.Dir(class)
		case path.Dir(class) == "java/lang" && path.Dir(cur) != pkgPath:
			ret[path.Base(class)] = path.Dir(class)
		}
	}
	return
}

// javaClassPaths returns pathnames of all Java classes originating in the
// provided type.
func javaClassPaths(def *TypeDef, forceClass bool, isService bool) (ret []string) {
	if def.Name != "" {
		return javaNamedClassPaths(def, forceClass, isService)
	}
	switch t := def.Base.(type) {
	case *ArrayType:
		ret = javaClassPaths(t.Elem.Def(), true, isService)
	case *SliceType:
		ret = append(ret, path.Join("java/util", "ArrayList"))
		ret = append(ret, javaClassPaths(t.Elem.Def(), true, isService)...)
	case *MapType:
		ret = append(ret, path.Join("java/util", "HashMap"))
		ret = append(ret, javaClassPaths(t.Key.Def(), true, isService)...)
		ret = append(ret, javaClassPaths(t.Elem.Def(), true, isService)...)
	case *NamedType:
		ret = javaClassPaths(t.Def(), forceClass, isService)
	case *StructType:
		log.Fatalf("idl: unnamed struct types not allowed")
	default:
		log.Fatalf("idl: unhandled type %#v", t)
	}
	return
}

func javaNamedClassPaths(def *TypeDef, forceClass bool, isService bool) []string {
	if def.File == globalFile {
		t, class := javaPrimitiveType(def.Kind, forceClass)
		if class {
			return []string{t}
		}
		return nil
	}
	switch def.Base.(type) {
	case *StructType:
		return []string{path.Join(javaGenPkgPath(def.File.Package.Path), def.Name)}
	case *InterfaceType:
		ret := path.Join(javaGenPkgPath(def.File.Package.Path), def.Name)
		if isService {
			ret += "Service"
		}
		return []string{ret}
	default:
		// Not a named struct/interface - recurse through the underlying
		// type, effectively getting rid of this (named) type.
		return javaClassPaths(def.Base.Def(), forceClass, isService)
	}
}

func javaStreamClassPaths(m *Method, isService bool) (ret []string) {
	if !javaIsStreamingMethod(m) {
		return
	}
	ret = append(ret, "com/veyron2/idl/Stream")
	if m.InStream != nil {
		ret = append(ret, javaClassPaths(m.InStream.Type.Def(), true, isService)...)
	} else {
		ret = append(ret, "java/lang/Void")
	}
	if m.OutStream != nil {
		ret = append(ret, javaClassPaths(m.OutStream.Type.Def(), true, isService)...)
	} else {
		ret = append(ret, "java/lang/Void")
	}
	return
}

// javaType returns the Java type string given the provided IDL type.  It
// consults the provided imports map to see if the full pathnames or only
// base names can be used (e.g., "java.util.HashMap" or "HashMap").
func javaType(imports javaUserImports, def *TypeDef, forceClass bool, isService bool) string {
	if def.Name != "" {
		return javaNamedType(imports, def, forceClass, isService)
	}
	switch t := def.Base.(type) {
	case *ArrayType:
		return fmt.Sprintf("%s[]", javaType(imports, t.Elem.Def(), false, isService))
	case *SliceType:
		return fmt.Sprintf("%s<%s>", javaName(imports, "java/util/ArrayList"), javaType(imports, t.Elem.Def(), true, isService))
	case *MapType:
		return fmt.Sprintf("%s<%s, %s>", javaName(imports, "java/util/HashMap"), javaType(imports, t.Key.Def(), true, isService), javaType(imports, t.Elem.Def(), true, isService))
	case *NamedType:
		return javaType(imports, t.Def(), forceClass, isService)
	case *StructType:
		log.Fatalf("idl: unnamed struct types not allowed")
		return ""
	default:
		// Catches TypeDefType, which should never appear here.
		log.Fatalf("idl: unhandled type %#v", t)
		return ""
	}
}

func javaNamedType(imports javaUserImports, def *TypeDef, forceClass bool, isService bool) string {
	if def.File == globalFile {
		t, class := javaPrimitiveType(def.Kind, forceClass)
		if class {
			return javaName(imports, t)
		}
		return t
	}
	switch def.Base.(type) {
	case *StructType:
		return javaName(imports, path.Join(javaGenPkgPath(def.File.Package.Path), def.Name))
	case *InterfaceType:
		name := path.Join(javaGenPkgPath(def.File.Package.Path), def.Name)
		if isService {
			name += "Service"
		}
		return javaName(imports, name)
	default:
		// Not a named struct/interface - recurse through the underlying type,
		// effectively getting rid of this (named) typedef.
		return javaType(imports, def.Base.Def(), forceClass, isService)
	}
}

func javaPrimitiveType(k Kind, forceClass bool) (string, bool) {
	switch k {
	case KindBool:
		if forceClass {
			return "java/lang/Boolean", true
		} else {
			return "boolean", false
		}
	case KindByte:
		if forceClass {
			return "java/lang/Byte", true
		} else {
			return "byte", false
		}
	case KindUint32, KindInt32:
		if forceClass {
			return "java/lang/Integer", true
		} else {
			return "int", false
		}
	case KindUint64, KindInt64:
		if forceClass {
			return "java/lang/Long", true
		} else {
			return "long", false
		}
	case KindFloat32:
		if forceClass {
			return "java/lang/Float", true
		} else {
			return "float", false
		}
	case KindFloat64:
		if forceClass {
			return "java/lang/Double", true
		} else {
			return "double", false
		}
	case KindString:
		return "java/lang/String", true
	case KindError:
		return "com/veyron2/ipc/VeyronException", true
	case KindAnyData:
		return "java/lang/Object", true
	// TODO(bprosnitz) handle complex here
	default:
		log.Fatalf("unexpected primitive type %q", k)
		return "", false
	}
}

func javaStreamType(imports javaUserImports, method *Method, isService bool) string {
	if !javaIsStreamingMethod(method) {
		return ""
	}
	stream := javaName(imports, "com/veyron2/idl/Stream") + "<"
	if method.InStream != nil {
		stream += javaType(imports, method.InStream.Type.Def(), true, isService)
	} else {
		stream += javaName(imports, "java/lang/Void")
	}
	stream += ", "
	if method.OutStream != nil {
		stream += javaType(imports, method.OutStream.Type.Def(), true, isService)
	} else {
		stream += javaName(imports, "java/lang/Void")
	}
	stream += ">"
	return stream
}

// javaConstType returns the typename for the provided constant.  Constants are
// special as they can be be untyped, in which case we infer the type from the
// provided value.
func javaConstType(imports javaUserImports, c *Const) string {
	if c.TypeDef != nil {
		return javaType(imports, c.TypeDef, false, false)
	}
	// No type definition - infer type from the value.
	switch c.Val.(type) {
	case bool:
		return "boolean"
	case string:
		return javaName(imports, "java/lang/String")
	// Untyped int/float constants aren't allowed, but we handle them anyway.
	case *big.Int:
		return "long"
	case *big.Rat:
		return "double"
	default:
		log.Fatalf("idl: illegal type for constant %v", c)
		return ""
	}
}

// javaConstVal returns the value string for the provided constant.
func javaConstVal(c *Const) string {
	if _, ok := c.Val.(string); ok {
		return fmt.Sprintf("%q", c.Val)
	}
	return fmt.Sprintf("%v", c.Val)
}

// javaImports prunes the provided imports list, removing the unnecessary
// imports, and returns the pruned list in the Java format.
func javaImports(imports javaUserImports, pkg *Package) (imp []string) {
	for base, dir := range imports {
		if dir == pkg.Path || dir == "java/lang" {
			continue
		}
		imp = append(imp, javaPath(path.Join(dir, base)))
	}
	return
}

// javaExtends returns the "extends" string for the provided interface,
// generated from all the embedded interface.
func javaExtends(imports javaUserImports, iface *Interface, isService bool) (ret string) {
	for i, e := range iface.Embeds() {
		if i == 0 {
			ret += "extends "
		} else {
			ret += ", "
		}
		ret += javaType(imports, e.Type.Def(), true, isService)
	}
	return
}

// javaNonErrorOutArgs returns the list of non-error output arguments for the
// provided method.
func javaNonErrorOutArgs(method *Method) []*Field {
	return method.OutArgs[:len(method.OutArgs)-1]
}

// javaOutArg returns the type for the (single) output argument for the provided
// method.
func javaOutArgType(imports javaUserImports, method *Method, isService bool) string {
	if javaIsStreamingMethod(method) {
		if isService {
			// Services have the stream inlined with the input arguments.
			return "void"
		}
		// Clients get a single output stream argument.
		return javaStreamType(imports, method, false)

		// TODO(spetrovic): All the other output arguments associated with this
		// method are moved onto the stream.  Implement this functionality.
	}
	switch len(method.OutArgs) {
	case 0:
		log.Fatalf("idl: method must have at least one output arg (i.e., error): %v", method)
		return ""
	case 1:
		return "void"
	case 2:
		return javaType(imports, method.OutArgs[0].Type.Def(), false, isService)
	default:
		return method.Name + "Out"
	}
}

func javaIsStreamingMethod(method *Method) bool {
	return method.InStream != nil || method.OutStream != nil
}

func javaShouldPackOutArgs(imports javaUserImports, method *Method, isService bool) bool {
	return javaOutArgType(imports, method, isService) == (method.Name + "Out")
}

// javaInArgs returns the in-args string for the provided method.
func javaInArgs(imports javaUserImports, method *Method, isService bool) (ret string) {
	if isService {
		ret += javaName(imports, "com/veyron2/ipc/Context") + " context"
	}
	for _, arg := range method.InArgs {
		if ret != "" {
			ret += ", "
		}
		ret += javaType(imports, arg.Type.Def(), false, isService) + " " + toCamelCase(arg.Name)
	}
	if !isService {
		if ret != "" {
			ret += ", "
		}
		ret += javaName(imports, "com/veyron2/ipc/Client") + ".CallOption... opts"
	}
	if javaIsStreamingMethod(method) && isService {
		// Services get the stream inlined with the input arguments; clients
		// treat the stream as an output argument so we ignore it here.
		if ret != "" {
			ret += ", "
		}
		ret += javaStreamType(imports, method, true) + " stream"
	}
	return
}

// javaDoc transforms the provided IDL comment into the JavaDoc format.
func javaDoc(goComment string) string {
	if goComment == "" {
		return ""
	}
	return "/**\n" + strings.Replace(goComment, "//", " *", -1) + "**/\n"
}

// javaPath converts the provided Go path into the Java path.  It replaces all "/"
// with "." in the path.
func javaPath(goPath string) string {
	return strings.Replace(goPath, "/", ".", -1)
}

// javaName converts the provided Go path into the Java pathname and returns a
// shorter version of it if possible, given the provided imports.
func javaName(imports javaUserImports, goPath string) string {
	if dir, ok := imports[path.Base(goPath)]; ok && dir == path.Dir(goPath) {
		return path.Base(goPath)
	}
	return javaPath(goPath)
}

// toCamelCase converts ThisString to thisString.
func toCamelCase(s string) string {
	if s == "" {
		return ""
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToLower(r)) + s[n:]
}

// toConstCase converts ThisString to THIS_STRING.
func toConstCase(s string) string {
	var buf bytes.Buffer
	for i, r := range s {
		if i > 0 && unicode.IsUpper(r) {
			buf.WriteRune('_')
		}
		buf.WriteRune(unicode.ToUpper(r))
	}
	return buf.String()
}

var (
	javaPkgTmpl   *template.Template
	javaConstTmpl *template.Template
	javaClassTmpl *template.Template
	javaIfaceTmpl *template.Template
)

// The template mechanism is great at high-level formatting and simple
// substitution, but is bad at more complicated logic (by design).  We define
// some functions that we can use in the template so that when things get
// complicated we back off to a regular function.
func init() {
	funcMap := template.FuncMap{
		"javaDoc":               javaDoc,
		"javaGenPkgPath":        javaGenPkgPath,
		"javaPath":              javaPath,
		"javaImports":           javaImports,
		"javaExtends":           javaExtends,
		"javaType":              javaType,
		"javaConstType":         javaConstType,
		"javaConstVal":          javaConstVal,
		"javaInArgs":            javaInArgs,
		"javaOutArgType":        javaOutArgType,
		"javaShouldPackOutArgs": javaShouldPackOutArgs,
		"javaName":              javaName,
		"javaNonErrorOutArgs":   javaNonErrorOutArgs,
		"toCamelCase":           toCamelCase,
		"toConstCase":           toConstCase,
	}
	javaPkgTmpl = template.Must(template.New("javaPkg").Funcs(funcMap).Parse(javaPkgTmplStr))
	javaConstTmpl = template.Must(template.New("javaConst").Funcs(funcMap).Parse(javaConstTmplStr))
	javaClassTmpl = template.Must(template.New("javaClass").Funcs(funcMap).Parse(javaClassTmplStr))
	javaIfaceTmpl = template.Must(template.New("javaIface").Funcs(funcMap).Parse(javaIfaceTmplStr))
}
